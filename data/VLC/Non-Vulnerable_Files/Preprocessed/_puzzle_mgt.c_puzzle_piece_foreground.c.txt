func	2:0	27:0	0	int	puzzle_piece_foreground
params	2:27	0:0	1	
param	2:29	2:47	2	filter_t *	p_filter
param	2:49	2:64	2	int32_t	i_piece
stmnts	0:0	26:22	1	
decl	3:4	3:41	2	filter_sys_t	*p_sys
op	3:24	0:0	2	=
water	3:26	0:0	2	p_filter
op	3:34	0:0	2	->
water	3:36	0:0	2	p_sys
decl	4:4	4:26	2	piece_t	*ps_pieces_tmp
decl	5:4	5:62	2	uint32_t	i_group_ID
op	5:24	0:0	2	=
water	5:26	0:0	2	p_sys
op	5:31	0:0	2	->
water	5:33	0:0	2	ps_pieces
op	5:42	0:0	2	[
water	5:43	0:0	2	i_piece
op	5:50	0:0	2	]
op	5:51	0:0	2	.
water	5:52	0:0	2	i_group_ID
water	6:4	0:0	2	ps_pieces_tmp
op	6:18	0:0	2	=
call	6:20	6:79	2	malloc
arg	6:28	6:79	3	sizeof(piece_t)*p_sys->s_allocated.i_pieces_nbr
op	6:28	0:0	4	sizeof
water	6:34	0:0	4	(
water	6:36	0:0	4	piece_t
water	6:43	0:0	4	)
op	6:45	0:0	4	*
water	6:47	0:0	4	p_sys
op	6:52	0:0	4	->
water	6:54	0:0	4	s_allocated
op	6:65	0:0	4	.
water	6:66	0:0	4	i_pieces_nbr
water	6:80	0:0	2	;
if	7:4	8:25	2	(! ps_pieces_tmp)
cond	7:8	7:9	3	! ps_pieces_tmp
op	7:8	0:0	4	!
water	7:9	0:0	4	ps_pieces_tmp
stmts	8:8	8:25	3	
return	8:8	8:25	4	VLC_ENOMEM
water	8:15	0:0	5	VLC_ENOMEM
decl	9:4	9:15	2	int32_t	j
op	9:13	0:0	2	=
water	9:14	0:0	2	0
call	10:4	10:75	2	memcpy
arg	10:12	10:29	3	&ps_pieces_tmp[j]
op	10:12	0:0	4	&
water	10:13	0:0	4	ps_pieces_tmp
op	10:26	0:0	4	[
water	10:27	0:0	4	j
op	10:28	0:0	4	]
arg	10:31	10:57	3	&p_sys->ps_pieces[i_piece]
op	10:31	0:0	4	&
water	10:32	0:0	4	p_sys
op	10:37	0:0	4	->
water	10:39	0:0	4	ps_pieces
op	10:48	0:0	4	[
water	10:49	0:0	4	i_piece
op	10:56	0:0	4	]
arg	10:59	10:75	3	sizeof(piece_t)
op	10:59	0:0	4	sizeof
water	10:65	0:0	4	(
water	10:66	0:0	4	piece_t
water	10:73	0:0	4	)
water	10:76	0:0	2	;
water	11:4	0:0	2	j
op	11:5	0:0	2	++
water	11:7	0:0	2	;
for	12:4	17:4	2	( uint32_t i = 0 ;i < p_sys -> s_allocated . i_pieces_nbr;i ++)
forinit	0:0	12:23	3	 uint32_t i = 0 ;
decl	12:9	12:23	4	uint32_t	i
op	12:20	0:0	4	=
water	12:22	0:0	4	0
cond	12:25	12:48	3	i < p_sys -> s_allocated . i_pieces_nbr
water	12:25	0:0	4	i
op	12:27	0:0	4	<
water	12:29	0:0	4	p_sys
op	12:34	0:0	4	->
water	12:36	0:0	4	s_allocated
op	12:47	0:0	4	.
water	12:48	0:0	4	i_pieces_nbr
forexpr	12:62	12:63	3	i ++
water	12:62	0:0	4	i
op	12:63	0:0	4	++
stmts	12:67	17:4	3	
water	12:67	0:0	4	{
if	13:8	16:8	4	(( p_sys -> ps_pieces [ i ] . i_group_ID == i_group_ID ) && ( ( int32_t ) i != i_piece ))
cond	13:13	13:89	5	( p_sys -> ps_pieces [ i ] . i_group_ID == i_group_ID ) && ( ( int32_t ) i != i_piece )
water	13:13	0:0	6	(
water	13:15	0:0	6	p_sys
op	13:20	0:0	6	->
water	13:22	0:0	6	ps_pieces
op	13:31	0:0	6	[
water	13:32	0:0	6	i
op	13:33	0:0	6	]
op	13:34	0:0	6	.
water	13:35	0:0	6	i_group_ID
op	13:46	0:0	6	==
water	13:49	0:0	6	i_group_ID
water	13:60	0:0	6	)
op	13:62	0:0	6	&&
water	13:65	0:0	6	(
water	13:67	0:0	6	(
water	13:68	0:0	6	int32_t
water	13:75	0:0	6	)
water	13:76	0:0	6	i
op	13:78	0:0	6	!=
water	13:81	0:0	6	i_piece
water	13:89	0:0	6	)
stmts	13:93	16:8	5	
water	13:93	0:0	6	{
call	14:12	14:76	6	memcpy
arg	14:20	14:37	7	&ps_pieces_tmp[j]
op	14:20	0:0	8	&
water	14:21	0:0	8	ps_pieces_tmp
op	14:34	0:0	8	[
water	14:35	0:0	8	j
op	14:36	0:0	8	]
arg	14:39	14:59	7	&p_sys->ps_pieces[i]
op	14:39	0:0	8	&
water	14:40	0:0	8	p_sys
op	14:45	0:0	8	->
water	14:47	0:0	8	ps_pieces
op	14:56	0:0	8	[
water	14:57	0:0	8	i
op	14:58	0:0	8	]
arg	14:61	14:76	7	sizeof(piece_t)
op	14:61	0:0	8	sizeof
water	14:67	0:0	8	(
water	14:68	0:0	8	piece_t
water	14:75	0:0	8	)
water	14:77	0:0	6	;
water	15:12	0:0	6	j
op	15:13	0:0	6	++
water	15:15	0:0	6	;
water	16:8	0:0	6	}
water	17:4	0:0	4	}
for	18:4	23:4	2	( uint32_t i = 0 ;i < p_sys -> s_allocated . i_pieces_nbr;i ++)
forinit	0:0	18:23	3	 uint32_t i = 0 ;
decl	18:9	18:23	4	uint32_t	i
op	18:20	0:0	4	=
water	18:22	0:0	4	0
cond	18:25	18:48	3	i < p_sys -> s_allocated . i_pieces_nbr
water	18:25	0:0	4	i
op	18:27	0:0	4	<
water	18:29	0:0	4	p_sys
op	18:34	0:0	4	->
water	18:36	0:0	4	s_allocated
op	18:47	0:0	4	.
water	18:48	0:0	4	i_pieces_nbr
forexpr	18:62	18:63	3	i ++
water	18:62	0:0	4	i
op	18:63	0:0	4	++
stmts	18:67	23:4	3	
water	18:67	0:0	4	{
if	19:8	22:8	4	(p_sys -> ps_pieces [ i ] . i_group_ID != i_group_ID)
cond	19:13	19:47	5	p_sys -> ps_pieces [ i ] . i_group_ID != i_group_ID
water	19:13	0:0	6	p_sys
op	19:18	0:0	6	->
water	19:20	0:0	6	ps_pieces
op	19:29	0:0	6	[
water	19:30	0:0	6	i
op	19:31	0:0	6	]
op	19:32	0:0	6	.
water	19:33	0:0	6	i_group_ID
op	19:44	0:0	6	!=
water	19:47	0:0	6	i_group_ID
stmts	19:60	22:8	5	
water	19:60	0:0	6	{
call	20:12	20:76	6	memcpy
arg	20:20	20:37	7	&ps_pieces_tmp[j]
op	20:20	0:0	8	&
water	20:21	0:0	8	ps_pieces_tmp
op	20:34	0:0	8	[
water	20:35	0:0	8	j
op	20:36	0:0	8	]
arg	20:39	20:59	7	&p_sys->ps_pieces[i]
op	20:39	0:0	8	&
water	20:40	0:0	8	p_sys
op	20:45	0:0	8	->
water	20:47	0:0	8	ps_pieces
op	20:56	0:0	8	[
water	20:57	0:0	8	i
op	20:58	0:0	8	]
arg	20:61	20:76	7	sizeof(piece_t)
op	20:61	0:0	8	sizeof
water	20:67	0:0	8	(
water	20:68	0:0	8	piece_t
water	20:75	0:0	8	)
water	20:77	0:0	6	;
water	21:12	0:0	6	j
op	21:13	0:0	6	++
water	21:15	0:0	6	;
water	22:8	0:0	6	}
water	23:4	0:0	4	}
call	24:4	24:37	2	free
arg	24:10	24:37	3	p_filter->p_sys->ps_pieces
water	24:10	0:0	4	p_filter
op	24:18	0:0	4	->
water	24:20	0:0	4	p_sys
op	24:25	0:0	4	->
water	24:27	0:0	4	ps_pieces
water	24:38	0:0	2	;
water	25:4	0:0	2	p_filter
op	25:12	0:0	2	->
water	25:14	0:0	2	p_sys
op	25:19	0:0	2	->
water	25:21	0:0	2	ps_pieces
op	25:31	0:0	2	=
water	25:33	0:0	2	ps_pieces_tmp
water	25:46	0:0	2	;
return	26:4	26:22	2	VLC_SUCCESS
water	26:11	0:0	3	VLC_SUCCESS
