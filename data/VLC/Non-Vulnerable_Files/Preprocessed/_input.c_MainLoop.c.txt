func	2:0	113:0	0	static void	MainLoop
params	2:20	0:0	1	
param	2:22	2:45	2	input_thread_t *	p_input
param	2:47	2:66	2	bool	b_interactive
stmnts	0:0	112:43	1	
decl	4:4	4:35	2	mtime_t	i_start_mdate
op	4:26	0:0	2	=
call	4:28	4:34	3	mdate
decl	5:4	5:29	2	mtime_t	i_intf_update
op	5:26	0:0	2	=
water	5:28	0:0	2	0
decl	6:4	6:34	2	mtime_t	i_statistic_update
op	6:31	0:0	2	=
water	6:33	0:0	2	0
decl	7:4	7:33	2	mtime_t	i_last_seek_mdate
op	7:30	0:0	2	=
water	7:32	0:0	2	0
decl	8:4	9:75	2	bool	b_pause_after_eof
op	8:27	0:0	2	=
water	8:29	0:0	2	b_interactive
op	8:43	0:0	2	&&
call	9:29	9:74	3	var_CreateGetBool
arg	9:48	9:55	4	p_input
water	9:48	0:0	5	p_input
arg	9:57	9:74	4	"play-and-pause"
water	9:57	0:0	5	"play-and-pause"
while	10:4	110:4	2	(vlc_object_alive (p_input ) && ! p_input -> b_error)
cond	10:11	10:52	3	vlc_object_alive (p_input ) && ! p_input -> b_error
call	10:11	10:37	4	vlc_object_alive
arg	10:29	10:37	5	p_input
water	10:29	0:0	6	p_input
op	10:39	0:0	4	&&
op	10:42	0:0	4	!
water	10:43	0:0	4	p_input
op	10:50	0:0	4	->
water	10:52	0:0	4	b_error
stmts	11:4	110:4	3	
water	11:4	0:0	4	{
decl	12:8	12:27	4	bool	b_force_update
decl	13:8	13:23	4	vlc_value_t	val
decl	14:8	14:25	4	mtime_t	i_current
decl	15:8	15:24	4	mtime_t	i_wakeup
decl	16:8	16:21	4	bool	b_paused
decl	17:8	17:27	4	bool	b_demux_polled
water	19:8	0:0	4	b_force_update
op	19:23	0:0	4	=
water	19:25	0:0	4	false
water	19:30	0:0	4	;
water	20:8	0:0	4	i_wakeup
op	20:17	0:0	4	=
water	20:19	0:0	4	0
water	20:20	0:0	4	;
water	24:8	0:0	4	b_paused
op	24:17	0:0	4	=
water	24:19	0:0	4	p_input
op	24:26	0:0	4	->
water	24:28	0:0	4	p
op	24:29	0:0	4	->
water	24:31	0:0	4	i_state
op	24:39	0:0	4	==
water	24:42	0:0	4	PAUSE_S
op	24:50	0:0	4	&&
water	25:19	0:0	4	(
op	25:21	0:0	4	!
call	25:22	25:64	4	es_out_GetBuffering
arg	25:43	25:64	5	p_input->p->p_es_out
water	25:43	0:0	6	p_input
op	25:50	0:0	6	->
water	25:52	0:0	6	p
op	25:53	0:0	6	->
water	25:55	0:0	6	p_es_out
op	25:66	0:0	4	||
water	25:69	0:0	4	p_input
op	25:76	0:0	4	->
water	25:78	0:0	4	p
op	25:79	0:0	4	->
water	25:81	0:0	4	input
op	25:86	0:0	4	.
water	25:87	0:0	4	b_eof
water	25:93	0:0	4	)
water	25:94	0:0	4	;
water	26:8	0:0	4	b_demux_polled
op	26:23	0:0	4	=
water	26:25	0:0	4	true
water	26:29	0:0	4	;
if	27:8	54:8	4	(! b_paused)
cond	27:12	27:13	5	! b_paused
op	27:12	0:0	6	!
water	27:13	0:0	6	b_paused
stmts	28:8	54:8	5	
water	28:8	0:0	6	{
if	29:12	33:12	6	(! p_input -> p -> input . b_eof)
cond	29:16	29:35	7	! p_input -> p -> input . b_eof
op	29:16	0:0	8	!
water	29:17	0:0	8	p_input
op	29:24	0:0	8	->
water	29:26	0:0	8	p
op	29:27	0:0	8	->
water	29:29	0:0	8	input
op	29:34	0:0	8	.
water	29:35	0:0	8	b_eof
stmts	30:12	33:12	7	
water	30:12	0:0	8	{
call	31:16	31:88	8	MainLoopDemux
arg	31:31	31:38	9	p_input
water	31:31	0:0	10	p_input
arg	31:40	31:55	9	&b_force_update
op	31:40	0:0	10	&
water	31:41	0:0	10	b_force_update
arg	31:57	31:72	9	&b_demux_polled
op	31:57	0:0	10	&
water	31:58	0:0	10	b_demux_polled
arg	31:74	31:88	9	i_start_mdate
water	31:74	0:0	10	i_start_mdate
water	31:89	0:0	8	;
water	32:16	0:0	8	i_wakeup
op	32:25	0:0	8	=
call	32:27	32:66	8	es_out_GetWakeup
arg	32:45	32:66	9	p_input->p->p_es_out
water	32:45	0:0	10	p_input
op	32:52	0:0	10	->
water	32:54	0:0	10	p
op	32:55	0:0	10	->
water	32:57	0:0	10	p_es_out
water	32:67	0:0	8	;
water	33:12	0:0	8	}
else	34:12	38:12	6
stmts	34:17	38:12	7	
if	34:17	38:12	8	(!es_out_GetEmpty (p_input -> p -> p_es_out ))
cond	34:21	34:60	9	!es_out_GetEmpty (p_input -> p -> p_es_out )
op	34:21	0:0	10	!
call	34:22	34:60	10	es_out_GetEmpty
arg	34:39	34:60	11	p_input->p->p_es_out
water	34:39	0:0	12	p_input
op	34:46	0:0	12	->
water	34:48	0:0	12	p
op	34:49	0:0	12	->
water	34:51	0:0	12	p_es_out
stmts	35:12	38:12	9	
water	35:12	0:0	10	{
call	36:16	36:67	10	msg_Dbg
arg	36:25	36:32	11	p_input
water	36:25	0:0	12	p_input
arg	36:34	36:67	11	"waiting decoder fifos to empty"
water	36:34	0:0	12	"waiting decoder fifos to empty"
water	36:68	0:0	10	;
water	37:16	0:0	10	i_wakeup
op	37:25	0:0	10	=
call	37:27	37:33	10	mdate
op	37:35	0:0	10	+
water	37:37	0:0	10	INPUT_IDLE_SLEEP
water	37:53	0:0	10	;
water	38:12	0:0	10	}
else	41:12	47:12	6
stmts	41:17	47:12	7	
if	41:17	47:12	8	(b_pause_after_eof && p_input -> p -> b_can_pause)
cond	41:21	41:54	9	b_pause_after_eof && p_input -> p -> b_can_pause
water	41:21	0:0	10	b_pause_after_eof
op	41:39	0:0	10	&&
water	41:42	0:0	10	p_input
op	41:49	0:0	10	->
water	41:51	0:0	10	p
op	41:52	0:0	10	->
water	41:54	0:0	10	b_can_pause
stmts	42:12	47:12	9	
water	42:12	0:0	10	{
call	43:16	43:69	10	msg_Dbg
arg	43:25	43:32	11	p_input
water	43:25	0:0	12	p_input
arg	43:34	43:69	11	"pausing at EOF (pause after each)"
water	43:34	0:0	12	"pausing at EOF (pause after each)"
water	43:70	0:0	10	;
water	44:16	0:0	10	val
op	44:19	0:0	10	.
water	44:20	0:0	10	i_int
op	44:26	0:0	10	=
water	44:28	0:0	10	PAUSE_S
water	44:35	0:0	10	;
call	45:16	45:63	10	Control
arg	45:25	45:32	11	p_input
water	45:25	0:0	12	p_input
arg	45:34	45:57	11	INPUT_CONTROL_SET_STATE
water	45:34	0:0	12	INPUT_CONTROL_SET_STATE
arg	45:59	45:63	11	val
water	45:59	0:0	12	val
water	45:64	0:0	10	;
water	46:16	0:0	10	b_paused
op	46:25	0:0	10	=
water	46:27	0:0	10	true
water	46:31	0:0	10	;
water	47:12	0:0	10	}
else	48:12	53:12	6
stmts	49:12	53:12	7	
water	49:12	0:0	8	{
if	50:16	51:25	8	(MainLoopTryRepeat (p_input ,& i_start_mdate ))
cond	50:20	50:63	9	MainLoopTryRepeat (p_input ,& i_start_mdate )
call	50:20	50:63	10	MainLoopTryRepeat
arg	50:39	50:46	11	p_input
water	50:39	0:0	12	p_input
arg	50:48	50:63	11	&i_start_mdate
op	50:48	0:0	12	&
water	50:49	0:0	12	i_start_mdate
stmts	51:20	51:25	9	
break	51:20	51:25	10	
water	52:16	0:0	8	b_pause_after_eof
op	52:34	0:0	8	=
call	52:36	52:75	8	var_GetBool
arg	52:49	52:56	9	p_input
water	52:49	0:0	10	p_input
arg	52:58	52:75	9	"play-and-pause"
water	52:58	0:0	10	"play-and-pause"
water	52:76	0:0	8	;
water	53:12	0:0	8	}
water	54:8	0:0	6	}
do	56:8	109:8	4	(i_current < i_wakeup)
cond	109:17	109:29	5	i_current < i_wakeup
water	109:17	0:0	6	i_current
op	109:27	0:0	6	<
water	109:29	0:0	6	i_wakeup
stmts	56:11	109:8	5	
water	56:11	0:0	6	{
decl	57:12	57:41	6	mtime_t	i_deadline
op	57:31	0:0	6	=
water	57:33	0:0	6	i_wakeup
if	58:12	59:71	6	(b_paused || ! b_demux_polled)
cond	58:16	58:29	7	b_paused || ! b_demux_polled
water	58:16	0:0	8	b_paused
op	58:25	0:0	8	||
op	58:28	0:0	8	!
water	58:29	0:0	8	b_demux_polled
stmts	59:16	59:71	7	
water	59:16	0:0	8	i_deadline
op	59:27	0:0	8	=
call	59:29	59:70	8	__MIN
arg	59:36	59:49	9	i_intf_update
water	59:36	0:0	10	i_intf_update
arg	59:51	59:70	9	i_statistic_update
water	59:51	0:0	10	i_statistic_update
water	59:71	0:0	8	;
for	61:12	92:12	6	(;;)
forinit	61:17	61:17	7	;
water	61:17	0:0	8	;
cond	0:0	0:0	7	
forexpr	0:0	0:0	7	
stmts	62:12	92:12	7	
water	62:12	0:0	8	{
decl	63:16	63:44	8	mtime_t	i_limit
op	63:32	0:0	8	=
water	63:34	0:0	8	i_deadline
decl	67:16	68:59	8	bool	b_buffering
op	67:33	0:0	8	=
call	67:35	67:77	9	es_out_GetBuffering
arg	67:56	67:77	10	p_input->p->p_es_out
water	67:56	0:0	11	p_input
op	67:63	0:0	11	->
water	67:65	0:0	11	p
op	67:66	0:0	11	->
water	67:68	0:0	11	p_es_out
op	67:79	0:0	8	&&
op	68:35	0:0	8	!
water	68:36	0:0	8	p_input
op	68:43	0:0	8	->
water	68:45	0:0	8	p
op	68:46	0:0	8	->
water	68:48	0:0	8	input
op	68:53	0:0	8	.
water	68:54	0:0	8	b_eof
if	69:16	75:16	8	(b_buffering)
cond	69:20	69:20	9	b_buffering
water	69:20	0:0	10	b_buffering
stmts	70:16	75:16	9	
water	70:16	0:0	10	{
decl	72:20	72:47	10	mtime_t	i_current
op	72:38	0:0	10	=
call	72:40	72:46	11	mdate
if	73:20	74:81	10	(i_last_seek_mdate +INT64_C (125000 ) >= i_current)
cond	73:24	73:63	11	i_last_seek_mdate +INT64_C (125000 ) >= i_current
water	73:24	0:0	12	i_last_seek_mdate
op	73:42	0:0	12	+
call	73:44	73:58	12	INT64_C
arg	73:52	73:58	13	125000
water	73:52	0:0	14	125000
op	73:60	0:0	12	>=
water	73:63	0:0	12	i_current
stmts	74:24	74:81	11	
water	74:24	0:0	12	i_limit
op	74:32	0:0	12	=
call	74:34	74:80	12	__MIN
arg	74:41	74:51	13	i_deadline
water	74:41	0:0	14	i_deadline
arg	74:53	74:80	13	i_current+INT64_C(20000)
water	74:53	0:0	14	i_current
op	74:63	0:0	14	+
call	74:65	74:78	14	INT64_C
arg	74:73	74:78	15	20000
water	74:73	0:0	16	20000
water	74:81	0:0	12	;
water	75:16	0:0	10	}
decl	76:16	76:26	8	int	i_type
if	77:16	82:16	8	(ControlPop (p_input ,& i_type ,& val ,i_limit ,b_buffering ))
cond	77:20	77:77	9	ControlPop (p_input ,& i_type ,& val ,i_limit ,b_buffering )
call	77:20	77:77	10	ControlPop
arg	77:32	77:39	11	p_input
water	77:32	0:0	12	p_input
arg	77:41	77:48	11	&i_type
op	77:41	0:0	12	&
water	77:42	0:0	12	i_type
arg	77:50	77:54	11	&val
op	77:50	0:0	12	&
water	77:51	0:0	12	val
arg	77:56	77:63	11	i_limit
water	77:56	0:0	12	i_limit
arg	77:65	77:77	11	b_buffering
water	77:65	0:0	12	b_buffering
stmts	78:16	82:16	9	
water	78:16	0:0	10	{
if	79:20	80:32	10	(b_buffering && i_limit < i_deadline)
cond	79:24	79:49	11	b_buffering && i_limit < i_deadline
water	79:24	0:0	12	b_buffering
op	79:36	0:0	12	&&
water	79:39	0:0	12	i_limit
op	79:47	0:0	12	<
water	79:49	0:0	12	i_deadline
stmts	80:24	80:32	11	
continue	80:24	80:32	12	
break	81:20	81:25	10	
water	82:16	0:0	10	}
call	84:16	84:60	8	msg_Dbg
arg	84:25	84:32	9	p_input
water	84:25	0:0	10	p_input
arg	84:34	84:51	9	"control type=%d"
water	84:34	0:0	10	"control type=%d"
arg	84:53	84:60	9	i_type
water	84:53	0:0	10	i_type
water	84:61	0:0	8	;
if	86:16	91:16	8	(Control (p_input ,i_type ,val ))
cond	86:20	86:50	9	Control (p_input ,i_type ,val )
call	86:20	86:50	10	Control
arg	86:29	86:36	11	p_input
water	86:29	0:0	12	p_input
arg	86:38	86:44	11	i_type
water	86:38	0:0	12	i_type
arg	86:46	86:50	11	val
water	86:46	0:0	12	val
stmts	87:16	91:16	9	
water	87:16	0:0	10	{
if	88:20	89:51	10	(ControlIsSeekRequest (i_type ))
cond	88:24	88:53	11	ControlIsSeekRequest (i_type )
call	88:24	88:53	12	ControlIsSeekRequest
arg	88:46	88:53	13	i_type
water	88:46	0:0	14	i_type
stmts	89:24	89:51	11	
water	89:24	0:0	12	i_last_seek_mdate
op	89:42	0:0	12	=
call	89:44	89:50	12	mdate
water	89:51	0:0	12	;
water	90:20	0:0	10	b_force_update
op	90:35	0:0	10	=
water	90:37	0:0	10	true
water	90:41	0:0	10	;
water	91:16	0:0	10	}
water	92:12	0:0	8	}
water	94:12	0:0	6	i_current
op	94:22	0:0	6	=
call	94:24	94:30	6	mdate
water	94:31	0:0	6	;
if	95:12	100:12	6	(i_intf_update < i_current || b_force_update)
cond	95:16	95:45	7	i_intf_update < i_current || b_force_update
water	95:16	0:0	8	i_intf_update
op	95:30	0:0	8	<
water	95:32	0:0	8	i_current
op	95:42	0:0	8	||
water	95:45	0:0	8	b_force_update
stmts	96:12	100:12	7	
water	96:12	0:0	8	{
call	97:16	97:43	8	MainLoopInterface
arg	97:35	97:43	9	p_input
water	97:35	0:0	10	p_input
water	97:44	0:0	8	;
water	98:16	0:0	8	i_intf_update
op	98:30	0:0	8	=
water	98:32	0:0	8	i_current
op	98:42	0:0	8	+
call	98:44	98:58	8	INT64_C
arg	98:52	98:58	9	250000
water	98:52	0:0	10	250000
water	98:59	0:0	8	;
water	99:16	0:0	8	b_force_update
op	99:31	0:0	8	=
water	99:33	0:0	8	false
water	99:38	0:0	8	;
water	100:12	0:0	8	}
if	101:12	105:12	6	(i_statistic_update < i_current)
cond	101:16	101:37	7	i_statistic_update < i_current
water	101:16	0:0	8	i_statistic_update
op	101:35	0:0	8	<
water	101:37	0:0	8	i_current
stmts	102:12	105:12	7	
water	102:12	0:0	8	{
call	103:16	103:43	8	MainLoopStatistic
arg	103:35	103:43	9	p_input
water	103:35	0:0	10	p_input
water	103:44	0:0	8	;
water	104:16	0:0	8	i_statistic_update
op	104:35	0:0	8	=
water	104:37	0:0	8	i_current
op	104:47	0:0	8	+
call	104:49	104:64	8	INT64_C
arg	104:57	104:64	9	1000000
water	104:57	0:0	10	1000000
water	104:65	0:0	8	;
water	105:12	0:0	8	}
if	107:12	108:67	6	(i_wakeup != 0)
cond	107:16	107:28	7	i_wakeup != 0
water	107:16	0:0	8	i_wakeup
op	107:25	0:0	8	!=
water	107:28	0:0	8	0
stmts	108:16	108:67	7	
water	108:16	0:0	8	i_wakeup
op	108:25	0:0	8	=
call	108:27	108:66	8	es_out_GetWakeup
arg	108:45	108:66	9	p_input->p->p_es_out
water	108:45	0:0	10	p_input
op	108:52	0:0	10	->
water	108:54	0:0	10	p
op	108:55	0:0	10	->
water	108:57	0:0	10	p_es_out
water	108:67	0:0	8	;
water	109:8	0:0	6	}
water	109:39	0:0	4	;
water	110:4	0:0	4	}
if	111:4	112:43	2	(! p_input -> b_error)
cond	111:8	111:18	3	! p_input -> b_error
op	111:8	0:0	4	!
water	111:9	0:0	4	p_input
op	111:16	0:0	4	->
water	111:18	0:0	4	b_error
stmts	112:8	112:43	3	
call	112:8	112:42	4	input_ChangeState
arg	112:27	112:34	5	p_input
water	112:27	0:0	6	p_input
arg	112:36	112:42	5	END_S
water	112:36	0:0	6	END_S
water	112:43	0:0	4	;
