func	2:0	105:0	0	static void	SubsdelayEnforceDelayRules
params	2:38	0:0	1	
param	2:40	2:59	2	filter_t *	p_filter
stmnts	0:0	104:4	1	
decl	4:4	4:36	2	subsdelay_heap_entry_t	**p_list
decl	5:4	5:32	2	int	i
water	5:9	0:0	2	,
decl	5:4	5:32	2	int	j
water	5:12	0:0	2	,
decl	5:4	5:32	2	int	i_count
water	5:21	0:0	2	,
decl	5:4	5:32	2	int	i_overlap
decl	6:4	6:20	2	int64_t	i_offset
decl	7:4	7:32	2	int64_t	i_min_stops_interval
decl	8:4	8:37	2	int64_t	i_min_stop_start_interval
decl	9:4	9:37	2	int64_t	i_min_start_stop_interval
water	10:4	0:0	2	p_list
op	10:11	0:0	2	=
water	10:13	0:0	2	p_filter
op	10:21	0:0	2	->
water	10:23	0:0	2	p_sys
op	10:28	0:0	2	->
water	10:30	0:0	2	heap
op	10:34	0:0	2	.
water	10:35	0:0	2	p_list
water	10:41	0:0	2	;
water	11:4	0:0	2	i_count
op	11:12	0:0	2	=
water	11:14	0:0	2	p_filter
op	11:22	0:0	2	->
water	11:24	0:0	2	p_sys
op	11:29	0:0	2	->
water	11:31	0:0	2	heap
op	11:35	0:0	2	.
water	11:36	0:0	2	i_count
water	11:43	0:0	2	;
water	12:4	0:0	2	i_overlap
op	12:14	0:0	2	=
water	12:16	0:0	2	p_filter
op	12:24	0:0	2	->
water	12:26	0:0	2	p_sys
op	12:31	0:0	2	->
water	12:33	0:0	2	i_overlap
water	12:42	0:0	2	;
water	13:4	0:0	2	i_min_stops_interval
op	13:25	0:0	2	=
water	13:27	0:0	2	p_filter
op	13:35	0:0	2	->
water	13:37	0:0	2	p_sys
op	13:42	0:0	2	->
water	13:44	0:0	2	i_min_stops_interval
water	13:64	0:0	2	;
water	14:4	0:0	2	i_min_stop_start_interval
op	14:30	0:0	2	=
water	14:32	0:0	2	p_filter
op	14:40	0:0	2	->
water	14:42	0:0	2	p_sys
op	14:47	0:0	2	->
water	14:49	0:0	2	i_min_stop_start_interval
water	14:74	0:0	2	;
water	15:4	0:0	2	i_min_start_stop_interval
op	15:30	0:0	2	=
water	15:32	0:0	2	p_filter
op	15:40	0:0	2	->
water	15:42	0:0	2	p_sys
op	15:47	0:0	2	->
water	15:49	0:0	2	i_min_start_stop_interval
water	15:74	0:0	2	;
for	26:4	30:4	2	(i = 0 ;i < i_count - 1;i ++)
forinit	26:9	26:14	3	i = 0 ;
water	26:9	0:0	4	i
op	26:11	0:0	4	=
water	26:13	0:0	4	0
water	26:14	0:0	4	;
cond	26:16	26:30	3	i < i_count - 1
water	26:16	0:0	4	i
op	26:18	0:0	4	<
water	26:20	0:0	4	i_count
op	26:28	0:0	4	-
water	26:30	0:0	4	1
forexpr	26:33	26:34	3	i ++
water	26:33	0:0	4	i
op	26:34	0:0	4	++
stmts	27:4	30:4	3	
water	27:4	0:0	4	{
water	28:8	0:0	4	p_list
op	28:14	0:0	4	[
water	28:15	0:0	4	i
op	28:17	0:0	4	+
water	28:19	0:0	4	1
op	28:20	0:0	4	]
op	28:21	0:0	4	->
water	28:23	0:0	4	i_new_stop
op	28:34	0:0	4	=
call	28:36	29:61	4	__MAX
arg	28:43	28:68	5	p_list[i+1]->i_new_stop
water	28:43	0:0	6	p_list
op	28:49	0:0	6	[
water	28:50	0:0	6	i
op	28:52	0:0	6	+
water	28:54	0:0	6	1
op	28:55	0:0	6	]
op	28:56	0:0	6	->
water	28:58	0:0	6	i_new_stop
arg	29:16	29:61	5	p_list[i]->i_new_stop+i_min_stops_interval
water	29:16	0:0	6	p_list
op	29:22	0:0	6	[
water	29:23	0:0	6	i
op	29:24	0:0	6	]
op	29:25	0:0	6	->
water	29:27	0:0	6	i_new_stop
op	29:38	0:0	6	+
water	29:40	0:0	6	i_min_stops_interval
water	29:62	0:0	4	;
water	30:4	0:0	4	}
for	41:4	56:4	2	(i = 0 ;i < i_count;i ++)
forinit	41:9	41:14	3	i = 0 ;
water	41:9	0:0	4	i
op	41:11	0:0	4	=
water	41:13	0:0	4	0
water	41:14	0:0	4	;
cond	41:16	41:20	3	i < i_count
water	41:16	0:0	4	i
op	41:18	0:0	4	<
water	41:20	0:0	4	i_count
forexpr	41:29	41:30	3	i ++
water	41:29	0:0	4	i
op	41:30	0:0	4	++
stmts	42:4	56:4	3	
water	42:4	0:0	4	{
for	43:8	55:8	4	(j = i + 1 ;j <__MIN (i_count ,i + 1 + i_overlap );j ++)
forinit	43:13	43:22	5	j = i + 1 ;
water	43:13	0:0	6	j
op	43:15	0:0	6	=
water	43:17	0:0	6	i
op	43:19	0:0	6	+
water	43:21	0:0	6	1
water	43:22	0:0	6	;
cond	43:24	43:62	5	j <__MIN (i_count ,i + 1 + i_overlap )
water	43:24	0:0	6	j
op	43:26	0:0	6	<
call	43:28	43:62	6	__MIN
arg	43:35	43:42	7	i_count
water	43:35	0:0	8	i_count
arg	43:44	43:62	7	i+1+i_overlap
water	43:44	0:0	8	i
op	43:46	0:0	8	+
water	43:48	0:0	8	1
op	43:50	0:0	8	+
water	43:52	0:0	8	i_overlap
forexpr	43:65	43:66	5	j ++
water	43:65	0:0	6	j
op	43:66	0:0	6	++
stmts	44:8	55:8	5	
water	44:8	0:0	6	{
water	45:12	0:0	6	i_offset
op	45:21	0:0	6	=
water	45:23	0:0	6	p_list
op	45:29	0:0	6	[
water	45:30	0:0	6	j
op	45:31	0:0	6	]
op	45:32	0:0	6	->
water	45:34	0:0	6	p_source
op	45:42	0:0	6	->
water	45:44	0:0	6	i_start
op	45:52	0:0	6	-
water	45:54	0:0	6	p_list
op	45:60	0:0	6	[
water	45:61	0:0	6	i
op	45:62	0:0	6	]
op	45:63	0:0	6	->
water	45:65	0:0	6	i_new_stop
water	45:75	0:0	6	;
if	46:12	49:12	6	(i_offset <= 0)
cond	46:16	46:28	7	i_offset <= 0
water	46:16	0:0	8	i_offset
op	46:25	0:0	8	<=
water	46:28	0:0	8	0
stmts	47:12	49:12	7	
water	47:12	0:0	8	{
continue	48:16	48:24	8	
water	49:12	0:0	8	}
if	50:12	53:12	6	(i_offset < i_min_stop_start_interval)
cond	50:16	50:27	7	i_offset < i_min_stop_start_interval
water	50:16	0:0	8	i_offset
op	50:25	0:0	8	<
water	50:27	0:0	8	i_min_stop_start_interval
stmts	51:12	53:12	7	
water	51:12	0:0	8	{
water	52:16	0:0	8	p_list
op	52:22	0:0	8	[
water	52:23	0:0	8	i
op	52:24	0:0	8	]
op	52:25	0:0	8	->
water	52:27	0:0	8	i_new_stop
op	52:38	0:0	8	=
water	52:40	0:0	8	p_list
op	52:46	0:0	8	[
water	52:47	0:0	8	j
op	52:48	0:0	8	]
op	52:49	0:0	8	->
water	52:51	0:0	8	p_source
op	52:59	0:0	8	->
water	52:61	0:0	8	i_start
water	52:68	0:0	8	;
water	53:12	0:0	8	}
break	54:12	54:17	6	
water	55:8	0:0	6	}
water	56:4	0:0	4	}
for	67:4	82:4	2	(i = 0 ;i < i_count;i ++)
forinit	67:9	67:14	3	i = 0 ;
water	67:9	0:0	4	i
op	67:11	0:0	4	=
water	67:13	0:0	4	0
water	67:14	0:0	4	;
cond	67:16	67:20	3	i < i_count
water	67:16	0:0	4	i
op	67:18	0:0	4	<
water	67:20	0:0	4	i_count
forexpr	67:29	67:30	3	i ++
water	67:29	0:0	4	i
op	67:30	0:0	4	++
stmts	68:4	82:4	3	
water	68:4	0:0	4	{
for	69:8	81:8	4	(j = i + 1 ;j <__MIN (i_count ,i + 1 + i_overlap );j ++)
forinit	69:13	69:22	5	j = i + 1 ;
water	69:13	0:0	6	j
op	69:15	0:0	6	=
water	69:17	0:0	6	i
op	69:19	0:0	6	+
water	69:21	0:0	6	1
water	69:22	0:0	6	;
cond	69:24	69:62	5	j <__MIN (i_count ,i + 1 + i_overlap )
water	69:24	0:0	6	j
op	69:26	0:0	6	<
call	69:28	69:62	6	__MIN
arg	69:35	69:42	7	i_count
water	69:35	0:0	8	i_count
arg	69:44	69:62	7	i+1+i_overlap
water	69:44	0:0	8	i
op	69:46	0:0	8	+
water	69:48	0:0	8	1
op	69:50	0:0	8	+
water	69:52	0:0	8	i_overlap
forexpr	69:65	69:66	5	j ++
water	69:65	0:0	6	j
op	69:66	0:0	6	++
stmts	70:8	81:8	5	
water	70:8	0:0	6	{
water	71:12	0:0	6	i_offset
op	71:21	0:0	6	=
water	71:23	0:0	6	p_list
op	71:29	0:0	6	[
water	71:30	0:0	6	i
op	71:31	0:0	6	]
op	71:32	0:0	6	->
water	71:34	0:0	6	i_new_stop
op	71:45	0:0	6	-
water	71:47	0:0	6	p_list
op	71:53	0:0	6	[
water	71:54	0:0	6	j
op	71:55	0:0	6	]
op	71:56	0:0	6	->
water	71:58	0:0	6	p_source
op	71:66	0:0	6	->
water	71:68	0:0	6	i_start
water	71:75	0:0	6	;
if	72:12	75:12	6	(i_offset <= 0)
cond	72:16	72:28	7	i_offset <= 0
water	72:16	0:0	8	i_offset
op	72:25	0:0	8	<=
water	72:28	0:0	8	0
stmts	73:12	75:12	7	
water	73:12	0:0	8	{
break	74:16	74:21	8	
water	75:12	0:0	8	}
if	76:12	80:12	6	(i_offset < i_min_start_stop_interval)
cond	76:16	76:27	7	i_offset < i_min_start_stop_interval
water	76:16	0:0	8	i_offset
op	76:25	0:0	8	<
water	76:27	0:0	8	i_min_start_stop_interval
stmts	77:12	80:12	7	
water	77:12	0:0	8	{
water	78:16	0:0	8	p_list
op	78:22	0:0	8	[
water	78:23	0:0	8	i
op	78:24	0:0	8	]
op	78:25	0:0	8	->
water	78:27	0:0	8	i_new_stop
op	78:38	0:0	8	=
water	78:40	0:0	8	p_list
op	78:46	0:0	8	[
water	78:47	0:0	8	j
op	78:48	0:0	8	]
op	78:49	0:0	8	->
water	78:51	0:0	8	p_source
op	78:59	0:0	8	->
water	78:61	0:0	8	i_start
water	78:68	0:0	8	;
break	79:16	79:21	8	
water	80:12	0:0	8	}
water	81:8	0:0	6	}
water	82:4	0:0	4	}
for	93:4	99:4	2	(i = 0 ;i < i_count - i_overlap;i ++)
forinit	93:9	93:14	3	i = 0 ;
water	93:9	0:0	4	i
op	93:11	0:0	4	=
water	93:13	0:0	4	0
water	93:14	0:0	4	;
cond	93:16	93:30	3	i < i_count - i_overlap
water	93:16	0:0	4	i
op	93:18	0:0	4	<
water	93:20	0:0	4	i_count
op	93:28	0:0	4	-
water	93:30	0:0	4	i_overlap
forexpr	93:41	93:42	3	i ++
water	93:41	0:0	4	i
op	93:42	0:0	4	++
stmts	94:4	99:4	3	
water	94:4	0:0	4	{
if	95:8	98:8	4	(p_list [ i ] -> i_new_stop > p_list [ i + i_overlap ] -> p_source -> i_start)
cond	95:12	95:69	5	p_list [ i ] -> i_new_stop > p_list [ i + i_overlap ] -> p_source -> i_start
water	95:12	0:0	6	p_list
op	95:18	0:0	6	[
water	95:19	0:0	6	i
op	95:20	0:0	6	]
op	95:21	0:0	6	->
water	95:23	0:0	6	i_new_stop
op	95:34	0:0	6	>
water	95:36	0:0	6	p_list
op	95:42	0:0	6	[
water	95:43	0:0	6	i
op	95:45	0:0	6	+
water	95:47	0:0	6	i_overlap
op	95:56	0:0	6	]
op	95:57	0:0	6	->
water	95:59	0:0	6	p_source
op	95:67	0:0	6	->
water	95:69	0:0	6	i_start
stmts	96:8	98:8	5	
water	96:8	0:0	6	{
water	97:12	0:0	6	p_list
op	97:18	0:0	6	[
water	97:19	0:0	6	i
op	97:20	0:0	6	]
op	97:21	0:0	6	->
water	97:23	0:0	6	i_new_stop
op	97:34	0:0	6	=
water	97:36	0:0	6	p_list
op	97:42	0:0	6	[
water	97:43	0:0	6	i
op	97:45	0:0	6	+
water	97:47	0:0	6	i_overlap
op	97:56	0:0	6	]
op	97:57	0:0	6	->
water	97:59	0:0	6	p_source
op	97:67	0:0	6	->
water	97:69	0:0	6	i_start
water	97:76	0:0	6	;
water	98:8	0:0	6	}
water	99:4	0:0	4	}
for	101:4	104:4	2	(i = 0 ;i < i_count;i ++)
forinit	101:9	101:14	3	i = 0 ;
water	101:9	0:0	4	i
op	101:11	0:0	4	=
water	101:13	0:0	4	0
water	101:14	0:0	4	;
cond	101:16	101:20	3	i < i_count
water	101:16	0:0	4	i
op	101:18	0:0	4	<
water	101:20	0:0	4	i_count
forexpr	101:29	101:30	3	i ++
water	101:29	0:0	4	i
op	101:30	0:0	4	++
stmts	102:4	104:4	3	
water	102:4	0:0	4	{
call	103:8	103:53	4	SubsdelayEntryNewStopValueUpdated
arg	103:43	103:53	5	p_list[i]
water	103:43	0:0	6	p_list
op	103:49	0:0	6	[
water	103:50	0:0	6	i
op	103:51	0:0	6	]
water	103:54	0:0	4	;
water	104:4	0:0	4	}
