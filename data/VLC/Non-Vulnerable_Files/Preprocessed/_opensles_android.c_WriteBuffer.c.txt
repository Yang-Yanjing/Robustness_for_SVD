func	2:0	66:0	0	static int	WriteBuffer
params	2:22	0:0	1	
param	2:23	2:43	2	audio_output_t *	aout
stmnts	0:0	65:4	1	
decl	4:4	4:31	2	aout_sys_t	*sys
op	4:20	0:0	2	=
water	4:22	0:0	2	aout
op	4:26	0:0	2	->
water	4:28	0:0	2	sys
decl	5:4	5:68	2	const size_t	unit_size
op	5:27	0:0	2	=
water	5:29	0:0	2	sys
op	5:32	0:0	2	->
water	5:34	0:0	2	samples_per_buf
call	5:50	5:67	3	*bytesPerSample
decl	6:4	6:36	2	block_t	*b
op	6:15	0:0	2	=
water	6:17	0:0	2	sys
op	6:20	0:0	2	->
water	6:22	0:0	2	p_buffer_chain
if	7:4	8:20	2	(! b)
cond	7:8	7:9	3	! b
op	7:8	0:0	4	!
water	7:9	0:0	4	b
stmts	8:8	8:20	3	
return	8:8	8:20	4	false
water	8:15	0:0	5	false
if	10:4	21:4	2	(b -> i_buffer < unit_size)
cond	10:8	10:22	3	b -> i_buffer < unit_size
water	10:8	0:0	4	b
op	10:9	0:0	4	->
water	10:11	0:0	4	i_buffer
op	10:20	0:0	4	<
water	10:22	0:0	4	unit_size
stmts	10:33	21:4	3	
water	10:33	0:0	4	{
if	11:8	12:24	4	(! b -> p_next)
cond	11:12	11:16	5	! b -> p_next
op	11:12	0:0	6	!
water	11:13	0:0	6	b
op	11:14	0:0	6	->
water	11:16	0:0	6	p_next
stmts	12:12	12:24	5	
return	12:12	12:24	6	false
water	12:19	0:0	7	false
decl	13:8	13:48	4	ssize_t	needed
op	13:23	0:0	4	=
water	13:25	0:0	4	unit_size
op	13:35	0:0	4	-
water	13:37	0:0	4	b
op	13:38	0:0	4	->
water	13:40	0:0	4	i_buffer
for	14:8	18:8	4	( block_t * next = b -> p_next ;next;next = next -> p_next)
forinit	0:0	14:38	5	 block_t * next = b -> p_next ;
decl	14:13	14:38	6	block_t	*next
op	14:27	0:0	6	=
water	14:29	0:0	6	b
op	14:30	0:0	6	->
water	14:32	0:0	6	p_next
cond	14:40	14:40	5	next
water	14:40	0:0	6	next
forexpr	14:46	14:59	5	next = next -> p_next
water	14:46	0:0	6	next
op	14:51	0:0	6	=
water	14:53	0:0	6	next
op	14:57	0:0	6	->
water	14:59	0:0	6	p_next
stmts	14:67	18:8	5	
water	14:67	0:0	6	{
water	15:12	0:0	6	needed
op	15:19	0:0	6	-=
water	15:22	0:0	6	next
op	15:26	0:0	6	->
water	15:28	0:0	6	i_buffer
water	15:36	0:0	6	;
if	16:12	17:21	6	(needed <= 0)
cond	16:16	16:26	7	needed <= 0
water	16:16	0:0	8	needed
op	16:23	0:0	8	<=
water	16:26	0:0	8	0
stmts	17:16	17:21	7	
break	17:16	17:21	8	
water	18:8	0:0	6	}
if	19:8	20:24	4	(needed > 0)
cond	19:12	19:21	5	needed > 0
water	19:12	0:0	6	needed
op	19:19	0:0	6	>
water	19:21	0:0	6	0
stmts	20:12	20:24	5	
return	20:12	20:24	6	false
water	20:19	0:0	7	false
water	21:4	0:0	4	}
decl	22:4	22:38	2	SLAndroidSimpleBufferQueueState	st
decl	23:4	23:56	2	SLresult	res
op	23:17	0:0	2	=
call	23:19	23:55	3	GetState
arg	23:28	23:50	4	sys->playerBufferQueue
water	23:28	0:0	5	sys
op	23:31	0:0	5	->
water	23:33	0:0	5	playerBufferQueue
arg	23:52	23:55	4	&st
op	23:52	0:0	5	&
water	23:53	0:0	5	st
if	24:4	27:4	2	(unlikely (res != SL_RESULT_SUCCESS ))
cond	24:8	24:41	3	unlikely (res != SL_RESULT_SUCCESS )
call	24:8	24:41	4	unlikely
arg	24:17	24:41	5	res!=SL_RESULT_SUCCESS
water	24:17	0:0	6	res
op	24:21	0:0	6	!=
water	24:24	0:0	6	SL_RESULT_SUCCESS
stmts	24:44	27:4	3	
water	24:44	0:0	4	{
call	25:8	25:85	4	msg_Err
arg	25:16	25:20	5	aout
water	25:16	0:0	6	aout
arg	25:22	25:70	5	"Could not query buffer queue state in %s (%lu)"
water	25:22	0:0	6	"Could not query buffer queue state in %s (%lu)"
arg	25:72	25:80	5	__func__
water	25:72	0:0	6	__func__
arg	25:82	25:85	5	res
water	25:82	0:0	6	res
water	25:86	0:0	4	;
return	26:8	26:20	4	false
water	26:15	0:0	5	false
water	27:4	0:0	4	}
if	28:4	29:20	2	(st . count == OPENSLES_BUFFERS)
cond	28:8	28:20	3	st . count == OPENSLES_BUFFERS
water	28:8	0:0	4	st
op	28:10	0:0	4	.
water	28:11	0:0	4	count
op	28:17	0:0	4	==
water	28:20	0:0	4	OPENSLES_BUFFERS
stmts	29:8	29:20	3	
return	29:8	29:20	4	false
water	29:15	0:0	5	false
decl	30:4	30:19	2	size_t	done
op	30:16	0:0	2	=
water	30:18	0:0	2	0
while	31:4	48:4	2	(done < unit_size)
cond	31:11	31:18	3	done < unit_size
water	31:11	0:0	4	done
op	31:16	0:0	4	<
water	31:18	0:0	4	unit_size
stmts	31:29	48:4	3	
water	31:29	0:0	4	{
decl	32:8	32:32	4	size_t	cur
op	32:19	0:0	4	=
water	32:21	0:0	4	b
op	32:22	0:0	4	->
water	32:24	0:0	4	i_buffer
if	33:8	34:34	4	(cur > unit_size - done)
cond	33:12	33:30	5	cur > unit_size - done
water	33:12	0:0	6	cur
op	33:16	0:0	6	>
water	33:18	0:0	6	unit_size
op	33:28	0:0	6	-
water	33:30	0:0	6	done
stmts	34:12	34:34	5	
water	34:12	0:0	6	cur
op	34:16	0:0	6	=
water	34:18	0:0	6	unit_size
op	34:28	0:0	6	-
water	34:30	0:0	6	done
water	34:34	0:0	6	;
call	35:8	35:76	4	memcpy
arg	35:15	35:58	5	&sys->buf[unit_size*sys->next_buf+done]
op	35:15	0:0	6	&
water	35:16	0:0	6	sys
op	35:19	0:0	6	->
water	35:21	0:0	6	buf
op	35:24	0:0	6	[
water	35:25	0:0	6	unit_size
op	35:35	0:0	6	*
water	35:37	0:0	6	sys
op	35:40	0:0	6	->
water	35:42	0:0	6	next_buf
op	35:51	0:0	6	+
water	35:53	0:0	6	done
op	35:57	0:0	6	]
arg	35:60	35:71	5	b->p_buffer
water	35:60	0:0	6	b
op	35:61	0:0	6	->
water	35:63	0:0	6	p_buffer
arg	35:73	35:76	5	cur
water	35:73	0:0	6	cur
water	35:77	0:0	4	;
water	36:8	0:0	4	b
op	36:9	0:0	4	->
water	36:11	0:0	4	i_buffer
op	36:20	0:0	4	-=
water	36:23	0:0	4	cur
water	36:26	0:0	4	;
water	37:8	0:0	4	b
op	37:9	0:0	4	->
water	37:11	0:0	4	p_buffer
op	37:20	0:0	4	+=
water	37:23	0:0	4	cur
water	37:26	0:0	4	;
water	38:8	0:0	4	done
op	38:13	0:0	4	+=
water	38:16	0:0	4	cur
water	38:19	0:0	4	;
decl	39:8	39:33	4	block_t	*next
op	39:22	0:0	4	=
water	39:24	0:0	4	b
op	39:25	0:0	4	->
water	39:27	0:0	4	p_next
if	40:8	43:8	4	(b -> i_buffer == 0)
cond	40:12	40:27	5	b -> i_buffer == 0
water	40:12	0:0	6	b
op	40:13	0:0	6	->
water	40:15	0:0	6	i_buffer
op	40:24	0:0	6	==
water	40:27	0:0	6	0
stmts	40:30	43:8	5	
water	40:30	0:0	6	{
call	41:12	41:27	6	block_Release
arg	41:26	41:27	7	b
water	41:26	0:0	8	b
water	41:28	0:0	6	;
water	42:12	0:0	6	b
op	42:14	0:0	6	=
water	42:16	0:0	6	NULL
water	42:20	0:0	6	;
water	43:8	0:0	6	}
if	44:8	45:17	4	(done == unit_size)
cond	44:12	44:20	5	done == unit_size
water	44:12	0:0	6	done
op	44:17	0:0	6	==
water	44:20	0:0	6	unit_size
stmts	45:12	45:17	5	
break	45:12	45:17	6	
else	46:8	47:20	4
stmts	47:12	47:20	5	
water	47:12	0:0	6	b
op	47:14	0:0	6	=
water	47:16	0:0	6	next
water	47:20	0:0	6	;
water	48:4	0:0	4	}
water	49:4	0:0	2	sys
op	49:7	0:0	2	->
water	49:9	0:0	2	p_buffer_chain
op	49:24	0:0	2	=
water	49:26	0:0	2	b
water	49:27	0:0	2	;
if	50:4	51:50	2	(! b)
cond	50:8	50:9	3	! b
op	50:8	0:0	4	!
water	50:9	0:0	4	b
stmts	51:8	51:50	3	
water	51:8	0:0	4	sys
op	51:11	0:0	4	->
water	51:13	0:0	4	pp_buffer_last
op	51:28	0:0	4	=
op	51:30	0:0	4	&
water	51:31	0:0	4	sys
op	51:34	0:0	4	->
water	51:36	0:0	4	p_buffer_chain
water	51:50	0:0	4	;
decl	52:4	53:56	2	SLresult	r
op	52:15	0:0	2	=
call	52:17	53:55	3	Enqueue
arg	52:25	52:47	4	sys->playerBufferQueue
water	52:25	0:0	5	sys
op	52:28	0:0	5	->
water	52:30	0:0	5	playerBufferQueue
arg	53:8	53:44	4	&sys->buf[unit_size*sys->next_buf]
op	53:8	0:0	5	&
water	53:9	0:0	5	sys
op	53:12	0:0	5	->
water	53:14	0:0	5	buf
op	53:17	0:0	5	[
water	53:18	0:0	5	unit_size
op	53:28	0:0	5	*
water	53:30	0:0	5	sys
op	53:33	0:0	5	->
water	53:35	0:0	5	next_buf
op	53:43	0:0	5	]
arg	53:46	53:55	4	unit_size
water	53:46	0:0	5	unit_size
water	54:4	0:0	2	sys
op	54:7	0:0	2	->
water	54:9	0:0	2	samples
op	54:17	0:0	2	-=
water	54:20	0:0	2	sys
op	54:23	0:0	2	->
water	54:25	0:0	2	samples_per_buf
water	54:40	0:0	2	;
if	55:4	59:4	2	(r == SL_RESULT_SUCCESS)
cond	55:8	55:13	3	r == SL_RESULT_SUCCESS
water	55:8	0:0	4	r
op	55:10	0:0	4	==
water	55:13	0:0	4	SL_RESULT_SUCCESS
stmts	55:32	59:4	3	
water	55:32	0:0	4	{
if	56:8	57:29	4	(++ sys -> next_buf == OPENSLES_BUFFERS)
cond	56:12	56:31	5	++ sys -> next_buf == OPENSLES_BUFFERS
op	56:12	0:0	6	++
water	56:14	0:0	6	sys
op	56:17	0:0	6	->
water	56:19	0:0	6	next_buf
op	56:28	0:0	6	==
water	56:31	0:0	6	OPENSLES_BUFFERS
stmts	57:12	57:29	5	
water	57:12	0:0	6	sys
op	57:15	0:0	6	->
water	57:17	0:0	6	next_buf
op	57:26	0:0	6	=
water	57:28	0:0	6	0
water	57:29	0:0	6	;
return	58:8	58:19	4	true
water	58:15	0:0	5	true
water	59:4	0:0	4	}
else	59:6	65:4	2
stmts	59:11	65:4	3	
water	59:11	0:0	4	{
call	61:8	63:84	4	msg_Err
arg	61:16	61:20	5	aout
water	61:16	0:0	6	aout
arg	61:22	61:58	5	"error %lu when writing %d bytes %s"
water	61:22	0:0	6	"error %lu when writing %d bytes %s"
arg	62:16	62:17	5	r
water	62:16	0:0	6	r
arg	62:19	62:30	5	b->i_buffer
water	62:19	0:0	6	b
op	62:20	0:0	6	->
water	62:22	0:0	6	i_buffer
arg	63:16	63:84	5	(r==SL_RESULT_BUFFER_INSUFFICIENT)?" (buffer insufficient)":""
water	63:16	0:0	6	(
water	63:17	0:0	6	r
op	63:19	0:0	6	==
water	63:22	0:0	6	SL_RESULT_BUFFER_INSUFFICIENT
water	63:51	0:0	6	)
water	63:53	0:0	6	?
water	63:55	0:0	6	" (buffer insufficient)"
water	63:80	0:0	6	:
water	63:82	0:0	6	""
water	63:85	0:0	4	;
return	64:8	64:20	4	false
water	64:15	0:0	5	false
water	65:4	0:0	4	}
