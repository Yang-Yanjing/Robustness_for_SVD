func	2:0	66:0	0	static block_t *	Parse
params	2:21	0:0	1	
param	2:23	2:39	2	decoder_t *	p_dec
param	2:41	2:61	2	int *	pi_frame_length
param	2:63	2:75	2	int *	pi_bits
param	3:23	3:41	2	block_t * *	pp_block
param	3:43	3:61	2	bool	b_packetizer
stmnts	0:0	65:18	1	
decl	5:4	5:39	2	decoder_sys_t	*p_sys
op	5:25	0:0	2	=
water	5:27	0:0	2	p_dec
op	5:32	0:0	2	->
water	5:34	0:0	2	p_sys
decl	6:4	6:26	2	block_t	*p_block
decl	7:4	7:14	2	uint32_t	h
decl	8:4	8:23	2	unsigned int	i_size
decl	9:4	9:18	2	int	i_channels
decl	10:4	10:14	2	int	i_bits
if	11:4	11:45	2	(! pp_block || ! * pp_block)
cond	11:8	11:23	3	! pp_block || ! * pp_block
op	11:8	0:0	4	!
water	11:9	0:0	4	pp_block
op	11:18	0:0	4	||
op	11:21	0:0	4	!
op	11:22	0:0	4	*
water	11:23	0:0	4	pp_block
stmts	11:34	11:45	3	
return	11:34	11:45	4	NULL
water	11:41	0:0	5	NULL
water	12:4	0:0	2	p_block
op	12:12	0:0	2	=
op	12:14	0:0	2	*
water	12:15	0:0	2	pp_block
water	12:23	0:0	2	;
op	13:4	0:0	2	*
water	13:5	0:0	2	pp_block
op	13:14	0:0	2	=
water	13:16	0:0	2	NULL
water	13:20	0:0	2	;
if	15:4	19:4	2	(p_block -> i_pts > VLC_TS_INVALID && p_block -> i_pts !=date_Get (& p_sys -> end_date ))
cond	15:8	16:53	3	p_block -> i_pts > VLC_TS_INVALID && p_block -> i_pts !=date_Get (& p_sys -> end_date )
water	15:8	0:0	4	p_block
op	15:15	0:0	4	->
water	15:17	0:0	4	i_pts
op	15:23	0:0	4	>
water	15:25	0:0	4	VLC_TS_INVALID
op	15:40	0:0	4	&&
water	16:8	0:0	4	p_block
op	16:15	0:0	4	->
water	16:17	0:0	4	i_pts
op	16:23	0:0	4	!=
call	16:26	16:53	4	date_Get
arg	16:36	16:53	5	&p_sys->end_date
op	16:36	0:0	6	&
water	16:37	0:0	6	p_sys
op	16:42	0:0	6	->
water	16:44	0:0	6	end_date
stmts	17:4	19:4	3	
water	17:4	0:0	4	{
call	18:8	18:51	4	date_Set
arg	18:18	18:34	5	&p_sys->end_date
op	18:18	0:0	6	&
water	18:19	0:0	6	p_sys
op	18:24	0:0	6	->
water	18:26	0:0	6	end_date
arg	18:36	18:51	5	p_block->i_pts
water	18:36	0:0	6	p_block
op	18:43	0:0	6	->
water	18:45	0:0	6	i_pts
water	18:52	0:0	4	;
water	19:4	0:0	4	}
if	20:4	25:4	2	(!date_Get (& p_sys -> end_date ))
cond	20:8	20:36	3	!date_Get (& p_sys -> end_date )
op	20:8	0:0	4	!
call	20:9	20:36	4	date_Get
arg	20:19	20:36	5	&p_sys->end_date
op	20:19	0:0	6	&
water	20:20	0:0	6	p_sys
op	20:25	0:0	6	->
water	20:27	0:0	6	end_date
stmts	21:4	25:4	3	
water	21:4	0:0	4	{
call	23:8	23:31	4	block_Release
arg	23:23	23:31	5	p_block
water	23:23	0:0	6	p_block
water	23:32	0:0	4	;
return	24:8	24:19	4	NULL
water	24:15	0:0	5	NULL
water	25:4	0:0	4	}
if	26:4	31:4	2	(p_block -> i_buffer <= AES3_HEADER_LEN)
cond	26:8	26:29	3	p_block -> i_buffer <= AES3_HEADER_LEN
water	26:8	0:0	4	p_block
op	26:15	0:0	4	->
water	26:17	0:0	4	i_buffer
op	26:26	0:0	4	<=
water	26:29	0:0	4	AES3_HEADER_LEN
stmts	27:4	31:4	3	
water	27:4	0:0	4	{
call	28:8	28:43	4	msg_Err
arg	28:16	28:21	5	p_dec
water	28:16	0:0	6	p_dec
arg	28:23	28:43	5	"frame is too short"
water	28:23	0:0	6	"frame is too short"
water	28:44	0:0	4	;
call	29:8	29:31	4	block_Release
arg	29:23	29:31	5	p_block
water	29:23	0:0	6	p_block
water	29:32	0:0	4	;
return	30:8	30:19	4	NULL
water	30:15	0:0	5	NULL
water	31:4	0:0	4	}
water	40:4	0:0	2	h
op	40:6	0:0	2	=
call	40:8	40:35	2	GetDWBE
arg	40:17	40:35	3	p_block->p_buffer
water	40:17	0:0	4	p_block
op	40:24	0:0	4	->
water	40:26	0:0	4	p_buffer
water	40:36	0:0	2	;
water	41:4	0:0	2	i_size
op	41:11	0:0	2	=
water	41:13	0:0	2	(
water	41:14	0:0	2	h
op	41:16	0:0	2	>>
water	41:19	0:0	2	16
water	41:21	0:0	2	)
op	41:23	0:0	2	&
water	41:25	0:0	2	0
water	41:26	0:0	2	xffff
water	41:31	0:0	2	;
water	42:4	0:0	2	i_channels
op	42:15	0:0	2	=
water	42:17	0:0	2	2
op	42:19	0:0	2	+
water	42:21	0:0	2	2
op	42:22	0:0	2	*
water	42:23	0:0	2	(
water	42:25	0:0	2	(
water	42:26	0:0	2	h
op	42:28	0:0	2	>>
water	42:31	0:0	2	14
water	42:33	0:0	2	)
op	42:35	0:0	2	&
water	42:37	0:0	2	0
water	42:38	0:0	2	x03
water	42:42	0:0	2	)
water	42:43	0:0	2	;
water	43:4	0:0	2	i_bits
op	43:11	0:0	2	=
water	43:13	0:0	2	16
op	43:16	0:0	2	+
water	43:18	0:0	2	4
op	43:19	0:0	2	*
water	43:20	0:0	2	(
water	43:22	0:0	2	(
water	43:23	0:0	2	h
op	43:25	0:0	2	>>
water	43:28	0:0	2	4
water	43:29	0:0	2	)
op	43:30	0:0	2	&
water	43:31	0:0	2	0
water	43:32	0:0	2	x03
water	43:36	0:0	2	)
water	43:37	0:0	2	;
if	44:4	49:4	2	(AES3_HEADER_LEN + i_size != p_block -> i_buffer || i_bits > 24)
cond	44:8	44:66	3	AES3_HEADER_LEN + i_size != p_block -> i_buffer || i_bits > 24
water	44:8	0:0	4	AES3_HEADER_LEN
op	44:24	0:0	4	+
water	44:26	0:0	4	i_size
op	44:33	0:0	4	!=
water	44:36	0:0	4	p_block
op	44:43	0:0	4	->
water	44:45	0:0	4	i_buffer
op	44:54	0:0	4	||
water	44:57	0:0	4	i_bits
op	44:64	0:0	4	>
water	44:66	0:0	4	24
stmts	45:4	49:4	3	
water	45:4	0:0	4	{
call	46:8	46:49	4	msg_Err
arg	46:16	46:21	5	p_dec
water	46:16	0:0	6	p_dec
arg	46:23	46:49	5	"frame has invalid header"
water	46:23	0:0	6	"frame has invalid header"
water	46:50	0:0	4	;
call	47:8	47:31	4	block_Release
arg	47:23	47:31	5	p_block
water	47:23	0:0	6	p_block
water	47:32	0:0	4	;
return	48:8	48:19	4	NULL
water	48:15	0:0	5	NULL
water	49:4	0:0	4	}
if	51:4	54:4	2	(b_packetizer)
cond	51:8	51:8	3	b_packetizer
water	51:8	0:0	4	b_packetizer
stmts	52:4	54:4	3	
water	52:4	0:0	4	{
water	53:8	0:0	4	p_dec
op	53:13	0:0	4	->
water	53:15	0:0	4	fmt_out
op	53:22	0:0	4	.
water	53:23	0:0	4	audio
op	53:28	0:0	4	.
water	53:29	0:0	4	i_bitspersample
op	53:45	0:0	4	=
water	53:47	0:0	4	i_bits
water	53:53	0:0	4	;
water	54:4	0:0	4	}
else	55:4	59:4	2
stmts	56:4	59:4	3	
water	56:4	0:0	4	{
water	57:8	0:0	4	p_dec
op	57:13	0:0	4	->
water	57:15	0:0	4	fmt_out
op	57:22	0:0	4	.
water	57:23	0:0	4	i_codec
op	57:31	0:0	4	=
water	57:33	0:0	4	i_bits
op	57:40	0:0	4	==
water	57:43	0:0	4	16
water	57:46	0:0	4	?
water	57:48	0:0	4	VLC_CODEC_S16N
water	57:63	0:0	4	:
water	57:65	0:0	4	VLC_CODEC_S32N
water	57:79	0:0	4	;
water	58:8	0:0	4	p_dec
op	58:13	0:0	4	->
water	58:15	0:0	4	fmt_out
op	58:22	0:0	4	.
water	58:23	0:0	4	audio
op	58:28	0:0	4	.
water	58:29	0:0	4	i_bitspersample
op	58:45	0:0	4	=
water	58:47	0:0	4	i_bits
op	58:54	0:0	4	==
water	58:57	0:0	4	16
water	58:60	0:0	4	?
water	58:62	0:0	4	16
water	58:65	0:0	4	:
water	58:67	0:0	4	32
water	58:69	0:0	4	;
water	59:4	0:0	4	}
water	60:4	0:0	2	p_dec
op	60:9	0:0	2	->
water	60:11	0:0	2	fmt_out
op	60:18	0:0	2	.
water	60:19	0:0	2	audio
op	60:24	0:0	2	.
water	60:25	0:0	2	i_channels
op	60:36	0:0	2	=
water	60:38	0:0	2	i_channels
water	60:48	0:0	2	;
water	61:4	0:0	2	p_dec
op	61:9	0:0	2	->
water	61:11	0:0	2	fmt_out
op	61:18	0:0	2	.
water	61:19	0:0	2	audio
op	61:24	0:0	2	.
water	61:25	0:0	2	i_original_channels
op	61:45	0:0	2	=
water	61:47	0:0	2	pi_original_channels
op	61:67	0:0	2	[
water	61:68	0:0	2	i_channels
op	61:78	0:0	2	/
water	61:79	0:0	2	2
op	61:80	0:0	2	-
water	61:81	0:0	2	1
op	61:82	0:0	2	]
water	61:83	0:0	2	;
water	62:4	0:0	2	p_dec
op	62:9	0:0	2	->
water	62:11	0:0	2	fmt_out
op	62:18	0:0	2	.
water	62:19	0:0	2	audio
op	62:24	0:0	2	.
water	62:25	0:0	2	i_physical_channels
op	62:45	0:0	2	=
water	62:47	0:0	2	pi_original_channels
op	62:67	0:0	2	[
water	62:68	0:0	2	i_channels
op	62:78	0:0	2	/
water	62:79	0:0	2	2
op	62:80	0:0	2	-
water	62:81	0:0	2	1
op	62:82	0:0	2	]
water	62:83	0:0	2	;
op	63:4	0:0	2	*
water	63:5	0:0	2	pi_frame_length
op	63:21	0:0	2	=
water	63:23	0:0	2	(
water	63:24	0:0	2	p_block
op	63:31	0:0	2	->
water	63:33	0:0	2	i_buffer
op	63:42	0:0	2	-
water	63:44	0:0	2	AES3_HEADER_LEN
water	63:59	0:0	2	)
op	63:61	0:0	2	/
water	63:63	0:0	2	(
water	63:65	0:0	2	(
water	63:66	0:0	2	4
op	63:67	0:0	2	+
water	63:68	0:0	2	i_bits
water	63:74	0:0	2	)
op	63:76	0:0	2	*
water	63:78	0:0	2	i_channels
op	63:89	0:0	2	/
water	63:91	0:0	2	8
water	63:93	0:0	2	)
water	63:94	0:0	2	;
op	64:4	0:0	2	*
water	64:5	0:0	2	pi_bits
op	64:13	0:0	2	=
water	64:15	0:0	2	i_bits
water	64:21	0:0	2	;
return	65:4	65:18	2	p_block
water	65:11	0:0	3	p_block
