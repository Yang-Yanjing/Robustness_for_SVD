func	2:0	47:0	0	static block_t *	PacketizeAVC1
params	2:29	0:0	1	
param	2:31	2:47	2	decoder_t *	p_dec
param	2:49	2:68	2	block_t * *	pp_block
stmnts	0:0	46:16	1	
decl	4:4	4:39	2	decoder_sys_t	*p_sys
op	4:25	0:0	2	=
water	4:27	0:0	2	p_dec
op	4:32	0:0	2	->
water	4:34	0:0	2	p_sys
decl	5:4	5:26	2	block_t	*p_block
decl	6:4	6:31	2	block_t	*p_ret
op	6:25	0:0	2	=
water	6:27	0:0	2	NULL
decl	7:4	7:20	2	uint8_t	*p
if	8:4	9:19	2	(! pp_block || ! * pp_block)
cond	8:8	8:23	3	! pp_block || ! * pp_block
op	8:8	0:0	4	!
water	8:9	0:0	4	pp_block
op	8:18	0:0	4	||
op	8:21	0:0	4	!
op	8:22	0:0	4	*
water	8:23	0:0	4	pp_block
stmts	9:8	9:19	3	
return	9:8	9:19	4	NULL
water	9:15	0:0	5	NULL
if	10:4	14:4	2	(( * pp_block ) -> i_flags & ( BLOCK_FLAG_DISCONTINUITY | BLOCK_FLAG_CORRUPTED ))
cond	10:8	10:75	3	( * pp_block ) -> i_flags & ( BLOCK_FLAG_DISCONTINUITY | BLOCK_FLAG_CORRUPTED )
water	10:8	0:0	4	(
op	10:9	0:0	4	*
water	10:10	0:0	4	pp_block
water	10:18	0:0	4	)
op	10:19	0:0	4	->
water	10:21	0:0	4	i_flags
op	10:28	0:0	4	&
water	10:29	0:0	4	(
water	10:30	0:0	4	BLOCK_FLAG_DISCONTINUITY
op	10:54	0:0	4	|
water	10:55	0:0	4	BLOCK_FLAG_CORRUPTED
water	10:75	0:0	4	)
stmts	11:4	14:4	3	
water	11:4	0:0	4	{
call	12:8	12:33	4	block_Release
arg	12:23	12:33	5	*pp_block
op	12:23	0:0	6	*
water	12:24	0:0	6	pp_block
water	12:34	0:0	4	;
return	13:8	13:19	4	NULL
water	13:15	0:0	5	NULL
water	14:4	0:0	4	}
water	15:4	0:0	2	p_block
op	15:12	0:0	2	=
op	15:14	0:0	2	*
water	15:15	0:0	2	pp_block
water	15:23	0:0	2	;
op	16:4	0:0	2	*
water	16:5	0:0	2	pp_block
op	16:14	0:0	2	=
water	16:16	0:0	2	NULL
water	16:20	0:0	2	;
for	17:4	44:4	2	(p = p_block -> p_buffer ;p < & p_block -> p_buffer [ p_block -> i_buffer ];)
forinit	17:9	17:30	3	p = p_block -> p_buffer ;
water	17:9	0:0	4	p
op	17:11	0:0	4	=
water	17:13	0:0	4	p_block
op	17:20	0:0	4	->
water	17:22	0:0	4	p_buffer
water	17:30	0:0	4	;
cond	17:32	17:72	3	p < & p_block -> p_buffer [ p_block -> i_buffer ]
water	17:32	0:0	4	p
op	17:34	0:0	4	<
op	17:36	0:0	4	&
water	17:37	0:0	4	p_block
op	17:44	0:0	4	->
water	17:46	0:0	4	p_buffer
op	17:54	0:0	4	[
water	17:55	0:0	4	p_block
op	17:62	0:0	4	->
water	17:64	0:0	4	i_buffer
op	17:72	0:0	4	]
forexpr	0:0	0:0	3	
stmts	18:4	44:4	3	
water	18:4	0:0	4	{
decl	19:8	19:22	4	block_t	*p_pic
decl	20:8	20:20	4	bool	b_dummy
decl	21:8	21:22	4	int	i_size
op	21:19	0:0	4	=
water	21:21	0:0	4	0
decl	22:8	22:13	4	int	i
for	23:8	26:8	4	(i = 0 ;i < p_sys -> i_avcC_length_size;i ++)
forinit	23:13	23:18	5	i = 0 ;
water	23:13	0:0	6	i
op	23:15	0:0	6	=
water	23:17	0:0	6	0
water	23:18	0:0	6	;
cond	23:20	23:31	5	i < p_sys -> i_avcC_length_size
water	23:20	0:0	6	i
op	23:22	0:0	6	<
water	23:24	0:0	6	p_sys
op	23:29	0:0	6	->
water	23:31	0:0	6	i_avcC_length_size
forexpr	23:51	23:52	5	i ++
water	23:51	0:0	6	i
op	23:52	0:0	6	++
stmts	24:8	26:8	5	
water	24:8	0:0	6	{
water	25:12	0:0	6	i_size
op	25:19	0:0	6	=
water	25:21	0:0	6	(
water	25:22	0:0	6	i_size
op	25:29	0:0	6	<<
water	25:32	0:0	6	8
water	25:33	0:0	6	)
op	25:35	0:0	6	|
water	25:37	0:0	6	(
op	25:38	0:0	6	*
water	25:39	0:0	6	p
op	25:40	0:0	6	++
water	25:42	0:0	6	)
water	25:43	0:0	6	;
water	26:8	0:0	6	}
if	27:8	32:8	4	(i_size <= 0 || i_size > ( p_block -> p_buffer + p_block -> i_buffer - p ))
cond	27:12	28:65	5	i_size <= 0 || i_size > ( p_block -> p_buffer + p_block -> i_buffer - p )
water	27:12	0:0	6	i_size
op	27:19	0:0	6	<=
water	27:22	0:0	6	0
op	27:24	0:0	6	||
water	28:12	0:0	6	i_size
op	28:19	0:0	6	>
water	28:21	0:0	6	(
water	28:23	0:0	6	p_block
op	28:30	0:0	6	->
water	28:32	0:0	6	p_buffer
op	28:41	0:0	6	+
water	28:43	0:0	6	p_block
op	28:50	0:0	6	->
water	28:52	0:0	6	i_buffer
op	28:61	0:0	6	-
water	28:63	0:0	6	p
water	28:65	0:0	6	)
stmts	29:8	32:8	5	
water	29:8	0:0	6	{
call	30:12	30:72	6	msg_Err
arg	30:21	30:26	7	p_dec
water	30:21	0:0	8	p_dec
arg	30:28	30:63	7	"Broken frame : size %d is too big"
water	30:28	0:0	8	"Broken frame : size %d is too big"
arg	30:65	30:72	7	i_size
water	30:65	0:0	8	i_size
water	30:73	0:0	6	;
break	31:12	31:17	6	
water	32:8	0:0	6	}
decl	33:8	33:61	4	block_t	*p_part
op	33:24	0:0	4	=
call	33:26	33:60	5	CreateAnnexbNAL
arg	33:43	33:48	6	p_dec
water	33:43	0:0	7	p_dec
arg	33:50	33:51	6	p
water	33:50	0:0	7	p
arg	33:53	33:60	6	i_size
water	33:53	0:0	7	i_size
if	34:8	35:17	4	(! p_part)
cond	34:12	34:13	5	! p_part
op	34:12	0:0	6	!
water	34:13	0:0	6	p_part
stmts	35:12	35:17	5	
break	35:12	35:17	6	
water	36:8	0:0	4	p_part
op	36:14	0:0	4	->
water	36:16	0:0	4	i_dts
op	36:22	0:0	4	=
water	36:24	0:0	4	p_block
op	36:31	0:0	4	->
water	36:33	0:0	4	i_dts
water	36:38	0:0	4	;
water	37:8	0:0	4	p_part
op	37:14	0:0	4	->
water	37:16	0:0	4	i_pts
op	37:22	0:0	4	=
water	37:24	0:0	4	p_block
op	37:31	0:0	4	->
water	37:33	0:0	4	i_pts
water	37:38	0:0	4	;
if	39:8	42:8	4	(( p_pic =ParseNALBlock (p_dec ,& b_dummy ,p_part ) ))
cond	39:12	39:63	5	( p_pic =ParseNALBlock (p_dec ,& b_dummy ,p_part ) )
water	39:12	0:0	6	(
water	39:14	0:0	6	p_pic
op	39:20	0:0	6	=
call	39:22	39:61	6	ParseNALBlock
arg	39:37	39:42	7	p_dec
water	39:37	0:0	8	p_dec
arg	39:44	39:52	7	&b_dummy
op	39:44	0:0	8	&
water	39:45	0:0	8	b_dummy
arg	39:54	39:61	7	p_part
water	39:54	0:0	8	p_part
water	39:63	0:0	6	)
stmts	40:8	42:8	5	
water	40:8	0:0	6	{
call	41:12	41:45	6	block_ChainAppend
arg	41:31	41:37	7	&p_ret
op	41:31	0:0	8	&
water	41:32	0:0	8	p_ret
arg	41:39	41:45	7	p_pic
water	41:39	0:0	8	p_pic
water	41:46	0:0	6	;
water	42:8	0:0	6	}
water	43:8	0:0	4	p
op	43:10	0:0	4	+=
water	43:13	0:0	4	i_size
water	43:19	0:0	4	;
water	44:4	0:0	4	}
call	45:4	45:27	2	block_Release
arg	45:19	45:27	3	p_block
water	45:19	0:0	4	p_block
water	45:28	0:0	2	;
return	46:4	46:16	2	p_ret
water	46:11	0:0	3	p_ret
