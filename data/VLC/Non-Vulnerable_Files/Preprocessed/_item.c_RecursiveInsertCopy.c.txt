func	2:0	38:0	0	static int	RecursiveInsertCopy
params	2:31	0:0	1	
param	3:4	3:26	2	playlist_t *	p_playlist
param	3:28	3:51	2	playlist_item_t *	p_item
param	4:4	4:29	2	playlist_item_t *	p_parent
param	4:31	4:40	2	int	i_pos
param	4:42	4:54	2	bool	b_flat
stmnts	6:4	37:16	1	
water	6:4	0:0	2	PL_ASSERT_LOCKED
water	6:20	0:0	2	;
call	7:4	7:47	2	assert
arg	7:12	7:47	3	p_parent!=NULL&&p_item!=NULL
water	7:12	0:0	4	p_parent
op	7:21	0:0	4	!=
water	7:24	0:0	4	NULL
op	7:29	0:0	4	&&
water	7:32	0:0	4	p_item
op	7:39	0:0	4	!=
water	7:42	0:0	4	NULL
water	7:48	0:0	2	;
if	8:4	8:41	2	(p_item == p_parent)
cond	8:8	8:18	3	p_item == p_parent
water	8:8	0:0	4	p_item
op	8:15	0:0	4	==
water	8:18	0:0	4	p_parent
stmts	8:29	8:41	3	
return	8:29	8:41	4	i_pos
water	8:36	0:0	5	i_pos
decl	9:4	9:43	2	input_item_t	*p_input
op	9:26	0:0	2	=
water	9:28	0:0	2	p_item
op	9:34	0:0	2	->
water	9:36	0:0	2	p_input
if	10:4	27:4	2	(! ( p_item -> i_children != - 1 && b_flat ))
cond	10:8	10:44	3	! ( p_item -> i_children != - 1 && b_flat )
op	10:8	0:0	4	!
water	10:9	0:0	4	(
water	10:10	0:0	4	p_item
op	10:16	0:0	4	->
water	10:18	0:0	4	i_children
op	10:29	0:0	4	!=
op	10:32	0:0	4	-
water	10:33	0:0	4	1
op	10:35	0:0	4	&&
water	10:38	0:0	4	b_flat
water	10:44	0:0	4	)
stmts	11:4	27:4	3	
water	11:4	0:0	4	{
decl	12:8	12:62	4	input_item_t	*p_new_input
op	12:34	0:0	4	=
call	12:36	12:61	5	input_item_Copy
arg	12:53	12:61	6	p_input
water	12:53	0:0	7	p_input
if	13:8	13:39	4	(! p_new_input)
cond	13:12	13:13	5	! p_new_input
op	13:12	0:0	6	!
water	13:13	0:0	6	p_new_input
stmts	13:27	13:39	5	
return	13:27	13:39	6	i_pos
water	13:34	0:0	7	i_pos
decl	14:8	14:42	4	playlist_item_t	*p_new_item
op	14:36	0:0	4	=
water	14:38	0:0	4	NULL
if	15:8	18:46	4	(p_item -> i_children == - 1)
cond	15:12	15:35	5	p_item -> i_children == - 1
water	15:12	0:0	6	p_item
op	15:18	0:0	6	->
water	15:20	0:0	6	i_children
op	15:31	0:0	6	==
op	15:34	0:0	6	-
water	15:35	0:0	6	1
stmts	16:12	18:46	5	
water	16:12	0:0	6	p_new_item
op	16:23	0:0	6	=
call	16:25	18:45	6	playlist_NodeAddInput
arg	16:48	16:58	7	p_playlist
water	16:48	0:0	8	p_playlist
arg	16:60	16:71	7	p_new_input
water	16:60	0:0	8	p_new_input
arg	17:35	17:43	7	p_parent
water	17:35	0:0	8	p_parent
arg	17:45	17:60	7	PLAYLIST_INSERT
water	17:45	0:0	8	PLAYLIST_INSERT
arg	17:62	17:67	7	i_pos
water	17:62	0:0	8	i_pos
arg	18:35	18:45	7	pl_Locked
water	18:35	0:0	8	pl_Locked
water	18:46	0:0	6	;
else	19:8	21:66	4
stmts	20:12	21:66	5	
water	20:12	0:0	6	p_new_item
op	20:23	0:0	6	=
call	20:25	21:65	6	playlist_NodeCreate
arg	20:46	20:56	7	p_playlist
water	20:46	0:0	8	p_playlist
arg	20:58	20:62	7	NULL
water	20:58	0:0	8	NULL
arg	21:33	21:41	7	p_parent
water	21:33	0:0	8	p_parent
arg	21:43	21:48	7	i_pos
water	21:43	0:0	8	i_pos
arg	21:50	21:51	7	0
water	21:50	0:0	8	0
arg	21:53	21:65	7	p_new_input
water	21:53	0:0	8	p_new_input
water	21:66	0:0	6	;
call	22:8	22:35	4	vlc_gc_decref
arg	22:23	22:35	5	p_new_input
water	22:23	0:0	6	p_new_input
water	22:36	0:0	4	;
if	23:8	23:38	4	(! p_new_item)
cond	23:12	23:13	5	! p_new_item
op	23:12	0:0	6	!
water	23:13	0:0	6	p_new_item
stmts	23:26	23:38	5	
return	23:26	23:38	6	i_pos
water	23:33	0:0	7	i_pos
water	24:8	0:0	4	i_pos
op	24:13	0:0	4	++
water	24:15	0:0	4	;
if	25:8	26:33	4	(p_new_item -> i_children != - 1)
cond	25:12	25:39	5	p_new_item -> i_children != - 1
water	25:12	0:0	6	p_new_item
op	25:22	0:0	6	->
water	25:24	0:0	6	i_children
op	25:35	0:0	6	!=
op	25:38	0:0	6	-
water	25:39	0:0	6	1
stmts	26:12	26:33	5	
water	26:12	0:0	6	p_parent
op	26:21	0:0	6	=
water	26:23	0:0	6	p_new_item
water	26:33	0:0	6	;
water	27:4	0:0	4	}
for	28:4	36:4	2	( int i = 0 ;i < p_item -> i_children;i ++)
forinit	0:0	28:18	3	 int i = 0 ;
decl	28:9	28:18	4	int	i
op	28:15	0:0	4	=
water	28:17	0:0	4	0
cond	28:20	28:32	3	i < p_item -> i_children
water	28:20	0:0	4	i
op	28:22	0:0	4	<
water	28:24	0:0	4	p_item
op	28:30	0:0	4	->
water	28:32	0:0	4	i_children
forexpr	28:44	28:45	3	i ++
water	28:44	0:0	4	i
op	28:45	0:0	4	++
stmts	29:4	36:4	3	
water	29:4	0:0	4	{
if	30:8	32:64	4	(b_flat)
cond	30:12	30:12	5	b_flat
water	30:12	0:0	6	b_flat
stmts	31:12	32:64	5	
water	31:12	0:0	6	i_pos
op	31:18	0:0	6	=
call	31:20	32:63	6	RecursiveInsertCopy
arg	31:41	31:51	7	p_playlist
water	31:41	0:0	8	p_playlist
arg	31:53	31:75	7	p_item->pp_children[i]
water	31:53	0:0	8	p_item
op	31:59	0:0	8	->
water	31:61	0:0	8	pp_children
op	31:72	0:0	8	[
water	31:73	0:0	8	i
op	31:74	0:0	8	]
arg	32:41	32:49	7	p_parent
water	32:41	0:0	8	p_parent
arg	32:51	32:56	7	i_pos
water	32:51	0:0	8	i_pos
arg	32:58	32:63	7	true
water	32:58	0:0	8	true
water	32:64	0:0	6	;
else	33:8	35:72	4
stmts	34:12	35:72	5	
call	34:12	35:71	6	RecursiveInsertCopy
arg	34:33	34:43	7	p_playlist
water	34:33	0:0	8	p_playlist
arg	34:45	34:67	7	p_item->pp_children[i]
water	34:45	0:0	8	p_item
op	34:51	0:0	8	->
water	34:53	0:0	8	pp_children
op	34:64	0:0	8	[
water	34:65	0:0	8	i
op	34:66	0:0	8	]
arg	35:33	35:41	7	p_parent
water	35:33	0:0	8	p_parent
arg	35:43	35:63	7	p_parent->i_children
water	35:43	0:0	8	p_parent
op	35:51	0:0	8	->
water	35:53	0:0	8	i_children
arg	35:65	35:71	7	false
water	35:65	0:0	8	false
water	35:72	0:0	6	;
water	36:4	0:0	4	}
return	37:4	37:16	2	i_pos
water	37:11	0:0	3	i_pos
