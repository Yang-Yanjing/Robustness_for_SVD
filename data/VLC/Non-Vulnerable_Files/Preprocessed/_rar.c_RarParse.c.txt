func	2:0	86:0	0	int	RarParse
params	2:12	0:0	1	
param	2:13	2:24	2	stream_t *	s
param	2:26	2:36	2	int *	count
param	2:38	2:56	2	rar_file_t * * *	file
param	2:58	2:72	2	bool	b_extonly
stmnts	4:4	85:4	1	
op	4:4	0:0	2	*
water	4:5	0:0	2	count
op	4:11	0:0	2	=
water	4:13	0:0	2	0
water	4:14	0:0	2	;
op	5:4	0:0	2	*
water	5:5	0:0	2	file
op	5:10	0:0	2	=
water	5:12	0:0	2	NULL
water	5:16	0:0	2	;
decl	6:4	6:76	2	const rar_pattern_t	*pattern
op	6:33	0:0	2	=
call	6:35	6:75	3	FindVolumePattern
arg	6:53	6:64	4	s->psz_path
water	6:53	0:0	5	s
op	6:54	0:0	5	->
water	6:56	0:0	5	psz_path
arg	6:66	6:75	4	b_extonly
water	6:66	0:0	5	b_extonly
decl	7:4	7:25	2	int	volume_offset
op	7:22	0:0	2	=
water	7:24	0:0	2	0
decl	8:4	8:20	2	char	*volume_mrl
if	9:4	11:27	2	(asprintf (& volume_mrl ,"%s://%s" ,s -> psz_access ,s -> psz_path ) < 0)
cond	9:8	10:47	3	asprintf (& volume_mrl ,"%s://%s" ,s -> psz_access ,s -> psz_path ) < 0
call	9:8	10:43	4	asprintf
arg	9:17	9:28	5	&volume_mrl
op	9:17	0:0	6	&
water	9:18	0:0	6	volume_mrl
arg	9:30	9:39	5	"%s://%s"
water	9:30	0:0	6	"%s://%s"
arg	10:17	10:30	5	s->psz_access
water	10:17	0:0	6	s
op	10:18	0:0	6	->
water	10:20	0:0	6	psz_access
arg	10:32	10:43	5	s->psz_path
water	10:32	0:0	6	s
op	10:33	0:0	6	->
water	10:35	0:0	6	psz_path
op	10:45	0:0	4	<
water	10:47	0:0	4	0
stmts	11:8	11:27	3	
return	11:8	11:27	4	VLC_EGENERIC
water	11:15	0:0	5	VLC_EGENERIC
decl	12:4	12:21	2	stream_t	*vol
op	12:18	0:0	2	=
water	12:20	0:0	2	s
for	13:4	85:4	2	(;;)
forinit	13:9	13:9	3	;
water	13:9	0:0	4	;
cond	0:0	0:0	3	
forexpr	0:0	0:0	3	
stmts	13:13	85:4	3	
water	13:13	0:0	4	{
if	15:8	21:8	4	(IgnoreBlock (vol ,RAR_BLOCK_MARKER ) ||IgnoreBlock (vol ,RAR_BLOCK_ARCHIVE ))
cond	15:12	16:46	5	IgnoreBlock (vol ,RAR_BLOCK_MARKER ) ||IgnoreBlock (vol ,RAR_BLOCK_ARCHIVE )
call	15:12	15:45	6	IgnoreBlock
arg	15:24	15:27	7	vol
water	15:24	0:0	8	vol
arg	15:29	15:45	7	RAR_BLOCK_MARKER
water	15:29	0:0	8	RAR_BLOCK_MARKER
op	15:47	0:0	6	||
call	16:12	16:46	6	IgnoreBlock
arg	16:24	16:27	7	vol
water	16:24	0:0	8	vol
arg	16:29	16:46	7	RAR_BLOCK_ARCHIVE
water	16:29	0:0	8	RAR_BLOCK_ARCHIVE
stmts	16:49	21:8	5	
water	16:49	0:0	6	{
if	17:12	18:34	6	(vol != s)
cond	17:16	17:23	7	vol != s
water	17:16	0:0	8	vol
op	17:20	0:0	8	!=
water	17:23	0:0	8	s
stmts	18:16	18:34	7	
call	18:16	18:33	8	stream_Delete
arg	18:30	18:33	9	vol
water	18:30	0:0	10	vol
water	18:34	0:0	8	;
call	19:12	19:27	6	free
arg	19:17	19:27	7	volume_mrl
water	19:17	0:0	8	volume_mrl
water	19:28	0:0	6	;
return	20:12	20:31	6	VLC_EGENERIC
water	20:19	0:0	7	VLC_EGENERIC
water	21:8	0:0	6	}
decl	23:8	23:25	4	int	has_next
op	23:21	0:0	4	=
op	23:23	0:0	4	-
water	23:24	0:0	4	1
for	24:8	43:8	4	(;;)
forinit	24:13	24:13	5	;
water	24:13	0:0	6	;
cond	0:0	0:0	5	
forexpr	0:0	0:0	5	
stmts	24:17	43:8	5	
water	24:17	0:0	6	{
decl	25:12	25:26	6	rar_block_t	bk
decl	26:12	26:19	6	int	ret
if	27:12	28:21	6	(PeekBlock (vol ,& bk ))
cond	27:16	27:34	7	PeekBlock (vol ,& bk )
call	27:16	27:34	8	PeekBlock
arg	27:26	27:29	9	vol
water	27:26	0:0	10	vol
arg	27:31	27:34	9	&bk
op	27:31	0:0	10	&
water	27:32	0:0	10	bk
stmts	28:16	28:21	7	
break	28:16	28:21	8	
switch	29:12	40:12	6	(bk . type)
cond	29:19	29:22	7	bk . type
water	29:19	0:0	8	bk
op	29:21	0:0	8	.
water	29:22	0:0	8	type
stmts	29:28	40:12	7	
water	29:28	0:0	8	{
label	30:12	30:30	8	case RAR_BLOCK_END :
water	31:16	0:0	8	ret
op	31:20	0:0	8	=
call	31:22	31:38	8	SkipEnd
arg	31:30	31:33	9	vol
water	31:30	0:0	10	vol
arg	31:35	31:38	9	&bk
op	31:35	0:0	10	&
water	31:36	0:0	10	bk
water	31:39	0:0	8	;
water	32:16	0:0	8	has_next
op	32:25	0:0	8	=
water	32:27	0:0	8	ret
op	32:31	0:0	8	&&
water	32:34	0:0	8	(
water	32:35	0:0	8	bk
op	32:37	0:0	8	.
water	32:38	0:0	8	flags
op	32:44	0:0	8	&
water	32:46	0:0	8	RAR_BLOCK_END_HAS_NEXT
water	32:68	0:0	8	)
water	32:69	0:0	8	;
break	33:16	33:21	8	
label	34:12	34:31	8	case RAR_BLOCK_FILE :
water	35:16	0:0	8	ret
op	35:20	0:0	8	=
call	35:22	35:64	8	SkipFile
arg	35:31	35:34	9	vol
water	35:31	0:0	10	vol
arg	35:36	35:41	9	count
water	35:36	0:0	10	count
arg	35:43	35:47	9	file
water	35:43	0:0	10	file
arg	35:49	35:52	9	&bk
op	35:49	0:0	10	&
water	35:50	0:0	10	bk
arg	35:54	35:64	9	volume_mrl
water	35:54	0:0	10	volume_mrl
water	35:65	0:0	8	;
break	36:16	36:21	8	
label	37:12	37:19	8	default :
water	38:16	0:0	8	ret
op	38:20	0:0	8	=
call	38:22	38:40	8	SkipBlock
arg	38:32	38:35	9	vol
water	38:32	0:0	10	vol
arg	38:37	38:40	9	&bk
op	38:37	0:0	10	&
water	38:38	0:0	10	bk
water	38:41	0:0	8	;
break	39:16	39:21	8	
water	40:12	0:0	8	}
if	41:12	42:21	6	(ret)
cond	41:16	41:16	7	ret
water	41:16	0:0	8	ret
stmts	42:16	42:21	7	
break	42:16	42:21	8	
water	43:8	0:0	6	}
if	44:8	45:24	4	(has_next < 0 && * count > 0 && ! ( * file ) [ * count - 1 ] -> is_complete)
cond	44:12	44:63	5	has_next < 0 && * count > 0 && ! ( * file ) [ * count - 1 ] -> is_complete
water	44:12	0:0	6	has_next
op	44:21	0:0	6	<
water	44:23	0:0	6	0
op	44:25	0:0	6	&&
op	44:28	0:0	6	*
water	44:29	0:0	6	count
op	44:35	0:0	6	>
water	44:37	0:0	6	0
op	44:39	0:0	6	&&
op	44:42	0:0	6	!
water	44:43	0:0	6	(
op	44:44	0:0	6	*
water	44:45	0:0	6	file
water	44:49	0:0	6	)
op	44:50	0:0	6	[
op	44:51	0:0	6	*
water	44:52	0:0	6	count
op	44:58	0:0	6	-
water	44:59	0:0	6	1
op	44:60	0:0	6	]
op	44:61	0:0	6	->
water	44:63	0:0	6	is_complete
stmts	45:12	45:24	5	
water	45:12	0:0	6	has_next
op	45:21	0:0	6	=
water	45:23	0:0	6	1
water	45:24	0:0	6	;
if	46:8	47:30	4	(vol != s)
cond	46:12	46:19	5	vol != s
water	46:12	0:0	6	vol
op	46:16	0:0	6	!=
water	46:19	0:0	6	s
stmts	47:12	47:30	5	
call	47:12	47:29	6	stream_Delete
arg	47:26	47:29	7	vol
water	47:26	0:0	8	vol
water	47:30	0:0	6	;
if	48:8	51:8	4	(! has_next || ! pattern)
cond	48:12	48:26	5	! has_next || ! pattern
op	48:12	0:0	6	!
water	48:13	0:0	6	has_next
op	48:22	0:0	6	||
op	48:25	0:0	6	!
water	48:26	0:0	6	pattern
stmts	48:35	51:8	5	
water	48:35	0:0	6	{
call	49:12	49:27	6	free
arg	49:17	49:27	7	volume_mrl
water	49:17	0:0	8	volume_mrl
water	49:28	0:0	6	;
return	50:12	50:30	6	VLC_SUCCESS
water	50:19	0:0	7	VLC_SUCCESS
water	51:8	0:0	6	}
decl	53:8	53:65	4	const int	volume_index
op	53:31	0:0	4	=
water	53:33	0:0	4	pattern
op	53:40	0:0	4	->
water	53:42	0:0	4	start
op	53:48	0:0	4	+
water	53:50	0:0	4	volume_offset
op	53:63	0:0	4	++
if	54:8	57:8	4	(volume_index > pattern -> stop)
cond	54:12	54:36	5	volume_index > pattern -> stop
water	54:12	0:0	6	volume_index
op	54:25	0:0	6	>
water	54:27	0:0	6	pattern
op	54:34	0:0	6	->
water	54:36	0:0	6	stop
stmts	54:42	57:8	5	
water	54:42	0:0	6	{
call	55:12	55:27	6	free
arg	55:17	55:27	7	volume_mrl
water	55:17	0:0	8	volume_mrl
water	55:28	0:0	6	;
return	56:12	56:30	6	VLC_SUCCESS
water	56:19	0:0	7	VLC_SUCCESS
water	57:8	0:0	6	}
decl	58:8	58:25	4	char	*volume_base
if	59:8	64:8	4	(asprintf (& volume_base ,"%s://%.*s" ,s -> psz_access ,( int ) (strlen (s -> psz_path ) -strlen (pattern -> match ) ) ,s -> psz_path ) < 0)
cond	59:12	61:89	5	asprintf (& volume_base ,"%s://%.*s" ,s -> psz_access ,( int ) (strlen (s -> psz_path ) -strlen (pattern -> match ) ) ,s -> psz_path ) < 0
call	59:12	61:85	6	asprintf
arg	59:21	59:33	7	&volume_base
op	59:21	0:0	8	&
water	59:22	0:0	8	volume_base
arg	59:35	59:46	7	"%s://%.*s"
water	59:35	0:0	8	"%s://%.*s"
arg	60:21	60:34	7	s->psz_access
water	60:21	0:0	8	s
op	60:22	0:0	8	->
water	60:24	0:0	8	psz_access
arg	61:21	61:72	7	(int)(strlen(s->psz_path)-strlen(pattern->match))
call	61:21	61:71	8	(int)
arg	61:27	61:71	9	strlen(s->psz_path)-strlen(pattern->match)
call	61:27	61:45	10	strlen
arg	61:34	61:45	11	s->psz_path
water	61:34	0:0	12	s
op	61:35	0:0	12	->
water	61:37	0:0	12	psz_path
op	61:47	0:0	10	-
call	61:49	61:70	10	strlen
arg	61:56	61:70	11	pattern->match
water	61:56	0:0	12	pattern
op	61:63	0:0	12	->
water	61:65	0:0	12	match
arg	61:74	61:85	7	s->psz_path
water	61:74	0:0	8	s
op	61:75	0:0	8	->
water	61:77	0:0	8	psz_path
op	61:87	0:0	6	<
water	61:89	0:0	6	0
stmts	61:92	64:8	5	
water	61:92	0:0	6	{
call	62:12	62:27	6	free
arg	62:17	62:27	7	volume_mrl
water	62:17	0:0	8	volume_mrl
water	62:28	0:0	6	;
return	63:12	63:30	6	VLC_SUCCESS
water	63:19	0:0	7	VLC_SUCCESS
water	64:8	0:0	6	}
call	65:8	65:23	4	free
arg	65:13	65:23	5	volume_mrl
water	65:13	0:0	6	volume_mrl
water	65:24	0:0	4	;
if	66:8	69:8	4	(pattern -> start)
cond	66:12	66:21	5	pattern -> start
water	66:12	0:0	6	pattern
op	66:19	0:0	6	->
water	66:21	0:0	6	start
stmts	66:28	69:8	5	
water	66:28	0:0	6	{
if	67:12	68:33	6	(asprintf (& volume_mrl ,pattern -> format ,volume_base ,volume_index ) < 0)
cond	67:16	67:84	7	asprintf (& volume_mrl ,pattern -> format ,volume_base ,volume_index ) < 0
call	67:16	67:80	8	asprintf
arg	67:25	67:36	9	&volume_mrl
op	67:25	0:0	10	&
water	67:26	0:0	10	volume_mrl
arg	67:38	67:53	9	pattern->format
water	67:38	0:0	10	pattern
op	67:45	0:0	10	->
water	67:47	0:0	10	format
arg	67:55	67:66	9	volume_base
water	67:55	0:0	10	volume_base
arg	67:68	67:80	9	volume_index
water	67:68	0:0	10	volume_index
op	67:82	0:0	8	<
water	67:84	0:0	8	0
stmts	68:16	68:33	7	
water	68:16	0:0	8	volume_mrl
op	68:27	0:0	8	=
water	68:29	0:0	8	NULL
water	68:33	0:0	8	;
water	69:8	0:0	6	}
else	69:10	73:8	4
stmts	69:15	73:8	5	
water	69:15	0:0	6	{
if	70:12	72:33	6	(asprintf (& volume_mrl ,pattern -> format ,volume_base ,'r' + volume_index / 100 ,volume_index % 100 ) < 0)
cond	70:16	71:73	7	asprintf (& volume_mrl ,pattern -> format ,volume_base ,'r' + volume_index / 100 ,volume_index % 100 ) < 0
call	70:16	71:69	8	asprintf
arg	70:25	70:36	9	&volume_mrl
op	70:25	0:0	10	&
water	70:26	0:0	10	volume_mrl
arg	70:38	70:53	9	pattern->format
water	70:38	0:0	10	pattern
op	70:45	0:0	10	->
water	70:47	0:0	10	format
arg	70:55	70:66	9	volume_base
water	70:55	0:0	10	volume_base
arg	71:25	71:49	9	'r'+volume_index/100
water	71:25	0:0	10	'r'
op	71:29	0:0	10	+
water	71:31	0:0	10	volume_index
op	71:44	0:0	10	/
water	71:46	0:0	10	100
arg	71:51	71:69	9	volume_index%100
water	71:51	0:0	10	volume_index
op	71:64	0:0	10	%
water	71:66	0:0	10	100
op	71:71	0:0	8	<
water	71:73	0:0	8	0
stmts	72:16	72:33	7	
water	72:16	0:0	8	volume_mrl
op	72:27	0:0	8	=
water	72:29	0:0	8	NULL
water	72:33	0:0	8	;
water	73:8	0:0	6	}
call	74:8	74:24	4	free
arg	74:13	74:24	5	volume_base
water	74:13	0:0	6	volume_base
water	74:25	0:0	4	;
if	75:8	76:30	4	(! volume_mrl)
cond	75:12	75:13	5	! volume_mrl
op	75:12	0:0	6	!
water	75:13	0:0	6	volume_mrl
stmts	76:12	76:30	5	
return	76:12	76:30	6	VLC_SUCCESS
water	76:19	0:0	7	VLC_SUCCESS
decl	77:8	77:38	4	const int	s_flags
op	77:26	0:0	4	=
water	77:28	0:0	4	s
op	77:29	0:0	4	->
water	77:31	0:0	4	i_flags
water	78:8	0:0	4	s
op	78:9	0:0	4	->
water	78:11	0:0	4	i_flags
op	78:19	0:0	4	|=
water	78:22	0:0	4	OBJECT_FLAGS_NOINTERACT
water	78:45	0:0	4	;
water	79:8	0:0	4	vol
op	79:12	0:0	4	=
call	79:14	79:41	4	stream_UrlNew
arg	79:28	79:29	5	s
water	79:28	0:0	6	s
arg	79:31	79:41	5	volume_mrl
water	79:31	0:0	6	volume_mrl
water	79:42	0:0	4	;
water	80:8	0:0	4	s
op	80:9	0:0	4	->
water	80:11	0:0	4	i_flags
op	80:19	0:0	4	=
water	80:21	0:0	4	s_flags
water	80:28	0:0	4	;
if	81:8	84:8	4	(! vol)
cond	81:12	81:13	5	! vol
op	81:12	0:0	6	!
water	81:13	0:0	6	vol
stmts	81:18	84:8	5	
water	81:18	0:0	6	{
call	82:12	82:27	6	free
arg	82:17	82:27	7	volume_mrl
water	82:17	0:0	8	volume_mrl
water	82:28	0:0	6	;
return	83:12	83:30	6	VLC_SUCCESS
water	83:19	0:0	7	VLC_SUCCESS
water	84:8	0:0	6	}
water	85:4	0:0	4	}
