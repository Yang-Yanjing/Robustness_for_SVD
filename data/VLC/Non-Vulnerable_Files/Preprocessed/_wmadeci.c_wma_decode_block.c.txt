func	1:0	435:0	0	static int	wma_decode_block
params	1:27	0:0	1	
param	1:28	1:47	2	WMADecodeContext *	s
stmnts	0:0	434:4	1	
decl	3:4	3:32	2	int	n
water	3:9	0:0	2	,
decl	3:4	3:32	2	int	v
water	3:12	0:0	2	,
decl	3:4	3:32	2	int	a
water	3:15	0:0	2	,
decl	3:4	3:32	2	int	ch
water	3:19	0:0	2	,
decl	3:4	3:32	2	int	code
water	3:25	0:0	2	,
decl	3:4	3:32	2	int	bsize
decl	4:4	4:32	2	int	coef_nb_bits
water	4:20	0:0	2	,
decl	4:4	4:32	2	int	total_gain
decl	5:4	5:30	2	int	nb_coefs[MAX_CHANNELS]
decl	6:4	6:21	2	int32_t	mdct_norm
if	8:4	37:4	2	(s -> use_variable_block_len)
cond	8:8	8:11	3	s -> use_variable_block_len
water	8:8	0:0	4	s
op	8:9	0:0	4	->
water	8:11	0:0	4	use_variable_block_len
stmts	9:4	37:4	3	
water	9:4	0:0	4	{
water	10:8	0:0	4	n
op	10:10	0:0	4	=
call	10:12	10:41	4	av_log2
arg	10:20	10:41	5	s->nb_block_sizes-1
water	10:20	0:0	6	s
op	10:21	0:0	6	->
water	10:23	0:0	6	nb_block_sizes
op	10:38	0:0	6	-
water	10:40	0:0	6	1
op	10:43	0:0	4	+
water	10:45	0:0	4	1
water	10:46	0:0	4	;
if	11:8	26:8	4	(s -> reset_block_lengths)
cond	11:12	11:15	5	s -> reset_block_lengths
water	11:12	0:0	6	s
op	11:13	0:0	6	->
water	11:15	0:0	6	reset_block_lengths
stmts	12:8	26:8	5	
water	12:8	0:0	6	{
water	13:12	0:0	6	s
op	13:13	0:0	6	->
water	13:15	0:0	6	reset_block_lengths
op	13:35	0:0	6	=
water	13:37	0:0	6	0
water	13:38	0:0	6	;
water	14:12	0:0	6	v
op	14:14	0:0	6	=
call	14:16	14:34	6	get_bits
arg	14:25	14:31	7	&s->gb
op	14:25	0:0	8	&
water	14:26	0:0	8	s
op	14:27	0:0	8	->
water	14:29	0:0	8	gb
arg	14:33	14:34	7	n
water	14:33	0:0	8	n
water	14:35	0:0	6	;
if	15:12	18:12	6	(v >= s -> nb_block_sizes)
cond	15:16	15:24	7	v >= s -> nb_block_sizes
water	15:16	0:0	8	v
op	15:18	0:0	8	>=
water	15:21	0:0	8	s
op	15:22	0:0	8	->
water	15:24	0:0	8	nb_block_sizes
stmts	16:12	18:12	7	
water	16:12	0:0	8	{
return	17:16	17:25	8	-2
op	17:23	0:0	9	-
water	17:24	0:0	9	2
water	18:12	0:0	8	}
water	19:12	0:0	6	s
op	19:13	0:0	6	->
water	19:15	0:0	6	prev_block_len_bits
op	19:35	0:0	6	=
water	19:37	0:0	6	s
op	19:38	0:0	6	->
water	19:40	0:0	6	frame_len_bits
op	19:55	0:0	6	-
water	19:57	0:0	6	v
water	19:58	0:0	6	;
water	20:12	0:0	6	v
op	20:14	0:0	6	=
call	20:16	20:34	6	get_bits
arg	20:25	20:31	7	&s->gb
op	20:25	0:0	8	&
water	20:26	0:0	8	s
op	20:27	0:0	8	->
water	20:29	0:0	8	gb
arg	20:33	20:34	7	n
water	20:33	0:0	8	n
water	20:35	0:0	6	;
if	21:12	24:12	6	(v >= s -> nb_block_sizes)
cond	21:16	21:24	7	v >= s -> nb_block_sizes
water	21:16	0:0	8	v
op	21:18	0:0	8	>=
water	21:21	0:0	8	s
op	21:22	0:0	8	->
water	21:24	0:0	8	nb_block_sizes
stmts	22:12	24:12	7	
water	22:12	0:0	8	{
return	23:16	23:25	8	-3
op	23:23	0:0	9	-
water	23:24	0:0	9	3
water	24:12	0:0	8	}
water	25:12	0:0	6	s
op	25:13	0:0	6	->
water	25:15	0:0	6	block_len_bits
op	25:30	0:0	6	=
water	25:32	0:0	6	s
op	25:33	0:0	6	->
water	25:35	0:0	6	frame_len_bits
op	25:50	0:0	6	-
water	25:52	0:0	6	v
water	25:53	0:0	6	;
water	26:8	0:0	6	}
else	27:8	32:8	4
stmts	28:8	32:8	5	
water	28:8	0:0	6	{
water	30:12	0:0	6	s
op	30:13	0:0	6	->
water	30:15	0:0	6	prev_block_len_bits
op	30:35	0:0	6	=
water	30:37	0:0	6	s
op	30:38	0:0	6	->
water	30:40	0:0	6	block_len_bits
water	30:54	0:0	6	;
water	31:12	0:0	6	s
op	31:13	0:0	6	->
water	31:15	0:0	6	block_len_bits
op	31:30	0:0	6	=
water	31:32	0:0	6	s
op	31:33	0:0	6	->
water	31:35	0:0	6	next_block_len_bits
water	31:54	0:0	6	;
water	32:8	0:0	6	}
water	33:8	0:0	4	v
op	33:10	0:0	4	=
call	33:12	33:30	4	get_bits
arg	33:21	33:27	5	&s->gb
op	33:21	0:0	6	&
water	33:22	0:0	6	s
op	33:23	0:0	6	->
water	33:25	0:0	6	gb
arg	33:29	33:30	5	n
water	33:29	0:0	6	n
water	33:31	0:0	4	;
if	34:8	35:21	4	(v >= s -> nb_block_sizes)
cond	34:12	34:20	5	v >= s -> nb_block_sizes
water	34:12	0:0	6	v
op	34:14	0:0	6	>=
water	34:17	0:0	6	s
op	34:18	0:0	6	->
water	34:20	0:0	6	nb_block_sizes
stmts	35:12	35:21	5	
return	35:12	35:21	6	-4
op	35:19	0:0	7	-
water	35:20	0:0	7	4
water	36:8	0:0	4	s
op	36:9	0:0	4	->
water	36:11	0:0	4	next_block_len_bits
op	36:31	0:0	4	=
water	36:33	0:0	4	s
op	36:34	0:0	4	->
water	36:36	0:0	4	frame_len_bits
op	36:51	0:0	4	-
water	36:53	0:0	4	v
water	36:54	0:0	4	;
water	37:4	0:0	4	}
else	38:4	44:4	2
stmts	39:4	44:4	3	
water	39:4	0:0	4	{
water	41:8	0:0	4	s
op	41:9	0:0	4	->
water	41:11	0:0	4	next_block_len_bits
op	41:31	0:0	4	=
water	41:33	0:0	4	s
op	41:34	0:0	4	->
water	41:36	0:0	4	frame_len_bits
water	41:50	0:0	4	;
water	42:8	0:0	4	s
op	42:9	0:0	4	->
water	42:11	0:0	4	prev_block_len_bits
op	42:31	0:0	4	=
water	42:33	0:0	4	s
op	42:34	0:0	4	->
water	42:36	0:0	4	frame_len_bits
water	42:50	0:0	4	;
water	43:8	0:0	4	s
op	43:9	0:0	4	->
water	43:11	0:0	4	block_len_bits
op	43:26	0:0	4	=
water	43:28	0:0	4	s
op	43:29	0:0	4	->
water	43:31	0:0	4	frame_len_bits
water	43:45	0:0	4	;
water	44:4	0:0	4	}
water	46:4	0:0	2	s
op	46:5	0:0	2	->
water	46:7	0:0	2	block_len
op	46:17	0:0	2	=
water	46:19	0:0	2	1
op	46:21	0:0	2	<<
water	46:24	0:0	2	s
op	46:25	0:0	2	->
water	46:27	0:0	2	block_len_bits
water	46:41	0:0	2	;
if	47:4	50:4	2	(( s -> block_pos + s -> block_len ) > s -> frame_len)
cond	47:8	47:43	3	( s -> block_pos + s -> block_len ) > s -> frame_len
water	47:8	0:0	4	(
water	47:9	0:0	4	s
op	47:10	0:0	4	->
water	47:12	0:0	4	block_pos
op	47:22	0:0	4	+
water	47:24	0:0	4	s
op	47:25	0:0	4	->
water	47:27	0:0	4	block_len
water	47:36	0:0	4	)
op	47:38	0:0	4	>
water	47:40	0:0	4	s
op	47:41	0:0	4	->
water	47:43	0:0	4	frame_len
stmts	48:4	50:4	3	
water	48:4	0:0	4	{
return	49:8	49:17	4	-5
op	49:15	0:0	5	-
water	49:16	0:0	5	5
water	50:4	0:0	4	}
if	51:4	54:4	2	(s -> nb_channels == 2)
cond	51:8	51:26	3	s -> nb_channels == 2
water	51:8	0:0	4	s
op	51:9	0:0	4	->
water	51:11	0:0	4	nb_channels
op	51:23	0:0	4	==
water	51:26	0:0	4	2
stmts	52:4	54:4	3	
water	52:4	0:0	4	{
water	53:8	0:0	4	s
op	53:9	0:0	4	->
water	53:11	0:0	4	ms_stereo
op	53:21	0:0	4	=
call	53:23	53:41	4	get_bits
arg	53:32	53:38	5	&s->gb
op	53:32	0:0	6	&
water	53:33	0:0	6	s
op	53:34	0:0	6	->
water	53:36	0:0	6	gb
arg	53:40	53:41	5	1
water	53:40	0:0	6	1
water	53:42	0:0	4	;
water	54:4	0:0	4	}
water	55:4	0:0	2	v
op	55:6	0:0	2	=
water	55:8	0:0	2	0
water	55:9	0:0	2	;
for	56:4	61:4	2	(ch = 0 ;ch < s -> nb_channels;++ ch)
forinit	56:9	56:15	3	ch = 0 ;
water	56:9	0:0	4	ch
op	56:12	0:0	4	=
water	56:14	0:0	4	0
water	56:15	0:0	4	;
cond	56:17	56:25	3	ch < s -> nb_channels
water	56:17	0:0	4	ch
op	56:20	0:0	4	<
water	56:22	0:0	4	s
op	56:23	0:0	4	->
water	56:25	0:0	4	nb_channels
forexpr	56:38	56:40	3	++ ch
op	56:38	0:0	4	++
water	56:40	0:0	4	ch
stmts	57:4	61:4	3	
water	57:4	0:0	4	{
water	58:8	0:0	4	a
op	58:10	0:0	4	=
call	58:12	58:30	4	get_bits
arg	58:21	58:27	5	&s->gb
op	58:21	0:0	6	&
water	58:22	0:0	6	s
op	58:23	0:0	6	->
water	58:25	0:0	6	gb
arg	58:29	58:30	5	1
water	58:29	0:0	6	1
water	58:31	0:0	4	;
water	59:8	0:0	4	s
op	59:9	0:0	4	->
water	59:11	0:0	4	channel_coded
op	59:24	0:0	4	[
water	59:25	0:0	4	ch
op	59:27	0:0	4	]
op	59:29	0:0	4	=
water	59:31	0:0	4	a
water	59:32	0:0	4	;
water	60:8	0:0	4	v
op	60:10	0:0	4	|=
water	60:13	0:0	4	a
water	60:14	0:0	4	;
water	61:4	0:0	4	}
if	64:4	67:4	2	(! v)
cond	64:8	64:9	3	! v
op	64:8	0:0	4	!
water	64:9	0:0	4	v
stmts	65:4	67:4	3	
water	65:4	0:0	4	{
goto	66:8	66:17	4	next
water	66:13	0:0	5	next
water	67:4	0:0	4	}
water	68:4	0:0	2	bsize
op	68:10	0:0	2	=
water	68:12	0:0	2	s
op	68:13	0:0	2	->
water	68:15	0:0	2	frame_len_bits
op	68:30	0:0	2	-
water	68:32	0:0	2	s
op	68:33	0:0	2	->
water	68:35	0:0	2	block_len_bits
water	68:49	0:0	2	;
water	71:4	0:0	2	total_gain
op	71:15	0:0	2	=
water	71:17	0:0	2	1
water	71:18	0:0	2	;
for	72:4	80:4	2	(;;)
forinit	72:8	72:8	3	;
water	72:8	0:0	4	;
cond	0:0	0:0	3	
forexpr	0:0	0:0	3	
stmts	73:4	80:4	3	
water	73:4	0:0	4	{
water	74:8	0:0	4	a
op	74:10	0:0	4	=
call	74:12	74:30	4	get_bits
arg	74:21	74:27	5	&s->gb
op	74:21	0:0	6	&
water	74:22	0:0	6	s
op	74:23	0:0	6	->
water	74:25	0:0	6	gb
arg	74:29	74:30	5	7
water	74:29	0:0	6	7
water	74:31	0:0	4	;
water	75:8	0:0	4	total_gain
op	75:19	0:0	4	+=
water	75:22	0:0	4	a
water	75:23	0:0	4	;
if	76:8	79:8	4	(a != 127)
cond	76:12	76:17	5	a != 127
water	76:12	0:0	6	a
op	76:14	0:0	6	!=
water	76:17	0:0	6	127
stmts	77:8	79:8	5	
water	77:8	0:0	6	{
break	78:12	78:17	6	
water	79:8	0:0	6	}
water	80:4	0:0	4	}
if	81:4	82:25	2	(total_gain < 15)
cond	81:8	81:21	3	total_gain < 15
water	81:8	0:0	4	total_gain
op	81:19	0:0	4	<
water	81:21	0:0	4	15
stmts	82:8	82:25	3	
water	82:8	0:0	4	coef_nb_bits
op	82:21	0:0	4	=
water	82:23	0:0	4	13
water	82:25	0:0	4	;
else	83:4	84:25	2
stmts	83:9	84:25	3	
if	83:9	84:25	4	(total_gain < 32)
cond	83:13	83:26	5	total_gain < 32
water	83:13	0:0	6	total_gain
op	83:24	0:0	6	<
water	83:26	0:0	6	32
stmts	84:8	84:25	5	
water	84:8	0:0	6	coef_nb_bits
op	84:21	0:0	6	=
water	84:23	0:0	6	12
water	84:25	0:0	6	;
else	85:4	86:25	2
stmts	85:9	86:25	3	
if	85:9	86:25	4	(total_gain < 40)
cond	85:13	85:26	5	total_gain < 40
water	85:13	0:0	6	total_gain
op	85:24	0:0	6	<
water	85:26	0:0	6	40
stmts	86:8	86:25	5	
water	86:8	0:0	6	coef_nb_bits
op	86:21	0:0	6	=
water	86:23	0:0	6	11
water	86:25	0:0	6	;
else	87:4	88:25	2
stmts	87:9	88:25	3	
if	87:9	88:25	4	(total_gain < 45)
cond	87:13	87:26	5	total_gain < 45
water	87:13	0:0	6	total_gain
op	87:24	0:0	6	<
water	87:26	0:0	6	45
stmts	88:8	88:25	5	
water	88:8	0:0	6	coef_nb_bits
op	88:21	0:0	6	=
water	88:23	0:0	6	10
water	88:25	0:0	6	;
else	89:4	90:24	2
stmts	90:8	90:24	3	
water	90:8	0:0	4	coef_nb_bits
op	90:21	0:0	4	=
water	90:23	0:0	4	9
water	90:24	0:0	4	;
water	92:4	0:0	2	n
op	92:6	0:0	2	=
water	92:8	0:0	2	s
op	92:9	0:0	2	->
water	92:11	0:0	2	coefs_end
op	92:20	0:0	2	[
water	92:21	0:0	2	bsize
op	92:26	0:0	2	]
op	92:28	0:0	2	-
water	92:30	0:0	2	s
op	92:31	0:0	2	->
water	92:33	0:0	2	coefs_start
water	92:44	0:0	2	;
for	93:4	96:4	2	(ch = 0 ;ch < s -> nb_channels;++ ch)
forinit	93:8	93:14	3	ch = 0 ;
water	93:8	0:0	4	ch
op	93:11	0:0	4	=
water	93:13	0:0	4	0
water	93:14	0:0	4	;
cond	93:16	93:24	3	ch < s -> nb_channels
water	93:16	0:0	4	ch
op	93:19	0:0	4	<
water	93:21	0:0	4	s
op	93:22	0:0	4	->
water	93:24	0:0	4	nb_channels
forexpr	93:37	93:39	3	++ ch
op	93:37	0:0	4	++
water	93:39	0:0	4	ch
stmts	94:4	96:4	3	
water	94:4	0:0	4	{
water	95:8	0:0	4	nb_coefs
op	95:16	0:0	4	[
water	95:17	0:0	4	ch
op	95:19	0:0	4	]
op	95:21	0:0	4	=
water	95:23	0:0	4	n
water	95:24	0:0	4	;
water	96:4	0:0	4	}
if	98:4	146:4	2	(s -> use_noise_coding)
cond	98:8	98:11	3	s -> use_noise_coding
water	98:8	0:0	4	s
op	98:9	0:0	4	->
water	98:11	0:0	4	use_noise_coding
stmts	99:4	146:4	3	
water	99:4	0:0	4	{
for	100:8	115:8	4	(ch = 0 ;ch < s -> nb_channels;++ ch)
forinit	100:12	100:18	5	ch = 0 ;
water	100:12	0:0	6	ch
op	100:15	0:0	6	=
water	100:17	0:0	6	0
water	100:18	0:0	6	;
cond	100:20	100:28	5	ch < s -> nb_channels
water	100:20	0:0	6	ch
op	100:23	0:0	6	<
water	100:25	0:0	6	s
op	100:26	0:0	6	->
water	100:28	0:0	6	nb_channels
forexpr	100:41	100:43	5	++ ch
op	100:41	0:0	6	++
water	100:43	0:0	6	ch
stmts	101:8	115:8	5	
water	101:8	0:0	6	{
if	102:12	114:12	6	(s -> channel_coded [ ch ])
cond	102:16	102:35	7	s -> channel_coded [ ch ]
water	102:16	0:0	8	s
op	102:17	0:0	8	->
water	102:19	0:0	8	channel_coded
op	102:32	0:0	8	[
water	102:33	0:0	8	ch
op	102:35	0:0	8	]
stmts	103:12	114:12	7	
water	103:12	0:0	8	{
decl	104:16	104:27	8	int	i
water	104:21	0:0	8	,
decl	104:16	104:27	8	int	n
water	104:24	0:0	8	,
decl	104:16	104:27	8	int	a
water	105:16	0:0	8	n
op	105:18	0:0	8	=
water	105:20	0:0	8	s
op	105:21	0:0	8	->
water	105:23	0:0	8	exponent_high_sizes
op	105:42	0:0	8	[
water	105:43	0:0	8	bsize
op	105:48	0:0	8	]
water	105:49	0:0	8	;
for	106:16	113:16	8	(i = 0 ;i < n;++ i)
forinit	106:20	106:23	9	i = 0 ;
water	106:20	0:0	10	i
op	106:21	0:0	10	=
water	106:22	0:0	10	0
water	106:23	0:0	10	;
cond	106:24	106:26	9	i < n
water	106:24	0:0	10	i
op	106:25	0:0	10	<
water	106:26	0:0	10	n
forexpr	106:28	106:30	9	++ i
op	106:28	0:0	10	++
water	106:30	0:0	10	i
stmts	107:16	113:16	9	
water	107:16	0:0	10	{
water	108:20	0:0	10	a
op	108:22	0:0	10	=
call	108:24	108:42	10	get_bits
arg	108:33	108:39	11	&s->gb
op	108:33	0:0	12	&
water	108:34	0:0	12	s
op	108:35	0:0	12	->
water	108:37	0:0	12	gb
arg	108:41	108:42	11	1
water	108:41	0:0	12	1
water	108:43	0:0	10	;
water	109:20	0:0	10	s
op	109:21	0:0	10	->
water	109:23	0:0	10	high_band_coded
op	109:38	0:0	10	[
water	109:39	0:0	10	ch
op	109:41	0:0	10	]
op	109:42	0:0	10	[
water	109:43	0:0	10	i
op	109:44	0:0	10	]
op	109:46	0:0	10	=
water	109:48	0:0	10	a
water	109:49	0:0	10	;
if	111:20	112:72	10	(a)
cond	111:24	111:24	11	a
water	111:24	0:0	12	a
stmts	112:24	112:72	11	
water	112:24	0:0	12	nb_coefs
op	112:32	0:0	12	[
water	112:33	0:0	12	ch
op	112:35	0:0	12	]
op	112:37	0:0	12	-=
water	112:40	0:0	12	s
op	112:41	0:0	12	->
water	112:43	0:0	12	exponent_high_bands
op	112:62	0:0	12	[
water	112:63	0:0	12	bsize
op	112:68	0:0	12	]
op	112:69	0:0	12	[
water	112:70	0:0	12	i
op	112:71	0:0	12	]
water	112:72	0:0	12	;
water	113:16	0:0	10	}
water	114:12	0:0	8	}
water	115:8	0:0	6	}
for	116:8	145:8	4	(ch = 0 ;ch < s -> nb_channels;++ ch)
forinit	116:12	116:18	5	ch = 0 ;
water	116:12	0:0	6	ch
op	116:15	0:0	6	=
water	116:17	0:0	6	0
water	116:18	0:0	6	;
cond	116:20	116:28	5	ch < s -> nb_channels
water	116:20	0:0	6	ch
op	116:23	0:0	6	<
water	116:25	0:0	6	s
op	116:26	0:0	6	->
water	116:28	0:0	6	nb_channels
forexpr	116:41	116:43	5	++ ch
op	116:41	0:0	6	++
water	116:43	0:0	6	ch
stmts	117:8	145:8	5	
water	117:8	0:0	6	{
if	118:12	144:12	6	(s -> channel_coded [ ch ])
cond	118:16	118:35	7	s -> channel_coded [ ch ]
water	118:16	0:0	8	s
op	118:17	0:0	8	->
water	118:19	0:0	8	channel_coded
op	118:32	0:0	8	[
water	118:33	0:0	8	ch
op	118:35	0:0	8	]
stmts	119:12	144:12	7	
water	119:12	0:0	8	{
decl	120:16	120:35	8	int	i
water	120:21	0:0	8	,
decl	120:16	120:35	8	int	n
water	120:24	0:0	8	,
decl	120:16	120:35	8	int	val
water	120:29	0:0	8	,
decl	120:16	120:35	8	int	code
water	121:16	0:0	8	n
op	121:18	0:0	8	=
water	121:20	0:0	8	s
op	121:21	0:0	8	->
water	121:23	0:0	8	exponent_high_sizes
op	121:42	0:0	8	[
water	121:43	0:0	8	bsize
op	121:48	0:0	8	]
water	121:49	0:0	8	;
water	122:16	0:0	8	val
op	122:20	0:0	8	=
water	122:22	0:0	8	(
water	122:23	0:0	8	int
water	122:26	0:0	8	)
water	122:27	0:0	8	0
water	122:28	0:0	8	x80000000
water	122:37	0:0	8	;
for	123:16	143:16	8	(i = 0 ;i < n;++ i)
forinit	123:20	123:23	9	i = 0 ;
water	123:20	0:0	10	i
op	123:21	0:0	10	=
water	123:22	0:0	10	0
water	123:23	0:0	10	;
cond	123:24	123:26	9	i < n
water	123:24	0:0	10	i
op	123:25	0:0	10	<
water	123:26	0:0	10	n
forexpr	123:28	123:30	9	++ i
op	123:28	0:0	10	++
water	123:30	0:0	10	i
stmts	124:16	143:16	9	
water	124:16	0:0	10	{
if	125:20	142:20	10	(s -> high_band_coded [ ch ] [ i ])
cond	125:24	125:48	11	s -> high_band_coded [ ch ] [ i ]
water	125:24	0:0	12	s
op	125:25	0:0	12	->
water	125:27	0:0	12	high_band_coded
op	125:42	0:0	12	[
water	125:43	0:0	12	ch
op	125:45	0:0	12	]
op	125:46	0:0	12	[
water	125:47	0:0	12	i
op	125:48	0:0	12	]
stmts	126:20	142:20	11	
water	126:20	0:0	12	{
if	127:24	130:24	12	(val == ( int ) 0 x80000000)
cond	127:28	127:41	13	val == ( int ) 0 x80000000
water	127:28	0:0	14	val
op	127:32	0:0	14	==
water	127:35	0:0	14	(
water	127:36	0:0	14	int
water	127:39	0:0	14	)
water	127:40	0:0	14	0
water	127:41	0:0	14	x80000000
stmts	128:24	130:24	13	
water	128:24	0:0	14	{
water	129:28	0:0	14	val
op	129:32	0:0	14	=
call	129:34	129:52	14	get_bits
arg	129:43	129:49	15	&s->gb
op	129:43	0:0	16	&
water	129:44	0:0	16	s
op	129:45	0:0	16	->
water	129:47	0:0	16	gb
arg	129:51	129:52	15	7
water	129:51	0:0	16	7
op	129:54	0:0	14	-
water	129:56	0:0	14	19
water	129:58	0:0	14	;
water	130:24	0:0	14	}
else	131:24	140:24	12
stmts	132:24	140:24	13	
water	132:24	0:0	14	{
water	134:28	0:0	14	code
op	134:33	0:0	14	=
call	134:35	134:94	14	get_vlc2
arg	134:44	134:50	15	&s->gb
op	134:44	0:0	16	&
water	134:45	0:0	16	s
op	134:46	0:0	16	->
water	134:48	0:0	16	gb
arg	134:52	134:70	15	s->hgain_vlc.table
water	134:52	0:0	16	s
op	134:53	0:0	16	->
water	134:55	0:0	16	hgain_vlc
op	134:64	0:0	16	.
water	134:65	0:0	16	table
arg	134:72	134:84	15	HGAINVLCBITS
water	134:72	0:0	16	HGAINVLCBITS
arg	134:86	134:94	15	HGAINMAX
water	134:86	0:0	16	HGAINMAX
water	134:95	0:0	14	;
if	135:28	138:28	14	(code < 0)
cond	135:32	135:39	15	code < 0
water	135:32	0:0	16	code
op	135:37	0:0	16	<
water	135:39	0:0	16	0
stmts	136:28	138:28	15	
water	136:28	0:0	16	{
return	137:32	137:41	16	-6
op	137:39	0:0	17	-
water	137:40	0:0	17	6
water	138:28	0:0	16	}
water	139:28	0:0	14	val
op	139:32	0:0	14	+=
water	139:35	0:0	14	code
op	139:40	0:0	14	-
water	139:42	0:0	14	18
water	139:44	0:0	14	;
water	140:24	0:0	14	}
water	141:24	0:0	12	s
op	141:25	0:0	12	->
water	141:27	0:0	12	high_band_values
op	141:43	0:0	12	[
water	141:44	0:0	12	ch
op	141:46	0:0	12	]
op	141:47	0:0	12	[
water	141:48	0:0	12	i
op	141:49	0:0	12	]
op	141:51	0:0	12	=
water	141:53	0:0	12	val
water	141:56	0:0	12	;
water	142:20	0:0	12	}
water	143:16	0:0	10	}
water	144:12	0:0	8	}
water	145:8	0:0	6	}
water	146:4	0:0	4	}
if	148:4	168:4	2	(( s -> block_len_bits == s -> frame_len_bits ) ||get_bits (& s -> gb ,1 ))
cond	148:8	148:70	3	( s -> block_len_bits == s -> frame_len_bits ) ||get_bits (& s -> gb ,1 )
water	148:8	0:0	4	(
water	148:9	0:0	4	s
op	148:10	0:0	4	->
water	148:12	0:0	4	block_len_bits
op	148:27	0:0	4	==
water	148:30	0:0	4	s
op	148:31	0:0	4	->
water	148:33	0:0	4	frame_len_bits
water	148:47	0:0	4	)
op	148:49	0:0	4	||
call	148:52	148:70	4	get_bits
arg	148:61	148:67	5	&s->gb
op	148:61	0:0	6	&
water	148:62	0:0	6	s
op	148:63	0:0	6	->
water	148:65	0:0	6	gb
arg	148:69	148:70	5	1
water	148:69	0:0	6	1
stmts	149:4	168:4	3	
water	149:4	0:0	4	{
for	150:8	167:8	4	(ch = 0 ;ch < s -> nb_channels;++ ch)
forinit	150:12	150:18	5	ch = 0 ;
water	150:12	0:0	6	ch
op	150:15	0:0	6	=
water	150:17	0:0	6	0
water	150:18	0:0	6	;
cond	150:20	150:28	5	ch < s -> nb_channels
water	150:20	0:0	6	ch
op	150:23	0:0	6	<
water	150:25	0:0	6	s
op	150:26	0:0	6	->
water	150:28	0:0	6	nb_channels
forexpr	150:41	150:43	5	++ ch
op	150:41	0:0	6	++
water	150:43	0:0	6	ch
stmts	151:8	167:8	5	
water	151:8	0:0	6	{
if	152:12	166:12	6	(s -> channel_coded [ ch ])
cond	152:16	152:35	7	s -> channel_coded [ ch ]
water	152:16	0:0	8	s
op	152:17	0:0	8	->
water	152:19	0:0	8	channel_coded
op	152:32	0:0	8	[
water	152:33	0:0	8	ch
op	152:35	0:0	8	]
stmts	153:12	166:12	7	
water	153:12	0:0	8	{
if	154:16	160:16	8	(s -> use_exp_vlc)
cond	154:20	154:23	9	s -> use_exp_vlc
water	154:20	0:0	10	s
op	154:21	0:0	10	->
water	154:23	0:0	10	use_exp_vlc
stmts	155:16	160:16	9	
water	155:16	0:0	10	{
if	156:20	159:20	10	(decode_exp_vlc (s ,ch ) < 0)
cond	156:24	156:48	11	decode_exp_vlc (s ,ch ) < 0
call	156:24	156:44	12	decode_exp_vlc
arg	156:39	156:40	13	s
water	156:39	0:0	14	s
arg	156:42	156:44	13	ch
water	156:42	0:0	14	ch
op	156:46	0:0	12	<
water	156:48	0:0	12	0
stmts	157:20	159:20	11	
water	157:20	0:0	12	{
return	158:24	158:33	12	-7
op	158:31	0:0	13	-
water	158:32	0:0	13	7
water	159:20	0:0	12	}
water	160:16	0:0	10	}
else	161:16	164:16	8
stmts	162:16	164:16	9	
water	162:16	0:0	10	{
call	163:20	163:40	10	decode_exp_lsp
arg	163:35	163:36	11	s
water	163:35	0:0	12	s
arg	163:38	163:40	11	ch
water	163:38	0:0	12	ch
water	163:41	0:0	10	;
water	164:16	0:0	10	}
water	165:16	0:0	8	s
op	165:17	0:0	8	->
water	165:19	0:0	8	exponents_bsize
op	165:34	0:0	8	[
water	165:35	0:0	8	ch
op	165:37	0:0	8	]
op	165:39	0:0	8	=
water	165:41	0:0	8	bsize
water	165:46	0:0	8	;
water	166:12	0:0	8	}
water	167:8	0:0	6	}
water	168:4	0:0	4	}
for	170:4	233:4	2	(ch = 0 ;ch < s -> nb_channels;++ ch)
forinit	170:8	170:14	3	ch = 0 ;
water	170:8	0:0	4	ch
op	170:11	0:0	4	=
water	170:13	0:0	4	0
water	170:14	0:0	4	;
cond	170:16	170:24	3	ch < s -> nb_channels
water	170:16	0:0	4	ch
op	170:19	0:0	4	<
water	170:21	0:0	4	s
op	170:22	0:0	4	->
water	170:24	0:0	4	nb_channels
forexpr	170:37	170:39	3	++ ch
op	170:37	0:0	4	++
water	170:39	0:0	4	ch
stmts	171:4	233:4	3	
water	171:4	0:0	4	{
if	172:8	228:8	4	(s -> channel_coded [ ch ])
cond	172:12	172:31	5	s -> channel_coded [ ch ]
water	172:12	0:0	6	s
op	172:13	0:0	6	->
water	172:15	0:0	6	channel_coded
op	172:28	0:0	6	[
water	172:29	0:0	6	ch
op	172:31	0:0	6	]
stmts	173:8	228:8	5	
water	173:8	0:0	6	{
decl	174:12	174:25	6	VLC	*coef_vlc
decl	175:12	175:40	6	int	level
water	175:21	0:0	6	,
decl	175:12	175:40	6	int	run
water	175:26	0:0	6	,
decl	175:12	175:40	6	int	sign
water	175:32	0:0	6	,
decl	175:12	175:40	6	int	tindex
decl	176:12	176:31	6	int16_t	*ptr
water	176:24	0:0	6	,
decl	176:12	176:31	6	int16_t	*eptr
decl	177:12	177:51	6	const uint16_t	*level_table
water	177:39	0:0	6	,
decl	177:12	177:51	6	const uint16_t	*run_table
water	180:12	0:0	6	tindex
op	180:19	0:0	6	=
water	180:21	0:0	6	(
water	180:22	0:0	6	ch
op	180:25	0:0	6	==
water	180:28	0:0	6	1
op	180:30	0:0	6	&&
water	180:33	0:0	6	s
op	180:34	0:0	6	->
water	180:36	0:0	6	ms_stereo
water	180:45	0:0	6	)
water	180:46	0:0	6	;
water	181:12	0:0	6	coef_vlc
op	181:21	0:0	6	=
op	181:23	0:0	6	&
water	181:24	0:0	6	s
op	181:25	0:0	6	->
water	181:27	0:0	6	coef_vlc
op	181:35	0:0	6	[
water	181:36	0:0	6	tindex
op	181:42	0:0	6	]
water	181:43	0:0	6	;
water	182:12	0:0	6	run_table
op	182:22	0:0	6	=
water	182:24	0:0	6	s
op	182:25	0:0	6	->
water	182:27	0:0	6	run_table
op	182:36	0:0	6	[
water	182:37	0:0	6	tindex
op	182:43	0:0	6	]
water	182:44	0:0	6	;
water	183:12	0:0	6	level_table
op	183:24	0:0	6	=
water	183:26	0:0	6	s
op	183:27	0:0	6	->
water	183:29	0:0	6	level_table
op	183:40	0:0	6	[
water	183:41	0:0	6	tindex
op	183:47	0:0	6	]
water	183:48	0:0	6	;
water	185:12	0:0	6	ptr
op	185:16	0:0	6	=
op	185:18	0:0	6	&
water	185:19	0:0	6	s
op	185:20	0:0	6	->
water	185:22	0:0	6	coefs1
op	185:28	0:0	6	[
water	185:29	0:0	6	ch
op	185:31	0:0	6	]
op	185:32	0:0	6	[
water	185:33	0:0	6	0
op	185:34	0:0	6	]
water	185:35	0:0	6	;
water	186:12	0:0	6	eptr
op	186:17	0:0	6	=
water	186:19	0:0	6	ptr
op	186:23	0:0	6	+
water	186:25	0:0	6	nb_coefs
op	186:33	0:0	6	[
water	186:34	0:0	6	ch
op	186:36	0:0	6	]
water	186:37	0:0	6	;
call	187:12	187:57	6	memset
arg	187:19	187:22	7	ptr
water	187:19	0:0	8	ptr
arg	187:24	187:25	7	0
water	187:24	0:0	8	0
arg	187:27	187:57	7	s->block_len*sizeof(int16_t)
water	187:27	0:0	8	s
op	187:28	0:0	8	->
water	187:30	0:0	8	block_len
op	187:40	0:0	8	*
op	187:42	0:0	8	sizeof
water	187:48	0:0	8	(
water	187:49	0:0	8	int16_t
water	187:56	0:0	8	)
water	187:58	0:0	6	;
for	188:12	227:12	6	(;;)
forinit	188:16	188:16	7	;
water	188:16	0:0	8	;
cond	0:0	0:0	7	
forexpr	0:0	0:0	7	
stmts	189:12	227:12	7	
water	189:12	0:0	8	{
water	190:16	0:0	8	code
op	190:21	0:0	8	=
call	190:23	190:72	8	get_vlc2
arg	190:32	190:38	9	&s->gb
op	190:32	0:0	10	&
water	190:33	0:0	10	s
op	190:34	0:0	10	->
water	190:36	0:0	10	gb
arg	190:40	190:55	9	coef_vlc->table
water	190:40	0:0	10	coef_vlc
op	190:48	0:0	10	->
water	190:50	0:0	10	table
arg	190:57	190:64	9	VLCBITS
water	190:57	0:0	10	VLCBITS
arg	190:66	190:72	9	VLCMAX
water	190:66	0:0	10	VLCMAX
water	190:73	0:0	8	;
if	192:16	195:16	8	(code < 0)
cond	192:20	192:27	9	code < 0
water	192:20	0:0	10	code
op	192:25	0:0	10	<
water	192:27	0:0	10	0
stmts	193:16	195:16	9	
water	193:16	0:0	10	{
return	194:20	194:29	10	-8
op	194:27	0:0	11	-
water	194:28	0:0	11	8
water	195:16	0:0	10	}
if	196:16	200:16	8	(code == 1)
cond	196:20	196:28	9	code == 1
water	196:20	0:0	10	code
op	196:25	0:0	10	==
water	196:28	0:0	10	1
stmts	197:16	200:16	9	
water	197:16	0:0	10	{
break	199:20	199:25	10	
water	200:16	0:0	10	}
else	201:16	208:16	8
stmts	201:21	208:16	9	
if	201:21	208:16	10	(code == 0)
cond	201:25	201:33	11	code == 0
water	201:25	0:0	12	code
op	201:30	0:0	12	==
water	201:33	0:0	12	0
stmts	202:16	208:16	11	
water	202:16	0:0	12	{
water	204:20	0:0	12	level
op	204:26	0:0	12	=
call	204:28	204:57	12	get_bits
arg	204:37	204:43	13	&s->gb
op	204:37	0:0	14	&
water	204:38	0:0	14	s
op	204:39	0:0	14	->
water	204:41	0:0	14	gb
arg	204:45	204:57	13	coef_nb_bits
water	204:45	0:0	14	coef_nb_bits
water	204:58	0:0	12	;
water	207:20	0:0	12	run
op	207:24	0:0	12	=
call	207:26	207:60	12	get_bits
arg	207:35	207:41	13	&s->gb
op	207:35	0:0	14	&
water	207:36	0:0	14	s
op	207:37	0:0	14	->
water	207:39	0:0	14	gb
arg	207:43	207:60	13	s->frame_len_bits
water	207:43	0:0	14	s
op	207:44	0:0	14	->
water	207:46	0:0	14	frame_len_bits
water	207:61	0:0	12	;
water	208:16	0:0	12	}
else	209:16	214:16	8
stmts	210:16	214:16	9	
water	210:16	0:0	10	{
water	212:20	0:0	10	run
op	212:24	0:0	10	=
water	212:26	0:0	10	run_table
op	212:35	0:0	10	[
water	212:36	0:0	10	code
op	212:40	0:0	10	]
water	212:41	0:0	10	;
water	213:20	0:0	10	level
op	213:26	0:0	10	=
water	213:28	0:0	10	level_table
op	213:39	0:0	10	[
water	213:40	0:0	10	code
op	213:44	0:0	10	]
water	213:45	0:0	10	;
water	214:16	0:0	10	}
water	215:16	0:0	8	sign
op	215:21	0:0	8	=
call	215:23	215:41	8	get_bits
arg	215:32	215:38	9	&s->gb
op	215:32	0:0	10	&
water	215:33	0:0	10	s
op	215:34	0:0	10	->
water	215:36	0:0	10	gb
arg	215:40	215:41	9	1
water	215:40	0:0	10	1
water	215:42	0:0	8	;
if	216:16	217:34	8	(! sign)
cond	216:20	216:21	9	! sign
op	216:20	0:0	10	!
water	216:21	0:0	10	sign
stmts	217:20	217:34	9	
water	217:20	0:0	10	level
op	217:26	0:0	10	=
op	217:28	0:0	10	-
water	217:29	0:0	10	level
water	217:34	0:0	10	;
water	218:16	0:0	8	ptr
op	218:20	0:0	8	+=
water	218:23	0:0	8	run
water	218:26	0:0	8	;
if	219:16	222:16	8	(ptr >= eptr)
cond	219:20	219:27	9	ptr >= eptr
water	219:20	0:0	10	ptr
op	219:24	0:0	10	>=
water	219:27	0:0	10	eptr
stmts	220:16	222:16	9	
water	220:16	0:0	10	{
break	221:20	221:25	10	
water	222:16	0:0	10	}
op	223:16	0:0	8	*
water	223:17	0:0	8	ptr
op	223:20	0:0	8	++
op	223:23	0:0	8	=
water	223:25	0:0	8	level
water	223:30	0:0	8	;
if	225:16	226:25	8	(ptr >= eptr)
cond	225:20	225:27	9	ptr >= eptr
water	225:20	0:0	10	ptr
op	225:24	0:0	10	>=
water	225:27	0:0	10	eptr
stmts	226:20	226:25	9	
break	226:20	226:25	10	
water	227:12	0:0	8	}
water	228:8	0:0	6	}
if	229:8	232:8	4	(s -> version == 1 && s -> nb_channels >= 2)
cond	229:12	229:49	5	s -> version == 1 && s -> nb_channels >= 2
water	229:12	0:0	6	s
op	229:13	0:0	6	->
water	229:15	0:0	6	version
op	229:23	0:0	6	==
water	229:26	0:0	6	1
op	229:28	0:0	6	&&
water	229:31	0:0	6	s
op	229:32	0:0	6	->
water	229:34	0:0	6	nb_channels
op	229:46	0:0	6	>=
water	229:49	0:0	6	2
stmts	230:8	232:8	5	
water	230:8	0:0	6	{
call	231:12	231:33	6	align_get_bits
arg	231:27	231:33	7	&s->gb
op	231:27	0:0	8	&
water	231:28	0:0	8	s
op	231:29	0:0	8	->
water	231:31	0:0	8	gb
water	231:34	0:0	6	;
water	232:8	0:0	6	}
water	233:4	0:0	4	}
water	234:4	0:0	2	{
decl	235:8	235:34	2	int	n4
op	235:15	0:0	2	=
water	235:17	0:0	2	s
op	235:18	0:0	2	->
water	235:20	0:0	2	block_len
op	235:30	0:0	2	>>
water	235:33	0:0	2	1
water	237:8	0:0	2	mdct_norm
op	237:18	0:0	2	=
water	237:20	0:0	2	0
water	237:21	0:0	2	x10000
op	237:27	0:0	2	>>
water	237:29	0:0	2	(
water	237:30	0:0	2	s
op	237:31	0:0	2	->
water	237:33	0:0	2	block_len_bits
op	237:47	0:0	2	-
water	237:48	0:0	2	1
water	237:49	0:0	2	)
water	237:50	0:0	2	;
if	238:8	241:8	2	(s -> version == 1)
cond	238:12	238:26	3	s -> version == 1
water	238:12	0:0	4	s
op	238:13	0:0	4	->
water	238:15	0:0	4	version
op	238:23	0:0	4	==
water	238:26	0:0	4	1
stmts	239:8	241:8	3	
water	239:8	0:0	4	{
water	240:12	0:0	4	mdct_norm
op	240:22	0:0	4	*=
call	240:25	240:57	4	fixtoi32
arg	240:34	240:57	5	fixsqrt32(itofix32(n4))
call	240:34	240:56	6	fixsqrt32
arg	240:44	240:56	7	itofix32(n4)
call	240:44	240:55	8	itofix32
arg	240:53	240:55	9	n4
water	240:53	0:0	10	n4
water	240:58	0:0	4	;
water	241:8	0:0	4	}
water	242:4	0:0	2	}
for	244:4	379:4	2	(ch = 0 ;ch < s -> nb_channels;++ ch)
forinit	244:8	244:14	3	ch = 0 ;
water	244:8	0:0	4	ch
op	244:11	0:0	4	=
water	244:13	0:0	4	0
water	244:14	0:0	4	;
cond	244:16	244:24	3	ch < s -> nb_channels
water	244:16	0:0	4	ch
op	244:19	0:0	4	<
water	244:21	0:0	4	s
op	244:22	0:0	4	->
water	244:24	0:0	4	nb_channels
forexpr	244:37	244:39	3	++ ch
op	244:37	0:0	4	++
water	244:39	0:0	4	ch
stmts	245:4	379:4	3	
water	245:4	0:0	4	{
if	246:8	378:8	4	(s -> channel_coded [ ch ])
cond	246:12	246:31	5	s -> channel_coded [ ch ]
water	246:12	0:0	6	s
op	246:13	0:0	6	->
water	246:15	0:0	6	channel_coded
op	246:28	0:0	6	[
water	246:29	0:0	6	ch
op	246:31	0:0	6	]
stmts	247:8	378:8	5	
water	247:8	0:0	6	{
decl	248:12	248:27	6	int16_t	*coefs1
decl	249:12	249:40	6	int32_t	*exponents
water	249:30	0:0	6	,
decl	249:12	249:40	6	int32_t	*exp_ptr
decl	250:12	250:33	6	int32_t	*coefs
water	250:26	0:0	6	,
decl	250:12	250:33	6	int32_t	atemp
decl	251:12	251:24	6	int64_t	mult
decl	252:12	252:25	6	int64_t	mult1
decl	253:12	253:46	6	int32_t	noise
water	253:25	0:0	6	,
decl	253:12	253:46	6	int32_t	temp1
water	253:32	0:0	6	,
decl	253:12	253:46	6	int32_t	temp2
water	253:39	0:0	6	,
decl	253:12	253:46	6	int32_t	mult2
decl	254:12	254:50	6	int	i
water	254:17	0:0	6	,
decl	254:12	254:50	6	int	j
water	254:20	0:0	6	,
decl	254:12	254:50	6	int	n
water	254:23	0:0	6	,
decl	254:12	254:50	6	int	n1
water	254:27	0:0	6	,
decl	254:12	254:50	6	int	last_high_band
water	254:43	0:0	6	,
decl	254:12	254:50	6	int	esize
decl	255:12	255:49	6	int32_t	exp_power[HIGH_BAND_MAX_SIZE]
water	256:12	0:0	6	coefs1
op	256:19	0:0	6	=
water	256:21	0:0	6	s
op	256:22	0:0	6	->
water	256:24	0:0	6	coefs1
op	256:30	0:0	6	[
water	256:31	0:0	6	ch
op	256:33	0:0	6	]
water	256:34	0:0	6	;
water	257:12	0:0	6	exponents
op	257:22	0:0	6	=
water	257:24	0:0	6	s
op	257:25	0:0	6	->
water	257:27	0:0	6	exponents
op	257:36	0:0	6	[
water	257:37	0:0	6	ch
op	257:39	0:0	6	]
water	257:40	0:0	6	;
water	258:12	0:0	6	esize
op	258:18	0:0	6	=
water	258:20	0:0	6	s
op	258:21	0:0	6	->
water	258:23	0:0	6	exponents_bsize
op	258:38	0:0	6	[
water	258:39	0:0	6	ch
op	258:41	0:0	6	]
water	258:42	0:0	6	;
water	259:12	0:0	6	coefs
op	259:18	0:0	6	=
water	259:20	0:0	6	(
op	259:21	0:0	6	*
water	259:22	0:0	6	(
water	259:23	0:0	6	s
op	259:24	0:0	6	->
water	259:26	0:0	6	coefs
water	259:31	0:0	6	)
water	259:32	0:0	6	)
op	259:33	0:0	6	[
water	259:34	0:0	6	ch
op	259:36	0:0	6	]
water	259:37	0:0	6	;
water	260:12	0:0	6	n
op	260:13	0:0	6	=
water	260:14	0:0	6	0
water	260:15	0:0	6	;
if	265:12	360:12	6	(s -> use_noise_coding)
cond	265:16	265:19	7	s -> use_noise_coding
water	265:16	0:0	8	s
op	265:17	0:0	8	->
water	265:19	0:0	8	use_noise_coding
stmts	266:12	360:12	7	
water	266:12	0:0	8	{
water	268:16	0:0	8	mult
op	268:21	0:0	8	=
call	268:23	268:89	8	fixdiv64
arg	268:32	268:56	9	pow_table[total_gain+20]
water	268:32	0:0	10	pow_table
op	268:41	0:0	10	[
water	268:42	0:0	10	total_gain
op	268:52	0:0	10	+
water	268:53	0:0	10	20
op	268:55	0:0	10	]
arg	268:57	268:89	9	Fixed32To64(s->max_exponent[ch])
call	268:57	268:88	10	Fixed32To64
arg	268:69	268:88	11	s->max_exponent[ch]
water	268:69	0:0	12	s
op	268:70	0:0	12	->
water	268:72	0:0	12	max_exponent
op	268:84	0:0	12	[
water	268:85	0:0	12	ch
op	268:87	0:0	12	]
water	268:90	0:0	8	;
water	269:16	0:0	8	mult
op	269:21	0:0	8	=
water	269:23	0:0	8	mult
op	269:27	0:0	8	*
water	269:29	0:0	8	mdct_norm
water	269:38	0:0	8	;
water	270:16	0:0	8	mult1
op	270:22	0:0	8	=
water	270:24	0:0	8	mult
water	270:28	0:0	8	;
for	272:16	277:16	8	(i = 0 ;i < s -> coefs_start;++ i)
forinit	272:20	272:25	9	i = 0 ;
water	272:20	0:0	10	i
op	272:22	0:0	10	=
water	272:24	0:0	10	0
water	272:25	0:0	10	;
cond	272:26	272:33	9	i < s -> coefs_start
water	272:26	0:0	10	i
op	272:28	0:0	10	<
water	272:30	0:0	10	s
op	272:31	0:0	10	->
water	272:33	0:0	10	coefs_start
forexpr	272:46	272:48	9	++ i
op	272:46	0:0	10	++
water	272:48	0:0	10	i
stmts	273:16	277:16	9	
water	273:16	0:0	10	{
op	274:20	0:0	10	*
water	274:21	0:0	10	coefs
op	274:26	0:0	10	++
op	274:29	0:0	10	=
call	274:31	275:80	10	fixmul32
arg	274:40	275:59	11	(fixmul32(s->noise_table[s->noise_index],(*exponents++))>>4)
water	274:40	0:0	12	(
call	274:41	275:54	12	fixmul32
arg	274:50	274:80	13	s->noise_table[s->noise_index]
water	274:50	0:0	14	s
op	274:51	0:0	14	->
water	274:53	0:0	14	noise_table
op	274:64	0:0	14	[
water	274:65	0:0	14	s
op	274:66	0:0	14	->
water	274:68	0:0	14	noise_index
op	274:79	0:0	14	]
arg	275:40	275:54	13	(*exponents++)
water	275:40	0:0	14	(
op	275:41	0:0	14	*
water	275:42	0:0	14	exponents
op	275:51	0:0	14	++
water	275:53	0:0	14	)
op	275:55	0:0	12	>>
water	275:57	0:0	12	4
water	275:58	0:0	12	)
arg	275:60	275:80	11	Fixed32From64(mult1)
call	275:60	275:79	12	Fixed32From64
arg	275:74	275:79	13	mult1
water	275:74	0:0	14	mult1
op	275:82	0:0	10	>>
water	275:84	0:0	10	1
water	275:85	0:0	10	;
water	276:20	0:0	10	s
op	276:21	0:0	10	->
water	276:23	0:0	10	noise_index
op	276:35	0:0	10	=
water	276:37	0:0	10	(
water	276:38	0:0	10	s
op	276:39	0:0	10	->
water	276:41	0:0	10	noise_index
op	276:53	0:0	10	+
water	276:55	0:0	10	1
water	276:56	0:0	10	)
op	276:58	0:0	10	&
water	276:60	0:0	10	(
water	276:61	0:0	10	NOISE_TAB_SIZE
op	276:76	0:0	10	-
water	276:78	0:0	10	1
water	276:79	0:0	10	)
water	276:80	0:0	10	;
water	277:16	0:0	10	}
water	278:16	0:0	8	n1
op	278:19	0:0	8	=
water	278:21	0:0	8	s
op	278:22	0:0	8	->
water	278:24	0:0	8	exponent_high_sizes
op	278:43	0:0	8	[
water	278:44	0:0	8	bsize
op	278:49	0:0	8	]
water	278:50	0:0	8	;
water	280:16	0:0	8	exp_ptr
op	280:24	0:0	8	=
water	280:26	0:0	8	exponents
op	280:36	0:0	8	+
water	281:26	0:0	8	s
op	281:27	0:0	8	->
water	281:29	0:0	8	high_band_start
op	281:44	0:0	8	[
water	281:45	0:0	8	bsize
op	281:50	0:0	8	]
op	281:52	0:0	8	-
water	282:26	0:0	8	s
op	282:27	0:0	8	->
water	282:29	0:0	8	coefs_start
water	282:40	0:0	8	;
water	283:16	0:0	8	last_high_band
op	283:31	0:0	8	=
water	283:33	0:0	8	0
water	283:34	0:0	8	;
for	284:16	302:16	8	(j = 0 ;j < n1;++ j)
forinit	284:21	284:24	9	j = 0 ;
water	284:21	0:0	10	j
op	284:22	0:0	10	=
water	284:23	0:0	10	0
water	284:24	0:0	10	;
cond	284:25	284:27	9	j < n1
water	284:25	0:0	10	j
op	284:26	0:0	10	<
water	284:27	0:0	10	n1
forexpr	284:30	284:32	9	++ j
op	284:30	0:0	10	++
water	284:32	0:0	10	j
stmts	285:16	302:16	9	
water	285:16	0:0	10	{
water	286:20	0:0	10	n
op	286:22	0:0	10	=
water	286:24	0:0	10	s
op	286:25	0:0	10	->
water	286:27	0:0	10	exponent_high_bands
op	286:46	0:0	10	[
water	286:47	0:0	10	s
op	286:48	0:0	10	->
water	286:50	0:0	10	frame_len_bits
op	286:65	0:0	10	-
water	287:47	0:0	10	s
op	287:48	0:0	10	->
water	287:50	0:0	10	block_len_bits
op	287:64	0:0	10	]
op	287:65	0:0	10	[
water	287:66	0:0	10	j
op	287:67	0:0	10	]
water	287:68	0:0	10	;
if	288:20	300:20	10	(s -> high_band_coded [ ch ] [ j ])
cond	288:24	288:48	11	s -> high_band_coded [ ch ] [ j ]
water	288:24	0:0	12	s
op	288:25	0:0	12	->
water	288:27	0:0	12	high_band_coded
op	288:42	0:0	12	[
water	288:43	0:0	12	ch
op	288:45	0:0	12	]
op	288:46	0:0	12	[
water	288:47	0:0	12	j
op	288:48	0:0	12	]
stmts	289:20	300:20	11	
water	289:20	0:0	12	{
decl	290:24	290:37	12	int32_t	e2
water	290:34	0:0	12	,
decl	290:24	290:37	12	int32_t	v
water	291:24	0:0	12	e2
op	291:27	0:0	12	=
water	291:29	0:0	12	0
water	291:30	0:0	12	;
for	292:24	297:24	12	(i = 0 ;i < n;++ i)
forinit	292:28	292:33	13	i = 0 ;
water	292:28	0:0	14	i
op	292:30	0:0	14	=
water	292:32	0:0	14	0
water	292:33	0:0	14	;
cond	292:34	292:38	13	i < n
water	292:34	0:0	14	i
op	292:36	0:0	14	<
water	292:38	0:0	14	n
forexpr	292:41	292:43	13	++ i
op	292:41	0:0	14	++
water	292:43	0:0	14	i
stmts	293:24	297:24	13	
water	293:24	0:0	14	{
water	295:28	0:0	14	v
op	295:30	0:0	14	=
water	295:32	0:0	14	exp_ptr
op	295:39	0:0	14	[
water	295:40	0:0	14	i
op	295:41	0:0	14	]
op	295:42	0:0	14	>>
water	295:44	0:0	14	4
water	295:45	0:0	14	;
water	296:28	0:0	14	e2
op	296:31	0:0	14	+=
call	296:34	296:47	14	fixmul32
arg	296:43	296:44	15	v
water	296:43	0:0	16	v
arg	296:46	296:47	15	v
water	296:46	0:0	16	v
op	296:48	0:0	14	>>
water	296:50	0:0	14	3
water	296:51	0:0	14	;
water	297:24	0:0	14	}
water	298:25	0:0	12	exp_power
op	298:34	0:0	12	[
water	298:35	0:0	12	j
op	298:36	0:0	12	]
op	298:38	0:0	12	=
water	298:40	0:0	12	e2
op	298:42	0:0	12	/
water	298:43	0:0	12	n
water	298:44	0:0	12	;
water	299:24	0:0	12	last_high_band
op	299:39	0:0	12	=
water	299:41	0:0	12	j
water	299:42	0:0	12	;
water	300:20	0:0	12	}
water	301:20	0:0	10	exp_ptr
op	301:28	0:0	10	+=
water	301:31	0:0	10	n
water	301:32	0:0	10	;
water	302:16	0:0	10	}
for	304:16	350:16	8	(j = - 1 ;j < n1;++ j)
forinit	304:20	304:24	9	j = - 1 ;
water	304:20	0:0	10	j
op	304:21	0:0	10	=
op	304:22	0:0	10	-
water	304:23	0:0	10	1
water	304:24	0:0	10	;
cond	304:25	304:27	9	j < n1
water	304:25	0:0	10	j
op	304:26	0:0	10	<
water	304:27	0:0	10	n1
forexpr	304:30	304:32	9	++ j
op	304:30	0:0	10	++
water	304:32	0:0	10	j
stmts	305:16	350:16	9	
water	305:16	0:0	10	{
if	306:20	310:20	10	(j < 0)
cond	306:24	306:28	11	j < 0
water	306:24	0:0	12	j
op	306:26	0:0	12	<
water	306:28	0:0	12	0
stmts	307:20	310:20	11	
water	307:20	0:0	12	{
water	308:24	0:0	12	n
op	308:26	0:0	12	=
water	308:28	0:0	12	s
op	308:29	0:0	12	->
water	308:31	0:0	12	high_band_start
op	308:46	0:0	12	[
water	308:47	0:0	12	bsize
op	308:52	0:0	12	]
op	308:54	0:0	12	-
water	309:28	0:0	12	s
op	309:29	0:0	12	->
water	309:31	0:0	12	coefs_start
water	309:42	0:0	12	;
water	310:20	0:0	12	}
else	311:20	315:20	10
stmts	312:20	315:20	11	
water	312:20	0:0	12	{
water	313:24	0:0	12	n
op	313:26	0:0	12	=
water	313:28	0:0	12	s
op	313:29	0:0	12	->
water	313:31	0:0	12	exponent_high_bands
op	313:50	0:0	12	[
water	313:51	0:0	12	s
op	313:52	0:0	12	->
water	313:54	0:0	12	frame_len_bits
op	313:69	0:0	12	-
water	314:51	0:0	12	s
op	314:52	0:0	12	->
water	314:54	0:0	12	block_len_bits
op	314:68	0:0	12	]
op	314:69	0:0	12	[
water	314:70	0:0	12	j
op	314:71	0:0	12	]
water	314:72	0:0	12	;
water	315:20	0:0	12	}
if	316:20	334:20	10	(j >= 0 && s -> high_band_coded [ ch ] [ j ])
cond	316:24	316:58	11	j >= 0 && s -> high_band_coded [ ch ] [ j ]
water	316:24	0:0	12	j
op	316:26	0:0	12	>=
water	316:29	0:0	12	0
op	316:31	0:0	12	&&
water	316:34	0:0	12	s
op	316:35	0:0	12	->
water	316:37	0:0	12	high_band_coded
op	316:52	0:0	12	[
water	316:53	0:0	12	ch
op	316:55	0:0	12	]
op	316:56	0:0	12	[
water	316:57	0:0	12	j
op	316:58	0:0	12	]
stmts	317:20	334:20	11	
water	317:20	0:0	12	{
decl	319:24	319:86	12	int32_t	tmp
op	319:36	0:0	12	=
call	319:38	319:85	13	fixdiv32
arg	319:47	319:59	14	exp_power[j]
water	319:47	0:0	15	exp_power
op	319:56	0:0	15	[
water	319:57	0:0	15	j
op	319:58	0:0	15	]
arg	319:60	319:85	14	exp_power[last_high_band]
water	319:60	0:0	15	exp_power
op	319:69	0:0	15	[
water	319:70	0:0	15	last_high_band
op	319:84	0:0	15	]
water	320:24	0:0	12	mult1
op	320:30	0:0	12	=
water	320:32	0:0	12	(
water	320:33	0:0	12	int64_t
water	320:40	0:0	12	)
call	320:41	320:54	12	fixsqrt32
arg	320:51	320:54	13	tmp
water	320:51	0:0	14	tmp
water	320:55	0:0	12	;
water	323:24	0:0	12	mult1
op	323:30	0:0	12	=
water	323:32	0:0	12	mult1
op	323:38	0:0	12	*
water	323:40	0:0	12	pow_table
op	323:49	0:0	12	[
water	323:50	0:0	12	s
op	323:51	0:0	12	->
water	323:53	0:0	12	high_band_values
op	323:69	0:0	12	[
water	323:70	0:0	12	ch
op	323:72	0:0	12	]
op	323:73	0:0	12	[
water	323:74	0:0	12	j
op	323:75	0:0	12	]
op	323:76	0:0	12	+
water	323:77	0:0	12	20
op	323:79	0:0	12	]
op	323:81	0:0	12	>>
water	323:84	0:0	12	PRECISION
water	323:93	0:0	12	;
water	325:24	0:0	12	mult1
op	325:30	0:0	12	=
call	325:32	325:90	12	fixdiv64
arg	325:41	325:46	13	mult1
water	325:41	0:0	14	mult1
arg	325:47	325:90	13	fixmul32(s->max_exponent[ch],s->noise_mult)
call	325:47	325:89	14	fixmul32
arg	325:56	325:75	15	s->max_exponent[ch]
water	325:56	0:0	16	s
op	325:57	0:0	16	->
water	325:59	0:0	16	max_exponent
op	325:71	0:0	16	[
water	325:72	0:0	16	ch
op	325:74	0:0	16	]
arg	325:76	325:89	15	s->noise_mult
water	325:76	0:0	16	s
op	325:77	0:0	16	->
water	325:79	0:0	16	noise_mult
water	325:91	0:0	12	;
water	326:24	0:0	12	mult1
op	326:30	0:0	12	=
water	326:32	0:0	12	mult1
op	326:37	0:0	12	*
water	326:38	0:0	12	mdct_norm
op	326:47	0:0	12	>>
water	326:49	0:0	12	PRECISION
water	326:58	0:0	12	;
for	327:24	333:24	12	(i = 0 ;i < n;++ i)
forinit	327:28	327:33	13	i = 0 ;
water	327:28	0:0	14	i
op	327:30	0:0	14	=
water	327:32	0:0	14	0
water	327:33	0:0	14	;
cond	327:34	327:38	13	i < n
water	327:34	0:0	14	i
op	327:36	0:0	14	<
water	327:38	0:0	14	n
forexpr	327:41	327:43	13	++ i
op	327:41	0:0	14	++
water	327:43	0:0	14	i
stmts	328:24	333:24	13	
water	328:24	0:0	14	{
water	329:28	0:0	14	noise
op	329:34	0:0	14	=
water	329:36	0:0	14	s
op	329:37	0:0	14	->
water	329:39	0:0	14	noise_table
op	329:50	0:0	14	[
water	329:51	0:0	14	s
op	329:52	0:0	14	->
water	329:54	0:0	14	noise_index
op	329:65	0:0	14	]
water	329:66	0:0	14	;
water	330:28	0:0	14	s
op	330:29	0:0	14	->
water	330:31	0:0	14	noise_index
op	330:43	0:0	14	=
water	330:45	0:0	14	(
water	330:46	0:0	14	s
op	330:47	0:0	14	->
water	330:49	0:0	14	noise_index
op	330:61	0:0	14	+
water	330:63	0:0	14	1
water	330:64	0:0	14	)
op	330:66	0:0	14	&
water	330:68	0:0	14	(
water	330:69	0:0	14	NOISE_TAB_SIZE
op	330:84	0:0	14	-
water	330:86	0:0	14	1
water	330:87	0:0	14	)
water	330:88	0:0	14	;
op	331:28	0:0	14	*
water	331:29	0:0	14	coefs
op	331:34	0:0	14	++
op	331:37	0:0	14	=
call	331:39	331:100	14	fixmul32
arg	331:48	331:79	15	(fixmul32(*exponents,noise)>>4)
water	331:48	0:0	16	(
call	331:49	331:74	16	fixmul32
arg	331:58	331:68	17	*exponents
op	331:58	0:0	18	*
water	331:59	0:0	18	exponents
arg	331:69	331:74	17	noise
water	331:69	0:0	18	noise
op	331:75	0:0	16	>>
water	331:77	0:0	16	4
water	331:78	0:0	16	)
arg	331:80	331:100	15	Fixed32From64(mult1)
call	331:80	331:99	16	Fixed32From64
arg	331:94	331:99	17	mult1
water	331:94	0:0	18	mult1
op	331:102	0:0	14	>>
water	331:104	0:0	14	1
water	331:105	0:0	14	;
op	332:28	0:0	14	++
water	332:30	0:0	14	exponents
water	332:39	0:0	14	;
water	333:24	0:0	14	}
water	334:20	0:0	12	}
else	335:20	349:20	10
stmts	336:20	349:20	11	
water	336:20	0:0	12	{
for	338:24	348:24	12	(i = 0 ;i < n;++ i)
forinit	338:28	338:33	13	i = 0 ;
water	338:28	0:0	14	i
op	338:30	0:0	14	=
water	338:32	0:0	14	0
water	338:33	0:0	14	;
cond	338:34	338:38	13	i < n
water	338:34	0:0	14	i
op	338:36	0:0	14	<
water	338:38	0:0	14	n
forexpr	338:41	338:43	13	++ i
op	338:41	0:0	14	++
water	338:43	0:0	14	i
stmts	339:24	348:24	13	
water	339:24	0:0	14	{
water	341:28	0:0	14	noise
op	341:34	0:0	14	=
water	341:36	0:0	14	s
op	341:37	0:0	14	->
water	341:39	0:0	14	noise_table
op	341:50	0:0	14	[
water	341:51	0:0	14	s
op	341:52	0:0	14	->
water	341:54	0:0	14	noise_index
op	341:65	0:0	14	]
water	341:66	0:0	14	;
water	342:28	0:0	14	s
op	342:29	0:0	14	->
water	342:31	0:0	14	noise_index
op	342:43	0:0	14	=
water	342:45	0:0	14	(
water	342:46	0:0	14	s
op	342:47	0:0	14	->
water	342:49	0:0	14	noise_index
op	342:61	0:0	14	+
water	342:63	0:0	14	1
water	342:64	0:0	14	)
op	342:66	0:0	14	&
water	342:68	0:0	14	(
water	342:69	0:0	14	NOISE_TAB_SIZE
op	342:84	0:0	14	-
water	342:86	0:0	14	1
water	342:87	0:0	14	)
water	342:88	0:0	14	;
water	344:27	0:0	14	temp1
op	344:33	0:0	14	=
water	344:35	0:0	14	(
water	344:36	0:0	14	(
water	344:37	0:0	14	(
water	344:38	0:0	14	int32_t
water	344:45	0:0	14	)
op	344:46	0:0	14	*
water	344:47	0:0	14	coefs1
op	344:53	0:0	14	++
water	344:55	0:0	14	)
op	344:56	0:0	14	<<
water	344:58	0:0	14	16
water	344:60	0:0	14	)
op	344:62	0:0	14	+
water	344:64	0:0	14	(
water	344:65	0:0	14	noise
op	344:70	0:0	14	>>
water	344:72	0:0	14	4
water	344:73	0:0	14	)
water	344:74	0:0	14	;
water	345:27	0:0	14	temp2
op	345:33	0:0	14	=
call	345:35	345:64	14	fixmul32
arg	345:44	345:54	15	*exponents
op	345:44	0:0	16	*
water	345:45	0:0	16	exponents
arg	345:56	345:64	15	mult>>17
water	345:56	0:0	16	mult
op	345:60	0:0	16	>>
water	345:62	0:0	16	17
water	345:65	0:0	14	;
op	346:27	0:0	14	*
water	346:28	0:0	14	coefs
op	346:33	0:0	14	++
op	346:36	0:0	14	=
call	346:38	346:59	14	fixmul32
arg	346:47	346:52	15	temp1
water	346:47	0:0	16	temp1
arg	346:54	346:59	15	temp2
water	346:54	0:0	16	temp2
water	346:60	0:0	14	;
op	347:27	0:0	14	++
water	347:29	0:0	14	exponents
water	347:38	0:0	14	;
water	348:24	0:0	14	}
water	349:20	0:0	12	}
water	350:16	0:0	10	}
water	352:16	0:0	8	n
op	352:18	0:0	8	=
water	352:20	0:0	8	s
op	352:21	0:0	8	->
water	352:23	0:0	8	block_len
op	352:33	0:0	8	-
water	352:35	0:0	8	s
op	352:36	0:0	8	->
water	352:38	0:0	8	coefs_end
op	352:47	0:0	8	[
water	352:48	0:0	8	bsize
op	352:53	0:0	8	]
water	352:54	0:0	8	;
water	353:16	0:0	8	mult2
op	353:22	0:0	8	=
call	353:24	353:55	8	fixmul32
arg	353:33	353:41	9	mult>>16
water	353:33	0:0	10	mult
op	353:37	0:0	10	>>
water	353:39	0:0	10	16
arg	353:42	353:55	9	exponents[-1]
water	353:42	0:0	10	exponents
op	353:51	0:0	10	[
op	353:52	0:0	10	-
water	353:53	0:0	10	1
op	353:54	0:0	10	]
water	353:57	0:0	8	;
for	354:16	359:16	8	(i = 0 ;i < n;++ i)
forinit	354:21	354:26	9	i = 0 ;
water	354:21	0:0	10	i
op	354:23	0:0	10	=
water	354:25	0:0	10	0
water	354:26	0:0	10	;
cond	354:28	354:32	9	i < n
water	354:28	0:0	10	i
op	354:30	0:0	10	<
water	354:32	0:0	10	n
forexpr	354:35	354:37	9	++ i
op	354:35	0:0	10	++
water	354:37	0:0	10	i
stmts	355:16	359:16	9	
water	355:16	0:0	10	{
op	357:20	0:0	10	*
water	357:21	0:0	10	coefs
op	357:26	0:0	10	++
op	357:29	0:0	10	=
call	357:31	357:76	10	fixmul32
arg	357:40	357:70	11	s->noise_table[s->noise_index]
water	357:40	0:0	12	s
op	357:41	0:0	12	->
water	357:43	0:0	12	noise_table
op	357:54	0:0	12	[
water	357:55	0:0	12	s
op	357:56	0:0	12	->
water	357:58	0:0	12	noise_index
op	357:69	0:0	12	]
arg	357:71	357:76	11	mult2
water	357:71	0:0	12	mult2
op	357:78	0:0	10	>>
water	357:80	0:0	10	5
water	357:81	0:0	10	;
water	358:20	0:0	10	s
op	358:21	0:0	10	->
water	358:23	0:0	10	noise_index
op	358:35	0:0	10	=
water	358:37	0:0	10	(
water	358:38	0:0	10	s
op	358:39	0:0	10	->
water	358:41	0:0	10	noise_index
op	358:53	0:0	10	+
water	358:55	0:0	10	1
water	358:56	0:0	10	)
op	358:58	0:0	10	&
water	358:60	0:0	10	(
water	358:61	0:0	10	NOISE_TAB_SIZE
op	358:76	0:0	10	-
water	358:78	0:0	10	1
water	358:79	0:0	10	)
water	358:80	0:0	10	;
water	359:16	0:0	10	}
water	360:12	0:0	8	}
else	361:12	377:12	6
stmts	362:12	377:12	7	
water	362:12	0:0	8	{
decl	364:16	364:110	8	int32_t	mult3
op	364:30	0:0	8	=
call	364:32	364:109	9	(int32_t)
arg	364:42	364:109	10	fixdiv64(pow_table[total_gain+20],Fixed32To64(s->max_exponent[ch]))
call	364:42	364:108	11	fixdiv64
arg	364:51	364:75	12	pow_table[total_gain+20]
water	364:51	0:0	13	pow_table
op	364:60	0:0	13	[
water	364:61	0:0	13	total_gain
op	364:71	0:0	13	+
water	364:72	0:0	13	20
op	364:74	0:0	13	]
arg	364:76	364:108	12	Fixed32To64(s->max_exponent[ch])
call	364:76	364:107	13	Fixed32To64
arg	364:88	364:107	14	s->max_exponent[ch]
water	364:88	0:0	15	s
op	364:89	0:0	15	->
water	364:91	0:0	15	max_exponent
op	364:103	0:0	15	[
water	364:104	0:0	15	ch
op	364:106	0:0	15	]
water	365:16	0:0	8	mult3
op	365:22	0:0	8	=
call	365:24	365:49	8	fixmul32
arg	365:33	365:38	9	mult3
water	365:33	0:0	10	mult3
arg	365:40	365:49	9	mdct_norm
water	365:40	0:0	10	mdct_norm
water	365:50	0:0	8	;
water	366:16	0:0	8	n
op	366:18	0:0	8	=
water	366:20	0:0	8	nb_coefs
op	366:28	0:0	8	[
water	366:29	0:0	8	ch
op	366:31	0:0	8	]
water	366:32	0:0	8	;
for	368:16	369:32	8	(i = 0 ;i < s -> coefs_start;i ++)
forinit	368:20	368:25	9	i = 0 ;
water	368:20	0:0	10	i
op	368:22	0:0	10	=
water	368:24	0:0	10	0
water	368:25	0:0	10	;
cond	368:26	368:33	9	i < s -> coefs_start
water	368:26	0:0	10	i
op	368:28	0:0	10	<
water	368:30	0:0	10	s
op	368:31	0:0	10	->
water	368:33	0:0	10	coefs_start
forexpr	368:46	368:47	9	i ++
water	368:46	0:0	10	i
op	368:47	0:0	10	++
stmts	369:20	369:32	9	
op	369:20	0:0	10	*
water	369:21	0:0	10	coefs
op	369:26	0:0	10	++
op	369:29	0:0	10	=
water	369:31	0:0	10	0
water	369:32	0:0	10	;
for	370:16	374:16	8	(i = 0 ;i < n;++ i)
forinit	370:20	370:25	9	i = 0 ;
water	370:20	0:0	10	i
op	370:22	0:0	10	=
water	370:24	0:0	10	0
water	370:25	0:0	10	;
cond	370:26	370:30	9	i < n
water	370:26	0:0	10	i
op	370:28	0:0	10	<
water	370:30	0:0	10	n
forexpr	370:33	370:35	9	++ i
op	370:33	0:0	10	++
water	370:35	0:0	10	i
stmts	371:16	374:16	9	
water	371:16	0:0	10	{
water	372:20	0:0	10	atemp
op	372:26	0:0	10	=
water	372:28	0:0	10	(
water	372:29	0:0	10	coefs1
op	372:35	0:0	10	[
water	372:36	0:0	10	i
op	372:37	0:0	10	]
op	372:39	0:0	10	*
water	372:41	0:0	10	mult3
water	372:46	0:0	10	)
op	372:47	0:0	10	>>
water	372:49	0:0	10	1
water	372:50	0:0	10	;
op	373:20	0:0	10	*
water	373:21	0:0	10	coefs
op	373:26	0:0	10	++
op	373:28	0:0	10	=
call	373:29	373:70	10	fixmul32
arg	373:38	373:43	11	atemp
water	373:38	0:0	12	atemp
arg	373:44	373:70	11	exponents[i<<bsize>>esize]
water	373:44	0:0	12	exponents
op	373:53	0:0	12	[
water	373:54	0:0	12	i
op	373:55	0:0	12	<<
water	373:57	0:0	12	bsize
op	373:62	0:0	12	>>
water	373:64	0:0	12	esize
op	373:69	0:0	12	]
water	373:71	0:0	10	;
water	374:16	0:0	10	}
water	375:16	0:0	8	n
op	375:18	0:0	8	=
water	375:20	0:0	8	s
op	375:21	0:0	8	->
water	375:23	0:0	8	block_len
op	375:33	0:0	8	-
water	375:35	0:0	8	s
op	375:36	0:0	8	->
water	375:38	0:0	8	coefs_end
op	375:47	0:0	8	[
water	375:48	0:0	8	bsize
op	375:53	0:0	8	]
water	375:54	0:0	8	;
call	376:16	376:50	8	memset
arg	376:23	376:28	9	coefs
water	376:23	0:0	10	coefs
arg	376:30	376:31	9	0
water	376:30	0:0	10	0
arg	376:33	376:50	9	n*sizeof(int32_t)
water	376:33	0:0	10	n
op	376:34	0:0	10	*
op	376:35	0:0	10	sizeof
water	376:41	0:0	10	(
water	376:42	0:0	10	int32_t
water	376:49	0:0	10	)
water	376:51	0:0	8	;
water	377:12	0:0	8	}
water	378:8	0:0	6	}
water	379:4	0:0	4	}
if	380:4	400:4	2	(s -> ms_stereo && s -> channel_coded [ 1 ])
cond	380:8	380:42	3	s -> ms_stereo && s -> channel_coded [ 1 ]
water	380:8	0:0	4	s
op	380:9	0:0	4	->
water	380:11	0:0	4	ms_stereo
op	380:21	0:0	4	&&
water	380:24	0:0	4	s
op	380:25	0:0	4	->
water	380:27	0:0	4	channel_coded
op	380:40	0:0	4	[
water	380:41	0:0	4	1
op	380:42	0:0	4	]
stmts	381:4	400:4	3	
water	381:4	0:0	4	{
decl	382:8	382:20	4	int32_t	a
water	382:17	0:0	4	,
decl	382:8	382:20	4	int32_t	b
decl	383:8	383:13	4	int	i
call	384:8	384:23	4	int32_t
arg	384:17	384:23	5	*coefs
op	384:17	0:0	6	*
water	384:18	0:0	6	coefs
op	384:24	0:0	4	[
water	384:25	0:0	4	MAX_CHANNELS
op	384:37	0:0	4	]
op	384:38	0:0	4	[
water	384:39	0:0	4	BLOCK_MAX_SIZE
op	384:53	0:0	4	]
op	384:56	0:0	4	=
water	384:58	0:0	4	(
water	384:59	0:0	4	s
op	384:60	0:0	4	->
water	384:62	0:0	4	coefs
water	384:67	0:0	4	)
water	384:68	0:0	4	;
if	388:8	392:8	4	(! s -> channel_coded [ 0 ])
cond	388:12	388:31	5	! s -> channel_coded [ 0 ]
op	388:12	0:0	6	!
water	388:13	0:0	6	s
op	388:14	0:0	6	->
water	388:16	0:0	6	channel_coded
op	388:29	0:0	6	[
water	388:30	0:0	6	0
op	388:31	0:0	6	]
stmts	389:8	392:8	5	
water	389:8	0:0	6	{
call	390:12	390:70	6	memset
arg	390:19	390:35	7	(*(s->coefs))[0]
water	390:19	0:0	8	(
op	390:20	0:0	8	*
water	390:21	0:0	8	(
water	390:22	0:0	8	s
op	390:23	0:0	8	->
water	390:25	0:0	8	coefs
water	390:30	0:0	8	)
water	390:31	0:0	8	)
op	390:32	0:0	8	[
water	390:33	0:0	8	0
op	390:34	0:0	8	]
arg	390:37	390:38	7	0
water	390:37	0:0	8	0
arg	390:40	390:70	7	sizeof(int32_t)*s->block_len
op	390:40	0:0	8	sizeof
water	390:46	0:0	8	(
water	390:47	0:0	8	int32_t
water	390:54	0:0	8	)
op	390:56	0:0	8	*
water	390:58	0:0	8	s
op	390:59	0:0	8	->
water	390:61	0:0	8	block_len
water	390:71	0:0	6	;
water	391:12	0:0	6	s
op	391:13	0:0	6	->
water	391:15	0:0	6	channel_coded
op	391:28	0:0	6	[
water	391:29	0:0	6	0
op	391:30	0:0	6	]
op	391:32	0:0	6	=
water	391:34	0:0	6	1
water	391:35	0:0	6	;
water	392:8	0:0	6	}
for	393:8	399:8	4	(i = 0 ;i < s -> block_len;++ i)
forinit	393:12	393:17	5	i = 0 ;
water	393:12	0:0	6	i
op	393:14	0:0	6	=
water	393:16	0:0	6	0
water	393:17	0:0	6	;
cond	393:19	393:26	5	i < s -> block_len
water	393:19	0:0	6	i
op	393:21	0:0	6	<
water	393:23	0:0	6	s
op	393:24	0:0	6	->
water	393:26	0:0	6	block_len
forexpr	393:37	393:39	5	++ i
op	393:37	0:0	6	++
water	393:39	0:0	6	i
stmts	394:8	399:8	5	
water	394:8	0:0	6	{
water	395:12	0:0	6	a
op	395:14	0:0	6	=
water	395:16	0:0	6	(
op	395:17	0:0	6	*
water	395:18	0:0	6	coefs
water	395:23	0:0	6	)
op	395:24	0:0	6	[
water	395:25	0:0	6	0
op	395:26	0:0	6	]
op	395:27	0:0	6	[
water	395:28	0:0	6	i
op	395:29	0:0	6	]
water	395:30	0:0	6	;
water	396:12	0:0	6	b
op	396:14	0:0	6	=
water	396:16	0:0	6	(
op	396:17	0:0	6	*
water	396:18	0:0	6	coefs
water	396:23	0:0	6	)
op	396:24	0:0	6	[
water	396:25	0:0	6	1
op	396:26	0:0	6	]
op	396:27	0:0	6	[
water	396:28	0:0	6	i
op	396:29	0:0	6	]
water	396:30	0:0	6	;
water	397:12	0:0	6	(
op	397:13	0:0	6	*
water	397:14	0:0	6	coefs
water	397:19	0:0	6	)
op	397:20	0:0	6	[
water	397:21	0:0	6	0
op	397:22	0:0	6	]
op	397:23	0:0	6	[
water	397:24	0:0	6	i
op	397:25	0:0	6	]
op	397:27	0:0	6	=
water	397:29	0:0	6	a
op	397:31	0:0	6	+
water	397:33	0:0	6	b
water	397:34	0:0	6	;
water	398:12	0:0	6	(
op	398:13	0:0	6	*
water	398:14	0:0	6	coefs
water	398:19	0:0	6	)
op	398:20	0:0	6	[
water	398:21	0:0	6	1
op	398:22	0:0	6	]
op	398:23	0:0	6	[
water	398:24	0:0	6	i
op	398:25	0:0	6	]
op	398:27	0:0	6	=
water	398:29	0:0	6	a
op	398:31	0:0	6	-
water	398:33	0:0	6	b
water	398:34	0:0	6	;
water	399:8	0:0	6	}
water	400:4	0:0	4	}
for	401:4	422:4	2	(ch = 0 ;ch < s -> nb_channels;++ ch)
forinit	401:8	401:14	3	ch = 0 ;
water	401:8	0:0	4	ch
op	401:11	0:0	4	=
water	401:13	0:0	4	0
water	401:14	0:0	4	;
cond	401:16	401:24	3	ch < s -> nb_channels
water	401:16	0:0	4	ch
op	401:19	0:0	4	<
water	401:21	0:0	4	s
op	401:22	0:0	4	->
water	401:24	0:0	4	nb_channels
forexpr	401:37	401:39	3	++ ch
op	401:37	0:0	4	++
water	401:39	0:0	4	ch
stmts	402:4	422:4	3	
water	402:4	0:0	4	{
if	403:8	421:8	4	(s -> channel_coded [ ch ])
cond	403:12	403:31	5	s -> channel_coded [ ch ]
water	403:12	0:0	6	s
op	403:13	0:0	6	->
water	403:15	0:0	6	channel_coded
op	403:28	0:0	6	[
water	403:29	0:0	6	ch
op	403:31	0:0	6	]
stmts	404:8	421:8	5	
water	404:8	0:0	6	{
water	405:12	0:0	6	static
water	405:19	0:0	6	int32_t
water	405:28	0:0	6	output
op	405:34	0:0	6	[
water	405:35	0:0	6	BLOCK_MAX_SIZE
op	405:50	0:0	6	*
water	405:52	0:0	6	2
op	405:53	0:0	6	]
water	405:55	0:0	6	IBSS_ATTR
water	405:64	0:0	6	;
decl	406:12	406:28	6	int	n4
water	406:18	0:0	6	,
decl	406:12	406:28	6	int	index
water	406:25	0:0	6	,
decl	406:12	406:28	6	int	n
water	407:12	0:0	6	n
op	407:14	0:0	6	=
water	407:16	0:0	6	s
op	407:17	0:0	6	->
water	407:19	0:0	6	block_len
water	407:28	0:0	6	;
water	408:12	0:0	6	n4
op	408:15	0:0	6	=
water	408:17	0:0	6	s
op	408:18	0:0	6	->
water	408:20	0:0	6	block_len
op	408:30	0:0	6	>>
water	408:32	0:0	6	1
water	408:33	0:0	6	;
call	409:12	411:43	6	ff_imdct_calc
arg	409:26	409:45	7	&s->mdct_ctx[bsize]
op	409:26	0:0	8	&
water	409:27	0:0	8	s
op	409:28	0:0	8	->
water	409:30	0:0	8	mdct_ctx
op	409:38	0:0	8	[
water	409:39	0:0	8	bsize
op	409:44	0:0	8	]
arg	410:26	410:32	7	output
water	410:26	0:0	8	output
arg	411:26	411:43	7	(*(s->coefs))[ch]
water	411:26	0:0	8	(
op	411:27	0:0	8	*
water	411:28	0:0	8	(
water	411:29	0:0	8	s
op	411:30	0:0	8	->
water	411:32	0:0	8	coefs
water	411:37	0:0	8	)
water	411:38	0:0	8	)
op	411:39	0:0	8	[
water	411:40	0:0	8	ch
op	411:42	0:0	8	]
water	411:44	0:0	6	;
water	413:12	0:0	6	index
op	413:18	0:0	6	=
water	413:20	0:0	6	(
water	413:21	0:0	6	s
op	413:22	0:0	6	->
water	413:24	0:0	6	frame_len
op	413:34	0:0	6	/
water	413:36	0:0	6	2
water	413:37	0:0	6	)
op	413:39	0:0	6	+
water	413:41	0:0	6	s
op	413:42	0:0	6	->
water	413:44	0:0	6	block_pos
op	413:54	0:0	6	-
water	413:56	0:0	6	n4
water	413:58	0:0	6	;
call	414:12	414:58	6	wma_window
arg	414:23	414:24	7	s
water	414:23	0:0	8	s
arg	414:26	414:32	7	output
water	414:26	0:0	8	output
arg	414:34	414:58	7	&s->frame_out[ch][index]
op	414:34	0:0	8	&
water	414:35	0:0	8	s
op	414:36	0:0	8	->
water	414:38	0:0	8	frame_out
op	414:47	0:0	8	[
water	414:48	0:0	8	ch
op	414:50	0:0	8	]
op	414:51	0:0	8	[
water	414:52	0:0	8	index
op	414:57	0:0	8	]
water	414:59	0:0	6	;
if	417:12	420:12	6	(s -> ms_stereo && ! s -> channel_coded [ 1 ])
cond	417:16	417:51	7	s -> ms_stereo && ! s -> channel_coded [ 1 ]
water	417:16	0:0	8	s
op	417:17	0:0	8	->
water	417:19	0:0	8	ms_stereo
op	417:29	0:0	8	&&
op	417:32	0:0	8	!
water	417:33	0:0	8	s
op	417:34	0:0	8	->
water	417:36	0:0	8	channel_coded
op	417:49	0:0	8	[
water	417:50	0:0	8	1
op	417:51	0:0	8	]
stmts	418:12	420:12	7	
water	418:12	0:0	8	{
call	419:16	419:61	8	wma_window
arg	419:27	419:28	9	s
water	419:27	0:0	10	s
arg	419:30	419:36	9	output
water	419:30	0:0	10	output
arg	419:38	419:61	9	&s->frame_out[1][index]
op	419:38	0:0	10	&
water	419:39	0:0	10	s
op	419:40	0:0	10	->
water	419:42	0:0	10	frame_out
op	419:51	0:0	10	[
water	419:52	0:0	10	1
op	419:53	0:0	10	]
op	419:54	0:0	10	[
water	419:55	0:0	10	index
op	419:60	0:0	10	]
water	419:62	0:0	8	;
water	420:12	0:0	8	}
water	421:8	0:0	6	}
water	422:4	0:0	4	}
label	423:0	423:4	2	next :
op	425:4	0:0	2	++
water	425:6	0:0	2	s
op	425:7	0:0	2	->
water	425:9	0:0	2	block_num
water	425:18	0:0	2	;
water	426:4	0:0	2	s
op	426:5	0:0	2	->
water	426:7	0:0	2	block_pos
op	426:17	0:0	2	+=
water	426:20	0:0	2	s
op	426:21	0:0	2	->
water	426:23	0:0	2	block_len
water	426:32	0:0	2	;
if	427:4	430:4	2	(s -> block_pos >= s -> frame_len)
cond	427:8	427:27	3	s -> block_pos >= s -> frame_len
water	427:8	0:0	4	s
op	427:9	0:0	4	->
water	427:11	0:0	4	block_pos
op	427:21	0:0	4	>=
water	427:24	0:0	4	s
op	427:25	0:0	4	->
water	427:27	0:0	4	frame_len
stmts	428:4	430:4	3	
water	428:4	0:0	4	{
return	429:8	429:16	4	1
water	429:15	0:0	5	1
water	430:4	0:0	4	}
else	431:4	434:4	2
stmts	432:4	434:4	3	
water	432:4	0:0	4	{
return	433:8	433:16	4	0
water	433:15	0:0	5	0
water	434:4	0:0	4	}
