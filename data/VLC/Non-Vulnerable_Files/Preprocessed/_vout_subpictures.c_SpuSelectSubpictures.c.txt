func	2:0	105:0	0	static void	SpuSelectSubpictures
params	2:32	0:0	1	
param	2:33	2:43	2	spu_t *	spu
param	3:33	3:63	2	unsigned int *	subpicture_count
param	4:33	4:64	2	subpicture_t * *	subpicture_array
param	5:33	5:61	2	mtime_t	render_subtitle_date
param	6:33	6:56	2	mtime_t	render_osd_date
param	7:33	7:48	2	bool	ignore_osd
stmnts	0:0	104:46	1	
decl	9:4	9:31	2	spu_private_t	*sys
op	9:23	0:0	2	=
water	9:25	0:0	2	spu
op	9:28	0:0	2	->
water	9:30	0:0	2	p
op	11:4	0:0	2	*
water	11:5	0:0	2	subpicture_count
op	11:22	0:0	2	=
water	11:24	0:0	2	0
water	11:25	0:0	2	;
decl	13:4	13:37	2	int	channel[VOUT_MAX_SUBPICTURES]
decl	14:4	14:25	2	int	channel_count
op	14:22	0:0	2	=
water	14:24	0:0	2	0
for	15:4	27:4	2	( int index = 0 ;index < VOUT_MAX_SUBPICTURES;index ++)
forinit	0:0	15:22	3	 int index = 0 ;
decl	15:9	15:22	4	int	index
op	15:19	0:0	4	=
water	15:21	0:0	4	0
cond	15:24	15:32	3	index < VOUT_MAX_SUBPICTURES
water	15:24	0:0	4	index
op	15:30	0:0	4	<
water	15:32	0:0	4	VOUT_MAX_SUBPICTURES
forexpr	15:54	15:59	3	index ++
water	15:54	0:0	4	index
op	15:59	0:0	4	++
stmts	15:63	27:4	3	
water	15:63	0:0	4	{
decl	16:8	16:57	4	spu_heap_entry_t	*entry
op	16:32	0:0	4	=
op	16:34	0:0	4	&
water	16:35	0:0	4	sys
op	16:38	0:0	4	->
water	16:40	0:0	4	heap
op	16:44	0:0	4	.
water	16:45	0:0	4	entry
op	16:50	0:0	4	[
water	16:51	0:0	4	index
op	16:56	0:0	4	]
if	17:8	18:20	4	(! entry -> subpicture || entry -> reject)
cond	17:12	17:41	5	! entry -> subpicture || entry -> reject
op	17:12	0:0	6	!
water	17:13	0:0	6	entry
op	17:18	0:0	6	->
water	17:20	0:0	6	subpicture
op	17:31	0:0	6	||
water	17:34	0:0	6	entry
op	17:39	0:0	6	->
water	17:41	0:0	6	reject
stmts	18:12	18:20	5	
continue	18:12	18:20	6	
decl	19:8	19:58	4	const int	i_channel
op	19:28	0:0	4	=
water	19:30	0:0	4	entry
op	19:35	0:0	4	->
water	19:37	0:0	4	subpicture
op	19:47	0:0	4	->
water	19:49	0:0	4	i_channel
decl	20:8	20:13	4	int	i
for	21:8	24:8	4	(i = 0 ;i < channel_count;i ++)
forinit	21:13	21:18	5	i = 0 ;
water	21:13	0:0	6	i
op	21:15	0:0	6	=
water	21:17	0:0	6	0
water	21:18	0:0	6	;
cond	21:20	21:24	5	i < channel_count
water	21:20	0:0	6	i
op	21:22	0:0	6	<
water	21:24	0:0	6	channel_count
forexpr	21:39	21:40	5	i ++
water	21:39	0:0	6	i
op	21:40	0:0	6	++
stmts	21:44	24:8	5	
water	21:44	0:0	6	{
if	22:12	23:21	6	(channel [ i ] == i_channel)
cond	22:16	22:30	7	channel [ i ] == i_channel
water	22:16	0:0	8	channel
op	22:23	0:0	8	[
water	22:24	0:0	8	i
op	22:25	0:0	8	]
op	22:27	0:0	8	==
water	22:30	0:0	8	i_channel
stmts	23:16	23:21	7	
break	23:16	23:21	8	
water	24:8	0:0	6	}
if	25:8	26:48	4	(channel_count <= i)
cond	25:12	25:29	5	channel_count <= i
water	25:12	0:0	6	channel_count
op	25:26	0:0	6	<=
water	25:29	0:0	6	i
stmts	26:12	26:48	5	
water	26:12	0:0	6	channel
op	26:19	0:0	6	[
water	26:20	0:0	6	channel_count
op	26:33	0:0	6	++
op	26:35	0:0	6	]
op	26:37	0:0	6	=
water	26:39	0:0	6	i_channel
water	26:48	0:0	6	;
water	27:4	0:0	4	}
for	29:4	103:4	2	( int i = 0 ;i < channel_count;i ++)
forinit	0:0	29:18	3	 int i = 0 ;
decl	29:9	29:18	4	int	i
op	29:15	0:0	4	=
water	29:17	0:0	4	0
cond	29:20	29:24	3	i < channel_count
water	29:20	0:0	4	i
op	29:22	0:0	4	<
water	29:24	0:0	4	channel_count
forexpr	29:39	29:40	3	i ++
water	29:39	0:0	4	i
op	29:40	0:0	4	++
stmts	29:44	103:4	3	
water	29:44	0:0	4	{
decl	30:8	30:60	4	subpicture_t	*available_subpic[VOUT_MAX_SUBPICTURES]
decl	31:8	31:60	4	bool	is_available_late[VOUT_MAX_SUBPICTURES]
decl	32:8	32:40	4	int	available_count
op	32:37	0:0	4	=
water	32:39	0:0	4	0
decl	33:8	33:54	4	mtime_t	start_date
op	33:32	0:0	4	=
water	33:34	0:0	4	render_subtitle_date
decl	34:8	34:46	4	mtime_t	ephemer_subtitle_date
op	34:43	0:0	4	=
water	34:45	0:0	4	0
decl	35:8	35:41	4	mtime_t	ephemer_osd_date
op	35:38	0:0	4	=
water	35:40	0:0	4	0
decl	36:8	36:55	4	int64_t	ephemer_subtitle_order
op	36:44	0:0	4	=
water	36:46	0:0	4	INT64_MIN
decl	37:8	37:53	4	int64_t	ephemer_system_order
op	37:42	0:0	4	=
water	37:44	0:0	4	INT64_MIN
for	39:8	76:8	4	( int index = 0 ;index < VOUT_MAX_SUBPICTURES;index ++)
forinit	0:0	39:26	5	 int index = 0 ;
decl	39:13	39:26	6	int	index
op	39:23	0:0	6	=
water	39:25	0:0	6	0
cond	39:28	39:36	5	index < VOUT_MAX_SUBPICTURES
water	39:28	0:0	6	index
op	39:34	0:0	6	<
water	39:36	0:0	6	VOUT_MAX_SUBPICTURES
forexpr	39:58	39:63	5	index ++
water	39:58	0:0	6	index
op	39:63	0:0	6	++
stmts	39:67	76:8	5	
water	39:67	0:0	6	{
decl	40:12	40:61	6	spu_heap_entry_t	*entry
op	40:36	0:0	6	=
op	40:38	0:0	6	&
water	40:39	0:0	6	sys
op	40:42	0:0	6	->
water	40:44	0:0	6	heap
op	40:48	0:0	6	.
water	40:49	0:0	6	entry
op	40:54	0:0	6	[
water	40:55	0:0	6	index
op	40:60	0:0	6	]
decl	41:12	41:53	6	subpicture_t	*current
op	41:34	0:0	6	=
water	41:36	0:0	6	entry
op	41:41	0:0	6	->
water	41:43	0:0	6	subpicture
decl	42:12	42:30	6	bool	is_stop_valid
decl	43:12	43:24	6	bool	is_late
if	44:12	48:12	6	(! current || entry -> reject)
cond	44:16	44:35	7	! current || entry -> reject
op	44:16	0:0	8	!
water	44:17	0:0	8	current
op	44:25	0:0	8	||
water	44:28	0:0	8	entry
op	44:33	0:0	8	->
water	44:35	0:0	8	reject
stmts	44:43	48:12	7	
water	44:43	0:0	8	{
if	45:16	46:54	8	(entry -> reject)
cond	45:20	45:27	9	entry -> reject
water	45:20	0:0	10	entry
op	45:25	0:0	10	->
water	45:27	0:0	10	reject
stmts	46:20	46:54	9	
call	46:20	46:53	10	SpuHeapDeleteAt
arg	46:36	46:46	11	&sys->heap
op	46:36	0:0	12	&
water	46:37	0:0	12	sys
op	46:40	0:0	12	->
water	46:42	0:0	12	heap
arg	46:48	46:53	11	index
water	46:48	0:0	12	index
water	46:54	0:0	10	;
continue	47:16	47:24	8	
water	48:12	0:0	8	}
if	49:12	51:24	6	(current -> i_channel != channel [ i ] || ( ignore_osd && ! current -> b_subtitle ))
cond	49:16	50:50	7	current -> i_channel != channel [ i ] || ( ignore_osd && ! current -> b_subtitle )
water	49:16	0:0	8	current
op	49:23	0:0	8	->
water	49:25	0:0	8	i_channel
op	49:35	0:0	8	!=
water	49:38	0:0	8	channel
op	49:45	0:0	8	[
water	49:46	0:0	8	i
op	49:47	0:0	8	]
op	49:49	0:0	8	||
water	50:15	0:0	8	(
water	50:16	0:0	8	ignore_osd
op	50:27	0:0	8	&&
op	50:30	0:0	8	!
water	50:31	0:0	8	current
op	50:38	0:0	8	->
water	50:40	0:0	8	b_subtitle
water	50:50	0:0	8	)
stmts	51:16	51:24	7	
continue	51:16	51:24	8	
decl	52:12	52:100	6	const mtime_t	render_date
op	52:38	0:0	6	=
water	52:40	0:0	6	current
op	52:47	0:0	6	->
water	52:49	0:0	6	b_subtitle
water	52:60	0:0	6	?
water	52:62	0:0	6	render_subtitle_date
water	52:83	0:0	6	:
water	52:85	0:0	6	render_osd_date
if	53:12	57:12	6	(render_date && render_date < current -> i_start)
cond	53:16	54:39	7	render_date && render_date < current -> i_start
water	53:16	0:0	8	render_date
op	53:28	0:0	8	&&
water	54:16	0:0	8	render_date
op	54:28	0:0	8	<
water	54:30	0:0	8	current
op	54:37	0:0	8	->
water	54:39	0:0	8	i_start
stmts	54:48	57:12	7	
water	54:48	0:0	8	{
continue	56:16	56:24	8	
water	57:12	0:0	8	}
decl	58:12	58:106	6	mtime_t	*ephemer_date_ptr
op	58:39	0:0	6	=
water	58:41	0:0	6	current
op	58:48	0:0	6	->
water	58:50	0:0	6	b_subtitle
water	58:61	0:0	6	?
op	58:63	0:0	6	&
water	58:64	0:0	6	ephemer_subtitle_date
water	58:87	0:0	6	:
op	58:89	0:0	6	&
water	58:90	0:0	6	ephemer_osd_date
decl	59:12	59:110	6	int64_t	*ephemer_order_ptr
op	59:39	0:0	6	=
water	59:41	0:0	6	current
op	59:48	0:0	6	->
water	59:50	0:0	6	b_subtitle
water	59:61	0:0	6	?
op	59:63	0:0	6	&
water	59:64	0:0	6	ephemer_subtitle_order
water	59:87	0:0	6	:
op	59:89	0:0	6	&
water	59:90	0:0	6	ephemer_system_order
if	60:12	64:12	6	(current -> i_start >= * ephemer_date_ptr)
cond	60:16	60:37	7	current -> i_start >= * ephemer_date_ptr
water	60:16	0:0	8	current
op	60:23	0:0	8	->
water	60:25	0:0	8	i_start
op	60:33	0:0	8	>=
op	60:36	0:0	8	*
water	60:37	0:0	8	ephemer_date_ptr
stmts	60:55	64:12	7	
water	60:55	0:0	8	{
op	61:16	0:0	8	*
water	61:17	0:0	8	ephemer_date_ptr
op	61:34	0:0	8	=
water	61:36	0:0	8	current
op	61:43	0:0	8	->
water	61:45	0:0	8	i_start
water	61:52	0:0	8	;
if	62:16	63:57	8	(current -> i_order > * ephemer_order_ptr)
cond	62:20	62:40	9	current -> i_order > * ephemer_order_ptr
water	62:20	0:0	10	current
op	62:27	0:0	10	->
water	62:29	0:0	10	i_order
op	62:37	0:0	10	>
op	62:39	0:0	10	*
water	62:40	0:0	10	ephemer_order_ptr
stmts	63:20	63:57	9	
op	63:20	0:0	10	*
water	63:21	0:0	10	ephemer_order_ptr
op	63:39	0:0	10	=
water	63:41	0:0	10	current
op	63:48	0:0	10	->
water	63:50	0:0	10	i_order
water	63:57	0:0	10	;
water	64:12	0:0	8	}
water	65:12	0:0	6	is_stop_valid
op	65:26	0:0	6	=
op	65:28	0:0	6	!
water	65:29	0:0	6	current
op	65:36	0:0	6	->
water	65:38	0:0	6	b_ephemer
op	65:48	0:0	6	||
water	65:51	0:0	6	current
op	65:58	0:0	6	->
water	65:60	0:0	6	i_stop
op	65:67	0:0	6	>
water	65:69	0:0	6	current
op	65:76	0:0	6	->
water	65:78	0:0	6	i_start
water	65:85	0:0	6	;
water	66:12	0:0	6	is_late
op	66:20	0:0	6	=
water	66:22	0:0	6	is_stop_valid
op	66:36	0:0	6	&&
water	66:39	0:0	6	current
op	66:46	0:0	6	->
water	66:48	0:0	6	i_stop
op	66:55	0:0	6	<=
water	66:58	0:0	6	render_date
water	66:69	0:0	6	;
if	70:12	71:45	6	(current -> b_subtitle && ! is_late && ! current -> b_ephemer)
cond	70:16	70:61	7	current -> b_subtitle && ! is_late && ! current -> b_ephemer
water	70:16	0:0	8	current
op	70:23	0:0	8	->
water	70:25	0:0	8	b_subtitle
op	70:36	0:0	8	&&
op	70:39	0:0	8	!
water	70:40	0:0	8	is_late
op	70:48	0:0	8	&&
op	70:51	0:0	8	!
water	70:52	0:0	8	current
op	70:59	0:0	8	->
water	70:61	0:0	8	b_ephemer
stmts	71:16	71:45	7	
water	71:16	0:0	8	start_date
op	71:27	0:0	8	=
water	71:29	0:0	8	current
op	71:36	0:0	8	->
water	71:38	0:0	8	i_start
water	71:45	0:0	8	;
water	73:12	0:0	6	available_subpic
op	73:28	0:0	6	[
water	73:29	0:0	6	available_count
op	73:44	0:0	6	]
op	73:46	0:0	6	=
water	73:48	0:0	6	current
water	73:55	0:0	6	;
water	74:12	0:0	6	is_available_late
op	74:29	0:0	6	[
water	74:30	0:0	6	available_count
op	74:45	0:0	6	]
op	74:47	0:0	6	=
water	74:49	0:0	6	is_late
water	74:56	0:0	6	;
water	75:12	0:0	6	available_count
op	75:27	0:0	6	++
water	75:29	0:0	6	;
water	76:8	0:0	6	}
if	78:8	79:44	4	(start_date < sys -> last_sort_date)
cond	78:12	78:30	5	start_date < sys -> last_sort_date
water	78:12	0:0	6	start_date
op	78:23	0:0	6	<
water	78:25	0:0	6	sys
op	78:28	0:0	6	->
water	78:30	0:0	6	last_sort_date
stmts	79:12	79:44	5	
water	79:12	0:0	6	start_date
op	79:23	0:0	6	=
water	79:25	0:0	6	sys
op	79:28	0:0	6	->
water	79:30	0:0	6	last_sort_date
water	79:44	0:0	6	;
if	80:8	81:34	4	(start_date <= 0)
cond	80:12	80:26	5	start_date <= 0
water	80:12	0:0	6	start_date
op	80:23	0:0	6	<=
water	80:26	0:0	6	0
stmts	81:12	81:34	5	
water	81:12	0:0	6	start_date
op	81:23	0:0	6	=
water	81:25	0:0	6	INT64_MAX
water	81:34	0:0	6	;
for	83:8	102:8	4	( int index = 0 ;index < available_count;index ++)
forinit	0:0	83:26	5	 int index = 0 ;
decl	83:13	83:26	6	int	index
op	83:23	0:0	6	=
water	83:25	0:0	6	0
cond	83:28	83:36	5	index < available_count
water	83:28	0:0	6	index
op	83:34	0:0	6	<
water	83:36	0:0	6	available_count
forexpr	83:53	83:58	5	index ++
water	83:53	0:0	6	index
op	83:58	0:0	6	++
stmts	83:62	102:8	5	
water	83:62	0:0	6	{
decl	84:12	84:59	6	subpicture_t	*current
op	84:34	0:0	6	=
water	84:36	0:0	6	available_subpic
op	84:52	0:0	6	[
water	84:53	0:0	6	index
op	84:58	0:0	6	]
decl	85:12	85:51	6	bool	is_late
op	85:25	0:0	6	=
water	85:27	0:0	6	is_available_late
op	85:44	0:0	6	[
water	85:45	0:0	6	index
op	85:50	0:0	6	]
decl	86:12	86:116	6	const mtime_t	stop_date
op	86:36	0:0	6	=
water	86:38	0:0	6	current
op	86:45	0:0	6	->
water	86:47	0:0	6	b_subtitle
water	86:58	0:0	6	?
call	86:60	86:97	7	__MAX
arg	86:66	86:76	8	start_date
water	86:66	0:0	9	start_date
arg	86:78	86:97	8	sys->last_sort_date
water	86:78	0:0	9	sys
op	86:81	0:0	9	->
water	86:83	0:0	9	last_sort_date
water	86:99	0:0	6	:
water	86:101	0:0	6	render_osd_date
decl	87:12	87:105	6	const mtime_t	ephemer_date
op	87:40	0:0	6	=
water	87:42	0:0	6	current
op	87:49	0:0	6	->
water	87:51	0:0	6	b_subtitle
water	87:62	0:0	6	?
water	87:64	0:0	6	ephemer_subtitle_date
water	87:87	0:0	6	:
water	87:89	0:0	6	ephemer_osd_date
decl	88:12	88:109	6	const int64_t	ephemer_order
op	88:40	0:0	6	=
water	88:42	0:0	6	current
op	88:49	0:0	6	->
water	88:51	0:0	6	b_subtitle
water	88:62	0:0	6	?
water	88:64	0:0	6	ephemer_subtitle_order
water	88:87	0:0	6	:
water	88:89	0:0	6	ephemer_system_order
decl	90:12	90:69	6	bool	is_rejeted
op	90:28	0:0	6	=
water	90:30	0:0	6	is_late
op	90:38	0:0	6	&&
water	90:41	0:0	6	current
op	90:48	0:0	6	->
water	90:50	0:0	6	i_stop
op	90:57	0:0	6	<=
water	90:60	0:0	6	stop_date
if	91:12	97:12	6	(current -> b_ephemer)
cond	91:16	91:25	7	current -> b_ephemer
water	91:16	0:0	8	current
op	91:23	0:0	8	->
water	91:25	0:0	8	b_ephemer
stmts	91:36	97:12	7	
water	91:36	0:0	8	{
if	92:16	93:37	8	(current -> i_start < ephemer_date)
cond	92:20	92:39	9	current -> i_start < ephemer_date
water	92:20	0:0	10	current
op	92:27	0:0	10	->
water	92:29	0:0	10	i_start
op	92:37	0:0	10	<
water	92:39	0:0	10	ephemer_date
stmts	93:20	93:37	9	
water	93:20	0:0	10	is_rejeted
op	93:31	0:0	10	=
water	93:33	0:0	10	true
water	93:37	0:0	10	;
else	94:16	96:37	8
stmts	94:21	96:37	9	
if	94:21	96:37	10	(current -> i_start == ephemer_date && current -> i_order < ephemer_order)
cond	94:25	95:44	11	current -> i_start == ephemer_date && current -> i_order < ephemer_order
water	94:25	0:0	12	current
op	94:32	0:0	12	->
water	94:34	0:0	12	i_start
op	94:42	0:0	12	==
water	94:45	0:0	12	ephemer_date
op	94:58	0:0	12	&&
water	95:25	0:0	12	current
op	95:32	0:0	12	->
water	95:34	0:0	12	i_order
op	95:42	0:0	12	<
water	95:44	0:0	12	ephemer_order
stmts	96:20	96:37	11	
water	96:20	0:0	12	is_rejeted
op	96:31	0:0	12	=
water	96:33	0:0	12	true
water	96:37	0:0	12	;
water	97:12	0:0	8	}
if	98:12	99:60	6	(is_rejeted)
cond	98:16	98:16	7	is_rejeted
water	98:16	0:0	8	is_rejeted
stmts	99:16	99:60	7	
call	99:16	99:59	8	SpuHeapDeleteSubpicture
arg	99:40	99:50	9	&sys->heap
op	99:40	0:0	10	&
water	99:41	0:0	10	sys
op	99:44	0:0	10	->
water	99:46	0:0	10	heap
arg	99:52	99:59	9	current
water	99:52	0:0	10	current
water	99:60	0:0	8	;
else	100:12	101:65	6
stmts	101:16	101:65	7	
water	101:16	0:0	8	subpicture_array
op	101:32	0:0	8	[
water	101:33	0:0	8	(
op	101:34	0:0	8	*
water	101:35	0:0	8	subpicture_count
water	101:51	0:0	8	)
op	101:52	0:0	8	++
op	101:54	0:0	8	]
op	101:56	0:0	8	=
water	101:58	0:0	8	current
water	101:65	0:0	8	;
water	102:8	0:0	6	}
water	103:4	0:0	4	}
water	104:4	0:0	2	sys
op	104:7	0:0	2	->
water	104:9	0:0	2	last_sort_date
op	104:24	0:0	2	=
water	104:26	0:0	2	render_subtitle_date
water	104:46	0:0	2	;
