func	1:0	383:0	0	static bool	Control
params	1:19	0:0	1	
param	1:21	1:44	2	input_thread_t *	p_input
param	2:21	2:31	2	int	i_type
param	2:33	2:49	2	vlc_value_t	val
stmnts	0:0	382:25	1	
decl	4:4	4:42	2	const mtime_t	i_control_date
op	4:33	0:0	2	=
call	4:35	4:41	3	mdate
decl	6:4	6:31	2	bool	b_force_update
op	6:24	0:0	2	=
water	6:26	0:0	2	false
if	7:4	8:29	2	(! p_input)
cond	7:8	7:9	3	! p_input
op	7:8	0:0	4	!
water	7:9	0:0	4	p_input
stmts	8:8	8:29	3	
return	8:8	8:29	4	b_force_update
water	8:15	0:0	5	b_force_update
switch	9:4	380:4	2	(i_type)
cond	9:12	9:12	3	i_type
water	9:12	0:0	4	i_type
stmts	10:4	380:4	3	
water	10:4	0:0	4	{
label	11:8	11:34	4	case INPUT_CONTROL_SET_DIE :
call	12:12	12:56	4	msg_Dbg
arg	12:21	12:28	5	p_input
water	12:21	0:0	6	p_input
arg	12:30	12:56	5	"control: stopping input"
water	12:30	0:0	6	"control: stopping input"
water	12:57	0:0	4	;
call	14:12	14:53	4	ObjectKillChildrens
arg	14:33	14:53	5	VLC_OBJECT(p_input)
call	14:33	14:51	6	VLC_OBJECT
arg	14:44	14:51	7	p_input
water	14:44	0:0	8	p_input
water	14:54	0:0	4	;
break	15:12	15:17	4	
label	16:8	16:39	4	case INPUT_CONTROL_SET_POSITION :
water	17:8	0:0	4	{
decl	18:12	18:24	4	double	f_pos
if	19:12	23:12	4	(p_input -> p -> b_recording)
cond	19:16	19:28	5	p_input -> p -> b_recording
water	19:16	0:0	6	p_input
op	19:23	0:0	6	->
water	19:25	0:0	6	p
op	19:26	0:0	6	->
water	19:28	0:0	6	b_recording
stmts	20:12	23:12	5	
water	20:12	0:0	6	{
call	21:16	21:96	6	msg_Err
arg	21:25	21:32	7	p_input
water	21:25	0:0	8	p_input
arg	21:34	21:96	7	"INPUT_CONTROL_SET_POSITION(_OFFSET) ignored while recording"
water	21:34	0:0	8	"INPUT_CONTROL_SET_POSITION(_OFFSET) ignored while recording"
water	21:97	0:0	6	;
break	22:16	22:21	6	
water	23:12	0:0	6	}
water	24:12	0:0	4	f_pos
op	24:18	0:0	4	=
water	24:20	0:0	4	val
op	24:23	0:0	4	.
water	24:24	0:0	4	f_float
water	24:31	0:0	4	;
if	25:12	26:60	4	(i_type != INPUT_CONTROL_SET_POSITION)
cond	25:16	25:26	5	i_type != INPUT_CONTROL_SET_POSITION
water	25:16	0:0	6	i_type
op	25:23	0:0	6	!=
water	25:26	0:0	6	INPUT_CONTROL_SET_POSITION
stmts	26:16	26:60	5	
water	26:16	0:0	6	f_pos
op	26:22	0:0	6	+=
call	26:25	26:59	6	var_GetFloat
arg	26:39	26:46	7	p_input
water	26:39	0:0	8	p_input
arg	26:48	26:59	7	"position"
water	26:48	0:0	8	"position"
water	26:60	0:0	6	;
if	27:12	28:27	4	(f_pos < 0 . 0)
cond	27:16	27:26	5	f_pos < 0 . 0
water	27:16	0:0	6	f_pos
op	27:22	0:0	6	<
water	27:24	0:0	6	0
op	27:25	0:0	6	.
water	27:26	0:0	6	0
stmts	28:16	28:27	5	
water	28:16	0:0	6	f_pos
op	28:22	0:0	6	=
water	28:24	0:0	6	0
op	28:25	0:0	6	.
water	28:26	0:0	6	0
water	28:27	0:0	6	;
else	29:12	30:27	4
stmts	29:17	30:27	5	
if	29:17	30:27	6	(f_pos > 1 . 0)
cond	29:21	29:31	7	f_pos > 1 . 0
water	29:21	0:0	8	f_pos
op	29:27	0:0	8	>
water	29:29	0:0	8	1
op	29:30	0:0	8	.
water	29:31	0:0	8	0
stmts	30:16	30:27	7	
water	30:16	0:0	8	f_pos
op	30:22	0:0	8	=
water	30:24	0:0	8	1
op	30:25	0:0	8	.
water	30:26	0:0	8	0
water	30:27	0:0	8	;
call	32:12	32:53	4	es_out_SetTime
arg	32:28	32:48	5	p_input->p->p_es_out
water	32:28	0:0	6	p_input
op	32:35	0:0	6	->
water	32:37	0:0	6	p
op	32:38	0:0	6	->
water	32:40	0:0	6	p_es_out
arg	32:50	32:53	5	-1
op	32:50	0:0	6	-
water	32:51	0:0	6	1
water	32:54	0:0	4	;
if	33:12	38:12	4	(demux_Control (p_input -> p -> input . p_demux ,DEMUX_SET_POSITION ,f_pos ,! p_input -> p -> b_fast_seek ))
cond	33:16	34:64	5	demux_Control (p_input -> p -> input . p_demux ,DEMUX_SET_POSITION ,f_pos ,! p_input -> p -> b_fast_seek )
call	33:16	34:64	6	demux_Control
arg	33:31	33:56	7	p_input->p->input.p_demux
water	33:31	0:0	8	p_input
op	33:38	0:0	8	->
water	33:40	0:0	8	p
op	33:41	0:0	8	->
water	33:43	0:0	8	input
op	33:48	0:0	8	.
water	33:49	0:0	8	p_demux
arg	33:58	33:76	7	DEMUX_SET_POSITION
water	33:58	0:0	8	DEMUX_SET_POSITION
arg	34:32	34:37	7	f_pos
water	34:32	0:0	8	f_pos
arg	34:39	34:64	7	!p_input->p->b_fast_seek
op	34:39	0:0	8	!
water	34:40	0:0	8	p_input
op	34:47	0:0	8	->
water	34:49	0:0	8	p
op	34:50	0:0	8	->
water	34:52	0:0	8	b_fast_seek
stmts	35:12	38:12	5	
water	35:12	0:0	6	{
call	36:16	37:55	6	msg_Err
arg	36:25	36:32	7	p_input
water	36:25	0:0	8	p_input
arg	36:34	37:41	7	"INPUT_CONTROL_SET_POSITION(_OFFSET) ""%2.1f%% failed"
water	36:34	0:0	8	"INPUT_CONTROL_SET_POSITION(_OFFSET) "
water	37:25	0:0	8	"%2.1f%% failed"
arg	37:43	37:55	7	f_pos*100
water	37:43	0:0	8	f_pos
op	37:49	0:0	8	*
water	37:51	0:0	8	100
water	37:56	0:0	6	;
water	38:12	0:0	6	}
else	39:12	45:12	4
stmts	40:12	45:12	5	
water	40:12	0:0	6	{
if	41:16	42:40	6	(p_input -> p -> i_slave > 0)
cond	41:20	41:42	7	p_input -> p -> i_slave > 0
water	41:20	0:0	8	p_input
op	41:27	0:0	8	->
water	41:29	0:0	8	p
op	41:30	0:0	8	->
water	41:32	0:0	8	i_slave
op	41:40	0:0	8	>
water	41:42	0:0	8	0
stmts	42:20	42:40	7	
call	42:20	42:39	8	SlaveSeek
arg	42:31	42:39	9	p_input
water	42:31	0:0	10	p_input
water	42:40	0:0	8	;
water	43:16	0:0	6	p_input
op	43:23	0:0	6	->
water	43:25	0:0	6	p
op	43:26	0:0	6	->
water	43:28	0:0	6	input
op	43:33	0:0	6	.
water	43:34	0:0	6	b_eof
op	43:40	0:0	6	=
water	43:42	0:0	6	false
water	43:47	0:0	6	;
water	44:16	0:0	6	b_force_update
op	44:31	0:0	6	=
water	44:33	0:0	6	true
water	44:37	0:0	6	;
water	45:12	0:0	6	}
break	46:12	46:17	4	
water	47:8	0:0	4	}
label	48:8	48:35	4	case INPUT_CONTROL_SET_TIME :
water	49:8	0:0	4	{
decl	50:12	50:26	4	int64_t	i_time
decl	51:12	51:21	4	int	i_ret
if	52:12	56:12	4	(p_input -> p -> b_recording)
cond	52:16	52:28	5	p_input -> p -> b_recording
water	52:16	0:0	6	p_input
op	52:23	0:0	6	->
water	52:25	0:0	6	p
op	52:26	0:0	6	->
water	52:28	0:0	6	b_recording
stmts	53:12	56:12	5	
water	53:12	0:0	6	{
call	54:16	54:92	6	msg_Err
arg	54:25	54:32	7	p_input
water	54:25	0:0	8	p_input
arg	54:34	54:92	7	"INPUT_CONTROL_SET_TIME(_OFFSET) ignored while recording"
water	54:34	0:0	8	"INPUT_CONTROL_SET_TIME(_OFFSET) ignored while recording"
water	54:93	0:0	6	;
break	55:16	55:21	6	
water	56:12	0:0	6	}
water	57:12	0:0	4	i_time
op	57:19	0:0	4	=
water	57:21	0:0	4	val
op	57:24	0:0	4	.
water	57:25	0:0	4	i_time
water	57:31	0:0	4	;
if	58:12	59:56	4	(i_type != INPUT_CONTROL_SET_TIME)
cond	58:16	58:26	5	i_type != INPUT_CONTROL_SET_TIME
water	58:16	0:0	6	i_type
op	58:23	0:0	6	!=
water	58:26	0:0	6	INPUT_CONTROL_SET_TIME
stmts	59:16	59:56	5	
water	59:16	0:0	6	i_time
op	59:23	0:0	6	+=
call	59:26	59:55	6	var_GetTime
arg	59:39	59:46	7	p_input
water	59:39	0:0	8	p_input
arg	59:48	59:55	7	"time"
water	59:48	0:0	8	"time"
water	59:56	0:0	6	;
if	60:12	61:26	4	(i_time < 0)
cond	60:16	60:25	5	i_time < 0
water	60:16	0:0	6	i_time
op	60:23	0:0	6	<
water	60:25	0:0	6	0
stmts	61:16	61:26	5	
water	61:16	0:0	6	i_time
op	61:23	0:0	6	=
water	61:25	0:0	6	0
water	61:26	0:0	6	;
call	63:12	63:53	4	es_out_SetTime
arg	63:28	63:48	5	p_input->p->p_es_out
water	63:28	0:0	6	p_input
op	63:35	0:0	6	->
water	63:37	0:0	6	p
op	63:38	0:0	6	->
water	63:40	0:0	6	p_es_out
arg	63:50	63:53	5	-1
op	63:50	0:0	6	-
water	63:51	0:0	6	1
water	63:54	0:0	4	;
water	64:12	0:0	4	i_ret
op	64:18	0:0	4	=
call	64:20	66:60	4	demux_Control
arg	64:35	64:60	5	p_input->p->input.p_demux
water	64:35	0:0	6	p_input
op	64:42	0:0	6	->
water	64:44	0:0	6	p
op	64:45	0:0	6	->
water	64:47	0:0	6	input
op	64:52	0:0	6	.
water	64:53	0:0	6	p_demux
arg	65:35	65:49	5	DEMUX_SET_TIME
water	65:35	0:0	6	DEMUX_SET_TIME
arg	65:51	65:57	5	i_time
water	65:51	0:0	6	i_time
arg	66:35	66:60	5	!p_input->p->b_fast_seek
op	66:35	0:0	6	!
water	66:36	0:0	6	p_input
op	66:43	0:0	6	->
water	66:45	0:0	6	p
op	66:46	0:0	6	->
water	66:48	0:0	6	b_fast_seek
water	66:61	0:0	4	;
if	67:12	79:12	4	(i_ret)
cond	67:16	67:16	5	i_ret
water	67:16	0:0	6	i_ret
stmts	68:12	79:12	5	
water	68:12	0:0	6	{
decl	69:16	69:32	6	int64_t	i_length
if	71:16	78:16	6	(!demux_Control (p_input -> p -> input . p_demux ,DEMUX_GET_LENGTH ,& i_length ) && i_length > 0)
cond	71:20	72:80	7	!demux_Control (p_input -> p -> input . p_demux ,DEMUX_GET_LENGTH ,& i_length ) && i_length > 0
op	71:20	0:0	8	!
call	71:21	72:64	8	demux_Control
arg	71:36	71:61	9	p_input->p->input.p_demux
water	71:36	0:0	10	p_input
op	71:43	0:0	10	->
water	71:45	0:0	10	p
op	71:46	0:0	10	->
water	71:48	0:0	10	input
op	71:53	0:0	10	.
water	71:54	0:0	10	p_demux
arg	72:36	72:52	9	DEMUX_GET_LENGTH
water	72:36	0:0	10	DEMUX_GET_LENGTH
arg	72:54	72:64	9	&i_length
op	72:54	0:0	10	&
water	72:55	0:0	10	i_length
op	72:66	0:0	8	&&
water	72:69	0:0	8	i_length
op	72:78	0:0	8	>
water	72:80	0:0	8	0
stmts	73:16	78:16	7	
water	73:16	0:0	8	{
decl	74:20	74:68	8	double	f_pos
op	74:33	0:0	8	=
water	74:35	0:0	8	(
water	74:36	0:0	8	double
water	74:42	0:0	8	)
water	74:43	0:0	8	i_time
op	74:50	0:0	8	/
water	74:52	0:0	8	(
water	74:53	0:0	8	double
water	74:59	0:0	8	)
water	74:60	0:0	8	i_length
water	75:20	0:0	8	i_ret
op	75:26	0:0	8	=
call	75:28	77:69	8	demux_Control
arg	75:43	75:68	9	p_input->p->input.p_demux
water	75:43	0:0	10	p_input
op	75:50	0:0	10	->
water	75:52	0:0	10	p
op	75:53	0:0	10	->
water	75:55	0:0	10	input
op	75:60	0:0	10	.
water	75:61	0:0	10	p_demux
arg	76:44	76:62	9	DEMUX_SET_POSITION
water	76:44	0:0	10	DEMUX_SET_POSITION
arg	76:64	76:69	9	f_pos
water	76:64	0:0	10	f_pos
arg	77:44	77:69	9	!p_input->p->b_fast_seek
op	77:44	0:0	10	!
water	77:45	0:0	10	p_input
op	77:52	0:0	10	->
water	77:54	0:0	10	p
op	77:55	0:0	10	->
water	77:57	0:0	10	b_fast_seek
water	77:70	0:0	8	;
water	78:16	0:0	8	}
water	79:12	0:0	6	}
if	80:12	84:12	4	(i_ret)
cond	80:16	80:16	5	i_ret
water	80:16	0:0	6	i_ret
stmts	81:12	84:12	5	
water	81:12	0:0	6	{
call	82:16	83:59	6	msg_Warn
arg	82:26	82:33	7	p_input
water	82:26	0:0	8	p_input
arg	82:35	83:50	7	"INPUT_CONTROL_SET_TIME(_OFFSET) %"PRId64" failed or not possible"
water	82:35	0:0	8	"INPUT_CONTROL_SET_TIME(_OFFSET) %"
water	82:70	0:0	8	PRId64
water	83:25	0:0	8	" failed or not possible"
arg	83:52	83:59	7	i_time
water	83:52	0:0	8	i_time
water	83:60	0:0	6	;
water	84:12	0:0	6	}
else	85:12	91:12	4
stmts	86:12	91:12	5	
water	86:12	0:0	6	{
if	87:16	88:40	6	(p_input -> p -> i_slave > 0)
cond	87:20	87:42	7	p_input -> p -> i_slave > 0
water	87:20	0:0	8	p_input
op	87:27	0:0	8	->
water	87:29	0:0	8	p
op	87:30	0:0	8	->
water	87:32	0:0	8	i_slave
op	87:40	0:0	8	>
water	87:42	0:0	8	0
stmts	88:20	88:40	7	
call	88:20	88:39	8	SlaveSeek
arg	88:31	88:39	9	p_input
water	88:31	0:0	10	p_input
water	88:40	0:0	8	;
water	89:16	0:0	6	p_input
op	89:23	0:0	6	->
water	89:25	0:0	6	p
op	89:26	0:0	6	->
water	89:28	0:0	6	input
op	89:33	0:0	6	.
water	89:34	0:0	6	b_eof
op	89:40	0:0	6	=
water	89:42	0:0	6	false
water	89:47	0:0	6	;
water	90:16	0:0	6	b_force_update
op	90:31	0:0	6	=
water	90:33	0:0	6	true
water	90:37	0:0	6	;
water	91:12	0:0	6	}
break	92:12	92:17	4	
water	93:8	0:0	4	}
label	94:8	94:36	4	case INPUT_CONTROL_SET_STATE :
if	95:12	96:78	4	(val . i_int != PLAYING_S && val . i_int != PAUSE_S)
cond	95:16	95:55	5	val . i_int != PLAYING_S && val . i_int != PAUSE_S
water	95:16	0:0	6	val
op	95:19	0:0	6	.
water	95:20	0:0	6	i_int
op	95:26	0:0	6	!=
water	95:29	0:0	6	PLAYING_S
op	95:39	0:0	6	&&
water	95:42	0:0	6	val
op	95:45	0:0	6	.
water	95:46	0:0	6	i_int
op	95:52	0:0	6	!=
water	95:55	0:0	6	PAUSE_S
stmts	96:16	96:78	5	
call	96:16	96:77	6	msg_Err
arg	96:25	96:32	7	p_input
water	96:25	0:0	8	p_input
arg	96:34	96:77	7	"invalid state in INPUT_CONTROL_SET_STATE"
water	96:34	0:0	8	"invalid state in INPUT_CONTROL_SET_STATE"
water	96:78	0:0	6	;
else	97:12	101:12	4
stmts	97:17	101:12	5	
if	97:17	101:12	6	(p_input -> p -> i_state == PAUSE_S)
cond	97:21	97:44	7	p_input -> p -> i_state == PAUSE_S
water	97:21	0:0	8	p_input
op	97:28	0:0	8	->
water	97:30	0:0	8	p
op	97:31	0:0	8	->
water	97:33	0:0	8	i_state
op	97:41	0:0	8	==
water	97:44	0:0	8	PAUSE_S
stmts	98:12	101:12	7	
water	98:12	0:0	8	{
call	99:16	99:56	8	ControlUnpause
arg	99:32	99:39	9	p_input
water	99:32	0:0	10	p_input
arg	99:41	99:56	9	i_control_date
water	99:41	0:0	10	i_control_date
water	99:57	0:0	8	;
water	100:16	0:0	8	b_force_update
op	100:31	0:0	8	=
water	100:33	0:0	8	true
water	100:37	0:0	8	;
water	101:12	0:0	8	}
else	102:12	107:12	4
stmts	102:17	107:12	5	
if	102:17	107:12	6	(val . i_int == PAUSE_S && p_input -> p -> i_state == PLAYING_S)
cond	102:21	102:68	7	val . i_int == PAUSE_S && p_input -> p -> i_state == PLAYING_S
water	102:21	0:0	8	val
op	102:24	0:0	8	.
water	102:25	0:0	8	i_int
op	102:31	0:0	8	==
water	102:34	0:0	8	PAUSE_S
op	102:42	0:0	8	&&
water	102:45	0:0	8	p_input
op	102:52	0:0	8	->
water	102:54	0:0	8	p
op	102:55	0:0	8	->
water	102:57	0:0	8	i_state
op	102:65	0:0	8	==
water	102:68	0:0	8	PLAYING_S
stmts	104:12	107:12	7	
water	104:12	0:0	8	{
call	105:16	105:54	8	ControlPause
arg	105:30	105:37	9	p_input
water	105:30	0:0	10	p_input
arg	105:39	105:54	9	i_control_date
water	105:39	0:0	10	i_control_date
water	105:55	0:0	8	;
water	106:16	0:0	8	b_force_update
op	106:31	0:0	8	=
water	106:33	0:0	8	true
water	106:37	0:0	8	;
water	107:12	0:0	8	}
else	108:12	113:12	4
stmts	108:17	113:12	5	
if	108:17	113:12	6	(val . i_int == PAUSE_S && ! p_input -> p -> b_can_pause && 0)
cond	108:21	108:73	7	val . i_int == PAUSE_S && ! p_input -> p -> b_can_pause && 0
water	108:21	0:0	8	val
op	108:24	0:0	8	.
water	108:25	0:0	8	i_int
op	108:31	0:0	8	==
water	108:34	0:0	8	PAUSE_S
op	108:42	0:0	8	&&
op	108:45	0:0	8	!
water	108:46	0:0	8	p_input
op	108:53	0:0	8	->
water	108:55	0:0	8	p
op	108:56	0:0	8	->
water	108:58	0:0	8	b_can_pause
op	108:70	0:0	8	&&
water	108:73	0:0	8	0
stmts	109:12	113:12	7	
water	109:12	0:0	8	{
water	110:16	0:0	8	b_force_update
op	110:31	0:0	8	=
water	110:33	0:0	8	true
water	110:37	0:0	8	;
call	112:16	112:64	8	input_ChangeState
arg	112:35	112:42	9	p_input
water	112:35	0:0	10	p_input
arg	112:44	112:64	9	p_input->p->i_state
water	112:44	0:0	10	p_input
op	112:51	0:0	10	->
water	112:53	0:0	10	p
op	112:54	0:0	10	->
water	112:56	0:0	10	i_state
water	112:65	0:0	8	;
water	113:12	0:0	8	}
break	114:12	114:17	4	
label	115:8	115:35	4	case INPUT_CONTROL_SET_RATE :
water	116:8	0:0	4	{
decl	118:12	118:41	4	int	i_rate
op	118:23	0:0	4	=
call	118:25	118:40	5	abs
arg	118:30	118:40	6	val.i_int
water	118:30	0:0	7	val
op	118:33	0:0	7	.
water	118:34	0:0	7	i_int
decl	119:12	119:52	4	int	i_rate_sign
op	119:28	0:0	4	=
water	119:30	0:0	4	val
op	119:33	0:0	4	.
water	119:34	0:0	4	i_int
op	119:40	0:0	4	<
water	119:42	0:0	4	0
water	119:44	0:0	4	?
op	119:46	0:0	4	-
water	119:47	0:0	4	1
water	119:49	0:0	4	:
water	119:51	0:0	4	1
if	121:12	125:12	4	(i_rate < INPUT_RATE_MIN)
cond	121:16	121:25	5	i_rate < INPUT_RATE_MIN
water	121:16	0:0	6	i_rate
op	121:23	0:0	6	<
water	121:25	0:0	6	INPUT_RATE_MIN
stmts	122:12	125:12	5	
water	122:12	0:0	6	{
call	123:16	123:59	6	msg_Dbg
arg	123:25	123:32	7	p_input
water	123:25	0:0	8	p_input
arg	123:34	123:59	7	"cannot set rate faster"
water	123:34	0:0	8	"cannot set rate faster"
water	123:60	0:0	6	;
water	124:16	0:0	6	i_rate
op	124:23	0:0	6	=
water	124:25	0:0	6	INPUT_RATE_MIN
water	124:39	0:0	6	;
water	125:12	0:0	6	}
else	126:12	130:12	4
stmts	126:17	130:12	5	
if	126:17	130:12	6	(i_rate > INPUT_RATE_MAX)
cond	126:21	126:30	7	i_rate > INPUT_RATE_MAX
water	126:21	0:0	8	i_rate
op	126:28	0:0	8	>
water	126:30	0:0	8	INPUT_RATE_MAX
stmts	127:12	130:12	7	
water	127:12	0:0	8	{
call	128:16	128:59	8	msg_Dbg
arg	128:25	128:32	9	p_input
water	128:25	0:0	10	p_input
arg	128:34	128:59	9	"cannot set rate slower"
water	128:34	0:0	10	"cannot set rate slower"
water	128:60	0:0	8	;
water	129:16	0:0	8	i_rate
op	129:23	0:0	8	=
water	129:25	0:0	8	INPUT_RATE_MAX
water	129:39	0:0	8	;
water	130:12	0:0	8	}
if	132:12	144:12	4	(i_rate_sign < 0)
cond	132:16	132:30	5	i_rate_sign < 0
water	132:16	0:0	6	i_rate_sign
op	132:28	0:0	6	<
water	132:30	0:0	6	0
stmts	133:12	144:12	5	
water	133:12	0:0	6	{
if	134:16	139:16	6	(p_input -> p -> input . b_rescale_ts)
cond	134:20	134:38	7	p_input -> p -> input . b_rescale_ts
water	134:20	0:0	8	p_input
op	134:27	0:0	8	->
water	134:29	0:0	8	p
op	134:30	0:0	8	->
water	134:32	0:0	8	input
op	134:37	0:0	8	.
water	134:38	0:0	8	b_rescale_ts
stmts	135:16	139:16	7	
water	135:16	0:0	8	{
call	136:20	136:65	8	msg_Dbg
arg	136:29	136:36	9	p_input
water	136:29	0:0	10	p_input
arg	136:38	136:65	9	"cannot set negative rate"
water	136:38	0:0	10	"cannot set negative rate"
water	136:66	0:0	8	;
water	137:20	0:0	8	i_rate
op	137:27	0:0	8	=
water	137:29	0:0	8	p_input
op	137:36	0:0	8	->
water	137:38	0:0	8	p
op	137:39	0:0	8	->
water	137:41	0:0	8	i_rate
water	137:47	0:0	8	;
call	138:20	138:39	8	assert
arg	138:28	138:39	9	i_rate>0
water	138:28	0:0	10	i_rate
op	138:35	0:0	10	>
water	138:37	0:0	10	0
water	138:40	0:0	8	;
water	139:16	0:0	8	}
else	140:16	143:16	6
stmts	141:16	143:16	7	
water	141:16	0:0	8	{
water	142:20	0:0	8	i_rate
op	142:27	0:0	8	*=
water	142:30	0:0	8	i_rate_sign
water	142:41	0:0	8	;
water	143:16	0:0	8	}
water	144:12	0:0	6	}
if	145:12	151:12	4	(i_rate != INPUT_RATE_DEFAULT && ( ( ! p_input -> p -> b_can_rate_control && ! p_input -> p -> input . b_rescale_ts ) || ( p_input -> p -> p_sout && ! p_input -> p -> b_out_pace_control ) ))
cond	145:16	147:76	5	i_rate != INPUT_RATE_DEFAULT && ( ( ! p_input -> p -> b_can_rate_control && ! p_input -> p -> input . b_rescale_ts ) || ( p_input -> p -> p_sout && ! p_input -> p -> b_out_pace_control ) )
water	145:16	0:0	6	i_rate
op	145:23	0:0	6	!=
water	145:26	0:0	6	INPUT_RATE_DEFAULT
op	145:45	0:0	6	&&
water	146:16	0:0	6	(
water	146:18	0:0	6	(
op	146:20	0:0	6	!
water	146:21	0:0	6	p_input
op	146:28	0:0	6	->
water	146:30	0:0	6	p
op	146:31	0:0	6	->
water	146:33	0:0	6	b_can_rate_control
op	146:52	0:0	6	&&
op	146:55	0:0	6	!
water	146:56	0:0	6	p_input
op	146:63	0:0	6	->
water	146:65	0:0	6	p
op	146:66	0:0	6	->
water	146:68	0:0	6	input
op	146:73	0:0	6	.
water	146:74	0:0	6	b_rescale_ts
water	146:87	0:0	6	)
op	146:89	0:0	6	||
water	147:18	0:0	6	(
water	147:20	0:0	6	p_input
op	147:27	0:0	6	->
water	147:29	0:0	6	p
op	147:30	0:0	6	->
water	147:32	0:0	6	p_sout
op	147:39	0:0	6	&&
op	147:42	0:0	6	!
water	147:43	0:0	6	p_input
op	147:50	0:0	6	->
water	147:52	0:0	6	p
op	147:53	0:0	6	->
water	147:55	0:0	6	b_out_pace_control
water	147:74	0:0	6	)
water	147:76	0:0	6	)
stmts	148:12	151:12	5	
water	148:12	0:0	6	{
call	149:16	149:55	6	msg_Dbg
arg	149:25	149:32	7	p_input
water	149:25	0:0	8	p_input
arg	149:34	149:55	7	"cannot change rate"
water	149:34	0:0	8	"cannot change rate"
water	149:56	0:0	6	;
water	150:16	0:0	6	i_rate
op	150:23	0:0	6	=
water	150:25	0:0	6	INPUT_RATE_DEFAULT
water	150:43	0:0	6	;
water	151:12	0:0	6	}
if	152:12	169:12	4	(i_rate != p_input -> p -> i_rate && ! p_input -> p -> b_can_pace_control && p_input -> p -> b_can_rate_control)
cond	152:16	153:63	5	i_rate != p_input -> p -> i_rate && ! p_input -> p -> b_can_pace_control && p_input -> p -> b_can_rate_control
water	152:16	0:0	6	i_rate
op	152:23	0:0	6	!=
water	152:26	0:0	6	p_input
op	152:33	0:0	6	->
water	152:35	0:0	6	p
op	152:36	0:0	6	->
water	152:38	0:0	6	i_rate
op	152:45	0:0	6	&&
op	153:16	0:0	6	!
water	153:17	0:0	6	p_input
op	153:24	0:0	6	->
water	153:26	0:0	6	p
op	153:27	0:0	6	->
water	153:29	0:0	6	b_can_pace_control
op	153:48	0:0	6	&&
water	153:51	0:0	6	p_input
op	153:58	0:0	6	->
water	153:60	0:0	6	p
op	153:61	0:0	6	->
water	153:63	0:0	6	b_can_rate_control
stmts	154:12	169:12	5	
water	154:12	0:0	6	{
decl	155:16	155:60	6	demux_t	*p_demux
op	155:33	0:0	6	=
water	155:35	0:0	6	p_input
op	155:42	0:0	6	->
water	155:44	0:0	6	p
op	155:45	0:0	6	->
water	155:47	0:0	6	input
op	155:52	0:0	6	.
water	155:53	0:0	6	p_demux
decl	156:16	156:40	6	int	i_ret
op	156:26	0:0	6	=
water	156:28	0:0	6	VLC_EGENERIC
if	157:16	163:16	6	(p_demux -> s == NULL)
cond	157:20	157:34	7	p_demux -> s == NULL
water	157:20	0:0	8	p_demux
op	157:27	0:0	8	->
water	157:29	0:0	8	s
op	157:31	0:0	8	==
water	157:34	0:0	8	NULL
stmts	158:16	163:16	7	
water	158:16	0:0	8	{
if	159:20	160:80	8	(! p_input -> p -> input . b_rescale_ts)
cond	159:24	159:43	9	! p_input -> p -> input . b_rescale_ts
op	159:24	0:0	10	!
water	159:25	0:0	10	p_input
op	159:32	0:0	10	->
water	159:34	0:0	10	p
op	159:35	0:0	10	->
water	159:37	0:0	10	input
op	159:42	0:0	10	.
water	159:43	0:0	10	b_rescale_ts
stmts	160:24	160:80	9	
call	160:24	160:79	10	es_out_Control
arg	160:40	160:60	11	p_input->p->p_es_out
water	160:40	0:0	12	p_input
op	160:47	0:0	12	->
water	160:49	0:0	12	p
op	160:50	0:0	12	->
water	160:52	0:0	12	p_es_out
arg	160:62	160:79	11	ES_OUT_RESET_PCR
water	160:62	0:0	12	ES_OUT_RESET_PCR
water	160:80	0:0	10	;
water	161:20	0:0	8	i_ret
op	161:26	0:0	8	=
call	161:28	162:68	8	demux_Control
arg	161:43	161:68	9	p_input->p->input.p_demux
water	161:43	0:0	10	p_input
op	161:50	0:0	10	->
water	161:52	0:0	10	p
op	161:53	0:0	10	->
water	161:55	0:0	10	input
op	161:60	0:0	10	.
water	161:61	0:0	10	p_demux
arg	162:44	162:58	9	DEMUX_SET_RATE
water	162:44	0:0	10	DEMUX_SET_RATE
arg	162:60	162:68	9	&i_rate
op	162:60	0:0	10	&
water	162:61	0:0	10	i_rate
water	162:69	0:0	8	;
water	163:16	0:0	8	}
if	164:16	168:16	6	(i_ret)
cond	164:20	164:20	7	i_ret
water	164:20	0:0	8	i_ret
stmts	165:16	168:16	7	
water	165:16	0:0	8	{
call	166:20	166:70	8	msg_Warn
arg	166:30	166:37	9	p_input
water	166:30	0:0	10	p_input
arg	166:39	166:70	9	"ACCESS/DEMUX_SET_RATE failed"
water	166:39	0:0	10	"ACCESS/DEMUX_SET_RATE failed"
water	166:71	0:0	8	;
water	167:20	0:0	8	i_rate
op	167:27	0:0	8	=
water	167:29	0:0	8	p_input
op	167:36	0:0	8	->
water	167:38	0:0	8	p
op	167:39	0:0	8	->
water	167:41	0:0	8	i_rate
water	167:47	0:0	8	;
water	168:16	0:0	8	}
water	169:12	0:0	6	}
if	171:12	181:12	4	(i_rate != p_input -> p -> i_rate)
cond	171:16	171:38	5	i_rate != p_input -> p -> i_rate
water	171:16	0:0	6	i_rate
op	171:23	0:0	6	!=
water	171:26	0:0	6	p_input
op	171:33	0:0	6	->
water	171:35	0:0	6	p
op	171:36	0:0	6	->
water	171:38	0:0	6	i_rate
stmts	172:12	181:12	5	
water	172:12	0:0	6	{
water	173:16	0:0	6	p_input
op	173:23	0:0	6	->
water	173:25	0:0	6	p
op	173:26	0:0	6	->
water	173:28	0:0	6	i_rate
op	173:35	0:0	6	=
water	173:37	0:0	6	i_rate
water	173:43	0:0	6	;
call	174:16	174:53	6	input_SendEventRate
arg	174:37	174:44	7	p_input
water	174:37	0:0	8	p_input
arg	174:46	174:53	7	i_rate
water	174:46	0:0	8	i_rate
water	174:54	0:0	6	;
if	175:16	179:16	6	(p_input -> p -> input . b_rescale_ts)
cond	175:20	175:38	7	p_input -> p -> input . b_rescale_ts
water	175:20	0:0	8	p_input
op	175:27	0:0	8	->
water	175:29	0:0	8	p
op	175:30	0:0	8	->
water	175:32	0:0	8	input
op	175:37	0:0	8	.
water	175:38	0:0	8	b_rescale_ts
stmts	176:16	179:16	7	
water	176:16	0:0	8	{
decl	177:20	177:143	8	const int	i_rate_source
op	177:44	0:0	8	=
water	177:46	0:0	8	(
water	177:47	0:0	8	p_input
op	177:54	0:0	8	->
water	177:56	0:0	8	p
op	177:57	0:0	8	->
water	177:59	0:0	8	b_can_pace_control
op	177:78	0:0	8	||
water	177:81	0:0	8	p_input
op	177:88	0:0	8	->
water	177:90	0:0	8	p
op	177:91	0:0	8	->
water	177:93	0:0	8	b_can_rate_control
water	177:112	0:0	8	)
water	177:114	0:0	8	?
water	177:116	0:0	8	i_rate
water	177:123	0:0	8	:
water	177:125	0:0	8	INPUT_RATE_DEFAULT
call	178:20	178:80	8	es_out_SetRate
arg	178:36	178:56	9	p_input->p->p_es_out
water	178:36	0:0	10	p_input
op	178:43	0:0	10	->
water	178:45	0:0	10	p
op	178:46	0:0	10	->
water	178:48	0:0	10	p_es_out
arg	178:58	178:71	9	i_rate_source
water	178:58	0:0	10	i_rate_source
arg	178:73	178:80	9	i_rate
water	178:73	0:0	10	i_rate
water	178:81	0:0	8	;
water	179:16	0:0	8	}
water	180:16	0:0	6	b_force_update
op	180:31	0:0	6	=
water	180:33	0:0	6	true
water	180:37	0:0	6	;
water	181:12	0:0	6	}
break	182:12	182:17	4	
water	183:8	0:0	4	}
label	184:8	184:38	4	case INPUT_CONTROL_SET_PROGRAM :
call	186:12	187:56	4	es_out_Control
arg	186:28	186:48	5	p_input->p->p_es_out
water	186:28	0:0	6	p_input
op	186:35	0:0	6	->
water	186:37	0:0	6	p
op	186:38	0:0	6	->
water	186:40	0:0	6	p_es_out
arg	187:28	187:44	5	ES_OUT_SET_GROUP
water	187:28	0:0	6	ES_OUT_SET_GROUP
arg	187:46	187:56	5	val.i_int
water	187:46	0:0	6	val
op	187:49	0:0	6	.
water	187:50	0:0	6	i_int
water	187:57	0:0	4	;
call	188:12	189:33	4	demux_Control
arg	188:27	188:52	5	p_input->p->input.p_demux
water	188:27	0:0	6	p_input
op	188:34	0:0	6	->
water	188:36	0:0	6	p
op	188:37	0:0	6	->
water	188:39	0:0	6	input
op	188:44	0:0	6	.
water	188:45	0:0	6	p_demux
arg	188:54	188:69	5	DEMUX_SET_GROUP
water	188:54	0:0	6	DEMUX_SET_GROUP
arg	188:71	188:80	5	val.i_int
water	188:71	0:0	6	val
op	188:74	0:0	6	.
water	188:75	0:0	6	i_int
arg	189:28	189:33	5	NULL
water	189:28	0:0	6	NULL
water	189:34	0:0	4	;
break	190:12	190:17	4	
label	191:8	191:33	4	case INPUT_CONTROL_SET_ES :
call	193:12	194:64	4	es_out_Control
arg	193:28	193:56	5	p_input->p->p_es_out_display
water	193:28	0:0	6	p_input
op	193:35	0:0	6	->
water	193:37	0:0	6	p
op	193:38	0:0	6	->
water	193:40	0:0	6	p_es_out_display
arg	194:28	194:47	5	ES_OUT_SET_ES_BY_ID
water	194:28	0:0	6	ES_OUT_SET_ES_BY_ID
arg	194:49	194:64	5	(int)val.i_int
water	194:49	0:0	6	(
water	194:50	0:0	6	int
water	194:53	0:0	6	)
water	194:54	0:0	6	val
op	194:57	0:0	6	.
water	194:58	0:0	6	i_int
water	194:65	0:0	4	;
call	195:12	195:83	4	demux_Control
arg	195:27	195:52	5	p_input->p->input.p_demux
water	195:27	0:0	6	p_input
op	195:34	0:0	6	->
water	195:36	0:0	6	p
op	195:37	0:0	6	->
water	195:39	0:0	6	input
op	195:44	0:0	6	.
water	195:45	0:0	6	p_demux
arg	195:54	195:66	5	DEMUX_SET_ES
water	195:54	0:0	6	DEMUX_SET_ES
arg	195:68	195:83	5	(int)val.i_int
water	195:68	0:0	6	(
water	195:69	0:0	6	int
water	195:72	0:0	6	)
water	195:73	0:0	6	val
op	195:76	0:0	6	.
water	195:77	0:0	6	i_int
water	195:84	0:0	4	;
break	196:12	196:17	4	
label	197:8	197:37	4	case INPUT_CONTROL_RESTART_ES :
call	198:12	199:68	4	es_out_Control
arg	198:28	198:56	5	p_input->p->p_es_out_display
water	198:28	0:0	6	p_input
op	198:35	0:0	6	->
water	198:37	0:0	6	p
op	198:38	0:0	6	->
water	198:40	0:0	6	p_es_out_display
arg	199:28	199:51	5	ES_OUT_RESTART_ES_BY_ID
water	199:28	0:0	6	ES_OUT_RESTART_ES_BY_ID
arg	199:53	199:68	5	(int)val.i_int
water	199:53	0:0	6	(
water	199:54	0:0	6	int
water	199:57	0:0	6	)
water	199:58	0:0	6	val
op	199:61	0:0	6	.
water	199:62	0:0	6	i_int
water	199:69	0:0	4	;
break	200:12	200:17	4	
label	201:8	201:42	4	case INPUT_CONTROL_SET_AUDIO_DELAY :
call	202:12	202:59	4	input_SendEventAudioDelay
arg	202:39	202:46	5	p_input
water	202:39	0:0	6	p_input
arg	202:48	202:59	5	val.i_time
water	202:48	0:0	6	val
op	202:51	0:0	6	.
water	202:52	0:0	6	i_time
water	202:60	0:0	4	;
call	203:12	203:36	4	UpdatePtsDelay
arg	203:28	203:36	5	p_input
water	203:28	0:0	6	p_input
water	203:37	0:0	4	;
break	204:12	204:17	4	
label	205:8	205:40	4	case INPUT_CONTROL_SET_SPU_DELAY :
call	206:12	206:62	4	input_SendEventSubtitleDelay
arg	206:42	206:49	5	p_input
water	206:42	0:0	6	p_input
arg	206:51	206:62	5	val.i_time
water	206:51	0:0	6	val
op	206:54	0:0	6	.
water	206:55	0:0	6	i_time
water	206:63	0:0	4	;
call	207:12	207:36	4	UpdatePtsDelay
arg	207:28	207:36	5	p_input
water	207:28	0:0	6	p_input
water	207:37	0:0	4	;
break	208:12	208:17	4	
label	209:8	209:36	4	case INPUT_CONTROL_SET_TITLE :
label	210:8	210:41	4	case INPUT_CONTROL_SET_TITLE_NEXT :
label	211:8	211:41	4	case INPUT_CONTROL_SET_TITLE_PREV :
water	212:8	0:0	4	{
if	213:12	217:12	4	(p_input -> p -> b_recording)
cond	213:16	213:28	5	p_input -> p -> b_recording
water	213:16	0:0	6	p_input
op	213:23	0:0	6	->
water	213:25	0:0	6	p
op	213:26	0:0	6	->
water	213:28	0:0	6	b_recording
stmts	214:12	217:12	5	
water	214:12	0:0	6	{
call	215:16	215:87	6	msg_Err
arg	215:25	215:32	7	p_input
water	215:25	0:0	8	p_input
arg	215:34	215:87	7	"INPUT_CONTROL_SET_TITLE(*) ignored while recording"
water	215:34	0:0	8	"INPUT_CONTROL_SET_TITLE(*) ignored while recording"
water	215:88	0:0	6	;
break	216:16	216:21	6	
water	217:12	0:0	6	}
if	218:12	219:21	4	(p_input -> p -> input . i_title <= 0)
cond	218:16	218:45	5	p_input -> p -> input . i_title <= 0
water	218:16	0:0	6	p_input
op	218:23	0:0	6	->
water	218:25	0:0	6	p
op	218:26	0:0	6	->
water	218:28	0:0	6	input
op	218:33	0:0	6	.
water	218:34	0:0	6	i_title
op	218:42	0:0	6	<=
water	218:45	0:0	6	0
stmts	219:16	219:21	5	
break	219:16	219:21	6	
decl	220:12	220:65	4	int	i_title
op	220:24	0:0	4	=
water	220:26	0:0	4	p_input
op	220:33	0:0	4	->
water	220:35	0:0	4	p
op	220:36	0:0	4	->
water	220:38	0:0	4	input
op	220:43	0:0	4	.
water	220:44	0:0	4	p_demux
op	220:51	0:0	4	->
water	220:53	0:0	4	info
op	220:57	0:0	4	.
water	220:58	0:0	4	i_title
if	221:12	222:25	4	(i_type == INPUT_CONTROL_SET_TITLE_PREV)
cond	221:16	221:26	5	i_type == INPUT_CONTROL_SET_TITLE_PREV
water	221:16	0:0	6	i_type
op	221:23	0:0	6	==
water	221:26	0:0	6	INPUT_CONTROL_SET_TITLE_PREV
stmts	222:16	222:25	5	
water	222:16	0:0	6	i_title
op	222:23	0:0	6	--
water	222:25	0:0	6	;
else	223:12	224:25	4
stmts	223:17	224:25	5	
if	223:17	224:25	6	(i_type == INPUT_CONTROL_SET_TITLE_NEXT)
cond	223:21	223:31	7	i_type == INPUT_CONTROL_SET_TITLE_NEXT
water	223:21	0:0	8	i_type
op	223:28	0:0	8	==
water	223:31	0:0	8	INPUT_CONTROL_SET_TITLE_NEXT
stmts	224:16	224:25	7	
water	224:16	0:0	8	i_title
op	224:23	0:0	8	++
water	224:25	0:0	8	;
else	225:12	226:35	4
stmts	226:16	226:35	5	
water	226:16	0:0	6	i_title
op	226:24	0:0	6	=
water	226:26	0:0	6	val
op	226:29	0:0	6	.
water	226:30	0:0	6	i_int
water	226:35	0:0	6	;
if	227:12	228:21	4	(i_title < 0 || i_title >= p_input -> p -> input . i_title)
cond	227:16	227:60	5	i_title < 0 || i_title >= p_input -> p -> input . i_title
water	227:16	0:0	6	i_title
op	227:24	0:0	6	<
water	227:26	0:0	6	0
op	227:28	0:0	6	||
water	227:31	0:0	6	i_title
op	227:39	0:0	6	>=
water	227:42	0:0	6	p_input
op	227:49	0:0	6	->
water	227:51	0:0	6	p
op	227:52	0:0	6	->
water	227:54	0:0	6	input
op	227:59	0:0	6	.
water	227:60	0:0	6	i_title
stmts	228:16	228:21	5	
break	228:16	228:21	6	
call	229:12	229:53	4	es_out_SetTime
arg	229:28	229:48	5	p_input->p->p_es_out
water	229:28	0:0	6	p_input
op	229:35	0:0	6	->
water	229:37	0:0	6	p
op	229:38	0:0	6	->
water	229:40	0:0	6	p_es_out
arg	229:50	229:53	5	-1
op	229:50	0:0	6	-
water	229:51	0:0	6	1
water	229:54	0:0	4	;
call	230:12	231:52	4	demux_Control
arg	230:27	230:52	5	p_input->p->input.p_demux
water	230:27	0:0	6	p_input
op	230:34	0:0	6	->
water	230:36	0:0	6	p
op	230:37	0:0	6	->
water	230:39	0:0	6	input
op	230:44	0:0	6	.
water	230:45	0:0	6	p_demux
arg	231:27	231:42	5	DEMUX_SET_TITLE
water	231:27	0:0	6	DEMUX_SET_TITLE
arg	231:44	231:52	5	i_title
water	231:44	0:0	6	i_title
water	231:53	0:0	4	;
call	232:12	232:51	4	input_SendEventTitle
arg	232:34	232:41	5	p_input
water	232:34	0:0	6	p_input
arg	232:43	232:51	5	i_title
water	232:43	0:0	6	i_title
water	232:52	0:0	4	;
break	233:12	233:17	4	
water	234:8	0:0	4	}
label	235:8	235:40	4	case INPUT_CONTROL_SET_SEEKPOINT :
label	236:8	236:45	4	case INPUT_CONTROL_SET_SEEKPOINT_NEXT :
label	237:8	237:45	4	case INPUT_CONTROL_SET_SEEKPOINT_PREV :
water	238:8	0:0	4	{
if	239:12	243:12	4	(p_input -> p -> b_recording)
cond	239:16	239:28	5	p_input -> p -> b_recording
water	239:16	0:0	6	p_input
op	239:23	0:0	6	->
water	239:25	0:0	6	p
op	239:26	0:0	6	->
water	239:28	0:0	6	b_recording
stmts	240:12	243:12	5	
water	240:12	0:0	6	{
call	241:16	241:91	6	msg_Err
arg	241:25	241:32	7	p_input
water	241:25	0:0	8	p_input
arg	241:34	241:91	7	"INPUT_CONTROL_SET_SEEKPOINT(*) ignored while recording"
water	241:34	0:0	8	"INPUT_CONTROL_SET_SEEKPOINT(*) ignored while recording"
water	241:92	0:0	6	;
break	242:16	242:21	6	
water	243:12	0:0	6	}
if	244:12	245:21	4	(p_input -> p -> input . i_title <= 0)
cond	244:16	244:45	5	p_input -> p -> input . i_title <= 0
water	244:16	0:0	6	p_input
op	244:23	0:0	6	->
water	244:25	0:0	6	p
op	244:26	0:0	6	->
water	244:28	0:0	6	input
op	244:33	0:0	6	.
water	244:34	0:0	6	i_title
op	244:42	0:0	6	<=
water	244:45	0:0	6	0
stmts	245:16	245:21	5	
break	245:16	245:21	6	
decl	246:12	246:56	4	demux_t	*p_demux
op	246:29	0:0	4	=
water	246:31	0:0	4	p_input
op	246:38	0:0	4	->
water	246:40	0:0	4	p
op	246:41	0:0	4	->
water	246:43	0:0	4	input
op	246:48	0:0	4	.
water	246:49	0:0	4	p_demux
decl	247:12	247:47	4	int	i_title
op	247:24	0:0	4	=
water	247:26	0:0	4	p_demux
op	247:33	0:0	4	->
water	247:35	0:0	4	info
op	247:39	0:0	4	.
water	247:40	0:0	4	i_title
decl	248:12	248:55	4	int	i_seekpoint
op	248:28	0:0	4	=
water	248:30	0:0	4	p_demux
op	248:37	0:0	4	->
water	248:39	0:0	4	info
op	248:43	0:0	4	.
water	248:44	0:0	4	i_seekpoint
if	249:12	260:12	4	(i_type == INPUT_CONTROL_SET_SEEKPOINT_PREV)
cond	249:16	249:26	5	i_type == INPUT_CONTROL_SET_SEEKPOINT_PREV
water	249:16	0:0	6	i_type
op	249:23	0:0	6	==
water	249:26	0:0	6	INPUT_CONTROL_SET_SEEKPOINT_PREV
stmts	250:12	260:12	5	
water	250:12	0:0	6	{
decl	251:16	251:114	6	int64_t	i_seekpoint_time
op	251:41	0:0	6	=
water	251:43	0:0	6	p_input
op	251:50	0:0	6	->
water	251:52	0:0	6	p
op	251:53	0:0	6	->
water	251:55	0:0	6	input
op	251:60	0:0	6	.
water	251:61	0:0	6	title
op	251:66	0:0	6	[
water	251:67	0:0	6	i_title
op	251:74	0:0	6	]
op	251:75	0:0	6	->
water	251:77	0:0	6	seekpoint
op	251:86	0:0	6	[
water	251:87	0:0	6	i_seekpoint
op	251:98	0:0	6	]
op	251:99	0:0	6	->
water	251:101	0:0	6	i_time_offset
decl	252:16	252:69	6	int64_t	i_input_time
op	252:37	0:0	6	=
call	252:39	252:68	7	var_GetTime
arg	252:52	252:59	8	p_input
water	252:52	0:0	9	p_input
arg	252:61	252:68	8	"time"
water	252:61	0:0	9	"time"
if	253:16	257:16	6	(i_seekpoint_time >= 0 && i_input_time >= 0)
cond	253:20	253:61	7	i_seekpoint_time >= 0 && i_input_time >= 0
water	253:20	0:0	8	i_seekpoint_time
op	253:37	0:0	8	>=
water	253:40	0:0	8	0
op	253:42	0:0	8	&&
water	253:45	0:0	8	i_input_time
op	253:58	0:0	8	>=
water	253:61	0:0	8	0
stmts	254:16	257:16	7	
water	254:16	0:0	8	{
if	255:20	256:37	8	(i_input_time < i_seekpoint_time + 3000000)
cond	255:24	255:58	9	i_input_time < i_seekpoint_time + 3000000
water	255:24	0:0	10	i_input_time
op	255:37	0:0	10	<
water	255:39	0:0	10	i_seekpoint_time
op	255:56	0:0	10	+
water	255:58	0:0	10	3000000
stmts	256:24	256:37	9	
water	256:24	0:0	10	i_seekpoint
op	256:35	0:0	10	--
water	256:37	0:0	10	;
water	257:16	0:0	8	}
else	258:16	259:33	6
stmts	259:20	259:33	7	
water	259:20	0:0	8	i_seekpoint
op	259:31	0:0	8	--
water	259:33	0:0	8	;
water	260:12	0:0	6	}
else	261:12	262:29	4
stmts	261:17	262:29	5	
if	261:17	262:29	6	(i_type == INPUT_CONTROL_SET_SEEKPOINT_NEXT)
cond	261:21	261:31	7	i_type == INPUT_CONTROL_SET_SEEKPOINT_NEXT
water	261:21	0:0	8	i_type
op	261:28	0:0	8	==
water	261:31	0:0	8	INPUT_CONTROL_SET_SEEKPOINT_NEXT
stmts	262:16	262:29	7	
water	262:16	0:0	8	i_seekpoint
op	262:27	0:0	8	++
water	262:29	0:0	8	;
else	263:12	264:39	4
stmts	264:16	264:39	5	
water	264:16	0:0	6	i_seekpoint
op	264:28	0:0	6	=
water	264:30	0:0	6	val
op	264:33	0:0	6	.
water	264:34	0:0	6	i_int
water	264:39	0:0	6	;
if	265:12	267:21	4	(i_seekpoint < 0 || i_seekpoint >= p_input -> p -> input . title [ i_title ] -> i_seekpoint)
cond	265:16	266:65	5	i_seekpoint < 0 || i_seekpoint >= p_input -> p -> input . title [ i_title ] -> i_seekpoint
water	265:16	0:0	6	i_seekpoint
op	265:28	0:0	6	<
water	265:30	0:0	6	0
op	266:13	0:0	6	||
water	266:16	0:0	6	i_seekpoint
op	266:28	0:0	6	>=
water	266:31	0:0	6	p_input
op	266:38	0:0	6	->
water	266:40	0:0	6	p
op	266:41	0:0	6	->
water	266:43	0:0	6	input
op	266:48	0:0	6	.
water	266:49	0:0	6	title
op	266:54	0:0	6	[
water	266:55	0:0	6	i_title
op	266:62	0:0	6	]
op	266:63	0:0	6	->
water	266:65	0:0	6	i_seekpoint
stmts	267:16	267:21	5	
break	267:16	267:21	6	
call	268:12	268:53	4	es_out_SetTime
arg	268:28	268:48	5	p_input->p->p_es_out
water	268:28	0:0	6	p_input
op	268:35	0:0	6	->
water	268:37	0:0	6	p
op	268:38	0:0	6	->
water	268:40	0:0	6	p_es_out
arg	268:50	268:53	5	-1
op	268:50	0:0	6	-
water	268:51	0:0	6	1
water	268:54	0:0	4	;
call	269:12	270:60	4	demux_Control
arg	269:27	269:52	5	p_input->p->input.p_demux
water	269:27	0:0	6	p_input
op	269:34	0:0	6	->
water	269:36	0:0	6	p
op	269:37	0:0	6	->
water	269:39	0:0	6	input
op	269:44	0:0	6	.
water	269:45	0:0	6	p_demux
arg	270:27	270:46	5	DEMUX_SET_SEEKPOINT
water	270:27	0:0	6	DEMUX_SET_SEEKPOINT
arg	270:48	270:60	5	i_seekpoint
water	270:48	0:0	6	i_seekpoint
water	270:61	0:0	4	;
call	271:12	271:68	4	input_SendEventSeekpoint
arg	271:38	271:45	5	p_input
water	271:38	0:0	6	p_input
arg	271:47	271:54	5	i_title
water	271:47	0:0	6	i_title
arg	271:56	271:68	5	i_seekpoint
water	271:56	0:0	6	i_seekpoint
water	271:69	0:0	4	;
break	272:12	272:17	4	
water	273:8	0:0	4	}
label	274:8	274:39	4	case INPUT_CONTROL_ADD_SUBTITLE :
if	275:12	276:70	4	(val . psz_string)
cond	275:16	275:20	5	val . psz_string
water	275:16	0:0	6	val
op	275:19	0:0	6	.
water	275:20	0:0	6	psz_string
stmts	276:16	276:70	5	
call	276:16	276:69	6	input_SubtitleFileAdd
arg	276:39	276:46	7	p_input
water	276:39	0:0	8	p_input
arg	276:48	276:62	7	val.psz_string
water	276:48	0:0	8	val
op	276:51	0:0	8	.
water	276:52	0:0	8	psz_string
arg	276:64	276:69	7	true
water	276:64	0:0	8	true
water	276:70	0:0	6	;
break	277:12	277:17	4	
label	278:8	278:36	4	case INPUT_CONTROL_ADD_SLAVE :
if	279:12	314:12	4	(val . psz_string)
cond	279:16	279:20	5	val . psz_string
water	279:16	0:0	6	val
op	279:19	0:0	6	.
water	279:20	0:0	6	psz_string
stmts	280:12	314:12	5	
water	280:12	0:0	6	{
decl	281:16	281:48	6	const char	*uri
op	281:32	0:0	6	=
water	281:34	0:0	6	val
op	281:37	0:0	6	.
water	281:38	0:0	6	psz_string
decl	282:16	282:65	6	input_source_t	*slave
op	282:38	0:0	6	=
call	282:40	282:64	7	InputSourceNew
arg	282:56	282:64	8	p_input
water	282:56	0:0	9	p_input
if	283:16	308:16	6	(slave && !InputSourceInit (p_input ,slave ,uri ,NULL ,false ))
cond	283:20	283:80	7	slave && !InputSourceInit (p_input ,slave ,uri ,NULL ,false )
water	283:20	0:0	8	slave
op	283:26	0:0	8	&&
op	283:29	0:0	8	!
call	283:30	283:80	8	InputSourceInit
arg	283:47	283:54	9	p_input
water	283:47	0:0	10	p_input
arg	283:56	283:61	9	slave
water	283:56	0:0	10	slave
arg	283:63	283:66	9	uri
water	283:63	0:0	10	uri
arg	283:68	283:72	9	NULL
water	283:68	0:0	10	NULL
arg	283:74	283:80	9	false
water	283:74	0:0	10	false
stmts	284:16	308:16	7	
water	284:16	0:0	8	{
decl	285:20	285:34	8	int64_t	i_time
call	287:20	287:75	8	msg_Dbg
arg	287:29	287:36	9	p_input
water	287:29	0:0	10	p_input
arg	287:38	287:69	9	"adding %s as slave on the fly"
water	287:38	0:0	10	"adding %s as slave on the fly"
arg	287:71	287:75	9	uri
water	287:71	0:0	10	uri
water	287:76	0:0	8	;
if	289:20	296:20	8	(demux_Control (p_input -> p -> input . p_demux ,DEMUX_GET_TIME ,& i_time ))
cond	289:24	290:64	9	demux_Control (p_input -> p -> input . p_demux ,DEMUX_GET_TIME ,& i_time )
call	289:24	290:64	10	demux_Control
arg	289:39	289:64	11	p_input->p->input.p_demux
water	289:39	0:0	12	p_input
op	289:46	0:0	12	->
water	289:48	0:0	12	p
op	289:49	0:0	12	->
water	289:51	0:0	12	input
op	289:56	0:0	12	.
water	289:57	0:0	12	p_demux
arg	290:40	290:54	11	DEMUX_GET_TIME
water	290:40	0:0	12	DEMUX_GET_TIME
arg	290:56	290:64	11	&i_time
op	290:56	0:0	12	&
water	290:57	0:0	12	i_time
stmts	291:20	296:20	9	
water	291:20	0:0	10	{
call	292:24	292:78	10	msg_Err
arg	292:33	292:40	11	p_input
water	292:33	0:0	12	p_input
arg	292:42	292:78	11	"demux doesn't like DEMUX_GET_TIME"
water	292:42	0:0	12	"demux doesn't like DEMUX_GET_TIME"
water	292:79	0:0	10	;
call	293:24	293:48	10	InputSourceClean
arg	293:42	293:48	11	slave
water	293:42	0:0	12	slave
water	293:49	0:0	10	;
call	294:24	294:36	10	free
arg	294:30	294:36	11	slave
water	294:30	0:0	12	slave
water	294:37	0:0	10	;
break	295:24	295:29	10	
water	296:20	0:0	10	}
if	297:20	304:20	8	(demux_Control (slave -> p_demux ,DEMUX_SET_TIME ,i_time ,true ))
cond	297:24	298:68	9	demux_Control (slave -> p_demux ,DEMUX_SET_TIME ,i_time ,true )
call	297:24	298:68	10	demux_Control
arg	297:39	297:53	11	slave->p_demux
water	297:39	0:0	12	slave
op	297:44	0:0	12	->
water	297:46	0:0	12	p_demux
arg	298:39	298:53	11	DEMUX_SET_TIME
water	298:39	0:0	12	DEMUX_SET_TIME
arg	298:55	298:61	11	i_time
water	298:55	0:0	12	i_time
arg	298:63	298:68	11	true
water	298:63	0:0	12	true
stmts	299:20	304:20	9	
water	299:20	0:0	10	{
call	300:24	300:70	10	msg_Err
arg	300:33	300:40	11	p_input
water	300:33	0:0	12	p_input
arg	300:42	300:70	11	"seek failed for new slave"
water	300:42	0:0	12	"seek failed for new slave"
water	300:71	0:0	10	;
call	301:24	301:48	10	InputSourceClean
arg	301:42	301:48	11	slave
water	301:42	0:0	12	slave
water	301:49	0:0	10	;
call	302:24	302:36	10	free
arg	302:30	302:36	11	slave
water	302:30	0:0	12	slave
water	302:37	0:0	10	;
break	303:24	303:29	10	
water	304:20	0:0	10	}
call	306:20	306:61	8	InputUpdateMeta
arg	306:37	306:44	9	p_input
water	306:37	0:0	10	p_input
arg	306:46	306:61	9	slave->p_demux
water	306:46	0:0	10	slave
op	306:51	0:0	10	->
water	306:53	0:0	10	p_demux
water	306:62	0:0	8	;
call	307:20	307:78	8	TAB_APPEND
arg	307:32	307:51	9	p_input->p->i_slave
water	307:32	0:0	10	p_input
op	307:39	0:0	10	->
water	307:41	0:0	10	p
op	307:42	0:0	10	->
water	307:44	0:0	10	i_slave
arg	307:53	307:70	9	p_input->p->slave
water	307:53	0:0	10	p_input
op	307:60	0:0	10	->
water	307:62	0:0	10	p
op	307:63	0:0	10	->
water	307:65	0:0	10	slave
arg	307:72	307:78	9	slave
water	307:72	0:0	10	slave
water	307:79	0:0	8	;
water	308:16	0:0	8	}
else	309:16	313:16	6
stmts	310:16	313:16	7	
water	310:16	0:0	8	{
call	311:20	311:32	8	free
arg	311:26	311:32	9	slave
water	311:26	0:0	10	slave
water	311:33	0:0	8	;
call	312:20	312:72	8	msg_Warn
arg	312:30	312:37	9	p_input
water	312:30	0:0	10	p_input
arg	312:39	312:66	9	"failed to add %s as slave"
water	312:39	0:0	10	"failed to add %s as slave"
arg	312:68	312:72	9	uri
water	312:68	0:0	10	uri
water	312:73	0:0	8	;
water	313:16	0:0	8	}
water	314:12	0:0	6	}
break	315:12	315:17	4	
label	316:8	316:43	4	case INPUT_CONTROL_SET_RECORD_STATE :
if	317:12	333:12	4	(! ! p_input -> p -> b_recording != ! ! val . b_bool)
cond	317:16	317:51	5	! ! p_input -> p -> b_recording != ! ! val . b_bool
op	317:16	0:0	6	!
op	317:17	0:0	6	!
water	317:18	0:0	6	p_input
op	317:25	0:0	6	->
water	317:27	0:0	6	p
op	317:28	0:0	6	->
water	317:30	0:0	6	b_recording
op	317:42	0:0	6	!=
op	317:45	0:0	6	!
op	317:46	0:0	6	!
water	317:47	0:0	6	val
op	317:50	0:0	6	.
water	317:51	0:0	6	b_bool
stmts	318:12	333:12	5	
water	318:12	0:0	6	{
if	319:16	324:16	6	(p_input -> p -> input . b_can_stream_record)
cond	319:20	319:38	7	p_input -> p -> input . b_can_stream_record
water	319:20	0:0	8	p_input
op	319:27	0:0	8	->
water	319:29	0:0	8	p
op	319:30	0:0	8	->
water	319:32	0:0	8	input
op	319:37	0:0	8	.
water	319:38	0:0	8	b_can_stream_record
stmts	320:16	324:16	7	
water	320:16	0:0	8	{
if	321:20	323:42	8	(demux_Control (p_input -> p -> input . p_demux ,DEMUX_SET_RECORD_STATE ,val . b_bool ))
cond	321:24	322:74	9	demux_Control (p_input -> p -> input . p_demux ,DEMUX_SET_RECORD_STATE ,val . b_bool )
call	321:24	322:74	10	demux_Control
arg	321:39	321:64	11	p_input->p->input.p_demux
water	321:39	0:0	12	p_input
op	321:46	0:0	12	->
water	321:48	0:0	12	p
op	321:49	0:0	12	->
water	321:51	0:0	12	input
op	321:56	0:0	12	.
water	321:57	0:0	12	p_demux
arg	322:39	322:61	11	DEMUX_SET_RECORD_STATE
water	322:39	0:0	12	DEMUX_SET_RECORD_STATE
arg	322:63	322:74	11	val.b_bool
water	322:63	0:0	12	val
op	322:66	0:0	12	.
water	322:67	0:0	12	b_bool
stmts	323:24	323:42	9	
water	323:24	0:0	10	val
op	323:27	0:0	10	.
water	323:28	0:0	10	b_bool
op	323:35	0:0	10	=
water	323:37	0:0	10	false
water	323:42	0:0	10	;
water	324:16	0:0	8	}
else	325:16	329:16	6
stmts	326:16	329:16	7	
water	326:16	0:0	8	{
if	327:20	328:42	8	(es_out_SetRecordState (p_input -> p -> p_es_out_display ,val . b_bool ))
cond	327:24	327:88	9	es_out_SetRecordState (p_input -> p -> p_es_out_display ,val . b_bool )
call	327:24	327:88	10	es_out_SetRecordState
arg	327:47	327:75	11	p_input->p->p_es_out_display
water	327:47	0:0	12	p_input
op	327:54	0:0	12	->
water	327:56	0:0	12	p
op	327:57	0:0	12	->
water	327:59	0:0	12	p_es_out_display
arg	327:77	327:88	11	val.b_bool
water	327:77	0:0	12	val
op	327:80	0:0	12	.
water	327:81	0:0	12	b_bool
stmts	328:24	328:42	9	
water	328:24	0:0	10	val
op	328:27	0:0	10	.
water	328:28	0:0	10	b_bool
op	328:35	0:0	10	=
water	328:37	0:0	10	false
water	328:42	0:0	10	;
water	329:16	0:0	8	}
water	330:16	0:0	6	p_input
op	330:23	0:0	6	->
water	330:25	0:0	6	p
op	330:26	0:0	6	->
water	330:28	0:0	6	b_recording
op	330:40	0:0	6	=
water	330:42	0:0	6	val
op	330:45	0:0	6	.
water	330:46	0:0	6	b_bool
water	330:52	0:0	6	;
call	331:16	331:59	6	input_SendEventRecord
arg	331:39	331:46	7	p_input
water	331:39	0:0	8	p_input
arg	331:48	331:59	7	val.b_bool
water	331:48	0:0	8	val
op	331:51	0:0	8	.
water	331:52	0:0	8	b_bool
water	331:60	0:0	6	;
water	332:16	0:0	6	b_force_update
op	332:31	0:0	6	=
water	332:33	0:0	6	true
water	332:37	0:0	6	;
water	333:12	0:0	6	}
break	334:12	334:17	4	
label	335:8	335:41	4	case INPUT_CONTROL_SET_FRAME_NEXT :
if	336:12	339:12	4	(p_input -> p -> i_state == PAUSE_S)
cond	336:16	336:39	5	p_input -> p -> i_state == PAUSE_S
water	336:16	0:0	6	p_input
op	336:23	0:0	6	->
water	336:25	0:0	6	p
op	336:26	0:0	6	->
water	336:28	0:0	6	i_state
op	336:36	0:0	6	==
water	336:39	0:0	6	PAUSE_S
stmts	337:12	339:12	5	
water	337:12	0:0	6	{
call	338:16	338:58	6	es_out_SetFrameNext
arg	338:37	338:58	7	p_input->p->p_es_out
water	338:37	0:0	8	p_input
op	338:44	0:0	8	->
water	338:46	0:0	8	p
op	338:47	0:0	8	->
water	338:49	0:0	8	p_es_out
water	338:59	0:0	6	;
water	339:12	0:0	6	}
else	340:12	343:12	4
stmts	340:17	343:12	5	
if	340:17	343:12	6	(p_input -> p -> i_state == PLAYING_S)
cond	340:21	340:44	7	p_input -> p -> i_state == PLAYING_S
water	340:21	0:0	8	p_input
op	340:28	0:0	8	->
water	340:30	0:0	8	p
op	340:31	0:0	8	->
water	340:33	0:0	8	i_state
op	340:41	0:0	8	==
water	340:44	0:0	8	PLAYING_S
stmts	341:12	343:12	7	
water	341:12	0:0	8	{
call	342:16	342:54	8	ControlPause
arg	342:30	342:37	9	p_input
water	342:30	0:0	10	p_input
arg	342:39	342:54	9	i_control_date
water	342:39	0:0	10	i_control_date
water	342:55	0:0	8	;
water	343:12	0:0	8	}
else	344:12	347:12	4
stmts	345:12	347:12	5	
water	345:12	0:0	6	{
call	346:16	346:65	6	msg_Err
arg	346:25	346:32	7	p_input
water	346:25	0:0	8	p_input
arg	346:34	346:65	7	"invalid state for frame next"
water	346:34	0:0	8	"invalid state for frame next"
water	346:66	0:0	6	;
water	347:12	0:0	6	}
water	348:12	0:0	4	b_force_update
op	348:27	0:0	4	=
water	348:29	0:0	4	true
water	348:33	0:0	4	;
break	349:12	349:17	4	
label	350:8	350:39	4	case INPUT_CONTROL_SET_BOOKMARK :
water	351:8	0:0	4	{
decl	352:12	352:36	4	mtime_t	time_offset
op	352:32	0:0	4	=
op	352:34	0:0	4	-
water	352:35	0:0	4	1
call	353:12	353:54	4	vlc_mutex_lock
arg	353:28	353:54	5	&p_input->p->p_item->lock
op	353:28	0:0	6	&
water	353:29	0:0	6	p_input
op	353:36	0:0	6	->
water	353:38	0:0	6	p
op	353:39	0:0	6	->
water	353:41	0:0	6	p_item
op	353:47	0:0	6	->
water	353:49	0:0	6	lock
water	353:55	0:0	4	;
if	354:12	358:12	4	(val . i_int >= 0 && val . i_int < p_input -> p -> i_bookmark)
cond	354:16	354:58	5	val . i_int >= 0 && val . i_int < p_input -> p -> i_bookmark
water	354:16	0:0	6	val
op	354:19	0:0	6	.
water	354:20	0:0	6	i_int
op	354:26	0:0	6	>=
water	354:29	0:0	6	0
op	354:31	0:0	6	&&
water	354:34	0:0	6	val
op	354:37	0:0	6	.
water	354:38	0:0	6	i_int
op	354:44	0:0	6	<
water	354:46	0:0	6	p_input
op	354:53	0:0	6	->
water	354:55	0:0	6	p
op	354:56	0:0	6	->
water	354:58	0:0	6	i_bookmark
stmts	355:12	358:12	5	
water	355:12	0:0	6	{
decl	356:16	356:82	6	const seekpoint_t	*p_bookmark
op	356:46	0:0	6	=
water	356:48	0:0	6	p_input
op	356:55	0:0	6	->
water	356:57	0:0	6	p
op	356:58	0:0	6	->
water	356:60	0:0	6	pp_bookmark
op	356:71	0:0	6	[
water	356:72	0:0	6	val
op	356:75	0:0	6	.
water	356:76	0:0	6	i_int
op	356:81	0:0	6	]
water	357:16	0:0	6	time_offset
op	357:28	0:0	6	=
water	357:30	0:0	6	p_bookmark
op	357:40	0:0	6	->
water	357:42	0:0	6	i_time_offset
water	357:55	0:0	6	;
water	358:12	0:0	6	}
call	359:12	359:56	4	vlc_mutex_unlock
arg	359:30	359:56	5	&p_input->p->p_item->lock
op	359:30	0:0	6	&
water	359:31	0:0	6	p_input
op	359:38	0:0	6	->
water	359:40	0:0	6	p
op	359:41	0:0	6	->
water	359:43	0:0	6	p_item
op	359:49	0:0	6	->
water	359:51	0:0	6	lock
water	359:57	0:0	4	;
if	360:12	364:12	4	(time_offset < 0)
cond	360:16	360:30	5	time_offset < 0
water	360:16	0:0	6	time_offset
op	360:28	0:0	6	<
water	360:30	0:0	6	0
stmts	361:12	364:12	5	
water	361:12	0:0	6	{
call	362:16	362:72	6	msg_Err
arg	362:25	362:32	7	p_input
water	362:25	0:0	8	p_input
arg	362:34	362:60	7	"invalid bookmark %"PRId64
water	362:34	0:0	8	"invalid bookmark %"
water	362:54	0:0	8	PRId64
arg	362:62	362:72	7	val.i_int
water	362:62	0:0	8	val
op	362:65	0:0	8	.
water	362:66	0:0	8	i_int
water	362:73	0:0	6	;
break	363:16	363:21	6	
water	364:12	0:0	6	}
water	365:12	0:0	4	val
op	365:15	0:0	4	.
water	365:16	0:0	4	i_time
op	365:23	0:0	4	=
water	365:25	0:0	4	time_offset
water	365:36	0:0	4	;
water	366:12	0:0	4	b_force_update
op	366:27	0:0	4	=
call	366:29	366:75	4	Control
arg	366:38	366:45	5	p_input
water	366:38	0:0	6	p_input
arg	366:47	366:69	5	INPUT_CONTROL_SET_TIME
water	366:47	0:0	6	INPUT_CONTROL_SET_TIME
arg	366:71	366:75	5	val
water	366:71	0:0	6	val
water	366:76	0:0	4	;
break	367:12	367:17	4	
water	368:8	0:0	4	}
label	369:8	369:39	4	case INPUT_CONTROL_NAV_ACTIVATE :
label	370:8	370:33	4	case INPUT_CONTROL_NAV_UP :
label	371:8	371:35	4	case INPUT_CONTROL_NAV_DOWN :
label	372:8	372:35	4	case INPUT_CONTROL_NAV_LEFT :
label	373:8	373:36	4	case INPUT_CONTROL_NAV_RIGHT :
call	374:12	375:77	4	demux_Control
arg	374:27	374:52	5	p_input->p->input.p_demux
water	374:27	0:0	6	p_input
op	374:34	0:0	6	->
water	374:36	0:0	6	p
op	374:37	0:0	6	->
water	374:39	0:0	6	input
op	374:44	0:0	6	.
water	374:45	0:0	6	p_demux
arg	374:54	375:77	5	i_type-INPUT_CONTROL_NAV_ACTIVATE+DEMUX_NAV_ACTIVATE
water	374:54	0:0	6	i_type
op	375:27	0:0	6	-
water	375:29	0:0	6	INPUT_CONTROL_NAV_ACTIVATE
op	375:56	0:0	6	+
water	375:58	0:0	6	DEMUX_NAV_ACTIVATE
water	375:78	0:0	4	;
break	376:12	376:17	4	
label	377:8	377:15	4	default :
call	378:12	378:52	4	msg_Err
arg	378:21	378:28	5	p_input
water	378:21	0:0	6	p_input
arg	378:30	378:52	5	"not yet implemented"
water	378:30	0:0	6	"not yet implemented"
water	378:53	0:0	4	;
break	379:12	379:17	4	
water	380:4	0:0	4	}
call	381:4	381:32	2	ControlRelease
arg	381:20	381:26	3	i_type
water	381:20	0:0	4	i_type
arg	381:28	381:32	3	val
water	381:28	0:0	4	val
water	381:33	0:0	2	;
return	382:4	382:25	2	b_force_update
water	382:11	0:0	3	b_force_update
