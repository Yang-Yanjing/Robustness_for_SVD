func	2:0	42:0	0	playlist_item_t *	GetNextItem
params	2:28	0:0	1	
param	2:30	2:52	2	playlist_t *	p_playlist
param	3:30	3:53	2	playlist_item_t *	p_root
param	4:30	4:54	2	playlist_item_t *	p_item
stmnts	7:4	41:15	1	
if	7:4	13:4	2	(p_item == NULL)
cond	7:8	7:18	3	p_item == NULL
water	7:8	0:0	4	p_item
op	7:15	0:0	4	==
water	7:18	0:0	4	NULL
stmts	8:4	13:4	3	
water	8:4	0:0	4	{
if	9:8	10:41	4	(p_root -> i_children > 0)
cond	9:12	9:33	5	p_root -> i_children > 0
water	9:12	0:0	6	p_root
op	9:18	0:0	6	->
water	9:20	0:0	6	i_children
op	9:31	0:0	6	>
water	9:33	0:0	6	0
stmts	10:12	10:41	5	
return	10:12	10:41	6	p_root->pp_children[0]
water	10:19	0:0	7	p_root
op	10:25	0:0	7	->
water	10:27	0:0	7	pp_children
op	10:38	0:0	7	[
water	10:39	0:0	7	0
op	10:40	0:0	7	]
else	11:8	12:23	4
stmts	12:12	12:23	5	
return	12:12	12:23	6	NULL
water	12:19	0:0	7	NULL
water	13:4	0:0	4	}
if	15:4	16:37	2	(p_item -> i_children > 0)
cond	15:8	15:29	3	p_item -> i_children > 0
water	15:8	0:0	4	p_item
op	15:14	0:0	4	->
water	15:16	0:0	4	i_children
op	15:27	0:0	4	>
water	15:29	0:0	4	0
stmts	16:8	16:37	3	
return	16:8	16:37	4	p_item->pp_children[0]
water	16:15	0:0	5	p_item
op	16:21	0:0	5	->
water	16:23	0:0	5	pp_children
op	16:34	0:0	5	[
water	16:35	0:0	5	0
op	16:36	0:0	5	]
decl	17:4	17:48	2	playlist_item_t	*p_parent
op	17:30	0:0	2	=
water	17:32	0:0	2	p_item
op	17:38	0:0	2	->
water	17:40	0:0	2	p_parent
for	18:4	40:4	2	( int i = 0 ;i < p_parent -> i_children;i ++)
forinit	0:0	18:19	3	 int i = 0 ;
decl	18:9	18:19	4	int	i
op	18:15	0:0	4	=
water	18:17	0:0	4	0
cond	18:21	18:35	3	i < p_parent -> i_children
water	18:21	0:0	4	i
op	18:23	0:0	4	<
water	18:25	0:0	4	p_parent
op	18:33	0:0	4	->
water	18:35	0:0	4	i_children
forexpr	18:48	18:49	3	i ++
water	18:48	0:0	4	i
op	18:49	0:0	4	++
stmts	19:4	40:4	3	
water	19:4	0:0	4	{
if	20:8	39:8	4	(p_parent -> pp_children [ i ] == p_item)
cond	20:12	20:40	5	p_parent -> pp_children [ i ] == p_item
water	20:12	0:0	6	p_parent
op	20:20	0:0	6	->
water	20:22	0:0	6	pp_children
op	20:33	0:0	6	[
water	20:34	0:0	6	i
op	20:35	0:0	6	]
op	20:37	0:0	6	==
water	20:40	0:0	6	p_item
stmts	21:8	39:8	5	
water	21:8	0:0	6	{
if	23:12	24:49	6	(i + 1 < p_parent -> i_children)
cond	23:16	23:34	7	i + 1 < p_parent -> i_children
water	23:16	0:0	8	i
op	23:18	0:0	8	+
water	23:20	0:0	8	1
op	23:22	0:0	8	<
water	23:24	0:0	8	p_parent
op	23:32	0:0	8	->
water	23:34	0:0	8	i_children
stmts	24:16	24:49	7	
return	24:16	24:49	8	p_parent->pp_children[i+1]
water	24:23	0:0	9	p_parent
op	24:31	0:0	9	->
water	24:33	0:0	9	pp_children
op	24:44	0:0	9	[
water	24:45	0:0	9	i
op	24:46	0:0	9	+
water	24:47	0:0	9	1
op	24:48	0:0	9	]
else	26:12	38:12	6
stmts	27:12	38:12	7	
water	27:12	0:0	8	{
call	28:16	30:56	8	PL_DEBUG2
arg	28:27	29:54	9	"Current item is the last of the node,""looking for uncle from %s"
water	28:27	0:0	10	"Current item is the last of the node,"
water	29:27	0:0	10	"looking for uncle from %s"
arg	30:28	30:56	9	p_parent->p_input->psz_name
water	30:28	0:0	10	p_parent
op	30:36	0:0	10	->
water	30:38	0:0	10	p_input
op	30:45	0:0	10	->
water	30:47	0:0	10	psz_name
water	30:57	0:0	8	;
if	31:16	35:16	8	(p_parent == p_root)
cond	31:20	31:32	9	p_parent == p_root
water	31:20	0:0	10	p_parent
op	31:29	0:0	10	==
water	31:32	0:0	10	p_root
stmts	32:16	35:16	9	
water	32:16	0:0	10	{
call	33:20	33:49	10	PL_DEBUG2
arg	33:31	33:49	11	"already at root"
water	33:31	0:0	12	"already at root"
water	33:50	0:0	10	;
return	34:20	34:31	10	NULL
water	34:27	0:0	11	NULL
water	35:16	0:0	10	}
else	36:16	37:69	8
stmts	37:20	37:69	9	
return	37:20	37:69	10	GetNextUncle(p_playlist,p_item,p_root)
call	37:27	37:68	11	GetNextUncle
arg	37:41	37:51	12	p_playlist
water	37:41	0:0	13	p_playlist
arg	37:53	37:59	12	p_item
water	37:53	0:0	13	p_item
arg	37:61	37:68	12	p_root
water	37:61	0:0	13	p_root
water	38:12	0:0	8	}
water	39:8	0:0	6	}
water	40:4	0:0	4	}
return	41:4	41:15	2	NULL
water	41:11	0:0	3	NULL
