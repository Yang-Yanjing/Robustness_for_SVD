func	1:0	72:0	0	bool	vcdplayer_play_next
params	2:19	0:0	1	
param	2:21	2:41	2	access_t *	p_access
stmnts	0:0	71:20	1	
decl	4:2	4:58	2	vcdplayer_t	*p_vcdplayer
op	4:26	0:0	2	=
water	4:28	0:0	2	(
water	4:29	0:0	2	vcdplayer_t
op	4:41	0:0	2	*
water	4:42	0:0	2	)
water	4:43	0:0	2	p_access
op	4:51	0:0	2	->
water	4:53	0:0	2	p_sys
decl	5:2	5:30	2	vcdinfo_obj_t	*p_vcdinfo
decl	6:2	6:27	2	vcdinfo_itemid_t	itemid
if	7:2	7:32	2	(! p_vcdplayer)
cond	7:6	7:7	3	! p_vcdplayer
op	7:6	0:0	4	!
water	7:7	0:0	4	p_vcdplayer
stmts	7:20	7:32	3	
return	7:20	7:32	4	false
water	7:27	0:0	5	false
call	8:2	9:51	2	dbg_print
arg	8:13	8:43	3	(INPUT_DBG_CALL|INPUT_DBG_PBC)
water	8:13	0:0	4	(
water	8:14	0:0	4	INPUT_DBG_CALL
op	8:28	0:0	4	|
water	8:29	0:0	4	INPUT_DBG_PBC
water	8:42	0:0	4	)
arg	9:9	9:23	3	"current: %d"
water	9:9	0:0	4	"current: %d"
arg	9:25	9:51	3	p_vcdplayer->play_item.num
water	9:25	0:0	4	p_vcdplayer
op	9:36	0:0	4	->
water	9:38	0:0	4	play_item
op	9:47	0:0	4	.
water	9:48	0:0	4	num
water	9:52	0:0	2	;
water	10:2	0:0	2	p_vcdinfo
op	10:12	0:0	2	=
water	10:14	0:0	2	p_vcdplayer
op	10:25	0:0	2	->
water	10:27	0:0	2	vcd
water	10:30	0:0	2	;
water	11:2	0:0	2	itemid
op	11:9	0:0	2	=
water	11:11	0:0	2	p_vcdplayer
op	11:22	0:0	2	->
water	11:24	0:0	2	play_item
water	11:33	0:0	2	;
if	12:2	35:2	2	(vcdplayer_pbc_is_on (p_vcdplayer ))
cond	12:7	12:38	3	vcdplayer_pbc_is_on (p_vcdplayer )
call	12:7	12:38	4	vcdplayer_pbc_is_on
arg	12:27	12:38	5	p_vcdplayer
water	12:27	0:0	6	p_vcdplayer
stmts	12:41	35:2	3	
water	12:41	0:0	4	{
call	13:4	13:74	4	vcdinfo_lid_get_pxd
arg	13:24	13:33	5	p_vcdinfo
water	13:24	0:0	6	p_vcdinfo
arg	13:35	13:54	5	&(p_vcdplayer->pxd)
op	13:35	0:0	6	&
water	13:36	0:0	6	(
water	13:37	0:0	6	p_vcdplayer
op	13:48	0:0	6	->
water	13:50	0:0	6	pxd
water	13:53	0:0	6	)
arg	13:56	13:74	5	p_vcdplayer->i_lid
water	13:56	0:0	6	p_vcdplayer
op	13:67	0:0	6	->
water	13:69	0:0	6	i_lid
water	13:75	0:0	4	;
switch	14:4	34:4	4	(p_vcdplayer -> pxd . descriptor_type)
cond	14:12	14:29	5	p_vcdplayer -> pxd . descriptor_type
water	14:12	0:0	6	p_vcdplayer
op	14:23	0:0	6	->
water	14:25	0:0	6	pxd
op	14:28	0:0	6	.
water	14:29	0:0	6	descriptor_type
stmts	14:46	34:4	5	
water	14:46	0:0	6	{
label	15:4	15:32	6	case PSD_TYPE_SELECTION_LIST :
label	16:4	16:36	6	case PSD_TYPE_EXT_SELECTION_LIST :
if	17:6	17:52	6	(p_vcdplayer -> pxd . psd == NULL)
cond	17:10	17:34	7	p_vcdplayer -> pxd . psd == NULL
water	17:10	0:0	8	p_vcdplayer
op	17:21	0:0	8	->
water	17:23	0:0	8	pxd
op	17:26	0:0	8	.
water	17:27	0:0	8	psd
op	17:31	0:0	8	==
water	17:34	0:0	8	NULL
stmts	17:40	17:52	7	
return	17:40	17:52	8	false
water	17:47	0:0	9	false
call	18:6	20:48	6	vcdplayer_update_entry
arg	18:29	18:37	7	p_access
water	18:29	0:0	8	p_access
arg	19:29	19:77	7	vcdinf_psd_get_next_offset(p_vcdplayer->pxd.psd)
call	19:29	19:76	8	vcdinf_psd_get_next_offset
arg	19:56	19:76	9	p_vcdplayer->pxd.psd
water	19:56	0:0	10	p_vcdplayer
op	19:67	0:0	10	->
water	19:69	0:0	10	pxd
op	19:72	0:0	10	.
water	19:73	0:0	10	psd
arg	20:29	20:40	7	&itemid.num
op	20:29	0:0	8	&
water	20:30	0:0	8	itemid
op	20:36	0:0	8	.
water	20:37	0:0	8	num
arg	20:42	20:48	7	"next"
water	20:42	0:0	8	"next"
water	20:49	0:0	6	;
water	21:6	0:0	6	itemid
op	21:12	0:0	6	.
water	21:13	0:0	6	type
op	21:18	0:0	6	=
water	21:20	0:0	6	VCDINFO_ITEM_TYPE_LID
water	21:41	0:0	6	;
break	22:6	22:11	6	
label	23:4	23:27	6	case PSD_TYPE_PLAY_LIST :
if	24:6	24:52	6	(p_vcdplayer -> pxd . pld == NULL)
cond	24:10	24:34	7	p_vcdplayer -> pxd . pld == NULL
water	24:10	0:0	8	p_vcdplayer
op	24:21	0:0	8	->
water	24:23	0:0	8	pxd
op	24:26	0:0	8	.
water	24:27	0:0	8	pld
op	24:31	0:0	8	==
water	24:34	0:0	8	NULL
stmts	24:40	24:52	7	
return	24:40	24:52	8	false
water	24:47	0:0	9	false
call	25:6	27:48	6	vcdplayer_update_entry
arg	25:29	25:37	7	p_access
water	25:29	0:0	8	p_access
arg	26:29	26:77	7	vcdinf_pld_get_next_offset(p_vcdplayer->pxd.pld)
call	26:29	26:76	8	vcdinf_pld_get_next_offset
arg	26:56	26:76	9	p_vcdplayer->pxd.pld
water	26:56	0:0	10	p_vcdplayer
op	26:67	0:0	10	->
water	26:69	0:0	10	pxd
op	26:72	0:0	10	.
water	26:73	0:0	10	pld
arg	27:29	27:40	7	&itemid.num
op	27:29	0:0	8	&
water	27:30	0:0	8	itemid
op	27:36	0:0	8	.
water	27:37	0:0	8	num
arg	27:42	27:48	7	"next"
water	27:42	0:0	8	"next"
water	27:49	0:0	6	;
water	28:6	0:0	6	itemid
op	28:12	0:0	6	.
water	28:13	0:0	6	type
op	28:18	0:0	6	=
water	28:20	0:0	6	VCDINFO_ITEM_TYPE_LID
water	28:41	0:0	6	;
break	29:6	29:11	6	
label	30:4	30:26	6	case PSD_TYPE_END_LIST :
label	31:4	31:30	6	case PSD_TYPE_COMMAND_LIST :
call	32:6	32:56	6	LOG_WARN
arg	32:16	32:56	7	"There is no PBC 'next' selection here"
water	32:16	0:0	8	"There is no PBC 'next' selection here"
water	32:57	0:0	6	;
return	33:6	33:18	6	false
water	33:13	0:0	7	false
water	34:4	0:0	6	}
water	35:2	0:0	4	}
else	35:4	68:2	2
stmts	35:9	68:2	3	
water	35:9	0:0	4	{
decl	37:4	37:21	4	int	max_entry
op	37:18	0:0	4	=
water	37:20	0:0	4	0
switch	38:4	67:4	4	(p_vcdplayer -> play_item . type)
cond	38:12	38:35	5	p_vcdplayer -> play_item . type
water	38:12	0:0	6	p_vcdplayer
op	38:23	0:0	6	->
water	38:25	0:0	6	play_item
op	38:34	0:0	6	.
water	38:35	0:0	6	type
stmts	38:41	67:4	5	
water	38:41	0:0	6	{
label	39:4	39:32	6	case VCDINFO_ITEM_TYPE_ENTRY :
label	40:4	40:34	6	case VCDINFO_ITEM_TYPE_SEGMENT :
label	41:4	41:32	6	case VCDINFO_ITEM_TYPE_TRACK :
switch	42:6	53:6	6	(p_vcdplayer -> play_item . type)
cond	42:14	42:37	7	p_vcdplayer -> play_item . type
water	42:14	0:0	8	p_vcdplayer
op	42:25	0:0	8	->
water	42:27	0:0	8	play_item
op	42:36	0:0	8	.
water	42:37	0:0	8	type
stmts	42:43	53:6	7	
water	42:43	0:0	8	{
label	43:6	43:34	8	case VCDINFO_ITEM_TYPE_ENTRY :
water	44:8	0:0	8	max_entry
op	44:18	0:0	8	=
water	44:20	0:0	8	p_vcdplayer
op	44:31	0:0	8	->
water	44:33	0:0	8	i_entries
water	44:42	0:0	8	;
break	45:8	45:13	8	
label	46:6	46:36	8	case VCDINFO_ITEM_TYPE_SEGMENT :
water	47:8	0:0	8	max_entry
op	47:18	0:0	8	=
water	47:20	0:0	8	p_vcdplayer
op	47:31	0:0	8	->
water	47:33	0:0	8	i_segments
water	47:43	0:0	8	;
break	48:8	48:13	8	
label	49:6	49:34	8	case VCDINFO_ITEM_TYPE_TRACK :
water	50:8	0:0	8	max_entry
op	50:18	0:0	8	=
water	50:20	0:0	8	p_vcdplayer
op	50:31	0:0	8	->
water	50:33	0:0	8	i_tracks
water	50:41	0:0	8	;
break	51:8	51:13	8	
label	52:6	52:13	8	default :
water	52:15	0:0	8	;
water	53:6	0:0	8	}
if	54:6	56:6	6	(p_vcdplayer -> play_item . num + 1 < max_entry)
cond	54:10	54:41	7	p_vcdplayer -> play_item . num + 1 < max_entry
water	54:10	0:0	8	p_vcdplayer
op	54:21	0:0	8	->
water	54:23	0:0	8	play_item
op	54:32	0:0	8	.
water	54:33	0:0	8	num
op	54:36	0:0	8	+
water	54:37	0:0	8	1
op	54:39	0:0	8	<
water	54:41	0:0	8	max_entry
stmts	54:52	56:6	7	
water	54:52	0:0	8	{
water	55:8	0:0	8	itemid
op	55:14	0:0	8	.
water	55:15	0:0	8	num
op	55:19	0:0	8	=
water	55:21	0:0	8	p_vcdplayer
op	55:32	0:0	8	->
water	55:34	0:0	8	play_item
op	55:43	0:0	8	.
water	55:44	0:0	8	num
op	55:47	0:0	8	+
water	55:48	0:0	8	1
water	55:49	0:0	8	;
water	56:6	0:0	8	}
else	56:8	59:6	6
stmts	56:13	59:6	7	
water	56:13	0:0	8	{
call	57:8	57:66	8	LOG_WARN
arg	57:18	57:66	9	"At the end - non-PBC 'next' not possible here"
water	57:18	0:0	10	"At the end - non-PBC 'next' not possible here"
water	57:67	0:0	8	;
return	58:8	58:20	8	false
water	58:15	0:0	9	false
water	59:6	0:0	8	}
break	60:6	60:11	6	
label	61:4	61:30	6	case VCDINFO_ITEM_TYPE_LID :
call	63:6	63:72	6	LOG_WARN
arg	63:16	63:72	7	"Internal inconsistency - should not have gotten here."
water	63:16	0:0	8	"Internal inconsistency - should not have gotten here."
water	63:73	0:0	6	;
return	64:6	64:18	6	false
water	64:13	0:0	7	false
label	65:4	65:11	6	default :
return	66:6	66:18	6	false
water	66:13	0:0	7	false
water	67:4	0:0	6	}
water	68:2	0:0	4	}
call	70:2	70:35	2	vcdplayer_play
arg	70:18	70:26	3	p_access
water	70:18	0:0	4	p_access
arg	70:28	70:35	3	itemid
water	70:28	0:0	4	itemid
water	70:36	0:0	2	;
return	71:2	71:20	2	VLC_SUCCESS
water	71:9	0:0	3	VLC_SUCCESS
