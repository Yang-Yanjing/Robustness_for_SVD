func	2:0	86:0	0	int	wma_decode_superframe_frame
params	2:31	0:0	1	
param	2:32	2:51	2	WMADecodeContext *	s
param	3:32	3:48	2	int32_t *	samples
param	4:32	4:44	2	uint8_t *	buf
param	5:32	5:44	2	int	buf_size
stmnts	0:0	85:13	1	
decl	7:4	7:16	2	int	pos
water	7:11	0:0	2	,
decl	7:4	7:16	2	int	len
decl	8:4	8:14	2	uint8_t	*q
decl	9:4	9:16	2	int	done
op	9:13	0:0	2	=
water	9:15	0:0	2	0
if	10:4	54:4	2	(( s -> use_bit_reservoir ) && ( s -> current_frame == 0 ))
cond	10:8	10:56	3	( s -> use_bit_reservoir ) && ( s -> current_frame == 0 )
water	10:8	0:0	4	(
water	10:9	0:0	4	s
op	10:10	0:0	4	->
water	10:12	0:0	4	use_bit_reservoir
water	10:29	0:0	4	)
op	10:31	0:0	4	&&
water	10:34	0:0	4	(
water	10:35	0:0	4	s
op	10:36	0:0	4	->
water	10:38	0:0	4	current_frame
op	10:52	0:0	4	==
water	10:55	0:0	4	0
water	10:56	0:0	4	)
stmts	11:4	54:4	3	
water	11:4	0:0	4	{
if	12:8	46:8	4	(s -> last_superframe_len > 0)
cond	12:12	12:37	5	s -> last_superframe_len > 0
water	12:12	0:0	6	s
op	12:13	0:0	6	->
water	12:15	0:0	6	last_superframe_len
op	12:35	0:0	6	>
water	12:37	0:0	6	0
stmts	13:8	46:8	5	
water	13:8	0:0	6	{
if	15:12	22:12	6	(( s -> last_superframe_len + ( ( s -> bit_offset + 7 ) >> 3 ) ) > MAX_CODED_SUPERFRAME_SIZE)
cond	15:16	16:20	7	( s -> last_superframe_len + ( ( s -> bit_offset + 7 ) >> 3 ) ) > MAX_CODED_SUPERFRAME_SIZE
water	15:16	0:0	8	(
water	15:17	0:0	8	s
op	15:18	0:0	8	->
water	15:20	0:0	8	last_superframe_len
op	15:40	0:0	8	+
water	15:42	0:0	8	(
water	15:43	0:0	8	(
water	15:44	0:0	8	s
op	15:45	0:0	8	->
water	15:47	0:0	8	bit_offset
op	15:58	0:0	8	+
water	15:60	0:0	8	7
water	15:61	0:0	8	)
op	15:63	0:0	8	>>
water	15:66	0:0	8	3
water	15:67	0:0	8	)
water	15:68	0:0	8	)
op	15:70	0:0	8	>
water	16:20	0:0	8	MAX_CODED_SUPERFRAME_SIZE
stmts	17:12	22:12	7	
water	17:12	0:0	8	{
call	19:16	19:58	8	printf
arg	19:23	19:58	9	"superframe size too large error\n"
water	19:23	0:0	10	"superframe size too large error\n"
water	19:59	0:0	8	;
goto	21:16	21:25	8	fail
water	21:21	0:0	9	fail
water	22:12	0:0	8	}
water	23:12	0:0	6	q
op	23:14	0:0	6	=
water	23:16	0:0	6	s
op	23:17	0:0	6	->
water	23:19	0:0	6	last_superframe
op	23:35	0:0	6	+
water	23:37	0:0	6	s
op	23:38	0:0	6	->
water	23:40	0:0	6	last_superframe_len
water	23:59	0:0	6	;
water	24:12	0:0	6	len
op	24:16	0:0	6	=
water	24:18	0:0	6	s
op	24:19	0:0	6	->
water	24:21	0:0	6	bit_offset
water	24:31	0:0	6	;
while	25:12	29:12	6	(len > 0)
cond	25:19	25:25	7	len > 0
water	25:19	0:0	8	len
op	25:23	0:0	8	>
water	25:25	0:0	8	0
stmts	26:12	29:12	7	
water	26:12	0:0	8	{
op	27:16	0:0	8	*
water	27:17	0:0	8	q
op	27:18	0:0	8	++
op	27:21	0:0	8	=
call	27:23	27:43	8	(get_bits)
arg	27:34	27:40	9	&s->gb
op	27:34	0:0	10	&
water	27:35	0:0	10	s
op	27:36	0:0	10	->
water	27:38	0:0	10	gb
arg	27:42	27:43	9	8
water	27:42	0:0	10	8
water	27:44	0:0	8	;
water	28:16	0:0	8	len
op	28:20	0:0	8	-=
water	28:23	0:0	8	8
water	28:24	0:0	8	;
water	29:12	0:0	8	}
if	30:12	33:12	6	(len > 0)
cond	30:16	30:22	7	len > 0
water	30:16	0:0	8	len
op	30:20	0:0	8	>
water	30:22	0:0	8	0
stmts	31:12	33:12	7	
water	31:12	0:0	8	{
op	32:16	0:0	8	*
water	32:17	0:0	8	q
op	32:18	0:0	8	++
op	32:21	0:0	8	=
call	32:23	32:45	8	(get_bits)
arg	32:34	32:40	9	&s->gb
op	32:34	0:0	10	&
water	32:35	0:0	10	s
op	32:36	0:0	10	->
water	32:38	0:0	10	gb
arg	32:42	32:45	9	len
water	32:42	0:0	10	len
op	32:47	0:0	8	<<
water	32:50	0:0	8	(
water	32:51	0:0	8	8
op	32:53	0:0	8	-
water	32:55	0:0	8	len
water	32:58	0:0	8	)
water	32:59	0:0	8	;
water	33:12	0:0	8	}
call	35:12	35:81	6	init_get_bits
arg	35:26	35:32	7	&s->gb
op	35:26	0:0	8	&
water	35:27	0:0	8	s
op	35:28	0:0	8	->
water	35:30	0:0	8	gb
arg	35:34	35:52	7	s->last_superframe
water	35:34	0:0	8	s
op	35:35	0:0	8	->
water	35:37	0:0	8	last_superframe
arg	35:54	35:81	7	MAX_CODED_SUPERFRAME_SIZE*8
water	35:54	0:0	8	MAX_CODED_SUPERFRAME_SIZE
op	35:79	0:0	8	*
water	35:80	0:0	8	8
water	35:82	0:0	6	;
if	37:12	38:52	6	(s -> last_bitoffset > 0)
cond	37:16	37:36	7	s -> last_bitoffset > 0
water	37:16	0:0	8	s
op	37:17	0:0	8	->
water	37:19	0:0	8	last_bitoffset
op	37:34	0:0	8	>
water	37:36	0:0	8	0
stmts	38:16	38:52	7	
call	38:16	38:51	8	skip_bits
arg	38:26	38:32	9	&s->gb
op	38:26	0:0	10	&
water	38:27	0:0	10	s
op	38:28	0:0	10	->
water	38:30	0:0	10	gb
arg	38:34	38:51	9	s->last_bitoffset
water	38:34	0:0	10	s
op	38:35	0:0	10	->
water	38:37	0:0	10	last_bitoffset
water	38:52	0:0	8	;
if	41:12	44:12	6	(wma_decode_frame (s ,samples ) < 0)
cond	41:16	41:47	7	wma_decode_frame (s ,samples ) < 0
call	41:16	41:43	8	wma_decode_frame
arg	41:33	41:34	9	s
water	41:33	0:0	10	s
arg	41:36	41:43	9	samples
water	41:36	0:0	10	samples
op	41:45	0:0	8	<
water	41:47	0:0	8	0
stmts	42:12	44:12	7	
water	42:12	0:0	8	{
goto	43:16	43:25	8	fail
water	43:21	0:0	9	fail
water	44:12	0:0	8	}
water	45:12	0:0	6	done
op	45:17	0:0	6	=
water	45:19	0:0	6	1
water	45:20	0:0	6	;
water	46:8	0:0	6	}
water	48:8	0:0	4	pos
op	48:12	0:0	4	=
water	48:14	0:0	4	s
op	48:15	0:0	4	->
water	48:17	0:0	4	bit_offset
op	48:28	0:0	4	+
water	48:30	0:0	4	4
op	48:32	0:0	4	+
water	48:34	0:0	4	4
op	48:36	0:0	4	+
water	48:38	0:0	4	s
op	48:39	0:0	4	->
water	48:41	0:0	4	byte_offset_bits
op	48:58	0:0	4	+
water	48:60	0:0	4	3
water	48:61	0:0	4	;
call	49:8	49:90	4	init_get_bits
arg	49:22	49:28	5	&s->gb
op	49:22	0:0	6	&
water	49:23	0:0	6	s
op	49:24	0:0	6	->
water	49:26	0:0	6	gb
arg	49:30	49:46	5	buf+(pos>>3)
water	49:30	0:0	6	buf
op	49:34	0:0	6	+
water	49:36	0:0	6	(
water	49:37	0:0	6	pos
op	49:41	0:0	6	>>
water	49:44	0:0	6	3
water	49:45	0:0	6	)
arg	49:48	49:90	5	(MAX_CODED_SUPERFRAME_SIZE-(pos>>3))*8
water	49:48	0:0	6	(
water	49:49	0:0	6	MAX_CODED_SUPERFRAME_SIZE
op	49:75	0:0	6	-
water	49:77	0:0	6	(
water	49:78	0:0	6	pos
op	49:82	0:0	6	>>
water	49:85	0:0	6	3
water	49:86	0:0	6	)
water	49:87	0:0	6	)
op	49:88	0:0	6	*
water	49:89	0:0	6	8
water	49:91	0:0	4	;
water	50:8	0:0	4	len
op	50:12	0:0	4	=
water	50:14	0:0	4	pos
op	50:18	0:0	4	&
water	50:20	0:0	4	7
water	50:21	0:0	4	;
if	51:8	52:34	4	(len > 0)
cond	51:12	51:18	5	len > 0
water	51:12	0:0	6	len
op	51:16	0:0	6	>
water	51:18	0:0	6	0
stmts	52:12	52:34	5	
call	52:12	52:33	6	skip_bits
arg	52:22	52:28	7	&s->gb
op	52:22	0:0	8	&
water	52:23	0:0	8	s
op	52:24	0:0	8	->
water	52:26	0:0	8	gb
arg	52:30	52:33	7	len
water	52:30	0:0	8	len
water	52:34	0:0	6	;
water	53:8	0:0	4	s
op	53:9	0:0	4	->
water	53:11	0:0	4	reset_block_lengths
op	53:31	0:0	4	=
water	53:33	0:0	4	1
water	53:34	0:0	4	;
water	54:4	0:0	4	}
if	56:4	62:8	2	(! done)
cond	56:8	56:9	3	! done
op	56:8	0:0	4	!
water	56:9	0:0	4	done
stmts	57:8	62:8	3	
water	57:8	0:0	4	{
if	58:12	61:12	4	(wma_decode_frame (s ,samples ) < 0)
cond	58:16	58:47	5	wma_decode_frame (s ,samples ) < 0
call	58:16	58:43	6	wma_decode_frame
arg	58:33	58:34	7	s
water	58:33	0:0	8	s
arg	58:36	58:43	7	samples
water	58:36	0:0	8	samples
op	58:45	0:0	6	<
water	58:47	0:0	6	0
stmts	59:12	61:12	5	
water	59:12	0:0	6	{
goto	60:16	60:25	6	fail
water	60:21	0:0	7	fail
water	61:12	0:0	6	}
water	62:8	0:0	4	}
water	63:4	0:0	2	s
op	63:5	0:0	2	->
water	63:7	0:0	2	current_frame
op	63:20	0:0	2	++
water	63:22	0:0	2	;
if	64:4	80:4	2	(( s -> use_bit_reservoir ) && ( s -> current_frame == s -> nb_frames ))
cond	64:8	64:67	3	( s -> use_bit_reservoir ) && ( s -> current_frame == s -> nb_frames )
water	64:8	0:0	4	(
water	64:9	0:0	4	s
op	64:10	0:0	4	->
water	64:12	0:0	4	use_bit_reservoir
water	64:29	0:0	4	)
op	64:31	0:0	4	&&
water	64:34	0:0	4	(
water	64:35	0:0	4	s
op	64:36	0:0	4	->
water	64:38	0:0	4	current_frame
op	64:52	0:0	4	==
water	64:55	0:0	4	s
op	64:56	0:0	4	->
water	64:58	0:0	4	nb_frames
water	64:67	0:0	4	)
stmts	65:4	80:4	3	
water	65:4	0:0	4	{
water	67:8	0:0	4	pos
op	67:12	0:0	4	=
call	67:14	67:35	4	get_bits_count
arg	67:29	67:35	5	&s->gb
op	67:29	0:0	6	&
water	67:30	0:0	6	s
op	67:31	0:0	6	->
water	67:33	0:0	6	gb
op	67:37	0:0	4	+
water	67:39	0:0	4	(
water	67:40	0:0	4	(
water	67:41	0:0	4	s
op	67:42	0:0	4	->
water	67:44	0:0	4	bit_offset
op	67:55	0:0	4	+
water	67:57	0:0	4	4
op	67:59	0:0	4	+
water	67:61	0:0	4	4
op	67:63	0:0	4	+
water	67:65	0:0	4	s
op	67:66	0:0	4	->
water	67:68	0:0	4	byte_offset_bits
op	67:85	0:0	4	+
water	67:87	0:0	4	3
water	67:88	0:0	4	)
op	67:90	0:0	4	&
water	67:92	0:0	4	~7
water	67:94	0:0	4	)
water	67:95	0:0	4	;
water	68:8	0:0	4	s
op	68:9	0:0	4	->
water	68:11	0:0	4	last_bitoffset
op	68:26	0:0	4	=
water	68:28	0:0	4	pos
op	68:32	0:0	4	&
water	68:34	0:0	4	7
water	68:35	0:0	4	;
water	69:8	0:0	4	pos
op	69:12	0:0	4	>>=
water	69:16	0:0	4	3
water	69:17	0:0	4	;
water	70:8	0:0	4	len
op	70:12	0:0	4	=
water	70:14	0:0	4	buf_size
op	70:23	0:0	4	-
water	70:25	0:0	4	pos
water	70:28	0:0	4	;
if	71:8	77:8	4	(len > MAX_CODED_SUPERFRAME_SIZE || len < 0)
cond	71:12	71:53	5	len > MAX_CODED_SUPERFRAME_SIZE || len < 0
water	71:12	0:0	6	len
op	71:16	0:0	6	>
water	71:18	0:0	6	MAX_CODED_SUPERFRAME_SIZE
op	71:44	0:0	6	||
water	71:47	0:0	6	len
op	71:51	0:0	6	<
water	71:53	0:0	6	0
stmts	72:8	77:8	5	
water	72:8	0:0	6	{
call	74:12	74:70	6	printf
arg	74:19	74:70	7	"superframe size too large error after decodeing\n"
water	74:19	0:0	8	"superframe size too large error after decodeing\n"
water	74:71	0:0	6	;
goto	76:12	76:21	6	fail
water	76:17	0:0	7	fail
water	77:8	0:0	6	}
water	78:8	0:0	4	s
op	78:9	0:0	4	->
water	78:11	0:0	4	last_superframe_len
op	78:31	0:0	4	=
water	78:33	0:0	4	len
water	78:36	0:0	4	;
call	79:8	79:49	4	memcpy
arg	79:15	79:33	5	s->last_superframe
water	79:15	0:0	6	s
op	79:16	0:0	6	->
water	79:18	0:0	6	last_superframe
arg	79:35	79:44	5	buf+pos
water	79:35	0:0	6	buf
op	79:39	0:0	6	+
water	79:41	0:0	6	pos
arg	79:46	79:49	5	len
water	79:46	0:0	6	len
water	79:50	0:0	4	;
water	80:4	0:0	4	}
return	81:4	81:23	2	s->frame_len
water	81:11	0:0	3	s
op	81:12	0:0	3	->
water	81:14	0:0	3	frame_len
label	82:0	82:4	2	fail :
water	84:4	0:0	2	s
op	84:5	0:0	2	->
water	84:7	0:0	2	last_superframe_len
op	84:27	0:0	2	=
water	84:29	0:0	2	0
water	84:30	0:0	2	;
return	85:4	85:13	2	-1
op	85:11	0:0	3	-
water	85:12	0:0	3	1
