func	1:0	27:0	0	void	libvlc_event_async_fini
params	2:23	0:0	1	
param	2:24	2:53	2	libvlc_event_manager_t *	p_em
stmnts	4:4	26:21	1	
if	4:4	4:42	2	(!is_queue_initialized (p_em ))
cond	4:7	4:33	3	!is_queue_initialized (p_em )
op	4:7	0:0	4	!
call	4:8	4:33	4	is_queue_initialized
arg	4:29	4:33	5	p_em
water	4:29	0:0	6	p_em
stmts	4:36	4:42	3	
return	4:36	4:42	4	
if	5:4	9:4	2	(current_thread_is_asynch_thread (p_em ))
cond	5:7	5:43	3	current_thread_is_asynch_thread (p_em )
call	5:7	5:43	4	current_thread_is_asynch_thread
arg	5:39	5:43	5	p_em
water	5:39	0:0	6	p_em
stmts	6:4	9:4	3	
water	6:4	0:0	4	{
call	7:8	7:139	4	fprintf
arg	7:16	7:22	5	stderr
water	7:16	0:0	6	stderr
arg	7:24	7:139	5	"*** Error: releasing the last reference of the observed object from its callback thread is not (yet!) supported\n"
water	7:24	0:0	6	"*** Error: releasing the last reference of the observed object from its callback thread is not (yet!) supported\n"
water	7:140	0:0	4	;
call	8:8	8:14	4	abort
water	8:15	0:0	4	;
water	9:4	0:0	4	}
decl	10:4	10:45	2	vlc_thread_t	thread
op	10:24	0:0	2	=
call	10:26	10:36	3	queue
arg	10:32	10:36	4	p_em
water	10:32	0:0	5	p_em
op	10:37	0:0	2	->
water	10:39	0:0	2	thread
if	11:4	15:4	2	(thread)
cond	11:7	11:7	3	thread
water	11:7	0:0	4	thread
stmts	12:4	15:4	3	
water	12:4	0:0	4	{
call	13:8	13:25	4	vlc_cancel
arg	13:19	13:25	5	thread
water	13:19	0:0	6	thread
water	13:26	0:0	4	;
call	14:8	14:29	4	vlc_join
arg	14:17	14:23	5	thread
water	14:17	0:0	6	thread
arg	14:25	14:29	5	NULL
water	14:25	0:0	6	NULL
water	14:30	0:0	4	;
water	15:4	0:0	4	}
call	16:4	16:40	2	vlc_mutex_destroy
arg	16:22	16:40	3	&queue(p_em)->lock
call	16:22	16:33	4	&queue
arg	16:29	16:33	5	p_em
water	16:29	0:0	6	p_em
op	16:34	0:0	4	->
water	16:36	0:0	4	lock
water	16:41	0:0	2	;
call	17:4	17:41	2	vlc_cond_destroy
arg	17:21	17:41	3	&queue(p_em)->signal
call	17:21	17:32	4	&queue
arg	17:28	17:32	5	p_em
water	17:28	0:0	6	p_em
op	17:33	0:0	4	->
water	17:35	0:0	4	signal
water	17:42	0:0	2	;
call	18:4	18:46	2	vlc_cond_destroy
arg	18:21	18:46	3	&queue(p_em)->signal_idle
call	18:21	18:32	4	&queue
arg	18:28	18:32	5	p_em
water	18:28	0:0	6	p_em
op	18:33	0:0	4	->
water	18:35	0:0	4	signal_idle
water	18:47	0:0	2	;
call	19:4	19:68	2	vlc_threadvar_delete
arg	19:25	19:68	3	&queue(p_em)->is_asynch_dispatch_thread_var
call	19:25	19:36	4	&queue
arg	19:32	19:36	5	p_em
water	19:32	0:0	6	p_em
op	19:37	0:0	4	->
water	19:39	0:0	4	is_asynch_dispatch_thread_var
water	19:69	0:0	2	;
decl	20:4	20:54	2	struct queue_elmt	*iter
op	20:29	0:0	2	=
call	20:31	20:41	3	queue
arg	20:37	20:41	4	p_em
water	20:37	0:0	5	p_em
op	20:42	0:0	2	->
water	20:44	0:0	2	first_elmt
while	21:4	25:4	2	(iter)
cond	21:11	21:11	3	iter
water	21:11	0:0	4	iter
stmts	21:17	25:4	3	
water	21:17	0:0	4	{
decl	22:8	22:50	4	struct queue_elmt	*elemt_to_delete
op	22:44	0:0	4	=
water	22:46	0:0	4	iter
water	23:8	0:0	4	iter
op	23:13	0:0	4	=
water	23:15	0:0	4	iter
op	23:19	0:0	4	->
water	23:21	0:0	4	next
water	23:25	0:0	4	;
call	24:8	24:28	4	free
arg	24:13	24:28	5	elemt_to_delete
water	24:13	0:0	6	elemt_to_delete
water	24:29	0:0	4	;
water	25:4	0:0	4	}
call	26:4	26:20	2	free
arg	26:9	26:20	3	queue(p_em)
call	26:9	26:19	4	queue
arg	26:15	26:19	5	p_em
water	26:15	0:0	6	p_em
water	26:21	0:0	2	;
