func	2:0	39:0	0	int	puzzle_allocate_ps_pieces
params	2:29	0:0	1	
param	2:31	2:49	2	filter_t *	p_filter
stmnts	0:0	38:22	1	
decl	4:4	4:41	2	filter_sys_t	*p_sys
op	4:24	0:0	2	=
water	4:26	0:0	2	p_filter
op	4:34	0:0	2	->
water	4:36	0:0	2	p_sys
call	5:4	5:34	2	puzzle_free_ps_pieces
arg	5:26	5:34	3	p_filter
water	5:26	0:0	4	p_filter
water	5:35	0:0	2	;
water	6:4	0:0	2	p_sys
op	6:9	0:0	2	->
water	6:11	0:0	2	s_allocated
op	6:22	0:0	2	.
water	6:23	0:0	2	i_pieces_nbr
op	6:36	0:0	2	=
water	6:38	0:0	2	p_sys
op	6:43	0:0	2	->
water	6:45	0:0	2	s_allocated
op	6:56	0:0	2	.
water	6:57	0:0	2	i_rows
op	6:64	0:0	2	*
water	6:66	0:0	2	p_sys
op	6:71	0:0	2	->
water	6:73	0:0	2	s_allocated
op	6:84	0:0	2	.
water	6:85	0:0	2	i_cols
water	6:91	0:0	2	;
water	7:4	0:0	2	p_sys
op	7:9	0:0	2	->
water	7:11	0:0	2	ps_pieces
op	7:21	0:0	2	=
call	7:23	7:82	2	malloc
arg	7:31	7:82	3	sizeof(piece_t)*p_sys->s_allocated.i_pieces_nbr
op	7:31	0:0	4	sizeof
water	7:37	0:0	4	(
water	7:39	0:0	4	piece_t
water	7:46	0:0	4	)
op	7:48	0:0	4	*
water	7:50	0:0	4	p_sys
op	7:55	0:0	4	->
water	7:57	0:0	4	s_allocated
op	7:68	0:0	4	.
water	7:69	0:0	4	i_pieces_nbr
water	7:83	0:0	2	;
if	8:4	9:25	2	(! p_sys -> ps_pieces)
cond	8:8	8:16	3	! p_sys -> ps_pieces
op	8:8	0:0	4	!
water	8:9	0:0	4	p_sys
op	8:14	0:0	4	->
water	8:16	0:0	4	ps_pieces
stmts	9:8	9:25	3	
return	9:8	9:25	4	VLC_ENOMEM
water	9:15	0:0	5	VLC_ENOMEM
for	10:4	19:4	2	( uint32_t p = 0 ;p < p_sys -> s_allocated . i_pieces_nbr;p ++)
forinit	0:0	10:23	3	 uint32_t p = 0 ;
decl	10:9	10:23	4	uint32_t	p
op	10:20	0:0	4	=
water	10:22	0:0	4	0
cond	10:25	10:48	3	p < p_sys -> s_allocated . i_pieces_nbr
water	10:25	0:0	4	p
op	10:27	0:0	4	<
water	10:29	0:0	4	p_sys
op	10:34	0:0	4	->
water	10:36	0:0	4	s_allocated
op	10:47	0:0	4	.
water	10:48	0:0	4	i_pieces_nbr
forexpr	10:62	10:63	3	p ++
water	10:62	0:0	4	p
op	10:63	0:0	4	++
stmts	10:67	19:4	3	
water	10:67	0:0	4	{
water	11:8	0:0	4	p_sys
op	11:13	0:0	4	->
water	11:15	0:0	4	ps_pieces
op	11:24	0:0	4	[
water	11:25	0:0	4	p
op	11:26	0:0	4	]
op	11:27	0:0	4	.
water	11:28	0:0	4	ps_piece_in_plane
op	11:46	0:0	4	=
call	11:48	11:112	4	malloc
arg	11:56	11:112	5	sizeof(piece_in_plane_t)*p_sys->s_allocated.i_planes
op	11:56	0:0	6	sizeof
water	11:62	0:0	6	(
water	11:64	0:0	6	piece_in_plane_t
water	11:80	0:0	6	)
op	11:82	0:0	6	*
water	11:84	0:0	6	p_sys
op	11:89	0:0	6	->
water	11:91	0:0	6	s_allocated
op	11:102	0:0	6	.
water	11:103	0:0	6	i_planes
water	11:113	0:0	4	;
if	12:8	18:8	4	(! p_sys -> ps_pieces [ p ] . ps_piece_in_plane)
cond	12:12	12:33	5	! p_sys -> ps_pieces [ p ] . ps_piece_in_plane
op	12:12	0:0	6	!
water	12:13	0:0	6	p_sys
op	12:18	0:0	6	->
water	12:20	0:0	6	ps_pieces
op	12:29	0:0	6	[
water	12:30	0:0	6	p
op	12:31	0:0	6	]
op	12:32	0:0	6	.
water	12:33	0:0	6	ps_piece_in_plane
stmts	12:53	18:8	5	
water	12:53	0:0	6	{
for	13:12	14:59	6	( uint32_t i = 0 ;i < p;i ++)
forinit	0:0	13:29	7	 uint32_t i = 0 ;
decl	13:17	13:29	8	uint32_t	i
op	13:27	0:0	8	=
water	13:28	0:0	8	0
cond	13:30	13:32	7	i < p
water	13:30	0:0	8	i
op	13:31	0:0	8	<
water	13:32	0:0	8	p
forexpr	13:34	13:35	7	i ++
water	13:34	0:0	8	i
op	13:35	0:0	8	++
stmts	14:16	14:59	7	
call	14:16	14:58	8	free
arg	14:21	14:58	9	p_sys->ps_pieces[i].ps_piece_in_plane
water	14:21	0:0	10	p_sys
op	14:26	0:0	10	->
water	14:28	0:0	10	ps_pieces
op	14:37	0:0	10	[
water	14:38	0:0	10	i
op	14:39	0:0	10	]
op	14:40	0:0	10	.
water	14:41	0:0	10	ps_piece_in_plane
water	14:59	0:0	8	;
call	15:12	15:33	6	free
arg	15:17	15:33	7	p_sys->ps_pieces
water	15:17	0:0	8	p_sys
op	15:22	0:0	8	->
water	15:24	0:0	8	ps_pieces
water	15:34	0:0	6	;
water	16:12	0:0	6	p_sys
op	16:17	0:0	6	->
water	16:19	0:0	6	ps_pieces
op	16:29	0:0	6	=
water	16:31	0:0	6	NULL
water	16:35	0:0	6	;
return	17:12	17:29	6	VLC_ENOMEM
water	17:19	0:0	7	VLC_ENOMEM
water	18:8	0:0	6	}
water	19:4	0:0	4	}
water	20:4	0:0	2	p_sys
op	20:9	0:0	2	->
water	20:11	0:0	2	ps_pieces_tmp
op	20:25	0:0	2	=
call	20:27	20:86	2	malloc
arg	20:35	20:86	3	sizeof(piece_t)*p_sys->s_allocated.i_pieces_nbr
op	20:35	0:0	4	sizeof
water	20:41	0:0	4	(
water	20:43	0:0	4	piece_t
water	20:50	0:0	4	)
op	20:52	0:0	4	*
water	20:54	0:0	4	p_sys
op	20:59	0:0	4	->
water	20:61	0:0	4	s_allocated
op	20:72	0:0	4	.
water	20:73	0:0	4	i_pieces_nbr
water	20:87	0:0	2	;
if	21:4	27:4	2	(! p_sys -> ps_pieces_tmp)
cond	21:8	21:16	3	! p_sys -> ps_pieces_tmp
op	21:8	0:0	4	!
water	21:9	0:0	4	p_sys
op	21:14	0:0	4	->
water	21:16	0:0	4	ps_pieces_tmp
stmts	21:32	27:4	3	
water	21:32	0:0	4	{
for	22:8	23:55	4	( uint32_t i = 0 ;i < p_sys -> s_allocated . i_pieces_nbr;i ++)
forinit	0:0	22:25	5	 uint32_t i = 0 ;
decl	22:13	22:25	6	uint32_t	i
op	22:23	0:0	6	=
water	22:24	0:0	6	0
cond	22:26	22:47	5	i < p_sys -> s_allocated . i_pieces_nbr
water	22:26	0:0	6	i
op	22:27	0:0	6	<
water	22:28	0:0	6	p_sys
op	22:33	0:0	6	->
water	22:35	0:0	6	s_allocated
op	22:46	0:0	6	.
water	22:47	0:0	6	i_pieces_nbr
forexpr	22:60	22:61	5	i ++
water	22:60	0:0	6	i
op	22:61	0:0	6	++
stmts	23:12	23:55	5	
call	23:12	23:54	6	free
arg	23:17	23:54	7	p_sys->ps_pieces[i].ps_piece_in_plane
water	23:17	0:0	8	p_sys
op	23:22	0:0	8	->
water	23:24	0:0	8	ps_pieces
op	23:33	0:0	8	[
water	23:34	0:0	8	i
op	23:35	0:0	8	]
op	23:36	0:0	8	.
water	23:37	0:0	8	ps_piece_in_plane
water	23:55	0:0	6	;
call	24:8	24:29	4	free
arg	24:13	24:29	5	p_sys->ps_pieces
water	24:13	0:0	6	p_sys
op	24:18	0:0	6	->
water	24:20	0:0	6	ps_pieces
water	24:30	0:0	4	;
water	25:8	0:0	4	p_sys
op	25:13	0:0	4	->
water	25:15	0:0	4	ps_pieces
op	25:25	0:0	4	=
water	25:27	0:0	4	NULL
water	25:31	0:0	4	;
return	26:8	26:25	4	VLC_ENOMEM
water	26:15	0:0	5	VLC_ENOMEM
water	27:4	0:0	4	}
water	28:4	0:0	2	p_sys
op	28:9	0:0	2	->
water	28:11	0:0	2	pi_group_qty
op	28:24	0:0	2	=
call	28:26	28:87	2	malloc
arg	28:34	28:87	3	sizeof(int32_t)*(p_sys->s_allocated.i_pieces_nbr)
op	28:34	0:0	4	sizeof
water	28:40	0:0	4	(
water	28:42	0:0	4	int32_t
water	28:50	0:0	4	)
op	28:52	0:0	4	*
water	28:54	0:0	4	(
water	28:55	0:0	4	p_sys
op	28:60	0:0	4	->
water	28:62	0:0	4	s_allocated
op	28:73	0:0	4	.
water	28:74	0:0	4	i_pieces_nbr
water	28:86	0:0	4	)
water	28:88	0:0	2	;
if	29:4	37:4	2	(! p_sys -> pi_group_qty)
cond	29:8	29:16	3	! p_sys -> pi_group_qty
op	29:8	0:0	4	!
water	29:9	0:0	4	p_sys
op	29:14	0:0	4	->
water	29:16	0:0	4	pi_group_qty
stmts	29:31	37:4	3	
water	29:31	0:0	4	{
for	30:8	31:55	4	( uint32_t i = 0 ;i < p_sys -> s_allocated . i_pieces_nbr;i ++)
forinit	0:0	30:25	5	 uint32_t i = 0 ;
decl	30:13	30:25	6	uint32_t	i
op	30:23	0:0	6	=
water	30:24	0:0	6	0
cond	30:26	30:47	5	i < p_sys -> s_allocated . i_pieces_nbr
water	30:26	0:0	6	i
op	30:27	0:0	6	<
water	30:28	0:0	6	p_sys
op	30:33	0:0	6	->
water	30:35	0:0	6	s_allocated
op	30:46	0:0	6	.
water	30:47	0:0	6	i_pieces_nbr
forexpr	30:60	30:61	5	i ++
water	30:60	0:0	6	i
op	30:61	0:0	6	++
stmts	31:12	31:55	5	
call	31:12	31:54	6	free
arg	31:17	31:54	7	p_sys->ps_pieces[i].ps_piece_in_plane
water	31:17	0:0	8	p_sys
op	31:22	0:0	8	->
water	31:24	0:0	8	ps_pieces
op	31:33	0:0	8	[
water	31:34	0:0	8	i
op	31:35	0:0	8	]
op	31:36	0:0	8	.
water	31:37	0:0	8	ps_piece_in_plane
water	31:55	0:0	6	;
call	32:8	32:29	4	free
arg	32:13	32:29	5	p_sys->ps_pieces
water	32:13	0:0	6	p_sys
op	32:18	0:0	6	->
water	32:20	0:0	6	ps_pieces
water	32:30	0:0	4	;
water	33:8	0:0	4	p_sys
op	33:13	0:0	4	->
water	33:15	0:0	4	ps_pieces
op	33:25	0:0	4	=
water	33:27	0:0	4	NULL
water	33:31	0:0	4	;
call	34:8	34:33	4	free
arg	34:13	34:33	5	p_sys->ps_pieces_tmp
water	34:13	0:0	6	p_sys
op	34:18	0:0	6	->
water	34:20	0:0	6	ps_pieces_tmp
water	34:34	0:0	4	;
water	35:8	0:0	4	p_sys
op	35:13	0:0	4	->
water	35:15	0:0	4	ps_pieces_tmp
op	35:29	0:0	4	=
water	35:31	0:0	4	NULL
water	35:35	0:0	4	;
return	36:8	36:25	4	VLC_ENOMEM
water	36:15	0:0	5	VLC_ENOMEM
water	37:4	0:0	4	}
return	38:4	38:22	2	VLC_SUCCESS
water	38:11	0:0	3	VLC_SUCCESS
