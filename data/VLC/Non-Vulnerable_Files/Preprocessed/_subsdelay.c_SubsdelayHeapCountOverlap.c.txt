func	2:0	20:0	0	static int	SubsdelayHeapCountOverlap
params	2:36	0:0	1	
param	2:38	2:62	2	subsdelay_heap_t *	p_heap
param	2:64	2:95	2	subsdelay_heap_entry_t *	p_entry
param	2:97	2:112	2	mtime_t	i_date
stmnts	0:0	19:21	1	
decl	4:4	4:34	2	subsdelay_heap_entry_t	*p_curr
decl	5:4	5:18	2	int	i_overlaps
call	6:4	6:23	2	VLC_UNUSED
arg	6:16	6:23	3	p_heap
water	6:16	0:0	4	p_heap
water	6:24	0:0	2	;
water	7:4	0:0	2	i_overlaps
op	7:15	0:0	2	=
water	7:17	0:0	2	0
water	7:18	0:0	2	;
for	8:4	18:4	2	(p_curr = p_entry -> p_next ;p_curr != NULL;p_curr = p_curr -> p_next)
forinit	8:9	8:33	3	p_curr = p_entry -> p_next ;
water	8:9	0:0	4	p_curr
op	8:16	0:0	4	=
water	8:18	0:0	4	p_entry
op	8:25	0:0	4	->
water	8:27	0:0	4	p_next
water	8:33	0:0	4	;
cond	8:35	8:45	3	p_curr != NULL
water	8:35	0:0	4	p_curr
op	8:42	0:0	4	!=
water	8:45	0:0	4	NULL
forexpr	8:51	8:68	3	p_curr = p_curr -> p_next
water	8:51	0:0	4	p_curr
op	8:58	0:0	4	=
water	8:60	0:0	4	p_curr
op	8:66	0:0	4	->
water	8:68	0:0	4	p_next
stmts	9:4	18:4	3	
water	9:4	0:0	4	{
if	10:8	13:8	4	(p_curr -> p_source -> i_start > i_date)
cond	10:12	10:40	5	p_curr -> p_source -> i_start > i_date
water	10:12	0:0	6	p_curr
op	10:18	0:0	6	->
water	10:20	0:0	6	p_source
op	10:28	0:0	6	->
water	10:30	0:0	6	i_start
op	10:38	0:0	6	>
water	10:40	0:0	6	i_date
stmts	11:8	13:8	5	
water	11:8	0:0	6	{
break	12:12	12:17	6	
water	13:8	0:0	6	}
if	14:8	17:8	4	(! p_curr -> b_check_empty)
cond	14:12	14:21	5	! p_curr -> b_check_empty
op	14:12	0:0	6	!
water	14:13	0:0	6	p_curr
op	14:19	0:0	6	->
water	14:21	0:0	6	b_check_empty
stmts	15:8	17:8	5	
water	15:8	0:0	6	{
water	16:12	0:0	6	i_overlaps
op	16:22	0:0	6	++
water	16:24	0:0	6	;
water	17:8	0:0	6	}
water	18:4	0:0	4	}
return	19:4	19:21	2	i_overlaps
water	19:11	0:0	3	i_overlaps
