func	2:0	126:0	0	static int	updateIndexAndDel
params	2:28	0:0	1	
param	2:30	2:57	2	sout_access_out_t *	p_access
param	2:59	2:87	2	sout_access_out_sys_t *	p_sys
param	2:89	2:102	2	bool	b_isend
stmnts	0:0	125:12	1	
decl	4:4	4:23	2	uint32_t	i_firstseg
water	5:4	0:0	2	unsigned
water	5:13	0:0	2	i_index_offset
op	5:28	0:0	2	=
water	5:30	0:0	2	0
water	5:31	0:0	2	;
if	6:4	10:4	2	(p_sys -> i_numsegs == 0 || p_sys -> i_segment < ( p_sys -> i_numsegs + p_sys -> i_initial_segment ))
cond	6:9	7:74	3	p_sys -> i_numsegs == 0 || p_sys -> i_segment < ( p_sys -> i_numsegs + p_sys -> i_initial_segment )
water	6:9	0:0	4	p_sys
op	6:14	0:0	4	->
water	6:16	0:0	4	i_numsegs
op	6:26	0:0	4	==
water	6:29	0:0	4	0
op	6:31	0:0	4	||
water	7:9	0:0	4	p_sys
op	7:14	0:0	4	->
water	7:16	0:0	4	i_segment
op	7:26	0:0	4	<
water	7:28	0:0	4	(
water	7:30	0:0	4	p_sys
op	7:35	0:0	4	->
water	7:37	0:0	4	i_numsegs
op	7:47	0:0	4	+
water	7:49	0:0	4	p_sys
op	7:54	0:0	4	->
water	7:56	0:0	4	i_initial_segment
water	7:74	0:0	4	)
stmts	8:4	10:4	3	
water	8:4	0:0	4	{
water	9:8	0:0	4	i_firstseg
op	9:19	0:0	4	=
water	9:21	0:0	4	p_sys
op	9:26	0:0	4	->
water	9:28	0:0	4	i_initial_segment
op	9:46	0:0	4	==
water	9:49	0:0	4	0
water	9:51	0:0	4	?
water	9:53	0:0	4	1
water	9:55	0:0	4	:
water	9:57	0:0	4	p_sys
op	9:62	0:0	4	->
water	9:64	0:0	4	i_initial_segment
water	9:81	0:0	4	;
water	10:4	0:0	4	}
else	11:4	16:4	2
stmts	12:4	16:4	3	
water	12:4	0:0	4	{
water	13:8	0:0	4	unsigned
water	13:17	0:0	4	numsegs
op	13:25	0:0	4	=
call	13:27	13:54	4	segmentAmountNeeded
arg	13:48	13:54	5	p_sys
water	13:48	0:0	6	p_sys
water	13:55	0:0	4	;
water	14:8	0:0	4	i_firstseg
op	14:19	0:0	4	=
water	14:21	0:0	4	(
water	14:23	0:0	4	p_sys
op	14:28	0:0	4	->
water	14:30	0:0	4	i_segment
op	14:40	0:0	4	-
water	14:42	0:0	4	numsegs
water	14:50	0:0	4	)
op	14:52	0:0	4	+
water	14:54	0:0	4	1
water	14:55	0:0	4	;
water	15:8	0:0	4	i_index_offset
op	15:23	0:0	4	=
call	15:25	15:60	4	vlc_array_count
arg	15:42	15:60	5	p_sys->segments_t
water	15:42	0:0	6	p_sys
op	15:47	0:0	6	->
water	15:49	0:0	6	segments_t
op	15:62	0:0	4	-
water	15:64	0:0	4	numsegs
water	15:71	0:0	4	;
water	16:4	0:0	4	}
if	18:4	108:4	2	(p_sys -> psz_indexPath)
cond	18:9	18:16	3	p_sys -> psz_indexPath
water	18:9	0:0	4	p_sys
op	18:14	0:0	4	->
water	18:16	0:0	4	psz_indexPath
stmts	19:4	108:4	3	
water	19:4	0:0	4	{
decl	20:8	20:15	4	int	val
decl	21:8	21:16	4	FILE	*fp
decl	22:8	22:24	4	char	*psz_idxTmp
if	23:8	24:21	4	(asprintf (& psz_idxTmp ,"%s.tmp" ,p_sys -> psz_indexPath ) < 0)
cond	23:13	23:71	5	asprintf (& psz_idxTmp ,"%s.tmp" ,p_sys -> psz_indexPath ) < 0
call	23:13	23:67	6	asprintf
arg	23:23	23:34	7	&psz_idxTmp
op	23:23	0:0	8	&
water	23:24	0:0	8	psz_idxTmp
arg	23:36	23:44	7	"%s.tmp"
water	23:36	0:0	8	"%s.tmp"
arg	23:46	23:67	7	p_sys->psz_indexPath
water	23:46	0:0	8	p_sys
op	23:51	0:0	8	->
water	23:53	0:0	8	psz_indexPath
op	23:69	0:0	6	<
water	23:71	0:0	6	0
stmts	24:12	24:21	5	
return	24:12	24:21	6	-1
op	24:19	0:0	7	-
water	24:20	0:0	7	1
water	25:8	0:0	4	fp
op	25:11	0:0	4	=
call	25:13	25:40	4	vlc_fopen
arg	25:24	25:34	5	psz_idxTmp
water	25:24	0:0	6	psz_idxTmp
arg	25:36	25:40	5	"wt"
water	25:36	0:0	6	"wt"
water	25:41	0:0	4	;
if	26:8	31:8	4	(! fp)
cond	26:13	26:14	5	! fp
op	26:13	0:0	6	!
water	26:14	0:0	6	fp
stmts	27:8	31:8	5	
water	27:8	0:0	6	{
call	28:12	28:73	6	msg_Err
arg	28:21	28:29	7	p_access
water	28:21	0:0	8	p_access
arg	28:31	28:60	7	"cannot open index file `%s'"
water	28:31	0:0	8	"cannot open index file `%s'"
arg	28:62	28:73	7	psz_idxTmp
water	28:62	0:0	8	psz_idxTmp
water	28:74	0:0	6	;
call	29:12	29:29	6	free
arg	29:18	29:29	7	psz_idxTmp
water	29:18	0:0	8	psz_idxTmp
water	29:30	0:0	6	;
return	30:12	30:21	6	-1
op	30:19	0:0	7	-
water	30:20	0:0	7	1
water	31:8	0:0	6	}
if	32:8	41:8	4	(fprintf (fp ,"#EXTM3U\n#EXT-X-TARGETDURATION:%zu\n#EXT-X-VERSION:3\n#EXT-X-ALLOW-CACHE:%s" "%s\n#EXT-X-MEDIA-SEQUENCE:%" PRIu32 "\n" ,p_sys -> i_seglen ,p_sys -> b_caching ? "YES" : "NO" ,p_sys -> i_numsegs > 0 ? "" : b_isend ? "\n#EXT-X-PLAYLIST-TYPE:VOD" : "\n#EXT-X-PLAYLIST-TYPE:EVENT" ,i_firstseg ) < 0)
cond	32:13	36:41	5	fprintf (fp ,"#EXTM3U\n#EXT-X-TARGETDURATION:%zu\n#EXT-X-VERSION:3\n#EXT-X-ALLOW-CACHE:%s" "%s\n#EXT-X-MEDIA-SEQUENCE:%" PRIu32 "\n" ,p_sys -> i_seglen ,p_sys -> b_caching ? "YES" : "NO" ,p_sys -> i_numsegs > 0 ? "" : b_isend ? "\n#EXT-X-PLAYLIST-TYPE:VOD" : "\n#EXT-X-PLAYLIST-TYPE:EVENT" ,i_firstseg ) < 0
call	32:13	36:37	6	fprintf
arg	32:22	32:24	7	fp
water	32:22	0:0	8	fp
arg	32:26	33:65	7	"#EXTM3U\n#EXT-X-TARGETDURATION:%zu\n#EXT-X-VERSION:3\n#EXT-X-ALLOW-CACHE:%s""%s\n#EXT-X-MEDIA-SEQUENCE:%"PRIu32"\n"
water	32:26	0:0	8	"#EXTM3U\n#EXT-X-TARGETDURATION:%zu\n#EXT-X-VERSION:3\n#EXT-X-ALLOW-CACHE:%s"
water	33:26	0:0	8	"%s\n#EXT-X-MEDIA-SEQUENCE:%"
water	33:55	0:0	8	PRIu32
water	33:61	0:0	8	"\n"
arg	33:67	33:82	7	p_sys->i_seglen
water	33:67	0:0	8	p_sys
op	33:72	0:0	8	->
water	33:74	0:0	8	i_seglen
arg	34:26	34:57	7	p_sys->b_caching?"YES":"NO"
water	34:26	0:0	8	p_sys
op	34:31	0:0	8	->
water	34:33	0:0	8	b_caching
water	34:43	0:0	8	?
water	34:45	0:0	8	"YES"
water	34:51	0:0	8	:
water	34:53	0:0	8	"NO"
arg	35:26	35:125	7	p_sys->i_numsegs>0?"":b_isend?"\n#EXT-X-PLAYLIST-TYPE:VOD":"\n#EXT-X-PLAYLIST-TYPE:EVENT"
water	35:26	0:0	8	p_sys
op	35:31	0:0	8	->
water	35:33	0:0	8	i_numsegs
op	35:43	0:0	8	>
water	35:45	0:0	8	0
water	35:47	0:0	8	?
water	35:49	0:0	8	""
water	35:52	0:0	8	:
water	35:54	0:0	8	b_isend
water	35:62	0:0	8	?
water	35:64	0:0	8	"\n#EXT-X-PLAYLIST-TYPE:VOD"
water	35:93	0:0	8	:
water	35:95	0:0	8	"\n#EXT-X-PLAYLIST-TYPE:EVENT"
arg	36:26	36:37	7	i_firstseg
water	36:26	0:0	8	i_firstseg
op	36:39	0:0	6	<
water	36:41	0:0	6	0
stmts	37:8	41:8	5	
water	37:8	0:0	6	{
call	38:12	38:29	6	free
arg	38:18	38:29	7	psz_idxTmp
water	38:18	0:0	8	psz_idxTmp
water	38:30	0:0	6	;
call	39:12	39:23	6	fclose
arg	39:20	39:23	7	fp
water	39:20	0:0	8	fp
water	39:24	0:0	6	;
return	40:12	40:21	6	-1
op	40:19	0:0	7	-
water	40:20	0:0	7	1
water	41:8	0:0	6	}
decl	42:8	42:34	4	char	*psz_current_uri
op	42:29	0:0	4	=
water	42:30	0:0	4	NULL
for	43:8	87:8	4	( uint32_t i = i_firstseg ;i <= p_sys -> i_segment;i ++)
forinit	0:0	43:37	5	 uint32_t i = i_firstseg ;
decl	43:14	43:37	6	uint32_t	i
op	43:25	0:0	6	=
water	43:27	0:0	6	i_firstseg
cond	43:39	43:51	5	i <= p_sys -> i_segment
water	43:39	0:0	6	i
op	43:41	0:0	6	<=
water	43:44	0:0	6	p_sys
op	43:49	0:0	6	->
water	43:51	0:0	6	i_segment
forexpr	43:62	43:63	5	i ++
water	43:62	0:0	6	i
op	43:63	0:0	6	++
stmts	44:8	87:8	5	
water	44:8	0:0	6	{
decl	46:12	46:60	6	uint32_t	index
op	46:27	0:0	6	=
water	46:29	0:0	6	i
op	46:31	0:0	6	-
water	46:33	0:0	6	i_firstseg
op	46:44	0:0	6	+
water	46:46	0:0	6	i_index_offset
decl	47:12	47:111	6	output_segment_t	*segment
op	47:38	0:0	6	=
water	47:40	0:0	6	(
water	47:41	0:0	6	output_segment_t
op	47:58	0:0	6	*
water	47:59	0:0	6	)
call	47:60	47:110	7	vlc_array_item_at_index
arg	47:85	47:102	8	p_sys->segments_t
water	47:85	0:0	9	p_sys
op	47:90	0:0	9	->
water	47:92	0:0	9	segments_t
arg	47:104	47:110	8	index
water	47:104	0:0	9	index
if	48:12	78:12	6	(p_sys -> key_uri && ( ! psz_current_uri ||strcmp (psz_current_uri ,segment -> psz_key_uri ) ))
cond	48:16	49:87	7	p_sys -> key_uri && ( ! psz_current_uri ||strcmp (psz_current_uri ,segment -> psz_key_uri ) )
water	48:16	0:0	8	p_sys
op	48:21	0:0	8	->
water	48:23	0:0	8	key_uri
op	48:31	0:0	8	&&
water	49:16	0:0	8	(
op	49:18	0:0	8	!
water	49:19	0:0	8	psz_current_uri
op	49:35	0:0	8	||
call	49:39	49:85	8	strcmp
arg	49:47	49:62	9	psz_current_uri
water	49:47	0:0	10	psz_current_uri
arg	49:64	49:85	9	segment->psz_key_uri
water	49:64	0:0	10	segment
op	49:71	0:0	10	->
water	49:73	0:0	10	psz_key_uri
water	49:87	0:0	8	)
stmts	51:12	78:12	7	
water	51:12	0:0	8	{
decl	52:16	52:27	8	int	ret
op	52:24	0:0	8	=
water	52:26	0:0	8	0
call	53:16	53:38	8	free
arg	53:22	53:38	9	psz_current_uri
water	53:22	0:0	10	psz_current_uri
water	53:39	0:0	8	;
water	54:16	0:0	8	psz_current_uri
op	54:32	0:0	8	=
call	54:34	54:63	8	strdup
arg	54:42	54:63	9	segment->psz_key_uri
water	54:42	0:0	10	segment
op	54:49	0:0	10	->
water	54:51	0:0	10	psz_key_uri
water	54:64	0:0	8	;
if	55:16	68:16	8	(p_sys -> b_generate_iv)
cond	55:20	55:27	9	p_sys -> b_generate_iv
water	55:20	0:0	10	p_sys
op	55:25	0:0	10	->
water	55:27	0:0	10	b_generate_iv
stmts	56:16	68:16	9	
water	56:16	0:0	10	{
water	57:20	0:0	10	unsigned
water	57:29	0:0	10	long
water	57:34	0:0	10	long
water	57:39	0:0	10	iv_hi
op	57:45	0:0	10	=
water	57:47	0:0	10	segment
op	57:54	0:0	10	->
water	57:56	0:0	10	aes_ivs
op	57:63	0:0	10	[
water	57:64	0:0	10	0
op	57:65	0:0	10	]
water	57:66	0:0	10	;
water	58:20	0:0	10	unsigned
water	58:29	0:0	10	long
water	58:34	0:0	10	long
water	58:39	0:0	10	iv_lo
op	58:45	0:0	10	=
water	58:47	0:0	10	segment
op	58:54	0:0	10	->
water	58:56	0:0	10	aes_ivs
op	58:63	0:0	10	[
water	58:64	0:0	10	8
op	58:65	0:0	10	]
water	58:66	0:0	10	;
for	59:20	65:20	10	( unsigned short i = 1 ;i < 8;i ++)
forinit	0:0	59:45	11	 unsigned short i = 1 ;
decl	59:25	59:45	12	unsigned short	i
op	59:42	0:0	12	=
water	59:44	0:0	12	1
cond	59:47	59:51	11	i < 8
water	59:47	0:0	12	i
op	59:49	0:0	12	<
water	59:51	0:0	12	8
forexpr	59:54	59:55	11	i ++
water	59:54	0:0	12	i
op	59:55	0:0	12	++
stmts	60:20	65:20	11	
water	60:20	0:0	12	{
water	61:24	0:0	12	iv_hi
op	61:30	0:0	12	<<=
water	61:34	0:0	12	8
water	61:35	0:0	12	;
water	62:24	0:0	12	iv_hi
op	62:30	0:0	12	|=
water	62:33	0:0	12	segment
op	62:40	0:0	12	->
water	62:42	0:0	12	aes_ivs
op	62:49	0:0	12	[
water	62:50	0:0	12	i
op	62:51	0:0	12	]
op	62:53	0:0	12	&
water	62:55	0:0	12	0
water	62:56	0:0	12	xff
water	62:59	0:0	12	;
water	63:24	0:0	12	iv_lo
op	63:30	0:0	12	<<=
water	63:34	0:0	12	8
water	63:35	0:0	12	;
water	64:24	0:0	12	iv_lo
op	64:30	0:0	12	|=
water	64:33	0:0	12	segment
op	64:40	0:0	12	->
water	64:42	0:0	12	aes_ivs
op	64:49	0:0	12	[
water	64:50	0:0	12	8
op	64:51	0:0	12	+
water	64:52	0:0	12	i
op	64:53	0:0	12	]
op	64:55	0:0	12	&
water	64:57	0:0	12	0
water	64:58	0:0	12	xff
water	64:61	0:0	12	;
water	65:20	0:0	12	}
water	66:20	0:0	10	ret
op	66:24	0:0	10	=
call	66:26	67:70	10	fprintf
arg	66:35	66:37	11	fp
water	66:35	0:0	12	fp
arg	66:39	66:103	11	"#EXT-X-KEY:METHOD=AES-128,URI=\"%s\",IV=0X%16.16llx%16.16llx\n"
water	66:39	0:0	12	"#EXT-X-KEY:METHOD=AES-128,URI=\"%s\",IV=0X%16.16llx%16.16llx\n"
arg	67:35	67:55	11	segment->psz_key_uri
water	67:35	0:0	12	segment
op	67:42	0:0	12	->
water	67:44	0:0	12	psz_key_uri
arg	67:57	67:62	11	iv_hi
water	67:57	0:0	12	iv_hi
arg	67:64	67:70	11	iv_lo
water	67:64	0:0	12	iv_lo
water	67:71	0:0	10	;
water	68:16	0:0	10	}
else	68:18	70:16	8
stmts	68:23	70:16	9	
water	68:23	0:0	10	{
water	69:20	0:0	10	ret
op	69:24	0:0	10	=
call	69:26	69:102	10	fprintf
arg	69:35	69:37	11	fp
water	69:35	0:0	12	fp
arg	69:39	69:79	11	"#EXT-X-KEY:METHOD=AES-128,URI=\"%s\"\n"
water	69:39	0:0	12	"#EXT-X-KEY:METHOD=AES-128,URI=\"%s\"\n"
arg	69:81	69:102	11	segment->psz_key_uri
water	69:81	0:0	12	segment
op	69:88	0:0	12	->
water	69:90	0:0	12	psz_key_uri
water	69:103	0:0	10	;
water	70:16	0:0	10	}
if	71:16	77:16	8	(ret < 0)
cond	71:20	71:26	9	ret < 0
water	71:20	0:0	10	ret
op	71:24	0:0	10	<
water	71:26	0:0	10	0
stmts	72:16	77:16	9	
water	72:16	0:0	10	{
call	73:20	73:42	10	free
arg	73:26	73:42	11	psz_current_uri
water	73:26	0:0	12	psz_current_uri
water	73:43	0:0	10	;
call	74:20	74:37	10	free
arg	74:26	74:37	11	psz_idxTmp
water	74:26	0:0	12	psz_idxTmp
water	74:38	0:0	10	;
call	75:20	75:31	10	fclose
arg	75:28	75:31	11	fp
water	75:28	0:0	12	fp
water	75:32	0:0	10	;
return	76:20	76:29	10	-1
op	76:27	0:0	11	-
water	76:28	0:0	11	1
water	77:16	0:0	10	}
water	78:12	0:0	8	}
water	79:12	0:0	6	val
op	79:16	0:0	6	=
call	79:18	79:91	6	fprintf
arg	79:27	79:29	7	fp
water	79:27	0:0	8	fp
arg	79:31	79:50	7	"#EXTINF:%s,\n%s\n"
water	79:31	0:0	8	"#EXTINF:%s,\n%s\n"
arg	79:52	79:73	7	segment->psz_duration
water	79:52	0:0	8	segment
op	79:59	0:0	8	->
water	79:61	0:0	8	psz_duration
arg	79:75	79:91	7	segment->psz_uri
water	79:75	0:0	8	segment
op	79:82	0:0	8	->
water	79:84	0:0	8	psz_uri
water	79:92	0:0	6	;
if	80:12	86:12	6	(val < 0)
cond	80:17	80:23	7	val < 0
water	80:17	0:0	8	val
op	80:21	0:0	8	<
water	80:23	0:0	8	0
stmts	81:12	86:12	7	
water	81:12	0:0	8	{
call	82:16	82:38	8	free
arg	82:22	82:38	9	psz_current_uri
water	82:22	0:0	10	psz_current_uri
water	82:39	0:0	8	;
call	83:16	83:33	8	free
arg	83:22	83:33	9	psz_idxTmp
water	83:22	0:0	10	psz_idxTmp
water	83:34	0:0	8	;
call	84:16	84:27	8	fclose
arg	84:24	84:27	9	fp
water	84:24	0:0	10	fp
water	84:28	0:0	8	;
return	85:16	85:25	8	-1
op	85:23	0:0	9	-
water	85:24	0:0	9	1
water	86:12	0:0	8	}
water	87:8	0:0	6	}
call	88:8	88:30	4	free
arg	88:14	88:30	5	psz_current_uri
water	88:14	0:0	6	psz_current_uri
water	88:31	0:0	4	;
if	89:8	97:8	4	(b_isend)
cond	89:13	89:13	5	b_isend
water	89:13	0:0	6	b_isend
stmts	90:8	97:8	5	
water	90:8	0:0	6	{
if	91:12	96:12	6	(fputs (STR_ENDLIST ,fp ) < 0)
cond	91:17	91:45	7	fputs (STR_ENDLIST ,fp ) < 0
call	91:17	91:41	8	fputs
arg	91:25	91:36	9	STR_ENDLIST
water	91:25	0:0	10	STR_ENDLIST
arg	91:38	91:41	9	fp
water	91:38	0:0	10	fp
op	91:43	0:0	8	<
water	91:45	0:0	8	0
stmts	92:12	96:12	7	
water	92:12	0:0	8	{
call	93:16	93:33	8	free
arg	93:22	93:33	9	psz_idxTmp
water	93:22	0:0	10	psz_idxTmp
water	93:34	0:0	8	;
call	94:16	94:27	8	fclose
arg	94:24	94:27	9	fp
water	94:24	0:0	10	fp
water	94:29	0:0	8	;
return	95:16	95:25	8	-1
op	95:23	0:0	9	-
water	95:24	0:0	9	1
water	96:12	0:0	8	}
water	97:8	0:0	6	}
call	98:8	98:19	4	fclose
arg	98:16	98:19	5	fp
water	98:16	0:0	6	fp
water	98:20	0:0	4	;
water	99:8	0:0	4	val
op	99:12	0:0	4	=
call	99:14	99:59	4	vlc_rename
arg	99:27	99:37	5	psz_idxTmp
water	99:27	0:0	6	psz_idxTmp
arg	99:39	99:59	5	p_sys->psz_indexPath
water	99:39	0:0	6	p_sys
op	99:44	0:0	6	->
water	99:46	0:0	6	psz_indexPath
water	99:60	0:0	4	;
if	100:8	104:8	4	(val < 0)
cond	100:13	100:19	5	val < 0
water	100:13	0:0	6	val
op	100:17	0:0	6	<
water	100:19	0:0	6	0
stmts	101:8	104:8	5	
water	101:8	0:0	6	{
call	102:12	102:35	6	vlc_unlink
arg	102:24	102:35	7	psz_idxTmp
water	102:24	0:0	8	psz_idxTmp
water	102:36	0:0	6	;
call	103:12	103:66	6	msg_Err
arg	103:21	103:29	7	p_access
water	103:21	0:0	8	p_access
arg	103:31	103:66	7	"Error moving LiveHttp index file"
water	103:31	0:0	8	"Error moving LiveHttp index file"
water	103:67	0:0	6	;
water	104:8	0:0	6	}
else	105:8	106:83	4
stmts	106:12	106:83	5	
call	106:12	106:82	6	msg_Dbg
arg	106:21	106:29	7	p_access
water	106:21	0:0	8	p_access
arg	106:31	106:59	7	"LiveHttpIndexComplete: %s"
water	106:31	0:0	8	"LiveHttpIndexComplete: %s"
arg	106:61	106:82	7	p_sys->psz_indexPath
water	106:61	0:0	8	p_sys
op	106:66	0:0	8	->
water	106:68	0:0	8	psz_indexPath
water	106:83	0:0	6	;
call	107:8	107:25	4	free
arg	107:14	107:25	5	psz_idxTmp
water	107:14	0:0	6	psz_idxTmp
water	107:26	0:0	4	;
water	108:4	0:0	4	}
while	111:4	124:4	2	(p_sys -> b_delsegs && p_sys -> i_numsegs &&isFirstItemRemovable (p_sys ,i_firstseg ,i_index_offset ))
cond	111:11	112:67	3	p_sys -> b_delsegs && p_sys -> i_numsegs &&isFirstItemRemovable (p_sys ,i_firstseg ,i_index_offset )
water	111:11	0:0	4	p_sys
op	111:16	0:0	4	->
water	111:18	0:0	4	b_delsegs
op	111:28	0:0	4	&&
water	111:31	0:0	4	p_sys
op	111:36	0:0	4	->
water	111:38	0:0	4	i_numsegs
op	111:48	0:0	4	&&
call	112:11	112:67	4	isFirstItemRemovable
arg	112:33	112:38	5	p_sys
water	112:33	0:0	6	p_sys
arg	112:40	112:50	5	i_firstseg
water	112:40	0:0	6	i_firstseg
arg	112:52	112:67	5	i_index_offset
water	112:52	0:0	6	i_index_offset
stmts	114:4	124:4	3	
water	114:4	0:0	4	{
decl	115:9	115:84	4	output_segment_t	*segment
op	115:35	0:0	4	=
call	115:37	115:83	5	vlc_array_item_at_index
arg	115:62	115:79	6	p_sys->segments_t
water	115:62	0:0	7	p_sys
op	115:67	0:0	7	->
water	115:69	0:0	7	segments_t
arg	115:81	115:83	6	0
water	115:81	0:0	7	0
call	116:9	116:84	4	msg_Dbg
arg	116:18	116:26	5	p_access
water	116:18	0:0	6	p_access
arg	116:28	116:56	5	"Removing segment number %d"
water	116:28	0:0	6	"Removing segment number %d"
arg	116:58	116:84	5	segment->i_segment_number
water	116:58	0:0	6	segment
op	116:65	0:0	6	->
water	116:67	0:0	6	i_segment_number
water	116:85	0:0	4	;
call	117:9	117:48	4	vlc_array_remove
arg	117:27	117:44	5	p_sys->segments_t
water	117:27	0:0	6	p_sys
op	117:32	0:0	6	->
water	117:34	0:0	6	segments_t
arg	117:46	117:48	5	0
water	117:46	0:0	6	0
water	117:49	0:0	4	;
if	118:9	121:9	4	(segment -> psz_filename)
cond	118:14	118:23	5	segment -> psz_filename
water	118:14	0:0	6	segment
op	118:21	0:0	6	->
water	118:23	0:0	6	psz_filename
stmts	119:9	121:9	5	
water	119:9	0:0	6	{
call	120:13	120:47	6	vlc_unlink
arg	120:25	120:47	7	segment->psz_filename
water	120:25	0:0	8	segment
op	120:32	0:0	8	->
water	120:34	0:0	8	psz_filename
water	120:48	0:0	6	;
water	121:9	0:0	6	}
call	122:9	122:33	4	destroySegment
arg	122:25	122:33	5	segment
water	122:25	0:0	6	segment
water	122:34	0:0	4	;
water	123:9	0:0	4	i_index_offset
op	123:24	0:0	4	-=
water	123:26	0:0	4	1
water	123:27	0:0	4	;
water	124:4	0:0	4	}
return	125:4	125:12	2	0
water	125:11	0:0	3	0
