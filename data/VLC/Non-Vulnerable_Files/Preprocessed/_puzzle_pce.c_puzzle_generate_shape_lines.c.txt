func	2:0	73:0	0	int	puzzle_generate_shape_lines
params	2:31	0:0	1	
param	2:33	2:51	2	filter_t *	p_filter
param	2:53	2:82	2	piece_shape_t *	ps_piece_shape
param	2:84	2:99	2	int32_t	i_min_y
param	2:101	2:115	2	int32_t	i_nb_y
param	2:117	2:132	2	float	f_x_ratio
param	2:134	2:149	2	float	f_y_ratio
param	2:151	2:165	2	point_t *	ps_pt
param	2:167	2:184	2	uint8_t	i_pts_nbr
param	2:186	2:202	2	uint8_t	i_border
param	2:204	2:219	2	uint8_t	i_plane
stmnts	5:4	72:22	1	
for	5:4	71:4	2	( int32_t i_y = i_min_y ;i_y < i_nb_y + i_min_y;i_y ++)
forinit	0:0	5:30	3	 int32_t i_y = i_min_y ;
decl	5:9	5:30	4	int32_t	i_y
op	5:21	0:0	4	=
water	5:23	0:0	4	i_min_y
cond	5:32	5:47	3	i_y < i_nb_y + i_min_y
water	5:32	0:0	4	i_y
op	5:36	0:0	4	<
water	5:38	0:0	4	i_nb_y
op	5:45	0:0	4	+
water	5:47	0:0	4	i_min_y
forexpr	5:56	5:59	3	i_y ++
water	5:56	0:0	4	i_y
op	5:59	0:0	4	++
stmts	5:63	71:4	3	
water	5:63	0:0	4	{
decl	6:8	6:37	4	int32_t	i_row
op	6:22	0:0	4	=
water	6:24	0:0	4	i_y
op	6:28	0:0	4	-
water	6:30	0:0	4	i_min_y
decl	7:8	7:34	4	int32_t	pi_sects[MAX_SECT]
decl	8:8	8:129	4	uint8_t	i_sect
op	8:23	0:0	4	=
call	8:25	8:128	5	puzzle_detect_curve
arg	8:46	8:54	6	p_filter
water	8:46	0:0	7	p_filter
arg	8:56	8:59	6	i_y
water	8:56	0:0	7	i_y
arg	8:61	8:70	6	f_x_ratio
water	8:61	0:0	7	f_x_ratio
arg	8:72	8:81	6	f_y_ratio
water	8:72	0:0	7	f_y_ratio
arg	8:83	8:88	6	ps_pt
water	8:83	0:0	7	ps_pt
arg	8:90	8:99	6	i_pts_nbr
water	8:90	0:0	7	i_pts_nbr
arg	8:101	8:109	6	i_border
water	8:101	0:0	7	i_border
arg	8:111	8:118	6	i_plane
water	8:111	0:0	7	i_plane
arg	8:120	8:128	6	pi_sects
water	8:120	0:0	7	pi_sects
decl	10:8	10:22	4	int8_t	i_s
op	10:19	0:0	4	=
water	10:21	0:0	4	0
decl	11:8	11:123	4	int32_t	i_last_x
op	11:25	0:0	4	=
water	11:27	0:0	4	(
water	11:28	0:0	4	i_border
op	11:36	0:0	4	==
water	11:38	0:0	4	puzzle_SHAPE_TOP
op	11:55	0:0	4	&&
water	11:58	0:0	4	(
water	11:59	0:0	4	i_y
op	11:62	0:0	4	>=
water	11:64	0:0	4	0
water	11:65	0:0	4	)
water	11:66	0:0	4	)
water	11:67	0:0	4	?
call	11:68	11:120	5	puzzle_diagonal_limit
arg	11:91	11:99	6	p_filter
water	11:91	0:0	7	p_filter
arg	11:101	11:104	6	i_y
water	11:101	0:0	7	i_y
arg	11:106	11:110	6	true
water	11:106	0:0	7	true
arg	11:112	11:120	6	i_plane
water	11:112	0:0	7	i_plane
water	11:121	0:0	4	:
water	11:122	0:0	4	0
for	12:8	17:8	4	(i_s = 0 ;i_s < i_sect;i_s ++)
forinit	12:13	12:20	5	i_s = 0 ;
water	12:13	0:0	6	i_s
op	12:17	0:0	6	=
water	12:19	0:0	6	0
water	12:20	0:0	6	;
cond	12:22	12:26	5	i_s < i_sect
water	12:22	0:0	6	i_s
op	12:25	0:0	6	<
water	12:26	0:0	6	i_sect
forexpr	12:34	12:37	5	i_s ++
water	12:34	0:0	6	i_s
op	12:37	0:0	6	++
stmts	12:41	17:8	5	
water	12:41	0:0	6	{
decl	13:12	13:47	6	int32_t	i_current_x
op	13:32	0:0	6	=
water	13:34	0:0	6	pi_sects
op	13:42	0:0	6	[
water	13:43	0:0	6	i_s
op	13:46	0:0	6	]
decl	14:12	14:52	6	int32_t	i_delta
op	14:28	0:0	6	=
water	14:30	0:0	6	i_current_x
op	14:42	0:0	6	-
water	14:44	0:0	6	i_last_x
water	15:12	0:0	6	pi_sects
op	15:20	0:0	6	[
water	15:21	0:0	6	i_s
op	15:24	0:0	6	]
op	15:26	0:0	6	=
water	15:28	0:0	6	i_delta
water	15:35	0:0	6	;
water	16:12	0:0	6	i_last_x
op	16:21	0:0	6	=
water	16:23	0:0	6	i_current_x
water	16:34	0:0	6	;
water	17:8	0:0	6	}
switch	18:8	70:8	4	(i_border)
cond	18:16	18:16	5	i_border
water	18:16	0:0	6	i_border
stmts	19:8	70:8	5	
water	19:8	0:0	6	{
label	20:10	20:31	6	case puzzle_SHAPE_TOP :
if	23:12	37:12	6	(i_y >= 0)
cond	23:17	23:24	7	i_y >= 0
water	23:17	0:0	8	i_y
op	23:21	0:0	8	>=
water	23:24	0:0	8	0
stmts	23:28	37:12	7	
water	23:28	0:0	8	{
water	24:16	0:0	8	ps_piece_shape
op	24:30	0:0	8	->
water	24:32	0:0	8	ps_piece_shape_row
op	24:50	0:0	8	[
water	24:51	0:0	8	i_row
op	24:56	0:0	8	]
op	24:57	0:0	8	.
water	24:58	0:0	8	i_section_nbr
op	24:72	0:0	8	=
water	24:74	0:0	8	i_sect
water	24:80	0:0	8	;
water	25:16	0:0	8	ps_piece_shape
op	25:30	0:0	8	->
water	25:32	0:0	8	ps_piece_shape_row
op	25:50	0:0	8	[
water	25:51	0:0	8	i_row
op	25:56	0:0	8	]
op	25:57	0:0	8	.
water	25:58	0:0	8	ps_row_section
op	25:73	0:0	8	=
call	25:75	25:115	8	malloc
arg	25:85	25:115	9	sizeof(row_section_t)*i_sect
op	25:85	0:0	10	sizeof
water	25:91	0:0	10	(
water	25:92	0:0	10	row_section_t
water	25:105	0:0	10	)
op	25:107	0:0	10	*
water	25:109	0:0	10	i_sect
water	25:116	0:0	8	;
if	26:16	32:16	8	(! ps_piece_shape -> ps_piece_shape_row [ i_row ] . ps_row_section)
cond	26:20	26:63	9	! ps_piece_shape -> ps_piece_shape_row [ i_row ] . ps_row_section
op	26:20	0:0	10	!
water	26:21	0:0	10	ps_piece_shape
op	26:35	0:0	10	->
water	26:37	0:0	10	ps_piece_shape_row
op	26:55	0:0	10	[
water	26:56	0:0	10	i_row
op	26:61	0:0	10	]
op	26:62	0:0	10	.
water	26:63	0:0	10	ps_row_section
stmts	26:79	32:16	9	
water	26:79	0:0	10	{
for	27:20	28:82	10	( uint8_t i = 0 ;i < i_row;i ++)
forinit	0:0	27:36	11	 uint8_t i = 0 ;
decl	27:25	27:36	12	uint8_t	i
op	27:34	0:0	12	=
water	27:35	0:0	12	0
cond	27:38	27:40	11	i < i_row
water	27:38	0:0	12	i
op	27:39	0:0	12	<
water	27:40	0:0	12	i_row
forexpr	27:46	27:47	11	i ++
water	27:46	0:0	12	i
op	27:47	0:0	12	++
stmts	28:24	28:82	11	
call	28:24	28:81	12	free
arg	28:29	28:81	13	ps_piece_shape->ps_piece_shape_row[i].ps_row_section
water	28:29	0:0	14	ps_piece_shape
op	28:43	0:0	14	->
water	28:45	0:0	14	ps_piece_shape_row
op	28:63	0:0	14	[
water	28:64	0:0	14	i
op	28:65	0:0	14	]
op	28:66	0:0	14	.
water	28:67	0:0	14	ps_row_section
water	28:82	0:0	12	;
call	29:20	29:59	10	free
arg	29:25	29:59	11	ps_piece_shape->ps_piece_shape_row
water	29:25	0:0	12	ps_piece_shape
op	29:39	0:0	12	->
water	29:41	0:0	12	ps_piece_shape_row
water	29:60	0:0	10	;
water	30:20	0:0	10	ps_piece_shape
op	30:34	0:0	10	->
water	30:36	0:0	10	ps_piece_shape_row
op	30:55	0:0	10	=
water	30:57	0:0	10	NULL
water	30:61	0:0	10	;
return	31:20	31:37	10	VLC_ENOMEM
water	31:27	0:0	11	VLC_ENOMEM
water	32:16	0:0	10	}
for	33:16	36:16	8	( uint8_t i = 0 ;i < i_sect;i ++)
forinit	0:0	33:32	9	 uint8_t i = 0 ;
decl	33:21	33:32	10	uint8_t	i
op	33:30	0:0	10	=
water	33:31	0:0	10	0
cond	33:34	33:38	9	i < i_sect
water	33:34	0:0	10	i
op	33:36	0:0	10	<
water	33:38	0:0	10	i_sect
forexpr	33:46	33:47	9	i ++
water	33:46	0:0	10	i
op	33:47	0:0	10	++
stmts	33:51	36:16	9	
water	33:51	0:0	10	{
water	34:20	0:0	10	ps_piece_shape
op	34:34	0:0	10	->
water	34:36	0:0	10	ps_piece_shape_row
op	34:54	0:0	10	[
water	34:55	0:0	10	i_row
op	34:60	0:0	10	]
op	34:61	0:0	10	.
water	34:62	0:0	10	ps_row_section
op	34:76	0:0	10	[
water	34:77	0:0	10	i
op	34:78	0:0	10	]
op	34:79	0:0	10	.
water	34:80	0:0	10	i_type
op	34:87	0:0	10	=
water	34:89	0:0	10	i
op	34:91	0:0	10	%
water	34:93	0:0	10	2
water	34:94	0:0	10	;
water	35:20	0:0	10	ps_piece_shape
op	35:34	0:0	10	->
water	35:36	0:0	10	ps_piece_shape_row
op	35:54	0:0	10	[
water	35:55	0:0	10	i_row
op	35:60	0:0	10	]
op	35:61	0:0	10	.
water	35:62	0:0	10	ps_row_section
op	35:76	0:0	10	[
water	35:77	0:0	10	i
op	35:78	0:0	10	]
op	35:79	0:0	10	.
water	35:80	0:0	10	i_width
op	35:88	0:0	10	=
water	35:90	0:0	10	pi_sects
op	35:98	0:0	10	[
water	35:99	0:0	10	i
op	35:100	0:0	10	]
water	35:101	0:0	10	;
water	36:16	0:0	10	}
water	37:12	0:0	8	}
else	38:12	52:12	6
stmts	38:17	52:12	7	
water	38:17	0:0	8	{
water	39:16	0:0	8	ps_piece_shape
op	39:30	0:0	8	->
water	39:32	0:0	8	ps_piece_shape_row
op	39:50	0:0	8	[
water	39:51	0:0	8	i_row
op	39:56	0:0	8	]
op	39:57	0:0	8	.
water	39:58	0:0	8	i_section_nbr
op	39:72	0:0	8	=
water	39:74	0:0	8	i_sect
water	39:80	0:0	8	;
water	40:16	0:0	8	ps_piece_shape
op	40:30	0:0	8	->
water	40:32	0:0	8	ps_piece_shape_row
op	40:50	0:0	8	[
water	40:51	0:0	8	i_row
op	40:56	0:0	8	]
op	40:57	0:0	8	.
water	40:58	0:0	8	ps_row_section
op	40:73	0:0	8	=
call	40:75	40:115	8	malloc
arg	40:85	40:115	9	sizeof(row_section_t)*i_sect
op	40:85	0:0	10	sizeof
water	40:91	0:0	10	(
water	40:92	0:0	10	row_section_t
water	40:105	0:0	10	)
op	40:107	0:0	10	*
water	40:109	0:0	10	i_sect
water	40:116	0:0	8	;
if	41:16	47:16	8	(! ps_piece_shape -> ps_piece_shape_row [ i_row ] . ps_row_section)
cond	41:20	41:63	9	! ps_piece_shape -> ps_piece_shape_row [ i_row ] . ps_row_section
op	41:20	0:0	10	!
water	41:21	0:0	10	ps_piece_shape
op	41:35	0:0	10	->
water	41:37	0:0	10	ps_piece_shape_row
op	41:55	0:0	10	[
water	41:56	0:0	10	i_row
op	41:61	0:0	10	]
op	41:62	0:0	10	.
water	41:63	0:0	10	ps_row_section
stmts	41:79	47:16	9	
water	41:79	0:0	10	{
for	42:20	43:82	10	( uint8_t i = 0 ;i < i_row;i ++)
forinit	0:0	42:36	11	 uint8_t i = 0 ;
decl	42:25	42:36	12	uint8_t	i
op	42:34	0:0	12	=
water	42:35	0:0	12	0
cond	42:38	42:40	11	i < i_row
water	42:38	0:0	12	i
op	42:39	0:0	12	<
water	42:40	0:0	12	i_row
forexpr	42:46	42:47	11	i ++
water	42:46	0:0	12	i
op	42:47	0:0	12	++
stmts	43:24	43:82	11	
call	43:24	43:81	12	free
arg	43:29	43:81	13	ps_piece_shape->ps_piece_shape_row[i].ps_row_section
water	43:29	0:0	14	ps_piece_shape
op	43:43	0:0	14	->
water	43:45	0:0	14	ps_piece_shape_row
op	43:63	0:0	14	[
water	43:64	0:0	14	i
op	43:65	0:0	14	]
op	43:66	0:0	14	.
water	43:67	0:0	14	ps_row_section
water	43:82	0:0	12	;
call	44:20	44:59	10	free
arg	44:25	44:59	11	ps_piece_shape->ps_piece_shape_row
water	44:25	0:0	12	ps_piece_shape
op	44:39	0:0	12	->
water	44:41	0:0	12	ps_piece_shape_row
water	44:60	0:0	10	;
water	45:20	0:0	10	ps_piece_shape
op	45:34	0:0	10	->
water	45:36	0:0	10	ps_piece_shape_row
op	45:55	0:0	10	=
water	45:57	0:0	10	NULL
water	45:61	0:0	10	;
return	46:20	46:37	10	VLC_ENOMEM
water	46:27	0:0	11	VLC_ENOMEM
water	47:16	0:0	10	}
for	48:16	51:16	8	( uint8_t i = 0 ;i < i_sect;i ++)
forinit	0:0	48:32	9	 uint8_t i = 0 ;
decl	48:21	48:32	10	uint8_t	i
op	48:30	0:0	10	=
water	48:31	0:0	10	0
cond	48:34	48:38	9	i < i_sect
water	48:34	0:0	10	i
op	48:36	0:0	10	<
water	48:38	0:0	10	i_sect
forexpr	48:46	48:47	9	i ++
water	48:46	0:0	10	i
op	48:47	0:0	10	++
stmts	48:51	51:16	9	
water	48:51	0:0	10	{
water	49:20	0:0	10	ps_piece_shape
op	49:34	0:0	10	->
water	49:36	0:0	10	ps_piece_shape_row
op	49:54	0:0	10	[
water	49:55	0:0	10	i_row
op	49:60	0:0	10	]
op	49:61	0:0	10	.
water	49:62	0:0	10	ps_row_section
op	49:76	0:0	10	[
water	49:77	0:0	10	i
op	49:78	0:0	10	]
op	49:79	0:0	10	.
water	49:80	0:0	10	i_type
op	49:87	0:0	10	=
water	49:89	0:0	10	(
water	49:90	0:0	10	i
op	49:92	0:0	10	+
water	49:94	0:0	10	1
water	49:95	0:0	10	)
op	49:97	0:0	10	%
water	49:99	0:0	10	2
water	49:100	0:0	10	;
water	50:20	0:0	10	ps_piece_shape
op	50:34	0:0	10	->
water	50:36	0:0	10	ps_piece_shape_row
op	50:54	0:0	10	[
water	50:55	0:0	10	i_row
op	50:60	0:0	10	]
op	50:61	0:0	10	.
water	50:62	0:0	10	ps_row_section
op	50:76	0:0	10	[
water	50:77	0:0	10	i
op	50:78	0:0	10	]
op	50:79	0:0	10	.
water	50:80	0:0	10	i_width
op	50:88	0:0	10	=
water	50:90	0:0	10	pi_sects
op	50:98	0:0	10	[
water	50:99	0:0	10	i
op	50:100	0:0	10	]
water	50:101	0:0	10	;
water	51:16	0:0	10	}
water	52:12	0:0	8	}
break	53:12	53:17	6	
label	54:10	54:32	6	case puzzle_SHAPE_LEFT :
water	57:12	0:0	6	ps_piece_shape
op	57:26	0:0	6	->
water	57:28	0:0	6	ps_piece_shape_row
op	57:46	0:0	6	[
water	57:47	0:0	6	i_row
op	57:52	0:0	6	]
op	57:53	0:0	6	.
water	57:54	0:0	6	i_section_nbr
op	57:68	0:0	6	=
water	57:70	0:0	6	i_sect
water	57:76	0:0	6	;
water	58:12	0:0	6	ps_piece_shape
op	58:26	0:0	6	->
water	58:28	0:0	6	ps_piece_shape_row
op	58:46	0:0	6	[
water	58:47	0:0	6	i_row
op	58:52	0:0	6	]
op	58:53	0:0	6	.
water	58:54	0:0	6	ps_row_section
op	58:69	0:0	6	=
call	58:71	58:111	6	malloc
arg	58:81	58:111	7	sizeof(row_section_t)*i_sect
op	58:81	0:0	8	sizeof
water	58:87	0:0	8	(
water	58:88	0:0	8	row_section_t
water	58:101	0:0	8	)
op	58:103	0:0	8	*
water	58:105	0:0	8	i_sect
water	58:112	0:0	6	;
if	59:12	65:12	6	(! ps_piece_shape -> ps_piece_shape_row [ i_row ] . ps_row_section)
cond	59:16	59:59	7	! ps_piece_shape -> ps_piece_shape_row [ i_row ] . ps_row_section
op	59:16	0:0	8	!
water	59:17	0:0	8	ps_piece_shape
op	59:31	0:0	8	->
water	59:33	0:0	8	ps_piece_shape_row
op	59:51	0:0	8	[
water	59:52	0:0	8	i_row
op	59:57	0:0	8	]
op	59:58	0:0	8	.
water	59:59	0:0	8	ps_row_section
stmts	59:75	65:12	7	
water	59:75	0:0	8	{
for	60:16	61:78	8	( uint8_t i = 0 ;i < i_row;i ++)
forinit	0:0	60:32	9	 uint8_t i = 0 ;
decl	60:21	60:32	10	uint8_t	i
op	60:30	0:0	10	=
water	60:31	0:0	10	0
cond	60:34	60:36	9	i < i_row
water	60:34	0:0	10	i
op	60:35	0:0	10	<
water	60:36	0:0	10	i_row
forexpr	60:42	60:43	9	i ++
water	60:42	0:0	10	i
op	60:43	0:0	10	++
stmts	61:20	61:78	9	
call	61:20	61:77	10	free
arg	61:25	61:77	11	ps_piece_shape->ps_piece_shape_row[i].ps_row_section
water	61:25	0:0	12	ps_piece_shape
op	61:39	0:0	12	->
water	61:41	0:0	12	ps_piece_shape_row
op	61:59	0:0	12	[
water	61:60	0:0	12	i
op	61:61	0:0	12	]
op	61:62	0:0	12	.
water	61:63	0:0	12	ps_row_section
water	61:78	0:0	10	;
call	62:16	62:55	8	free
arg	62:21	62:55	9	ps_piece_shape->ps_piece_shape_row
water	62:21	0:0	10	ps_piece_shape
op	62:35	0:0	10	->
water	62:37	0:0	10	ps_piece_shape_row
water	62:56	0:0	8	;
water	63:16	0:0	8	ps_piece_shape
op	63:30	0:0	8	->
water	63:32	0:0	8	ps_piece_shape_row
op	63:51	0:0	8	=
water	63:53	0:0	8	NULL
water	63:57	0:0	8	;
return	64:16	64:33	8	VLC_ENOMEM
water	64:23	0:0	9	VLC_ENOMEM
water	65:12	0:0	8	}
for	66:12	69:12	6	( uint8_t i = 0 ;i < i_sect;i ++)
forinit	0:0	66:28	7	 uint8_t i = 0 ;
decl	66:17	66:28	8	uint8_t	i
op	66:26	0:0	8	=
water	66:27	0:0	8	0
cond	66:30	66:34	7	i < i_sect
water	66:30	0:0	8	i
op	66:32	0:0	8	<
water	66:34	0:0	8	i_sect
forexpr	66:42	66:43	7	i ++
water	66:42	0:0	8	i
op	66:43	0:0	8	++
stmts	66:47	69:12	7	
water	66:47	0:0	8	{
water	67:16	0:0	8	ps_piece_shape
op	67:30	0:0	8	->
water	67:32	0:0	8	ps_piece_shape_row
op	67:50	0:0	8	[
water	67:51	0:0	8	i_row
op	67:56	0:0	8	]
op	67:57	0:0	8	.
water	67:58	0:0	8	ps_row_section
op	67:72	0:0	8	[
water	67:73	0:0	8	i
op	67:74	0:0	8	]
op	67:75	0:0	8	.
water	67:76	0:0	8	i_type
op	67:83	0:0	8	=
water	67:85	0:0	8	(
water	67:86	0:0	8	i
op	67:87	0:0	8	+
water	67:88	0:0	8	1
water	67:89	0:0	8	)
op	67:91	0:0	8	%
water	67:93	0:0	8	2
water	67:94	0:0	8	;
water	68:16	0:0	8	ps_piece_shape
op	68:30	0:0	8	->
water	68:32	0:0	8	ps_piece_shape_row
op	68:50	0:0	8	[
water	68:51	0:0	8	i_row
op	68:56	0:0	8	]
op	68:57	0:0	8	.
water	68:58	0:0	8	ps_row_section
op	68:72	0:0	8	[
water	68:73	0:0	8	i
op	68:74	0:0	8	]
op	68:75	0:0	8	.
water	68:76	0:0	8	i_width
op	68:84	0:0	8	=
water	68:86	0:0	8	pi_sects
op	68:94	0:0	8	[
water	68:95	0:0	8	i
op	68:96	0:0	8	]
water	68:97	0:0	8	;
water	69:12	0:0	8	}
water	70:8	0:0	6	}
water	71:4	0:0	4	}
return	72:4	72:22	2	VLC_SUCCESS
water	72:11	0:0	3	VLC_SUCCESS
