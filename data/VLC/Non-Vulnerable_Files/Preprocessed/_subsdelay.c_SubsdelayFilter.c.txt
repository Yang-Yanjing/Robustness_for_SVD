func	2:0	38:0	0	static subpicture_t *	SubsdelayFilter
params	2:37	0:0	1	
param	2:39	2:57	2	filter_t *	p_filter
param	2:59	2:82	2	subpicture_t *	p_subpic
stmnts	0:0	37:19	1	
decl	4:4	4:28	2	subsdelay_heap_t	*p_heap
decl	5:4	5:35	2	subsdelay_heap_entry_t	*p_entry
if	6:4	9:4	2	(! p_subpic -> b_subtitle)
cond	6:8	6:19	3	! p_subpic -> b_subtitle
op	6:8	0:0	4	!
water	6:9	0:0	4	p_subpic
op	6:17	0:0	4	->
water	6:19	0:0	4	b_subtitle
stmts	7:4	9:4	3	
water	7:4	0:0	4	{
return	8:8	8:23	4	p_subpic
water	8:15	0:0	5	p_subpic
water	9:4	0:0	4	}
if	10:4	16:4	2	(SubpicIsEmpty (p_subpic ))
cond	10:8	10:32	3	SubpicIsEmpty (p_subpic )
call	10:8	10:32	4	SubpicIsEmpty
arg	10:23	10:32	5	p_subpic
water	10:23	0:0	6	p_subpic
stmts	11:4	16:4	3	
water	11:4	0:0	4	{
call	14:8	14:36	4	subpicture_Delete
arg	14:27	14:36	5	p_subpic
water	14:27	0:0	6	p_subpic
water	14:37	0:0	4	;
return	15:8	15:19	4	NULL
water	15:15	0:0	5	NULL
water	16:4	0:0	4	}
water	17:4	0:0	2	p_heap
op	17:11	0:0	2	=
op	17:13	0:0	2	&
water	17:14	0:0	2	p_filter
op	17:22	0:0	2	->
water	17:24	0:0	2	p_sys
op	17:29	0:0	2	->
water	17:31	0:0	2	heap
water	17:35	0:0	2	;
call	19:4	19:30	2	SubsdelayHeapLock
arg	19:23	19:30	3	p_heap
water	19:23	0:0	4	p_heap
water	19:31	0:0	2	;
water	20:4	0:0	2	p_entry
op	20:12	0:0	2	=
call	20:14	20:60	2	SubsdelayHeapPush
arg	20:33	20:39	3	p_heap
water	20:33	0:0	4	p_heap
arg	20:41	20:49	3	p_subpic
water	20:41	0:0	4	p_subpic
arg	20:51	20:60	3	p_filter
water	20:51	0:0	4	p_filter
water	20:61	0:0	2	;
if	21:4	26:4	2	(! p_entry)
cond	21:8	21:9	3	! p_entry
op	21:8	0:0	4	!
water	21:9	0:0	4	p_entry
stmts	22:4	26:4	3	
water	22:4	0:0	4	{
call	23:8	23:36	4	SubsdelayHeapUnlock
arg	23:29	23:36	5	p_heap
water	23:29	0:0	6	p_heap
water	23:37	0:0	4	;
call	24:8	24:60	4	msg_Err
arg	24:16	24:24	5	p_filter
water	24:16	0:0	6	p_filter
arg	24:26	24:60	5	"Can't add subpicture to the heap"
water	24:26	0:0	6	"Can't add subpicture to the heap"
water	24:61	0:0	4	;
return	25:8	25:23	4	p_subpic
water	25:15	0:0	5	p_subpic
water	26:4	0:0	4	}
water	27:4	0:0	2	p_subpic
op	27:13	0:0	2	=
water	27:15	0:0	2	p_entry
op	27:22	0:0	2	->
water	27:24	0:0	2	p_subpic
water	27:32	0:0	2	;
if	28:4	34:4	2	(p_subpic -> b_ephemer)
cond	28:8	28:18	3	p_subpic -> b_ephemer
water	28:8	0:0	4	p_subpic
op	28:16	0:0	4	->
water	28:18	0:0	4	b_ephemer
stmts	29:4	34:4	3	
water	29:4	0:0	4	{
water	32:8	0:0	4	p_subpic
op	32:16	0:0	4	->
water	32:18	0:0	4	i_stop
op	32:25	0:0	4	=
water	32:27	0:0	4	p_subpic
op	32:35	0:0	4	->
water	32:37	0:0	4	i_start
op	32:45	0:0	4	+
water	32:47	0:0	4	20000000
water	32:55	0:0	4	;
water	33:8	0:0	4	p_subpic
op	33:16	0:0	4	->
water	33:18	0:0	4	b_ephemer
op	33:28	0:0	4	=
water	33:30	0:0	4	false
water	33:35	0:0	4	;
water	34:4	0:0	4	}
call	35:4	35:41	2	SubsdelayEnforceDelayRules
arg	35:32	35:41	3	p_filter
water	35:32	0:0	4	p_filter
water	35:42	0:0	2	;
call	36:4	36:32	2	SubsdelayHeapUnlock
arg	36:25	36:32	3	p_heap
water	36:25	0:0	4	p_heap
water	36:33	0:0	2	;
return	37:4	37:19	2	p_subpic
water	37:11	0:0	3	p_subpic
