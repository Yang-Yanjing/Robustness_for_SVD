func	2:0	14:0	0	static void	SubsdelayRecalculateDelays
params	2:38	0:0	1	
param	2:40	2:59	2	filter_t *	p_filter
stmnts	0:0	13:42	1	
decl	4:4	4:34	2	subsdelay_heap_entry_t	*p_curr
for	5:4	12:4	2	(p_curr = p_filter -> p_sys -> heap . p_head ;p_curr != NULL;p_curr = p_curr -> p_next)
forinit	5:9	5:46	3	p_curr = p_filter -> p_sys -> heap . p_head ;
water	5:9	0:0	4	p_curr
op	5:16	0:0	4	=
water	5:18	0:0	4	p_filter
op	5:26	0:0	4	->
water	5:28	0:0	4	p_sys
op	5:33	0:0	4	->
water	5:35	0:0	4	heap
op	5:39	0:0	4	.
water	5:40	0:0	4	p_head
water	5:46	0:0	4	;
cond	5:48	5:58	3	p_curr != NULL
water	5:48	0:0	4	p_curr
op	5:55	0:0	4	!=
water	5:58	0:0	4	NULL
forexpr	5:64	5:81	3	p_curr = p_curr -> p_next
water	5:64	0:0	4	p_curr
op	5:71	0:0	4	=
water	5:73	0:0	4	p_curr
op	5:79	0:0	4	->
water	5:81	0:0	4	p_next
stmts	6:4	12:4	3	
water	6:4	0:0	4	{
if	7:8	11:8	4	(! p_curr -> b_update_ephemer)
cond	7:12	7:21	5	! p_curr -> b_update_ephemer
op	7:12	0:0	6	!
water	7:13	0:0	6	p_curr
op	7:19	0:0	6	->
water	7:21	0:0	6	b_update_ephemer
stmts	8:8	11:8	5	
water	8:8	0:0	6	{
water	9:12	0:0	6	p_curr
op	9:18	0:0	6	->
water	9:20	0:0	6	i_new_stop
op	9:31	0:0	6	=
water	9:33	0:0	6	p_curr
op	9:39	0:0	6	->
water	9:41	0:0	6	p_source
op	9:49	0:0	6	->
water	9:51	0:0	6	i_start
op	9:59	0:0	6	+
call	9:61	9:102	6	SubsdelayEstimateDelay
arg	9:85	9:93	7	p_filter
water	9:85	0:0	8	p_filter
arg	9:95	9:102	7	p_curr
water	9:95	0:0	8	p_curr
water	9:103	0:0	6	;
water	10:12	0:0	6	p_curr
op	10:18	0:0	6	->
water	10:20	0:0	6	b_update_stop
op	10:34	0:0	6	=
water	10:36	0:0	6	false
water	10:41	0:0	6	;
water	11:8	0:0	6	}
water	12:4	0:0	4	}
call	13:4	13:41	2	SubsdelayEnforceDelayRules
arg	13:32	13:41	3	p_filter
water	13:32	0:0	4	p_filter
water	13:42	0:0	2	;
