func	2:0	59:0	0	static void	dvbsub_pdata2bpp
params	2:28	0:0	1	
param	2:30	2:37	2	bs_t *	s
param	2:39	2:49	2	uint8_t *	p
param	2:51	2:62	2	int	i_width
param	2:64	2:76	2	int *	pi_off
stmnts	0:0	58:17	1	
decl	4:4	4:23	2	bool	b_stop
op	4:16	0:0	2	=
water	4:18	0:0	2	false
while	5:4	57:4	2	(! b_stop && !bs_eof (s ))
cond	5:11	5:33	3	! b_stop && !bs_eof (s )
op	5:11	0:0	4	!
water	5:12	0:0	4	b_stop
op	5:19	0:0	4	&&
op	5:22	0:0	4	!
call	5:23	5:33	4	bs_eof
arg	5:31	5:33	5	s
water	5:31	0:0	6	s
stmts	6:4	57:4	3	
water	6:4	0:0	4	{
decl	7:8	7:36	4	int	i_count
op	7:20	0:0	4	=
water	7:22	0:0	4	0
water	7:23	0:0	4	,
decl	7:8	7:36	4	int	i_color
op	7:33	0:0	4	=
water	7:35	0:0	4	0
water	8:8	0:0	4	i_color
op	8:16	0:0	4	=
call	8:18	8:32	4	bs_read
arg	8:27	8:28	5	s
water	8:27	0:0	6	s
arg	8:30	8:32	5	2
water	8:30	0:0	6	2
water	8:33	0:0	4	;
if	9:8	12:8	4	(i_color != 0 x00)
cond	9:12	9:24	5	i_color != 0 x00
water	9:12	0:0	6	i_color
op	9:20	0:0	6	!=
water	9:23	0:0	6	0
water	9:24	0:0	6	x00
stmts	10:8	12:8	5	
water	10:8	0:0	6	{
water	11:12	0:0	6	i_count
op	11:20	0:0	6	=
water	11:22	0:0	6	1
water	11:23	0:0	6	;
water	12:8	0:0	6	}
else	13:8	50:8	4
stmts	14:8	50:8	5	
water	14:8	0:0	6	{
if	15:12	19:12	6	(bs_read (s ,1 ) == 0 x01)
cond	15:16	15:36	7	bs_read (s ,1 ) == 0 x01
call	15:16	15:30	8	bs_read
arg	15:25	15:26	9	s
water	15:25	0:0	10	s
arg	15:28	15:30	9	1
water	15:28	0:0	10	1
op	15:32	0:0	8	==
water	15:35	0:0	8	0
water	15:36	0:0	8	x01
stmts	16:12	19:12	7	
water	16:12	0:0	8	{
water	17:16	0:0	8	i_count
op	17:24	0:0	8	=
water	17:26	0:0	8	3
op	17:28	0:0	8	+
call	17:30	17:44	8	bs_read
arg	17:39	17:40	9	s
water	17:39	0:0	10	s
arg	17:42	17:44	9	3
water	17:42	0:0	10	3
water	17:45	0:0	8	;
water	18:16	0:0	8	i_color
op	18:24	0:0	8	=
call	18:26	18:40	8	bs_read
arg	18:35	18:36	9	s
water	18:35	0:0	10	s
arg	18:38	18:40	9	2
water	18:38	0:0	10	2
water	18:41	0:0	8	;
water	19:12	0:0	8	}
else	20:12	49:12	6
stmts	21:12	49:12	7	
water	21:12	0:0	8	{
if	22:16	43:16	8	(bs_read (s ,1 ) == 0 x00)
cond	22:20	22:40	9	bs_read (s ,1 ) == 0 x00
call	22:20	22:34	10	bs_read
arg	22:29	22:30	11	s
water	22:29	0:0	12	s
arg	22:32	22:34	11	1
water	22:32	0:0	12	1
op	22:36	0:0	10	==
water	22:39	0:0	10	0
water	22:40	0:0	10	x00
stmts	23:16	43:16	9	
water	23:16	0:0	10	{
switch	24:20	42:20	10	(bs_read (s ,2 ))
cond	24:28	24:42	11	bs_read (s ,2 )
call	24:28	24:42	12	bs_read
arg	24:37	24:38	13	s
water	24:37	0:0	14	s
arg	24:40	24:42	13	2
water	24:40	0:0	14	2
stmts	25:20	42:20	11	
water	25:20	0:0	12	{
label	26:20	26:29	12	case 0 x00 :
water	27:24	0:0	12	b_stop
op	27:31	0:0	12	=
water	27:33	0:0	12	true
water	27:37	0:0	12	;
break	28:24	28:29	12	
label	29:20	29:29	12	case 0 x01 :
water	30:24	0:0	12	i_count
op	30:32	0:0	12	=
water	30:34	0:0	12	2
water	30:35	0:0	12	;
break	31:24	31:29	12	
label	32:20	32:29	12	case 0 x02 :
water	33:24	0:0	12	i_count
op	33:32	0:0	12	=
water	33:35	0:0	12	12
op	33:38	0:0	12	+
call	33:40	33:54	12	bs_read
arg	33:49	33:50	13	s
water	33:49	0:0	14	s
arg	33:52	33:54	13	4
water	33:52	0:0	14	4
water	33:55	0:0	12	;
water	34:24	0:0	12	i_color
op	34:32	0:0	12	=
call	34:34	34:48	12	bs_read
arg	34:43	34:44	13	s
water	34:43	0:0	14	s
arg	34:46	34:48	13	2
water	34:46	0:0	14	2
water	34:49	0:0	12	;
break	35:24	35:29	12	
label	36:20	36:29	12	case 0 x03 :
water	37:24	0:0	12	i_count
op	37:32	0:0	12	=
water	37:35	0:0	12	29
op	37:38	0:0	12	+
call	37:40	37:54	12	bs_read
arg	37:49	37:50	13	s
water	37:49	0:0	14	s
arg	37:52	37:54	13	8
water	37:52	0:0	14	8
water	37:55	0:0	12	;
water	38:24	0:0	12	i_color
op	38:32	0:0	12	=
call	38:34	38:48	12	bs_read
arg	38:43	38:44	13	s
water	38:43	0:0	14	s
arg	38:46	38:48	13	2
water	38:46	0:0	14	2
water	38:49	0:0	12	;
break	39:24	39:29	12	
label	40:20	40:27	12	default :
break	41:24	41:29	12	
water	42:20	0:0	12	}
water	43:16	0:0	10	}
else	44:16	48:16	8
stmts	45:16	48:16	9	
water	45:16	0:0	10	{
water	47:20	0:0	10	i_count
op	47:28	0:0	10	=
water	47:30	0:0	10	1
water	47:31	0:0	10	;
water	48:16	0:0	10	}
water	49:12	0:0	8	}
water	50:8	0:0	6	}
if	51:8	51:31	4	(! i_count)
cond	51:12	51:13	5	! i_count
op	51:12	0:0	6	!
water	51:13	0:0	6	i_count
stmts	51:23	51:31	5	
continue	51:23	51:31	6	
if	53:8	53:51	4	(( i_count + * pi_off ) > i_width)
cond	53:12	53:36	5	( i_count + * pi_off ) > i_width
water	53:12	0:0	6	(
water	53:14	0:0	6	i_count
op	53:22	0:0	6	+
op	53:24	0:0	6	*
water	53:25	0:0	6	pi_off
water	53:32	0:0	6	)
op	53:34	0:0	6	>
water	53:36	0:0	6	i_width
stmts	53:46	53:51	5	
break	53:46	53:51	6	
if	54:8	54:47	4	(i_count == 1)
cond	54:12	54:23	5	i_count == 1
water	54:12	0:0	6	i_count
op	54:20	0:0	6	==
water	54:23	0:0	6	1
stmts	54:27	54:47	5	
water	54:27	0:0	6	p
op	54:28	0:0	6	[
op	54:29	0:0	6	*
water	54:30	0:0	6	pi_off
op	54:36	0:0	6	]
op	54:38	0:0	6	=
water	54:40	0:0	6	i_color
water	54:47	0:0	6	;
else	55:8	55:56	4
stmts	55:13	55:56	5	
call	55:13	55:55	6	memset
arg	55:21	55:36	7	(p+*pi_off)
water	55:21	0:0	8	(
water	55:23	0:0	8	p
op	55:25	0:0	8	+
op	55:27	0:0	8	*
water	55:28	0:0	8	pi_off
water	55:35	0:0	8	)
arg	55:38	55:45	7	i_color
water	55:38	0:0	8	i_color
arg	55:47	55:55	7	i_count
water	55:47	0:0	8	i_count
water	55:56	0:0	6	;
water	56:8	0:0	4	(
op	56:9	0:0	4	*
water	56:10	0:0	4	pi_off
water	56:16	0:0	4	)
op	56:18	0:0	4	+=
water	56:21	0:0	4	i_count
water	56:28	0:0	4	;
water	57:4	0:0	4	}
call	58:4	58:16	2	bs_align
arg	58:14	58:16	3	s
water	58:14	0:0	4	s
water	58:17	0:0	2	;
