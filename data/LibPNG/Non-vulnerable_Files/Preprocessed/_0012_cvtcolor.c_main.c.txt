func	1:0	115:0	0	int	main
params	2:4	0:0	1	
param	2:5	2:13	2	int	argc
param	2:15	2:32	2	const char * *	argv
stmnts	0:0	114:11	1	
decl	4:3	4:29	2	const char	*prog
op	4:20	0:0	2	=
op	4:22	0:0	2	*
water	4:23	0:0	2	argv
op	4:27	0:0	2	++
decl	5:3	5:47	2	int	to_linear
op	5:17	0:0	2	=
water	5:19	0:0	2	0
water	5:20	0:0	2	,
decl	5:3	5:47	2	int	to_gray
op	5:30	0:0	2	=
water	5:32	0:0	2	0
water	5:33	0:0	2	,
decl	5:3	5:47	2	int	to_color
op	5:44	0:0	2	=
water	5:46	0:0	2	0
decl	6:3	6:19	2	int	channels
op	6:16	0:0	2	=
water	6:18	0:0	2	0
decl	7:3	7:14	2	double	c[4]
call	12:3	12:26	2	fesetround
arg	12:14	12:26	3	FE_TONEAREST
water	12:14	0:0	4	FE_TONEAREST
water	12:27	0:0	2	;
water	13:3	0:0	2	c
op	13:4	0:0	2	[
water	13:5	0:0	2	3
op	13:6	0:0	2	]
op	13:8	0:0	2	=
water	13:10	0:0	2	c
op	13:11	0:0	2	[
water	13:12	0:0	2	2
op	13:13	0:0	2	]
op	13:15	0:0	2	=
water	13:17	0:0	2	c
op	13:18	0:0	2	[
water	13:19	0:0	2	1
op	13:20	0:0	2	]
op	13:22	0:0	2	=
water	13:24	0:0	2	c
op	13:25	0:0	2	[
water	13:26	0:0	2	0
op	13:27	0:0	2	]
op	13:29	0:0	2	=
water	13:31	0:0	2	0
water	13:32	0:0	2	;
while	14:3	27:3	2	(-- argc > 0 && * * argv == '-')
cond	14:10	14:34	3	-- argc > 0 && * * argv == '-'
op	14:10	0:0	4	--
water	14:12	0:0	4	argc
op	14:17	0:0	4	>
water	14:19	0:0	4	0
op	14:21	0:0	4	&&
op	14:24	0:0	4	*
op	14:25	0:0	4	*
water	14:26	0:0	4	argv
op	14:31	0:0	4	==
water	14:34	0:0	4	'-'
stmts	15:3	27:3	3	
water	15:3	0:0	4	{
decl	16:6	16:33	4	const char	*arg
op	16:22	0:0	4	=
water	16:24	0:0	4	1
op	16:25	0:0	4	+
op	16:26	0:0	4	*
water	16:27	0:0	4	argv
op	16:31	0:0	4	++
if	17:6	18:22	4	(strcmp (arg ,"sRGB" ) == 0)
cond	17:10	17:33	5	strcmp (arg ,"sRGB" ) == 0
call	17:10	17:28	6	strcmp
arg	17:17	17:20	7	arg
water	17:17	0:0	8	arg
arg	17:22	17:28	7	"sRGB"
water	17:22	0:0	8	"sRGB"
op	17:30	0:0	6	==
water	17:33	0:0	6	0
stmts	18:9	18:22	5	
water	18:9	0:0	6	to_linear
op	18:19	0:0	6	=
water	18:21	0:0	6	0
water	18:22	0:0	6	;
else	19:6	20:22	4
stmts	19:11	20:22	5	
if	19:11	20:22	6	(strcmp (arg ,"linear" ) == 0)
cond	19:15	19:40	7	strcmp (arg ,"linear" ) == 0
call	19:15	19:35	8	strcmp
arg	19:22	19:25	9	arg
water	19:22	0:0	10	arg
arg	19:27	19:35	9	"linear"
water	19:27	0:0	10	"linear"
op	19:37	0:0	8	==
water	19:40	0:0	8	0
stmts	20:9	20:22	7	
water	20:9	0:0	8	to_linear
op	20:19	0:0	8	=
water	20:21	0:0	8	1
water	20:22	0:0	8	;
else	21:6	22:34	4
stmts	21:11	22:34	5	
if	21:11	22:34	6	(strcmp (arg ,"gray" ) == 0)
cond	21:15	21:38	7	strcmp (arg ,"gray" ) == 0
call	21:15	21:33	8	strcmp
arg	21:22	21:25	9	arg
water	21:22	0:0	10	arg
arg	21:27	21:33	9	"gray"
water	21:27	0:0	10	"gray"
op	21:35	0:0	8	==
water	21:38	0:0	8	0
stmts	22:9	22:34	7	
water	22:9	0:0	8	to_gray
op	22:17	0:0	8	=
water	22:19	0:0	8	1
water	22:20	0:0	8	,
water	22:22	0:0	8	to_color
op	22:31	0:0	8	=
water	22:33	0:0	8	0
water	22:34	0:0	8	;
else	23:6	24:34	4
stmts	23:11	24:34	5	
if	23:11	24:34	6	(strcmp (arg ,"color" ) == 0)
cond	23:15	23:39	7	strcmp (arg ,"color" ) == 0
call	23:15	23:34	8	strcmp
arg	23:22	23:25	9	arg
water	23:22	0:0	10	arg
arg	23:27	23:34	9	"color"
water	23:27	0:0	10	"color"
op	23:36	0:0	8	==
water	23:39	0:0	8	0
stmts	24:9	24:34	7	
water	24:9	0:0	8	to_gray
op	24:17	0:0	8	=
water	24:19	0:0	8	0
water	24:20	0:0	8	,
water	24:22	0:0	8	to_color
op	24:31	0:0	8	=
water	24:33	0:0	8	1
water	24:34	0:0	8	;
else	25:6	26:20	4
stmts	26:9	26:20	5	
call	26:9	26:19	6	usage
arg	26:15	26:19	7	prog
water	26:15	0:0	8	prog
water	26:20	0:0	6	;
water	27:3	0:0	4	}
switch	28:3	46:6	2	(argc)
cond	28:11	28:11	3	argc
water	28:11	0:0	4	argc
stmts	29:3	46:6	3	
water	29:3	0:0	4	{
label	30:6	30:13	4	default :
call	31:9	31:19	4	usage
arg	31:15	31:19	5	prog
water	31:15	0:0	6	prog
water	31:20	0:0	4	;
break	32:9	32:14	4	
label	33:6	33:12	4	case 4 :
water	34:9	0:0	4	c
op	34:10	0:0	4	[
water	34:11	0:0	4	3
op	34:12	0:0	4	]
op	34:14	0:0	4	=
call	34:16	34:50	4	component
arg	34:26	34:30	5	prog
water	34:26	0:0	6	prog
arg	34:32	34:39	5	argv[3]
water	34:32	0:0	6	argv
op	34:36	0:0	6	[
water	34:37	0:0	6	3
op	34:38	0:0	6	]
arg	34:41	34:50	5	to_linear
water	34:41	0:0	6	to_linear
water	34:51	0:0	4	;
op	35:9	0:0	4	++
water	35:11	0:0	4	channels
water	35:19	0:0	4	;
label	36:6	36:12	4	case 3 :
water	37:9	0:0	4	c
op	37:10	0:0	4	[
water	37:11	0:0	4	2
op	37:12	0:0	4	]
op	37:14	0:0	4	=
call	37:16	37:50	4	component
arg	37:26	37:30	5	prog
water	37:26	0:0	6	prog
arg	37:32	37:39	5	argv[2]
water	37:32	0:0	6	argv
op	37:36	0:0	6	[
water	37:37	0:0	6	2
op	37:38	0:0	6	]
arg	37:41	37:50	5	to_linear
water	37:41	0:0	6	to_linear
water	37:51	0:0	4	;
op	38:9	0:0	4	++
water	38:11	0:0	4	channels
water	38:19	0:0	4	;
label	39:6	39:12	4	case 2 :
water	40:9	0:0	4	c
op	40:10	0:0	4	[
water	40:11	0:0	4	1
op	40:12	0:0	4	]
op	40:14	0:0	4	=
call	40:16	40:50	4	component
arg	40:26	40:30	5	prog
water	40:26	0:0	6	prog
arg	40:32	40:39	5	argv[1]
water	40:32	0:0	6	argv
op	40:36	0:0	6	[
water	40:37	0:0	6	1
op	40:38	0:0	6	]
arg	40:41	40:50	5	to_linear
water	40:41	0:0	6	to_linear
water	40:51	0:0	4	;
op	41:9	0:0	4	++
water	41:11	0:0	4	channels
water	41:19	0:0	4	;
label	42:6	42:12	4	case 1 :
water	43:9	0:0	4	c
op	43:10	0:0	4	[
water	43:11	0:0	4	0
op	43:12	0:0	4	]
op	43:14	0:0	4	=
call	43:16	43:50	4	component
arg	43:26	43:30	5	prog
water	43:26	0:0	6	prog
arg	43:32	43:39	5	argv[0]
water	43:32	0:0	6	argv
op	43:36	0:0	6	[
water	43:37	0:0	6	0
op	43:38	0:0	6	]
arg	43:41	43:50	5	to_linear
water	43:41	0:0	6	to_linear
water	43:51	0:0	4	;
op	44:9	0:0	4	++
water	44:11	0:0	4	channels
water	44:19	0:0	4	;
break	45:9	45:14	4	
water	46:6	0:0	4	}
if	47:3	56:3	2	(to_linear)
cond	47:7	47:7	3	to_linear
water	47:7	0:0	4	to_linear
stmts	48:3	56:3	3	
water	48:3	0:0	4	{
decl	49:6	49:11	4	int	i
decl	50:6	50:31	4	int	components
op	50:21	0:0	4	=
water	50:23	0:0	4	channels
if	51:6	52:21	4	(( components & 1 ) == 0)
cond	51:10	51:30	5	( components & 1 ) == 0
water	51:10	0:0	6	(
water	51:11	0:0	6	components
op	51:22	0:0	6	&
water	51:24	0:0	6	1
water	51:25	0:0	6	)
op	51:27	0:0	6	==
water	51:30	0:0	6	0
stmts	52:9	52:21	5	
op	52:9	0:0	6	--
water	52:11	0:0	6	components
water	52:21	0:0	6	;
for	53:6	53:70	4	(i = 0 ;i < components;++ i)
forinit	53:11	53:14	5	i = 0 ;
water	53:11	0:0	6	i
op	53:12	0:0	6	=
water	53:13	0:0	6	0
water	53:14	0:0	6	;
cond	53:16	53:18	5	i < components
water	53:16	0:0	6	i
op	53:17	0:0	6	<
water	53:18	0:0	6	components
forexpr	53:30	53:32	5	++ i
op	53:30	0:0	6	++
water	53:32	0:0	6	i
stmts	53:35	53:70	5	
water	53:35	0:0	6	c
op	53:36	0:0	6	[
water	53:37	0:0	6	i
op	53:38	0:0	6	]
op	53:40	0:0	6	=
call	53:42	53:69	6	linear_from_sRGB
arg	53:59	53:69	7	c[i]/255
water	53:59	0:0	8	c
op	53:60	0:0	8	[
water	53:61	0:0	8	i
op	53:62	0:0	8	]
op	53:64	0:0	8	/
water	53:66	0:0	8	255
water	53:70	0:0	6	;
if	54:6	55:44	4	(components < channels)
cond	54:10	54:23	5	components < channels
water	54:10	0:0	6	components
op	54:21	0:0	6	<
water	54:23	0:0	6	channels
stmts	55:9	55:44	5	
water	55:9	0:0	6	c
op	55:10	0:0	6	[
water	55:11	0:0	6	components
op	55:21	0:0	6	]
op	55:23	0:0	6	=
water	55:25	0:0	6	c
op	55:26	0:0	6	[
water	55:27	0:0	6	components
op	55:37	0:0	6	]
op	55:39	0:0	6	/
water	55:41	0:0	6	255
water	55:44	0:0	6	;
water	56:3	0:0	4	}
else	57:3	69:3	2
stmts	58:3	69:3	3	
water	58:3	0:0	4	{
decl	59:6	59:11	4	int	i
for	60:6	60:39	4	(i = 0 ;i < 4;++ i)
forinit	60:11	60:14	5	i = 0 ;
water	60:11	0:0	6	i
op	60:12	0:0	6	=
water	60:13	0:0	6	0
water	60:14	0:0	6	;
cond	60:16	60:18	5	i < 4
water	60:16	0:0	6	i
op	60:17	0:0	6	<
water	60:18	0:0	6	4
forexpr	60:21	60:23	5	++ i
op	60:21	0:0	6	++
water	60:23	0:0	6	i
stmts	60:26	60:39	5	
water	60:26	0:0	6	c
op	60:27	0:0	6	[
water	60:28	0:0	6	i
op	60:29	0:0	6	]
op	60:31	0:0	6	/=
water	60:34	0:0	6	65535
water	60:39	0:0	6	;
if	61:6	68:6	4	(( channels & 1 ) == 0)
cond	61:10	61:28	5	( channels & 1 ) == 0
water	61:10	0:0	6	(
water	61:11	0:0	6	channels
op	61:20	0:0	6	&
water	61:22	0:0	6	1
water	61:23	0:0	6	)
op	61:25	0:0	6	==
water	61:28	0:0	6	0
stmts	62:6	68:6	5	
water	62:6	0:0	6	{
decl	63:9	63:37	6	double	alpha
op	63:22	0:0	6	=
water	63:24	0:0	6	c
op	63:25	0:0	6	[
water	63:26	0:0	6	channels
op	63:34	0:0	6	-
water	63:35	0:0	6	1
op	63:36	0:0	6	]
if	64:9	65:54	6	(alpha > 0)
cond	64:13	64:21	7	alpha > 0
water	64:13	0:0	8	alpha
op	64:19	0:0	8	>
water	64:21	0:0	8	0
stmts	65:12	65:54	7	
for	65:12	65:54	8	(i = 0 ;i < channels - 1;++ i)
forinit	65:17	65:20	9	i = 0 ;
water	65:17	0:0	10	i
op	65:18	0:0	10	=
water	65:19	0:0	10	0
water	65:20	0:0	10	;
cond	65:22	65:33	9	i < channels - 1
water	65:22	0:0	10	i
op	65:23	0:0	10	<
water	65:24	0:0	10	channels
op	65:32	0:0	10	-
water	65:33	0:0	10	1
forexpr	65:36	65:38	9	++ i
op	65:36	0:0	10	++
water	65:38	0:0	10	i
stmts	65:41	65:54	9	
water	65:41	0:0	10	c
op	65:42	0:0	10	[
water	65:43	0:0	10	i
op	65:44	0:0	10	]
op	65:46	0:0	10	/=
water	65:49	0:0	10	alpha
water	65:54	0:0	10	;
else	66:9	67:49	6
stmts	67:12	67:49	7	
for	67:12	67:49	8	(i = 0 ;i < channels - 1;++ i)
forinit	67:17	67:20	9	i = 0 ;
water	67:17	0:0	10	i
op	67:18	0:0	10	=
water	67:19	0:0	10	0
water	67:20	0:0	10	;
cond	67:22	67:33	9	i < channels - 1
water	67:22	0:0	10	i
op	67:23	0:0	10	<
water	67:24	0:0	10	channels
op	67:32	0:0	10	-
water	67:33	0:0	10	1
forexpr	67:36	67:38	9	++ i
op	67:36	0:0	10	++
water	67:38	0:0	10	i
stmts	67:41	67:49	9	
water	67:41	0:0	10	c
op	67:42	0:0	10	[
water	67:43	0:0	10	i
op	67:44	0:0	10	]
op	67:46	0:0	10	=
water	67:48	0:0	10	1
water	67:49	0:0	10	;
water	68:6	0:0	6	}
water	69:3	0:0	4	}
if	70:3	80:3	2	(to_gray)
cond	70:7	70:7	3	to_gray
water	70:7	0:0	4	to_gray
stmts	71:3	80:3	3	
water	71:3	0:0	4	{
if	72:6	77:6	4	(channels < 3)
cond	72:10	72:21	5	channels < 3
water	72:10	0:0	6	channels
op	72:19	0:0	6	<
water	72:21	0:0	6	3
stmts	73:6	77:6	5	
water	73:6	0:0	6	{
call	74:9	75:26	6	fprintf
arg	74:17	74:23	7	stderr
water	74:17	0:0	8	stderr
arg	74:25	74:64	7	"%s: too few channels (%d) for -gray\n"
water	74:25	0:0	8	"%s: too few channels (%d) for -gray\n"
arg	75:12	75:16	7	prog
water	75:12	0:0	8	prog
arg	75:18	75:26	7	channels
water	75:18	0:0	8	channels
water	75:27	0:0	6	;
call	76:9	76:19	6	usage
arg	76:15	76:19	7	prog
water	76:15	0:0	8	prog
water	76:20	0:0	6	;
water	77:6	0:0	6	}
water	78:6	0:0	4	c
op	78:7	0:0	4	[
water	78:8	0:0	4	0
op	78:9	0:0	4	]
op	78:11	0:0	4	=
call	78:13	78:38	4	YfromRGB
arg	78:22	78:26	5	c[0]
water	78:22	0:0	6	c
op	78:23	0:0	6	[
water	78:24	0:0	6	0
op	78:25	0:0	6	]
arg	78:28	78:32	5	c[1]
water	78:28	0:0	6	c
op	78:29	0:0	6	[
water	78:30	0:0	6	1
op	78:31	0:0	6	]
arg	78:34	78:38	5	c[2]
water	78:34	0:0	6	c
op	78:35	0:0	6	[
water	78:36	0:0	6	2
op	78:37	0:0	6	]
water	78:39	0:0	4	;
water	79:6	0:0	4	channels
op	79:15	0:0	4	-=
water	79:18	0:0	4	2
water	79:19	0:0	4	;
water	80:3	0:0	4	}
if	81:3	91:3	2	(to_color)
cond	81:7	81:7	3	to_color
water	81:7	0:0	4	to_color
stmts	82:3	91:3	3	
water	82:3	0:0	4	{
if	83:6	88:6	4	(channels > 2)
cond	83:10	83:21	5	channels > 2
water	83:10	0:0	6	channels
op	83:19	0:0	6	>
water	83:21	0:0	6	2
stmts	84:6	88:6	5	
water	84:6	0:0	6	{
call	85:9	86:26	6	fprintf
arg	85:17	85:23	7	stderr
water	85:17	0:0	8	stderr
arg	85:25	85:66	7	"%s: too many channels (%d) for -color\n"
water	85:25	0:0	8	"%s: too many channels (%d) for -color\n"
arg	86:12	86:16	7	prog
water	86:12	0:0	8	prog
arg	86:18	86:26	7	channels
water	86:18	0:0	8	channels
water	86:27	0:0	6	;
call	87:9	87:19	6	usage
arg	87:15	87:19	7	prog
water	87:15	0:0	8	prog
water	87:20	0:0	6	;
water	88:6	0:0	6	}
water	89:6	0:0	4	c
op	89:7	0:0	4	[
water	89:8	0:0	4	3
op	89:9	0:0	4	]
op	89:11	0:0	4	=
water	89:13	0:0	4	c
op	89:14	0:0	4	[
water	89:15	0:0	4	1
op	89:16	0:0	4	]
water	89:17	0:0	4	;
water	90:6	0:0	4	c
op	90:7	0:0	4	[
water	90:8	0:0	4	2
op	90:9	0:0	4	]
op	90:11	0:0	4	=
water	90:13	0:0	4	c
op	90:14	0:0	4	[
water	90:15	0:0	4	1
op	90:16	0:0	4	]
op	90:18	0:0	4	=
water	90:20	0:0	4	c
op	90:21	0:0	4	[
water	90:22	0:0	4	0
op	90:23	0:0	4	]
water	90:24	0:0	4	;
water	91:3	0:0	4	}
if	92:3	101:3	2	(to_linear)
cond	92:7	92:7	3	to_linear
water	92:7	0:0	4	to_linear
stmts	93:3	101:3	3	
water	93:3	0:0	4	{
decl	94:6	94:11	4	int	i
if	95:6	99:6	4	(( channels & 1 ) == 0)
cond	95:10	95:28	5	( channels & 1 ) == 0
water	95:10	0:0	6	(
water	95:11	0:0	6	channels
op	95:20	0:0	6	&
water	95:22	0:0	6	1
water	95:23	0:0	6	)
op	95:25	0:0	6	==
water	95:28	0:0	6	0
stmts	96:6	99:6	5	
water	96:6	0:0	6	{
decl	97:9	97:37	6	double	alpha
op	97:22	0:0	6	=
water	97:24	0:0	6	c
op	97:25	0:0	6	[
water	97:26	0:0	6	channels
op	97:34	0:0	6	-
water	97:35	0:0	6	1
op	97:36	0:0	6	]
for	98:9	98:51	6	(i = 0 ;i < channels - 1;++ i)
forinit	98:14	98:17	7	i = 0 ;
water	98:14	0:0	8	i
op	98:15	0:0	8	=
water	98:16	0:0	8	0
water	98:17	0:0	8	;
cond	98:19	98:30	7	i < channels - 1
water	98:19	0:0	8	i
op	98:20	0:0	8	<
water	98:21	0:0	8	channels
op	98:29	0:0	8	-
water	98:30	0:0	8	1
forexpr	98:33	98:35	7	++ i
op	98:33	0:0	8	++
water	98:35	0:0	8	i
stmts	98:38	98:51	7	
water	98:38	0:0	8	c
op	98:39	0:0	8	[
water	98:40	0:0	8	i
op	98:41	0:0	8	]
op	98:43	0:0	8	*=
water	98:46	0:0	8	alpha
water	98:51	0:0	8	;
water	99:6	0:0	6	}
for	100:6	100:63	4	(i = 0 ;i < channels;++ i)
forinit	100:11	100:14	5	i = 0 ;
water	100:11	0:0	6	i
op	100:12	0:0	6	=
water	100:13	0:0	6	0
water	100:14	0:0	6	;
cond	100:16	100:18	5	i < channels
water	100:16	0:0	6	i
op	100:17	0:0	6	<
water	100:18	0:0	6	channels
forexpr	100:28	100:30	5	++ i
op	100:28	0:0	6	++
water	100:30	0:0	6	i
stmts	100:33	100:63	5	
water	100:33	0:0	6	c
op	100:34	0:0	6	[
water	100:35	0:0	6	i
op	100:36	0:0	6	]
op	100:38	0:0	6	=
call	100:40	100:62	6	nearbyint
arg	100:50	100:62	7	c[i]*65535
water	100:50	0:0	8	c
op	100:51	0:0	8	[
water	100:52	0:0	8	i
op	100:53	0:0	8	]
op	100:55	0:0	8	*
water	100:57	0:0	8	65535
water	100:63	0:0	6	;
water	101:3	0:0	4	}
else	102:3	108:3	2
stmts	103:3	108:3	3	
water	103:3	0:0	4	{
decl	104:6	104:29	4	int	i
op	104:12	0:0	4	=
water	104:14	0:0	4	(
water	104:15	0:0	4	channels
op	104:23	0:0	4	+
water	104:24	0:0	4	1
water	104:25	0:0	4	)
op	104:26	0:0	4	&
water	104:27	0:0	4	~1
while	105:6	106:38	4	(-- i >= 0)
cond	105:13	105:20	5	-- i >= 0
op	105:13	0:0	6	--
water	105:15	0:0	6	i
op	105:17	0:0	6	>=
water	105:20	0:0	6	0
stmts	106:9	106:38	5	
water	106:9	0:0	6	c
op	106:10	0:0	6	[
water	106:11	0:0	6	i
op	106:12	0:0	6	]
op	106:14	0:0	6	=
call	106:16	106:37	6	sRGB_from_linear
arg	106:33	106:37	7	c[i]
water	106:33	0:0	8	c
op	106:34	0:0	8	[
water	106:35	0:0	8	i
op	106:36	0:0	8	]
water	106:38	0:0	6	;
for	107:6	107:61	4	(i = 0 ;i < channels;++ i)
forinit	107:11	107:14	5	i = 0 ;
water	107:11	0:0	6	i
op	107:12	0:0	6	=
water	107:13	0:0	6	0
water	107:14	0:0	6	;
cond	107:16	107:18	5	i < channels
water	107:16	0:0	6	i
op	107:17	0:0	6	<
water	107:18	0:0	6	channels
forexpr	107:28	107:30	5	++ i
op	107:28	0:0	6	++
water	107:30	0:0	6	i
stmts	107:33	107:61	5	
water	107:33	0:0	6	c
op	107:34	0:0	6	[
water	107:35	0:0	6	i
op	107:36	0:0	6	]
op	107:38	0:0	6	=
call	107:40	107:60	6	nearbyint
arg	107:50	107:60	7	c[i]*255
water	107:50	0:0	8	c
op	107:51	0:0	8	[
water	107:52	0:0	8	i
op	107:53	0:0	8	]
op	107:55	0:0	8	*
water	107:57	0:0	8	255
water	107:61	0:0	6	;
water	108:3	0:0	4	}
water	109:3	0:0	2	{
decl	110:6	110:11	2	int	i
for	111:6	111:52	2	(i = 0 ;i < channels;++ i)
forinit	111:11	111:14	3	i = 0 ;
water	111:11	0:0	4	i
op	111:12	0:0	4	=
water	111:13	0:0	4	0
water	111:14	0:0	4	;
cond	111:16	111:18	3	i < channels
water	111:16	0:0	4	i
op	111:17	0:0	4	<
water	111:18	0:0	4	channels
forexpr	111:28	111:30	3	++ i
op	111:28	0:0	4	++
water	111:30	0:0	4	i
stmts	111:33	111:52	3	
call	111:33	111:51	4	printf
arg	111:40	111:45	5	" %g"
water	111:40	0:0	6	" %g"
arg	111:47	111:51	5	c[i]
water	111:47	0:0	6	c
op	111:48	0:0	6	[
water	111:49	0:0	6	i
op	111:50	0:0	6	]
water	111:52	0:0	4	;
water	112:3	0:0	2	}
call	113:3	113:14	2	printf
arg	113:10	113:14	3	"\n"
water	113:10	0:0	4	"\n"
water	113:15	0:0	2	;
return	114:3	114:11	2	0
water	114:10	0:0	3	0
