func	1:0	89:0	0	static int	PixarLogEncode
params	2:14	0:0	1	
param	2:15	2:24	2	TIFF *	tif
param	2:26	2:35	2	uint8 *	bp
param	2:37	2:48	2	tmsize_t	cc
param	2:50	2:58	2	uint16	s
stmnts	4:1	88:11	1	
water	4:1	0:0	2	static
water	4:8	0:0	2	const
water	4:14	0:0	2	char
water	4:19	0:0	2	module
op	4:25	0:0	2	[
op	4:26	0:0	2	]
op	4:28	0:0	2	=
water	4:30	0:0	2	"PixarLogEncode"
water	4:46	0:0	2	;
decl	5:1	5:34	2	TIFFDirectory	*td
op	5:19	0:0	2	=
op	5:21	0:0	2	&
water	5:22	0:0	2	tif
op	5:25	0:0	2	->
water	5:27	0:0	2	tif_dir
decl	6:1	6:38	2	PixarLogState	*sp
op	6:19	0:0	2	=
call	6:21	6:37	3	EncoderState
arg	6:34	6:37	4	tif
water	6:34	0:0	5	tif
decl	7:1	7:11	2	tmsize_t	i
decl	8:1	8:11	2	tmsize_t	n
decl	9:1	9:9	2	int	llen
decl	10:1	10:20	2	unsigned short	*up
water	11:1	0:0	2	(
water	11:2	0:0	2	void
water	11:6	0:0	2	)
water	11:8	0:0	2	s
water	11:9	0:0	2	;
switch	12:1	30:1	2	(sp -> user_datafmt)
cond	12:9	12:13	3	sp -> user_datafmt
water	12:9	0:0	4	sp
op	12:11	0:0	4	->
water	12:13	0:0	4	user_datafmt
stmts	12:27	30:1	3	
water	12:27	0:0	4	{
label	13:1	13:27	4	case PIXARLOGDATAFMT_FLOAT :
water	14:2	0:0	4	n
op	14:4	0:0	4	=
water	14:6	0:0	4	cc
op	14:9	0:0	4	/
op	14:11	0:0	4	sizeof
water	14:17	0:0	4	(
water	14:18	0:0	4	float
water	14:23	0:0	4	)
water	14:24	0:0	4	;
break	15:2	15:7	4	
label	16:1	16:27	4	case PIXARLOGDATAFMT_16BIT :
label	17:1	17:32	4	case PIXARLOGDATAFMT_12BITPICIO :
label	18:1	18:30	4	case PIXARLOGDATAFMT_11BITLOG :
water	19:2	0:0	4	n
op	19:4	0:0	4	=
water	19:6	0:0	4	cc
op	19:9	0:0	4	/
op	19:11	0:0	4	sizeof
water	19:17	0:0	4	(
water	19:18	0:0	4	uint16
water	19:24	0:0	4	)
water	19:25	0:0	4	;
break	20:2	20:7	4	
label	21:1	21:26	4	case PIXARLOGDATAFMT_8BIT :
label	22:1	22:30	4	case PIXARLOGDATAFMT_8BITABGR :
water	23:2	0:0	4	n
op	23:4	0:0	4	=
water	23:6	0:0	4	cc
water	23:8	0:0	4	;
break	24:2	24:7	4	
label	25:1	25:8	4	default :
call	26:2	28:23	4	TIFFErrorExt
arg	26:15	26:34	5	tif->tif_clientdata
water	26:15	0:0	6	tif
op	26:18	0:0	6	->
water	26:20	0:0	6	tif_clientdata
arg	26:36	26:42	5	module
water	26:36	0:0	6	module
arg	27:3	27:43	5	"%d bit input not supported in PixarLog"
water	27:3	0:0	6	"%d bit input not supported in PixarLog"
arg	28:3	28:23	5	td->td_bitspersample
water	28:3	0:0	6	td
op	28:5	0:0	6	->
water	28:7	0:0	6	td_bitspersample
water	28:24	0:0	4	;
return	29:2	29:10	4	0
water	29:9	0:0	5	0
water	30:1	0:0	4	}
water	31:1	0:0	2	llen
op	31:6	0:0	2	=
water	31:8	0:0	2	sp
op	31:10	0:0	2	->
water	31:12	0:0	2	stride
op	31:19	0:0	2	*
water	31:21	0:0	2	td
op	31:23	0:0	2	->
water	31:25	0:0	2	td_imagewidth
water	31:38	0:0	2	;
if	33:4	38:4	2	(n >( tmsize_t ) (td -> td_rowsperstrip * llen ))
cond	33:8	33:49	3	n >( tmsize_t ) (td -> td_rowsperstrip * llen )
water	33:8	0:0	4	n
op	33:10	0:0	4	>
call	33:12	33:49	4	(tmsize_t)
arg	33:23	33:49	5	td->td_rowsperstrip*llen
water	33:23	0:0	6	td
op	33:25	0:0	6	->
water	33:27	0:0	6	td_rowsperstrip
op	33:43	0:0	6	*
water	33:45	0:0	6	llen
stmts	34:4	38:4	3	
water	34:4	0:0	4	{
call	35:8	36:52	4	TIFFErrorExt
arg	35:21	35:40	5	tif->tif_clientdata
water	35:21	0:0	6	tif
op	35:24	0:0	6	->
water	35:26	0:0	6	tif_clientdata
arg	35:42	35:48	5	module
water	35:42	0:0	6	module
arg	36:21	36:52	5	"Too many input bytes provided"
water	36:21	0:0	6	"Too many input bytes provided"
water	36:53	0:0	4	;
return	37:8	37:16	4	0
water	37:15	0:0	5	0
water	38:4	0:0	4	}
for	39:1	62:1	2	(i = 0 , up = sp -> tbuf ;i < n;i += llen , up += llen)
forinit	39:6	39:26	3	i = 0 , up = sp -> tbuf ;
water	39:6	0:0	4	i
op	39:8	0:0	4	=
water	39:10	0:0	4	0
water	39:11	0:0	4	,
water	39:13	0:0	4	up
op	39:16	0:0	4	=
water	39:18	0:0	4	sp
op	39:20	0:0	4	->
water	39:22	0:0	4	tbuf
water	39:26	0:0	4	;
cond	39:28	39:32	3	i < n
water	39:28	0:0	4	i
op	39:30	0:0	4	<
water	39:32	0:0	4	n
forexpr	39:35	39:52	3	i += llen , up += llen
water	39:35	0:0	4	i
op	39:37	0:0	4	+=
water	39:40	0:0	4	llen
water	39:44	0:0	4	,
water	39:46	0:0	4	up
op	39:49	0:0	4	+=
water	39:52	0:0	4	llen
stmts	39:58	62:1	3	
water	39:58	0:0	4	{
switch	40:2	61:2	4	(sp -> user_datafmt)
cond	40:10	40:14	5	sp -> user_datafmt
water	40:10	0:0	6	sp
op	40:12	0:0	6	->
water	40:14	0:0	6	user_datafmt
stmts	40:29	61:2	5	
water	40:29	0:0	6	{
label	41:2	41:28	6	case PIXARLOGDATAFMT_FLOAT :
call	42:3	43:31	6	horizontalDifferenceF
arg	42:25	42:36	7	(float*)bp
water	42:25	0:0	8	(
water	42:26	0:0	8	float
op	42:32	0:0	8	*
water	42:33	0:0	8	)
water	42:34	0:0	8	bp
arg	42:38	42:42	7	llen
water	42:38	0:0	8	llen
arg	43:4	43:14	7	sp->stride
water	43:4	0:0	8	sp
op	43:6	0:0	8	->
water	43:8	0:0	8	stride
arg	43:16	43:18	7	up
water	43:16	0:0	8	up
arg	43:20	43:31	7	sp->FromLT2
water	43:20	0:0	8	sp
op	43:22	0:0	8	->
water	43:24	0:0	8	FromLT2
water	43:32	0:0	6	;
water	44:3	0:0	6	bp
op	44:6	0:0	6	+=
water	44:9	0:0	6	llen
op	44:14	0:0	6	*
op	44:16	0:0	6	sizeof
water	44:22	0:0	6	(
water	44:23	0:0	6	float
water	44:28	0:0	6	)
water	44:29	0:0	6	;
break	45:3	45:8	6	
label	46:2	46:28	6	case PIXARLOGDATAFMT_16BIT :
call	47:3	48:30	6	horizontalDifference16
arg	47:26	47:38	7	(uint16*)bp
water	47:26	0:0	8	(
water	47:27	0:0	8	uint16
op	47:34	0:0	8	*
water	47:35	0:0	8	)
water	47:36	0:0	8	bp
arg	47:40	47:44	7	llen
water	47:40	0:0	8	llen
arg	48:4	48:14	7	sp->stride
water	48:4	0:0	8	sp
op	48:6	0:0	8	->
water	48:8	0:0	8	stride
arg	48:16	48:18	7	up
water	48:16	0:0	8	up
arg	48:20	48:30	7	sp->From14
water	48:20	0:0	8	sp
op	48:22	0:0	8	->
water	48:24	0:0	8	From14
water	48:31	0:0	6	;
water	49:3	0:0	6	bp
op	49:6	0:0	6	+=
water	49:9	0:0	6	llen
op	49:14	0:0	6	*
op	49:16	0:0	6	sizeof
water	49:22	0:0	6	(
water	49:23	0:0	6	uint16
water	49:29	0:0	6	)
water	49:30	0:0	6	;
break	50:3	50:8	6	
label	51:2	51:27	6	case PIXARLOGDATAFMT_8BIT :
call	52:3	53:29	6	horizontalDifference8
arg	52:25	52:44	7	(unsignedchar*)bp
water	52:25	0:0	8	(
water	52:26	0:0	8	unsigned
water	52:35	0:0	8	char
op	52:40	0:0	8	*
water	52:41	0:0	8	)
water	52:42	0:0	8	bp
arg	52:46	52:50	7	llen
water	52:46	0:0	8	llen
arg	53:4	53:14	7	sp->stride
water	53:4	0:0	8	sp
op	53:6	0:0	8	->
water	53:8	0:0	8	stride
arg	53:16	53:18	7	up
water	53:16	0:0	8	up
arg	53:20	53:29	7	sp->From8
water	53:20	0:0	8	sp
op	53:22	0:0	8	->
water	53:24	0:0	8	From8
water	53:30	0:0	6	;
water	54:3	0:0	6	bp
op	54:6	0:0	6	+=
water	54:9	0:0	6	llen
op	54:14	0:0	6	*
op	54:16	0:0	6	sizeof
water	54:22	0:0	6	(
water	54:23	0:0	6	unsigned
water	54:32	0:0	6	char
water	54:36	0:0	6	)
water	54:37	0:0	6	;
break	55:3	55:8	6	
label	56:2	56:9	6	default :
call	57:3	59:24	6	TIFFErrorExt
arg	57:16	57:35	7	tif->tif_clientdata
water	57:16	0:0	8	tif
op	57:19	0:0	8	->
water	57:21	0:0	8	tif_clientdata
arg	57:37	57:43	7	module
water	57:37	0:0	8	module
arg	58:4	58:44	7	"%d bit input not supported in PixarLog"
water	58:4	0:0	8	"%d bit input not supported in PixarLog"
arg	59:4	59:24	7	td->td_bitspersample
water	59:4	0:0	8	td
op	59:6	0:0	8	->
water	59:8	0:0	8	td_bitspersample
water	59:25	0:0	6	;
return	60:3	60:11	6	0
water	60:10	0:0	7	0
water	61:2	0:0	6	}
water	62:1	0:0	4	}
water	63:1	0:0	2	sp
op	63:3	0:0	2	->
water	63:5	0:0	2	stream
op	63:11	0:0	2	.
water	63:12	0:0	2	next_in
op	63:20	0:0	2	=
water	63:22	0:0	2	(
water	63:23	0:0	2	unsigned
water	63:32	0:0	2	char
op	63:37	0:0	2	*
water	63:38	0:0	2	)
water	63:40	0:0	2	sp
op	63:42	0:0	2	->
water	63:44	0:0	2	tbuf
water	63:48	0:0	2	;
call	64:1	64:38	2	assert
arg	64:8	64:38	3	sizeof(sp->stream.avail_in)==4
op	64:8	0:0	4	sizeof
water	64:14	0:0	4	(
water	64:15	0:0	4	sp
op	64:17	0:0	4	->
water	64:19	0:0	4	stream
op	64:25	0:0	4	.
water	64:26	0:0	4	avail_in
water	64:34	0:0	4	)
op	64:35	0:0	4	==
water	64:37	0:0	4	4
water	64:39	0:0	2	;
water	68:1	0:0	2	sp
op	68:3	0:0	2	->
water	68:5	0:0	2	stream
op	68:11	0:0	2	.
water	68:12	0:0	2	avail_in
op	68:21	0:0	2	=
call	68:23	68:49	2	(uInt)
arg	68:31	68:49	3	n*sizeof(uint16)
water	68:31	0:0	4	n
op	68:33	0:0	4	*
op	68:35	0:0	4	sizeof
water	68:41	0:0	4	(
water	68:42	0:0	4	uint16
water	68:48	0:0	4	)
water	68:50	0:0	2	;
if	69:1	74:1	2	(( sp -> stream . avail_in / sizeof ( uint16 ) ) != ( uInt ) n)
cond	69:5	69:54	3	( sp -> stream . avail_in / sizeof ( uint16 ) ) != ( uInt ) n
water	69:5	0:0	4	(
water	69:6	0:0	4	sp
op	69:8	0:0	4	->
water	69:10	0:0	4	stream
op	69:16	0:0	4	.
water	69:17	0:0	4	avail_in
op	69:26	0:0	4	/
op	69:28	0:0	4	sizeof
water	69:34	0:0	4	(
water	69:35	0:0	4	uint16
water	69:41	0:0	4	)
water	69:42	0:0	4	)
op	69:44	0:0	4	!=
water	69:47	0:0	4	(
water	69:48	0:0	4	uInt
water	69:52	0:0	4	)
water	69:54	0:0	4	n
stmts	70:1	74:1	3	
water	70:1	0:0	4	{
call	71:2	72:49	4	TIFFErrorExt
arg	71:15	71:34	5	tif->tif_clientdata
water	71:15	0:0	6	tif
op	71:18	0:0	6	->
water	71:20	0:0	6	tif_clientdata
arg	71:36	71:42	5	module
water	71:36	0:0	6	module
arg	72:8	72:49	5	"ZLib cannot deal with buffers this size"
water	72:8	0:0	6	"ZLib cannot deal with buffers this size"
water	72:50	0:0	4	;
return	73:2	73:12	4	(0)
water	73:9	0:0	5	(
water	73:10	0:0	5	0
water	73:11	0:0	5	)
water	74:1	0:0	4	}
do	75:1	87:1	2	(sp -> stream . avail_in > 0)
cond	87:10	87:32	3	sp -> stream . avail_in > 0
water	87:10	0:0	4	sp
op	87:12	0:0	4	->
water	87:14	0:0	4	stream
op	87:20	0:0	4	.
water	87:21	0:0	4	avail_in
op	87:30	0:0	4	>
water	87:32	0:0	4	0
stmts	75:4	87:1	3	
water	75:4	0:0	4	{
if	76:2	80:2	4	(deflate (& sp -> stream ,Z_NO_FLUSH ) != Z_OK)
cond	76:6	76:42	5	deflate (& sp -> stream ,Z_NO_FLUSH ) != Z_OK
call	76:6	76:37	6	deflate
arg	76:14	76:25	7	&sp->stream
op	76:14	0:0	8	&
water	76:15	0:0	8	sp
op	76:17	0:0	8	->
water	76:19	0:0	8	stream
arg	76:27	76:37	7	Z_NO_FLUSH
water	76:27	0:0	8	Z_NO_FLUSH
op	76:39	0:0	6	!=
water	76:42	0:0	6	Z_OK
stmts	76:48	80:2	5	
water	76:48	0:0	6	{
call	77:3	78:49	6	TIFFErrorExt
arg	77:16	77:35	7	tif->tif_clientdata
water	77:16	0:0	8	tif
op	77:19	0:0	8	->
water	77:21	0:0	8	tif_clientdata
arg	77:37	77:43	7	module
water	77:37	0:0	8	module
arg	77:45	77:64	7	"Encoder error: %s"
water	77:45	0:0	8	"Encoder error: %s"
arg	78:7	78:49	7	sp->stream.msg?sp->stream.msg:"(null)"
water	78:7	0:0	8	sp
op	78:9	0:0	8	->
water	78:11	0:0	8	stream
op	78:17	0:0	8	.
water	78:18	0:0	8	msg
water	78:22	0:0	8	?
water	78:24	0:0	8	sp
op	78:26	0:0	8	->
water	78:28	0:0	8	stream
op	78:34	0:0	8	.
water	78:35	0:0	8	msg
water	78:39	0:0	8	:
water	78:41	0:0	8	"(null)"
water	78:50	0:0	6	;
return	79:3	79:13	6	(0)
water	79:10	0:0	7	(
water	79:11	0:0	7	0
water	79:12	0:0	7	)
water	80:2	0:0	6	}
if	81:2	86:2	4	(sp -> stream . avail_out == 0)
cond	81:6	81:30	5	sp -> stream . avail_out == 0
water	81:6	0:0	6	sp
op	81:8	0:0	6	->
water	81:10	0:0	6	stream
op	81:16	0:0	6	.
water	81:17	0:0	6	avail_out
op	81:27	0:0	6	==
water	81:30	0:0	6	0
stmts	81:33	86:2	5	
water	81:33	0:0	6	{
water	82:3	0:0	6	tif
op	82:6	0:0	6	->
water	82:8	0:0	6	tif_rawcc
op	82:18	0:0	6	=
water	82:20	0:0	6	tif
op	82:23	0:0	6	->
water	82:25	0:0	6	tif_rawdatasize
water	82:40	0:0	6	;
call	83:3	83:21	6	TIFFFlushData1
arg	83:18	83:21	7	tif
water	83:18	0:0	8	tif
water	83:22	0:0	6	;
water	84:3	0:0	6	sp
op	84:5	0:0	6	->
water	84:7	0:0	6	stream
op	84:13	0:0	6	.
water	84:14	0:0	6	next_out
op	84:23	0:0	6	=
water	84:25	0:0	6	tif
op	84:28	0:0	6	->
water	84:30	0:0	6	tif_rawdata
water	84:41	0:0	6	;
water	85:3	0:0	6	sp
op	85:5	0:0	6	->
water	85:7	0:0	6	stream
op	85:13	0:0	6	.
water	85:14	0:0	6	avail_out
op	85:24	0:0	6	=
water	85:26	0:0	6	(
water	85:27	0:0	6	uInt
water	85:31	0:0	6	)
water	85:33	0:0	6	tif
op	85:36	0:0	6	->
water	85:38	0:0	6	tif_rawdatasize
water	85:53	0:0	6	;
water	86:2	0:0	6	}
water	87:1	0:0	4	}
water	87:34	0:0	2	;
return	88:1	88:11	2	(1)
water	88:8	0:0	3	(
water	88:9	0:0	3	1
water	88:10	0:0	3	)
