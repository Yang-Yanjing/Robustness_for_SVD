func	1:0	60:2	0	static int	extractContigSamplesBytes
params	2:26	0:0	1	
param	2:27	2:36	2	uint8 *	in
param	2:38	2:48	2	uint8 *	out
param	2:50	2:61	2	uint32	cols
param	3:27	3:43	2	tsample_t	sample
param	3:45	3:55	2	uint16	spp
param	3:57	3:67	2	uint16	bps
param	4:27	4:42	2	tsample_t	count
param	4:44	4:56	2	uint32	start
param	4:58	4:68	2	uint32	end
stmnts	0:0	59:12	1	
decl	6:2	6:33	2	int	i
water	6:7	0:0	2	,
decl	6:2	6:33	2	int	bytes_per_sample
water	6:25	0:0	2	,
decl	6:2	6:33	2	int	sindex
decl	7:2	7:37	2	uint32	col
water	7:12	0:0	2	,
decl	7:2	7:37	2	uint32	dst_rowsize
water	7:25	0:0	2	,
decl	7:2	7:37	2	uint32	bit_offset
decl	8:2	8:18	2	uint32	src_byte
decl	9:2	9:17	2	uint8	*src
op	9:13	0:0	2	=
water	9:15	0:0	2	in
decl	10:2	10:18	2	uint8	*dst
op	10:13	0:0	2	=
water	10:15	0:0	2	out
if	11:2	15:4	2	(( src == NULL ) || ( dst == NULL ))
cond	11:6	11:35	3	( src == NULL ) || ( dst == NULL )
water	11:6	0:0	4	(
water	11:7	0:0	4	src
op	11:11	0:0	4	==
water	11:14	0:0	4	NULL
water	11:18	0:0	4	)
op	11:20	0:0	4	||
water	11:23	0:0	4	(
water	11:24	0:0	4	dst
op	11:28	0:0	4	==
water	11:31	0:0	4	NULL
water	11:35	0:0	4	)
stmts	12:4	15:4	3	
water	12:4	0:0	4	{
call	13:4	13:74	4	TIFFError
arg	13:14	13:41	5	"extractContigSamplesBytes"
water	13:14	0:0	6	"extractContigSamplesBytes"
arg	13:42	13:74	5	"Invalid input or output buffer"
water	13:42	0:0	6	"Invalid input or output buffer"
water	13:75	0:0	4	;
return	14:4	14:14	4	(1)
water	14:11	0:0	5	(
water	14:12	0:0	5	1
water	14:13	0:0	5	)
water	15:4	0:0	4	}
if	16:2	21:4	2	(( start > end ) || ( start > cols ))
cond	16:6	16:36	3	( start > end ) || ( start > cols )
water	16:6	0:0	4	(
water	16:7	0:0	4	start
op	16:13	0:0	4	>
water	16:15	0:0	4	end
water	16:18	0:0	4	)
op	16:20	0:0	4	||
water	16:23	0:0	4	(
water	16:24	0:0	4	start
op	16:30	0:0	4	>
water	16:32	0:0	4	cols
water	16:36	0:0	4	)
stmts	17:4	21:4	3	
water	17:4	0:0	4	{
call	18:4	19:61	4	TIFFError
arg	18:15	18:42	5	"extractContigSamplesBytes"
water	18:15	0:0	6	"extractContigSamplesBytes"
arg	19:15	19:54	5	"Invalid start column value %d ignored"
water	19:15	0:0	6	"Invalid start column value %d ignored"
arg	19:56	19:61	5	start
water	19:56	0:0	6	start
water	19:62	0:0	4	;
water	20:4	0:0	4	start
op	20:10	0:0	4	=
water	20:12	0:0	4	0
water	20:13	0:0	4	;
water	21:4	0:0	4	}
if	22:2	27:4	2	(( end == 0 ) || ( end > cols ))
cond	22:6	22:31	3	( end == 0 ) || ( end > cols )
water	22:6	0:0	4	(
water	22:7	0:0	4	end
op	22:11	0:0	4	==
water	22:14	0:0	4	0
water	22:15	0:0	4	)
op	22:17	0:0	4	||
water	22:20	0:0	4	(
water	22:21	0:0	4	end
op	22:25	0:0	4	>
water	22:27	0:0	4	cols
water	22:31	0:0	4	)
stmts	23:4	27:4	3	
water	23:4	0:0	4	{
call	24:4	25:57	4	TIFFError
arg	24:15	24:42	5	"extractContigSamplesBytes"
water	24:15	0:0	6	"extractContigSamplesBytes"
arg	25:15	25:52	5	"Invalid end column value %d ignored"
water	25:15	0:0	6	"Invalid end column value %d ignored"
arg	25:54	25:57	5	end
water	25:54	0:0	6	end
water	25:58	0:0	4	;
water	26:4	0:0	4	end
op	26:8	0:0	4	=
water	26:10	0:0	4	cols
water	26:14	0:0	4	;
water	27:4	0:0	4	}
water	28:2	0:0	2	dst_rowsize
op	28:14	0:0	2	=
water	28:16	0:0	2	(
water	28:17	0:0	2	bps
op	28:21	0:0	2	*
water	28:23	0:0	2	(
water	28:24	0:0	2	end
op	28:28	0:0	2	-
water	28:30	0:0	2	start
water	28:35	0:0	2	)
op	28:37	0:0	2	*
water	28:39	0:0	2	count
water	28:44	0:0	2	)
op	28:46	0:0	2	/
water	28:48	0:0	2	8
water	28:49	0:0	2	;
water	29:2	0:0	2	bytes_per_sample
op	29:19	0:0	2	=
water	29:21	0:0	2	(
water	29:22	0:0	2	bps
op	29:26	0:0	2	+
water	29:28	0:0	2	7
water	29:29	0:0	2	)
op	29:31	0:0	2	/
water	29:33	0:0	2	8
water	29:34	0:0	2	;
if	31:2	35:4	2	(count == spp)
cond	31:6	31:15	3	count == spp
water	31:6	0:0	4	count
op	31:12	0:0	4	==
water	31:15	0:0	4	spp
stmts	32:4	35:4	3	
water	32:4	0:0	4	{
water	33:4	0:0	4	src
op	33:8	0:0	4	=
water	33:10	0:0	4	in
op	33:13	0:0	4	+
water	33:15	0:0	4	(
water	33:16	0:0	4	start
op	33:22	0:0	4	*
water	33:24	0:0	4	spp
op	33:28	0:0	4	*
water	33:30	0:0	4	bytes_per_sample
water	33:46	0:0	4	)
water	33:47	0:0	4	;
call	34:4	34:38	4	_TIFFmemcpy
arg	34:17	34:20	5	dst
water	34:17	0:0	6	dst
arg	34:22	34:25	5	src
water	34:22	0:0	6	src
arg	34:27	34:38	5	dst_rowsize
water	34:27	0:0	6	dst_rowsize
water	34:39	0:0	4	;
water	35:4	0:0	4	}
else	36:2	58:4	2
stmts	37:4	58:4	3	
water	37:4	0:0	4	{
for	38:4	57:6	4	(col = start ;col < end;col ++)
forinit	38:9	38:20	5	col = start ;
water	38:9	0:0	6	col
op	38:13	0:0	6	=
water	38:15	0:0	6	start
water	38:20	0:0	6	;
cond	38:22	38:28	5	col < end
water	38:22	0:0	6	col
op	38:26	0:0	6	<
water	38:28	0:0	6	end
forexpr	38:33	38:36	5	col ++
water	38:33	0:0	6	col
op	38:36	0:0	6	++
stmts	39:6	57:6	5	
water	39:6	0:0	6	{
for	40:6	56:8	6	(sindex = sample ;( sindex < spp ) && ( sindex < ( sample + count ) );sindex ++)
forinit	40:11	40:26	7	sindex = sample ;
water	40:11	0:0	8	sindex
op	40:18	0:0	8	=
water	40:20	0:0	8	sample
water	40:26	0:0	8	;
cond	40:28	40:72	7	( sindex < spp ) && ( sindex < ( sample + count ) )
water	40:28	0:0	8	(
water	40:29	0:0	8	sindex
op	40:36	0:0	8	<
water	40:38	0:0	8	spp
water	40:41	0:0	8	)
op	40:43	0:0	8	&&
water	40:46	0:0	8	(
water	40:47	0:0	8	sindex
op	40:54	0:0	8	<
water	40:56	0:0	8	(
water	40:57	0:0	8	sample
op	40:64	0:0	8	+
water	40:66	0:0	8	count
water	40:71	0:0	8	)
water	40:72	0:0	8	)
forexpr	40:75	40:81	7	sindex ++
water	40:75	0:0	8	sindex
op	40:81	0:0	8	++
stmts	41:8	56:8	7	
water	41:8	0:0	8	{
water	42:8	0:0	8	bit_offset
op	42:19	0:0	8	=
water	42:21	0:0	8	col
op	42:25	0:0	8	*
water	42:27	0:0	8	bps
op	42:31	0:0	8	*
water	42:33	0:0	8	spp
water	42:36	0:0	8	;
if	43:8	47:10	8	(sindex == 0)
cond	43:12	43:22	9	sindex == 0
water	43:12	0:0	10	sindex
op	43:19	0:0	10	==
water	43:22	0:0	10	0
stmts	44:10	47:10	9	
water	44:10	0:0	10	{
water	45:10	0:0	10	src_byte
op	45:19	0:0	10	=
water	45:21	0:0	10	bit_offset
op	45:32	0:0	10	/
water	45:34	0:0	10	8
water	45:35	0:0	10	;
water	47:10	0:0	10	}
else	48:8	52:10	8
stmts	49:10	52:10	9	
water	49:10	0:0	10	{
water	50:10	0:0	10	src_byte
op	50:19	0:0	10	=
water	50:21	0:0	10	(
water	50:22	0:0	10	bit_offset
op	50:33	0:0	10	+
water	50:35	0:0	10	(
water	50:36	0:0	10	sindex
op	50:43	0:0	10	*
water	50:45	0:0	10	bps
water	50:48	0:0	10	)
water	50:49	0:0	10	)
op	50:51	0:0	10	/
water	50:53	0:0	10	8
water	50:54	0:0	10	;
water	52:10	0:0	10	}
water	53:8	0:0	8	src
op	53:12	0:0	8	=
water	53:14	0:0	8	in
op	53:17	0:0	8	+
water	53:19	0:0	8	src_byte
water	53:27	0:0	8	;
for	54:8	55:27	8	(i = 0 ;i < bytes_per_sample;i ++)
forinit	54:13	54:18	9	i = 0 ;
water	54:13	0:0	10	i
op	54:15	0:0	10	=
water	54:17	0:0	10	0
water	54:18	0:0	10	;
cond	54:20	54:24	9	i < bytes_per_sample
water	54:20	0:0	10	i
op	54:22	0:0	10	<
water	54:24	0:0	10	bytes_per_sample
forexpr	54:42	54:43	9	i ++
water	54:42	0:0	10	i
op	54:43	0:0	10	++
stmts	55:12	55:27	9	
op	55:12	0:0	10	*
water	55:13	0:0	10	dst
op	55:16	0:0	10	++
op	55:19	0:0	10	=
op	55:21	0:0	10	*
water	55:22	0:0	10	src
op	55:25	0:0	10	++
water	55:27	0:0	10	;
water	56:8	0:0	8	}
water	57:6	0:0	6	}
water	58:4	0:0	4	}
return	59:2	59:12	2	(0)
water	59:9	0:0	3	(
water	59:10	0:0	3	0
water	59:11	0:0	3	)
