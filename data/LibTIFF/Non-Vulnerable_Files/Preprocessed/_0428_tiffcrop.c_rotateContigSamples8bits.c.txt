func	1:0	67:2	0	static int	rotateContigSamples8bits
params	2:24	0:0	1	
param	2:25	2:40	2	uint16	rotation
param	2:42	2:52	2	uint16	spp
param	2:54	2:64	2	uint16	bps
param	2:66	2:78	2	uint32	width
param	3:25	3:38	2	uint32	length
param	3:42	3:52	2	uint32	col
param	3:54	3:64	2	uint8 *	src
param	3:66	3:76	2	uint8 *	dst
stmnts	0:0	66:12	1	
decl	5:2	5:25	2	int	ready_bits
op	5:22	0:0	2	=
water	5:24	0:0	2	0
decl	6:2	6:36	2	uint32	src_byte
op	6:20	0:0	2	=
water	6:22	0:0	2	0
water	6:23	0:0	2	,
decl	6:2	6:36	2	uint32	src_bit
op	6:33	0:0	2	=
water	6:35	0:0	2	0
decl	7:2	7:43	2	uint32	row
water	7:14	0:0	2	,
decl	7:2	7:43	2	uint32	rowsize
op	7:24	0:0	2	=
water	7:26	0:0	2	0
water	7:27	0:0	2	,
decl	7:2	7:43	2	uint32	bit_offset
op	7:40	0:0	2	=
water	7:42	0:0	2	0
decl	8:2	8:38	2	uint8	matchbits
op	8:21	0:0	2	=
water	8:23	0:0	2	0
water	8:24	0:0	2	,
decl	8:2	8:38	2	uint8	maskbits
op	8:35	0:0	2	=
water	8:37	0:0	2	0
decl	9:2	9:31	2	uint8	buff1
op	9:17	0:0	2	=
water	9:19	0:0	2	0
water	9:20	0:0	2	,
decl	9:2	9:31	2	uint8	buff2
op	9:28	0:0	2	=
water	9:30	0:0	2	0
decl	10:2	10:15	2	uint8	*next
decl	11:2	11:18	2	tsample_t	sample
if	12:2	16:4	2	(( src == NULL ) || ( dst == NULL ))
cond	12:6	12:35	3	( src == NULL ) || ( dst == NULL )
water	12:6	0:0	4	(
water	12:7	0:0	4	src
op	12:11	0:0	4	==
water	12:14	0:0	4	NULL
water	12:18	0:0	4	)
op	12:20	0:0	4	||
water	12:23	0:0	4	(
water	12:24	0:0	4	dst
op	12:28	0:0	4	==
water	12:31	0:0	4	NULL
water	12:35	0:0	4	)
stmts	13:4	16:4	3	
water	13:4	0:0	4	{
call	14:4	14:76	4	TIFFError
arg	14:14	14:40	5	"rotateContigSamples8bits"
water	14:14	0:0	6	"rotateContigSamples8bits"
arg	14:41	14:76	5	"Invalid src or destination buffer"
water	14:41	0:0	6	"Invalid src or destination buffer"
water	14:77	0:0	4	;
return	15:4	15:14	4	(1)
water	15:11	0:0	5	(
water	15:12	0:0	5	1
water	15:13	0:0	5	)
water	16:4	0:0	4	}
water	17:2	0:0	2	rowsize
op	17:10	0:0	2	=
water	17:12	0:0	2	(
water	17:13	0:0	2	(
water	17:14	0:0	2	bps
op	17:18	0:0	2	*
water	17:20	0:0	2	spp
op	17:24	0:0	2	*
water	17:26	0:0	2	width
water	17:31	0:0	2	)
op	17:33	0:0	2	+
water	17:35	0:0	2	7
water	17:36	0:0	2	)
op	17:38	0:0	2	/
water	17:40	0:0	2	8
water	17:41	0:0	2	;
water	18:2	0:0	2	ready_bits
op	18:13	0:0	2	=
water	18:15	0:0	2	0
water	18:16	0:0	2	;
water	19:2	0:0	2	maskbits
op	19:11	0:0	2	=
water	19:14	0:0	2	(
water	19:15	0:0	2	uint8
water	19:20	0:0	2	)
op	19:21	0:0	2	-
water	19:22	0:0	2	1
op	19:24	0:0	2	>>
water	19:27	0:0	2	(
water	19:29	0:0	2	8
op	19:31	0:0	2	-
water	19:33	0:0	2	bps
water	19:36	0:0	2	)
water	19:37	0:0	2	;
water	20:2	0:0	2	buff1
op	20:8	0:0	2	=
water	20:10	0:0	2	buff2
op	20:16	0:0	2	=
water	20:18	0:0	2	0
water	20:19	0:0	2	;
for	21:2	60:4	2	(row = 0 ;row < length;row ++)
forinit	21:7	21:14	3	row = 0 ;
water	21:7	0:0	4	row
op	21:11	0:0	4	=
water	21:13	0:0	4	0
water	21:14	0:0	4	;
cond	21:16	21:22	3	row < length
water	21:16	0:0	4	row
op	21:20	0:0	4	<
water	21:22	0:0	4	length
forexpr	21:31	21:34	3	row ++
water	21:31	0:0	4	row
op	21:34	0:0	4	++
stmts	22:4	60:4	3	
water	22:4	0:0	4	{
water	23:4	0:0	4	bit_offset
op	23:15	0:0	4	=
water	23:17	0:0	4	col
op	23:21	0:0	4	*
water	23:23	0:0	4	bps
op	23:27	0:0	4	*
water	23:29	0:0	4	spp
water	23:32	0:0	4	;
for	24:4	59:6	4	(sample = 0 ;sample < spp;sample ++)
forinit	24:9	24:19	5	sample = 0 ;
water	24:9	0:0	6	sample
op	24:16	0:0	6	=
water	24:18	0:0	6	0
water	24:19	0:0	6	;
cond	24:21	24:30	5	sample < spp
water	24:21	0:0	6	sample
op	24:28	0:0	6	<
water	24:30	0:0	6	spp
forexpr	24:35	24:41	5	sample ++
water	24:35	0:0	6	sample
op	24:41	0:0	6	++
stmts	25:6	59:6	5	
water	25:6	0:0	6	{
if	26:6	30:8	6	(sample == 0)
cond	26:10	26:20	7	sample == 0
water	26:10	0:0	8	sample
op	26:17	0:0	8	==
water	26:20	0:0	8	0
stmts	27:8	30:8	7	
water	27:8	0:0	8	{
water	28:8	0:0	8	src_byte
op	28:17	0:0	8	=
water	28:19	0:0	8	bit_offset
op	28:30	0:0	8	/
water	28:32	0:0	8	8
water	28:33	0:0	8	;
water	29:8	0:0	8	src_bit
op	29:17	0:0	8	=
water	29:19	0:0	8	bit_offset
op	29:30	0:0	8	%
water	29:32	0:0	8	8
water	29:33	0:0	8	;
water	30:8	0:0	8	}
else	31:6	35:8	6
stmts	32:8	35:8	7	
water	32:8	0:0	8	{
water	33:8	0:0	8	src_byte
op	33:17	0:0	8	=
water	33:19	0:0	8	(
water	33:20	0:0	8	bit_offset
op	33:31	0:0	8	+
water	33:33	0:0	8	(
water	33:34	0:0	8	sample
op	33:41	0:0	8	*
water	33:43	0:0	8	bps
water	33:46	0:0	8	)
water	33:47	0:0	8	)
op	33:49	0:0	8	/
water	33:51	0:0	8	8
water	33:52	0:0	8	;
water	34:8	0:0	8	src_bit
op	34:17	0:0	8	=
water	34:19	0:0	8	(
water	34:20	0:0	8	bit_offset
op	34:31	0:0	8	+
water	34:33	0:0	8	(
water	34:34	0:0	8	sample
op	34:41	0:0	8	*
water	34:43	0:0	8	bps
water	34:46	0:0	8	)
water	34:47	0:0	8	)
op	34:49	0:0	8	%
water	34:51	0:0	8	8
water	34:52	0:0	8	;
water	35:8	0:0	8	}
switch	36:6	44:8	6	(rotation)
cond	36:14	36:14	7	rotation
water	36:14	0:0	8	rotation
stmts	37:1	44:8	7	
water	37:1	0:0	8	{
label	38:8	38:16	8	case 90 :
water	38:18	0:0	8	next
op	38:23	0:0	8	=
water	38:25	0:0	8	src
op	38:29	0:0	8	+
water	38:31	0:0	8	src_byte
op	38:40	0:0	8	-
water	38:42	0:0	8	(
water	38:43	0:0	8	row
op	38:47	0:0	8	*
water	38:49	0:0	8	rowsize
water	38:56	0:0	8	)
water	38:57	0:0	8	;
break	39:18	39:23	8	
label	40:8	40:16	8	case 270 :
water	40:18	0:0	8	next
op	40:23	0:0	8	=
water	40:25	0:0	8	src
op	40:29	0:0	8	+
water	40:31	0:0	8	src_byte
op	40:40	0:0	8	+
water	40:42	0:0	8	(
water	40:43	0:0	8	row
op	40:47	0:0	8	*
water	40:49	0:0	8	rowsize
water	40:56	0:0	8	)
water	40:57	0:0	8	;
break	41:11	41:16	8	
label	42:1	42:8	8	default :
call	42:11	42:80	8	TIFFError
arg	42:21	42:47	9	"rotateContigSamples8bits"
water	42:21	0:0	10	"rotateContigSamples8bits"
arg	42:49	42:70	9	"Invalid rotation %d"
water	42:49	0:0	10	"Invalid rotation %d"
arg	42:72	42:80	9	rotation
water	42:72	0:0	10	rotation
water	42:81	0:0	8	;
return	43:18	43:28	8	(1)
water	43:25	0:0	9	(
water	43:26	0:0	9	1
water	43:27	0:0	9	)
water	44:8	0:0	8	}
water	45:6	0:0	6	matchbits
op	45:16	0:0	6	=
water	45:18	0:0	6	maskbits
op	45:27	0:0	6	<<
water	45:30	0:0	6	(
water	45:31	0:0	6	8
op	45:33	0:0	6	-
water	45:35	0:0	6	src_bit
op	45:43	0:0	6	-
water	45:45	0:0	6	bps
water	45:48	0:0	6	)
water	45:49	0:0	6	;
water	46:6	0:0	6	buff1
op	46:12	0:0	6	=
water	46:14	0:0	6	(
water	46:15	0:0	6	(
op	46:16	0:0	6	*
water	46:17	0:0	6	next
water	46:21	0:0	6	)
op	46:23	0:0	6	&
water	46:25	0:0	6	matchbits
water	46:34	0:0	6	)
op	46:36	0:0	6	<<
water	46:39	0:0	6	(
water	46:40	0:0	6	src_bit
water	46:47	0:0	6	)
water	46:48	0:0	6	;
if	48:6	53:8	6	(ready_bits >= 8)
cond	48:10	48:24	7	ready_bits >= 8
water	48:10	0:0	8	ready_bits
op	48:21	0:0	8	>=
water	48:24	0:0	8	8
stmts	49:8	53:8	7	
water	49:8	0:0	8	{
op	50:8	0:0	8	*
water	50:9	0:0	8	dst
op	50:12	0:0	8	++
op	50:15	0:0	8	=
water	50:17	0:0	8	buff2
water	50:22	0:0	8	;
water	51:8	0:0	8	buff2
op	51:14	0:0	8	=
water	51:16	0:0	8	buff1
water	51:21	0:0	8	;
water	52:8	0:0	8	ready_bits
op	52:19	0:0	8	-=
water	52:22	0:0	8	8
water	52:23	0:0	8	;
water	53:8	0:0	8	}
else	54:6	57:8	6
stmts	55:8	57:8	7	
water	55:8	0:0	8	{
water	56:8	0:0	8	buff2
op	56:14	0:0	8	=
water	56:16	0:0	8	(
water	56:17	0:0	8	buff2
op	56:23	0:0	8	|
water	56:25	0:0	8	(
water	56:26	0:0	8	buff1
op	56:32	0:0	8	>>
water	56:35	0:0	8	ready_bits
water	56:45	0:0	8	)
water	56:46	0:0	8	)
water	56:47	0:0	8	;
water	57:8	0:0	8	}
water	58:6	0:0	6	ready_bits
op	58:17	0:0	6	+=
water	58:20	0:0	6	bps
water	58:23	0:0	6	;
water	59:6	0:0	6	}
water	60:4	0:0	4	}
if	61:2	65:4	2	(ready_bits > 0)
cond	61:6	61:19	3	ready_bits > 0
water	61:6	0:0	4	ready_bits
op	61:17	0:0	4	>
water	61:19	0:0	4	0
stmts	62:4	65:4	3	
water	62:4	0:0	4	{
water	63:4	0:0	4	buff1
op	63:10	0:0	4	=
water	63:12	0:0	4	(
water	63:13	0:0	4	buff2
op	63:19	0:0	4	&
water	63:21	0:0	4	(
water	63:22	0:0	4	(
water	63:23	0:0	4	unsigned
water	63:32	0:0	4	int
water	63:35	0:0	4	)
water	63:36	0:0	4	255
op	63:40	0:0	4	<<
water	63:43	0:0	4	(
water	63:44	0:0	4	8
op	63:46	0:0	4	-
water	63:48	0:0	4	ready_bits
water	63:58	0:0	4	)
water	63:59	0:0	4	)
water	63:60	0:0	4	)
water	63:61	0:0	4	;
op	64:4	0:0	4	*
water	64:5	0:0	4	dst
op	64:8	0:0	4	++
op	64:11	0:0	4	=
water	64:13	0:0	4	buff1
water	64:18	0:0	4	;
water	65:4	0:0	4	}
return	66:2	66:12	2	(0)
water	66:9	0:0	3	(
water	66:10	0:0	3	0
water	66:11	0:0	3	)
