func	1:0	81:2	0	static int	invertImage
params	2:11	0:0	1	
param	2:12	2:30	2	uint16	photometric
param	2:32	2:42	2	uint16	spp
param	2:44	2:54	2	uint16	bps
param	2:56	2:68	2	uint32	width
param	2:70	2:83	2	uint32	length
param	2:85	2:109	2	unsigned char *	work_buff
stmnts	0:0	80:12	1	
decl	4:2	4:19	2	uint32	row
water	4:14	0:0	2	,
decl	4:2	4:19	2	uint32	col
decl	5:2	5:59	2	unsigned char	bytebuff1
water	5:26	0:0	2	,
decl	5:2	5:59	2	unsigned char	bytebuff2
water	5:37	0:0	2	,
decl	5:2	5:59	2	unsigned char	bytebuff3
water	5:48	0:0	2	,
decl	5:2	5:59	2	unsigned char	bytebuff4
decl	6:2	6:20	2	unsigned char	*src
decl	7:2	7:27	2	uint16	*src_uint16
decl	8:2	8:27	2	uint32	*src_uint32
if	9:2	13:4	2	(spp != 1)
cond	9:6	9:13	3	spp != 1
water	9:6	0:0	4	spp
op	9:10	0:0	4	!=
water	9:13	0:0	4	1
stmts	10:4	13:4	3	
water	10:4	0:0	4	{
call	11:4	11:95	4	TIFFError
arg	11:14	11:27	5	"invertImage"
water	11:14	0:0	6	"invertImage"
arg	11:29	11:95	5	"Image inversion not supported for more than one sample per pixel"
water	11:29	0:0	6	"Image inversion not supported for more than one sample per pixel"
water	11:96	0:0	4	;
return	12:4	12:15	4	(-1)
water	12:11	0:0	5	(
op	12:12	0:0	5	-
water	12:13	0:0	5	1
water	12:14	0:0	5	)
water	13:4	0:0	4	}
if	14:2	18:4	2	(photometric != PHOTOMETRIC_MINISWHITE && photometric != PHOTOMETRIC_MINISBLACK)
cond	14:6	14:64	3	photometric != PHOTOMETRIC_MINISWHITE && photometric != PHOTOMETRIC_MINISBLACK
water	14:6	0:0	4	photometric
op	14:18	0:0	4	!=
water	14:22	0:0	4	PHOTOMETRIC_MINISWHITE
op	14:45	0:0	4	&&
water	14:48	0:0	4	photometric
op	14:60	0:0	4	!=
water	14:64	0:0	4	PHOTOMETRIC_MINISBLACK
stmts	15:4	18:4	3	
water	15:4	0:0	4	{
call	16:4	16:88	4	TIFFError
arg	16:14	16:27	5	"invertImage"
water	16:14	0:0	6	"invertImage"
arg	16:29	16:88	5	"Only black and white and grayscale images can be inverted"
water	16:29	0:0	6	"Only black and white and grayscale images can be inverted"
water	16:89	0:0	4	;
return	17:4	17:15	4	(-1)
water	17:11	0:0	5	(
op	17:12	0:0	5	-
water	17:13	0:0	5	1
water	17:14	0:0	5	)
water	18:4	0:0	4	}
water	19:2	0:0	2	src
op	19:6	0:0	2	=
water	19:8	0:0	2	work_buff
water	19:17	0:0	2	;
if	20:2	24:4	2	(src == NULL)
cond	20:6	20:13	3	src == NULL
water	20:6	0:0	4	src
op	20:10	0:0	4	==
water	20:13	0:0	4	NULL
stmts	21:4	24:4	3	
water	21:4	0:0	4	{
call	22:4	22:73	4	TIFFError
arg	22:15	22:28	5	"invertImage"
water	22:15	0:0	6	"invertImage"
arg	22:30	22:73	5	"Invalid crop buffer passed to invertImage"
water	22:30	0:0	6	"Invalid crop buffer passed to invertImage"
water	22:74	0:0	4	;
return	23:4	23:15	4	(-1)
water	23:11	0:0	5	(
op	23:12	0:0	5	-
water	23:13	0:0	5	1
water	23:14	0:0	5	)
water	24:4	0:0	4	}
switch	25:2	79:4	2	(bps)
cond	25:10	25:10	3	bps
water	25:10	0:0	4	bps
stmts	26:4	79:4	3	
water	26:4	0:0	4	{
label	27:4	27:11	4	case 32 :
water	27:13	0:0	4	src_uint32
op	27:24	0:0	4	=
water	27:26	0:0	4	(
water	27:27	0:0	4	uint32
op	27:34	0:0	4	*
water	27:35	0:0	4	)
water	27:36	0:0	4	src
water	27:39	0:0	4	;
for	28:13	33:17	4	(row = 0 ;row < length;row ++)
forinit	28:18	28:25	5	row = 0 ;
water	28:18	0:0	6	row
op	28:22	0:0	6	=
water	28:24	0:0	6	0
water	28:25	0:0	6	;
cond	28:27	28:33	5	row < length
water	28:27	0:0	6	row
op	28:31	0:0	6	<
water	28:33	0:0	6	length
forexpr	28:41	28:44	5	row ++
water	28:41	0:0	6	row
op	28:44	0:0	6	++
stmts	29:15	33:17	5	
for	29:15	33:17	6	(col = 0 ;col < width;col ++)
forinit	29:20	29:27	7	col = 0 ;
water	29:20	0:0	8	col
op	29:24	0:0	8	=
water	29:26	0:0	8	0
water	29:27	0:0	8	;
cond	29:29	29:35	7	col < width
water	29:29	0:0	8	col
op	29:33	0:0	8	<
water	29:35	0:0	8	width
forexpr	29:42	29:45	7	col ++
water	29:42	0:0	8	col
op	29:45	0:0	8	++
stmts	30:17	33:17	7	
water	30:17	0:0	8	{
op	31:3	0:0	8	*
water	31:4	0:0	8	src_uint32
op	31:15	0:0	8	=
water	31:17	0:0	8	(
water	31:18	0:0	8	uint32
water	31:24	0:0	8	)
water	31:25	0:0	8	0
water	31:26	0:0	8	xFFFFFFFF
op	31:36	0:0	8	-
op	31:38	0:0	8	*
water	31:39	0:0	8	src_uint32
water	31:49	0:0	8	;
water	32:18	0:0	8	src_uint32
op	32:28	0:0	8	++
water	32:30	0:0	8	;
water	33:17	0:0	8	}
break	34:12	34:17	4	
label	35:4	35:11	4	case 16 :
water	35:13	0:0	4	src_uint16
op	35:24	0:0	4	=
water	35:26	0:0	4	(
water	35:27	0:0	4	uint16
op	35:34	0:0	4	*
water	35:35	0:0	4	)
water	35:36	0:0	4	src
water	35:39	0:0	4	;
for	36:13	41:17	4	(row = 0 ;row < length;row ++)
forinit	36:18	36:25	5	row = 0 ;
water	36:18	0:0	6	row
op	36:22	0:0	6	=
water	36:24	0:0	6	0
water	36:25	0:0	6	;
cond	36:27	36:33	5	row < length
water	36:27	0:0	6	row
op	36:31	0:0	6	<
water	36:33	0:0	6	length
forexpr	36:41	36:44	5	row ++
water	36:41	0:0	6	row
op	36:44	0:0	6	++
stmts	37:15	41:17	5	
for	37:15	41:17	6	(col = 0 ;col < width;col ++)
forinit	37:20	37:27	7	col = 0 ;
water	37:20	0:0	8	col
op	37:24	0:0	8	=
water	37:26	0:0	8	0
water	37:27	0:0	8	;
cond	37:29	37:35	7	col < width
water	37:29	0:0	8	col
op	37:33	0:0	8	<
water	37:35	0:0	8	width
forexpr	37:42	37:45	7	col ++
water	37:42	0:0	8	col
op	37:45	0:0	8	++
stmts	38:17	41:17	7	
water	38:17	0:0	8	{
op	39:3	0:0	8	*
water	39:4	0:0	8	src_uint16
op	39:15	0:0	8	=
water	39:17	0:0	8	(
water	39:18	0:0	8	uint16
water	39:24	0:0	8	)
water	39:25	0:0	8	0
water	39:26	0:0	8	xFFFF
op	39:32	0:0	8	-
op	39:34	0:0	8	*
water	39:35	0:0	8	src_uint16
water	39:45	0:0	8	;
water	40:18	0:0	8	src_uint16
op	40:28	0:0	8	++
water	40:30	0:0	8	;
water	41:17	0:0	8	}
break	42:12	42:17	4	
label	43:4	43:10	4	case 8 :
for	43:12	48:16	4	(row = 0 ;row < length;row ++)
forinit	43:17	43:24	5	row = 0 ;
water	43:17	0:0	6	row
op	43:21	0:0	6	=
water	43:23	0:0	6	0
water	43:24	0:0	6	;
cond	43:26	43:32	5	row < length
water	43:26	0:0	6	row
op	43:30	0:0	6	<
water	43:32	0:0	6	length
forexpr	43:40	43:43	5	row ++
water	43:40	0:0	6	row
op	43:43	0:0	6	++
stmts	44:14	48:16	5	
for	44:14	48:16	6	(col = 0 ;col < width;col ++)
forinit	44:19	44:26	7	col = 0 ;
water	44:19	0:0	8	col
op	44:23	0:0	8	=
water	44:25	0:0	8	0
water	44:26	0:0	8	;
cond	44:28	44:34	7	col < width
water	44:28	0:0	8	col
op	44:32	0:0	8	<
water	44:34	0:0	8	width
forexpr	44:41	44:44	7	col ++
water	44:41	0:0	8	col
op	44:44	0:0	8	++
stmts	45:16	48:16	7	
water	45:16	0:0	8	{
op	46:2	0:0	8	*
water	46:3	0:0	8	src
op	46:7	0:0	8	=
water	46:9	0:0	8	(
water	46:10	0:0	8	uint8
water	46:15	0:0	8	)
water	46:16	0:0	8	255
op	46:20	0:0	8	-
op	46:22	0:0	8	*
water	46:23	0:0	8	src
water	46:26	0:0	8	;
water	47:17	0:0	8	src
op	47:20	0:0	8	++
water	47:22	0:0	8	;
water	48:16	0:0	8	}
break	49:12	49:17	4	
label	50:4	50:10	4	case 4 :
for	50:12	57:16	4	(row = 0 ;row < length;row ++)
forinit	50:17	50:24	5	row = 0 ;
water	50:17	0:0	6	row
op	50:21	0:0	6	=
water	50:23	0:0	6	0
water	50:24	0:0	6	;
cond	50:26	50:32	5	row < length
water	50:26	0:0	6	row
op	50:30	0:0	6	<
water	50:32	0:0	6	length
forexpr	50:40	50:43	5	row ++
water	50:40	0:0	6	row
op	50:43	0:0	6	++
stmts	51:14	57:16	5	
for	51:14	57:16	6	(col = 0 ;col < width;col ++)
forinit	51:19	51:26	7	col = 0 ;
water	51:19	0:0	8	col
op	51:23	0:0	8	=
water	51:25	0:0	8	0
water	51:26	0:0	8	;
cond	51:28	51:34	7	col < width
water	51:28	0:0	8	col
op	51:32	0:0	8	<
water	51:34	0:0	8	width
forexpr	51:41	51:44	7	col ++
water	51:41	0:0	8	col
op	51:44	0:0	8	++
stmts	52:16	57:16	7	
water	52:16	0:0	8	{
water	53:2	0:0	8	bytebuff1
op	53:12	0:0	8	=
water	53:14	0:0	8	16
op	53:17	0:0	8	-
call	53:19	53:42	8	(uint8)
arg	53:27	53:42	9	*src&240>>4
op	53:27	0:0	10	*
water	53:28	0:0	10	src
op	53:32	0:0	10	&
water	53:34	0:0	10	240
op	53:38	0:0	10	>>
water	53:41	0:0	10	4
water	53:43	0:0	8	;
water	54:2	0:0	8	bytebuff2
op	54:12	0:0	8	=
water	54:14	0:0	8	16
op	54:17	0:0	8	-
water	54:19	0:0	8	(
op	54:20	0:0	8	*
water	54:21	0:0	8	src
op	54:25	0:0	8	&
water	54:27	0:0	8	15
water	54:29	0:0	8	)
water	54:30	0:0	8	;
op	55:2	0:0	8	*
water	55:3	0:0	8	src
op	55:7	0:0	8	=
water	55:9	0:0	8	bytebuff1
op	55:19	0:0	8	<<
water	55:22	0:0	8	4
op	55:24	0:0	8	&
water	55:26	0:0	8	bytebuff2
water	55:35	0:0	8	;
water	56:16	0:0	8	src
op	56:19	0:0	8	++
water	56:21	0:0	8	;
water	57:16	0:0	8	}
break	58:12	58:17	4	
label	59:4	59:10	4	case 2 :
for	59:12	68:16	4	(row = 0 ;row < length;row ++)
forinit	59:17	59:24	5	row = 0 ;
water	59:17	0:0	6	row
op	59:21	0:0	6	=
water	59:23	0:0	6	0
water	59:24	0:0	6	;
cond	59:26	59:32	5	row < length
water	59:26	0:0	6	row
op	59:30	0:0	6	<
water	59:32	0:0	6	length
forexpr	59:40	59:43	5	row ++
water	59:40	0:0	6	row
op	59:43	0:0	6	++
stmts	60:14	68:16	5	
for	60:14	68:16	6	(col = 0 ;col < width;col ++)
forinit	60:19	60:26	7	col = 0 ;
water	60:19	0:0	8	col
op	60:23	0:0	8	=
water	60:25	0:0	8	0
water	60:26	0:0	8	;
cond	60:28	60:34	7	col < width
water	60:28	0:0	8	col
op	60:32	0:0	8	<
water	60:34	0:0	8	width
forexpr	60:41	60:44	7	col ++
water	60:41	0:0	8	col
op	60:44	0:0	8	++
stmts	61:16	68:16	7	
water	61:16	0:0	8	{
water	62:2	0:0	8	bytebuff1
op	62:12	0:0	8	=
water	62:14	0:0	8	4
op	62:16	0:0	8	-
call	62:18	62:41	8	(uint8)
arg	62:26	62:41	9	*src&192>>6
op	62:26	0:0	10	*
water	62:27	0:0	10	src
op	62:31	0:0	10	&
water	62:33	0:0	10	192
op	62:37	0:0	10	>>
water	62:40	0:0	10	6
water	62:42	0:0	8	;
water	63:2	0:0	8	bytebuff2
op	63:12	0:0	8	=
water	63:14	0:0	8	4
op	63:16	0:0	8	-
call	63:18	63:41	8	(uint8)
arg	63:26	63:41	9	*src&48>>4
op	63:26	0:0	10	*
water	63:27	0:0	10	src
op	63:31	0:0	10	&
water	63:33	0:0	10	48
op	63:37	0:0	10	>>
water	63:40	0:0	10	4
water	63:42	0:0	8	;
water	64:2	0:0	8	bytebuff3
op	64:12	0:0	8	=
water	64:14	0:0	8	4
op	64:16	0:0	8	-
call	64:18	64:41	8	(uint8)
arg	64:26	64:41	9	*src&12>>2
op	64:26	0:0	10	*
water	64:27	0:0	10	src
op	64:31	0:0	10	&
water	64:33	0:0	10	12
op	64:37	0:0	10	>>
water	64:40	0:0	10	2
water	64:42	0:0	8	;
water	65:2	0:0	8	bytebuff4
op	65:12	0:0	8	=
water	65:14	0:0	8	4
op	65:16	0:0	8	-
call	65:18	65:34	8	(uint8)
arg	65:26	65:34	9	*src&3
op	65:26	0:0	10	*
water	65:27	0:0	10	src
op	65:31	0:0	10	&
water	65:33	0:0	10	3
water	65:35	0:0	8	;
op	66:2	0:0	8	*
water	66:3	0:0	8	src
op	66:7	0:0	8	=
water	66:9	0:0	8	(
water	66:10	0:0	8	bytebuff1
op	66:20	0:0	8	<<
water	66:23	0:0	8	6
water	66:24	0:0	8	)
op	66:26	0:0	8	||
water	66:29	0:0	8	(
water	66:30	0:0	8	bytebuff2
op	66:40	0:0	8	<<
water	66:43	0:0	8	4
water	66:44	0:0	8	)
op	66:46	0:0	8	||
water	66:49	0:0	8	(
water	66:50	0:0	8	bytebuff3
op	66:60	0:0	8	<<
water	66:63	0:0	8	2
water	66:64	0:0	8	)
op	66:66	0:0	8	||
water	66:69	0:0	8	bytebuff4
water	66:78	0:0	8	;
water	67:16	0:0	8	src
op	67:19	0:0	8	++
water	67:21	0:0	8	;
water	68:16	0:0	8	}
break	69:12	69:17	4	
label	70:4	70:10	4	case 1 :
for	70:12	75:16	4	(row = 0 ;row < length;row ++)
forinit	70:17	70:24	5	row = 0 ;
water	70:17	0:0	6	row
op	70:21	0:0	6	=
water	70:23	0:0	6	0
water	70:24	0:0	6	;
cond	70:26	70:32	5	row < length
water	70:26	0:0	6	row
op	70:30	0:0	6	<
water	70:32	0:0	6	length
forexpr	70:40	70:43	5	row ++
water	70:40	0:0	6	row
op	70:43	0:0	6	++
stmts	71:14	75:16	5	
for	71:14	75:16	6	(col = 0 ;col < width;col += 8 / ( spp * bps ))
forinit	71:19	71:26	7	col = 0 ;
water	71:19	0:0	8	col
op	71:23	0:0	8	=
water	71:25	0:0	8	0
water	71:26	0:0	8	;
cond	71:28	71:34	7	col < width
water	71:28	0:0	8	col
op	71:32	0:0	8	<
water	71:34	0:0	8	width
forexpr	71:41	71:61	7	col += 8 / ( spp * bps )
water	71:41	0:0	8	col
op	71:45	0:0	8	+=
water	71:48	0:0	8	8
op	71:50	0:0	8	/
water	71:51	0:0	8	(
water	71:52	0:0	8	spp
op	71:56	0:0	8	*
water	71:58	0:0	8	bps
water	71:61	0:0	8	)
stmts	72:16	75:16	7	
water	72:16	0:0	8	{
op	73:16	0:0	8	*
water	73:17	0:0	8	src
op	73:21	0:0	8	=
op	73:23	0:0	8	~
water	73:24	0:0	8	(
op	73:25	0:0	8	*
water	73:26	0:0	8	src
water	73:29	0:0	8	)
water	73:30	0:0	8	;
water	74:16	0:0	8	src
op	74:19	0:0	8	++
water	74:21	0:0	8	;
water	75:16	0:0	8	}
break	76:12	76:17	4	
label	77:4	77:11	4	default :
call	77:13	77:69	4	TIFFError
arg	77:23	77:36	5	"invertImage"
water	77:23	0:0	6	"invertImage"
arg	77:38	77:64	5	"Unsupported bit depth %d"
water	77:38	0:0	6	"Unsupported bit depth %d"
arg	77:66	77:69	5	bps
water	77:66	0:0	6	bps
water	77:70	0:0	4	;
return	78:6	78:17	4	(-1)
water	78:13	0:0	5	(
op	78:14	0:0	5	-
water	78:15	0:0	5	1
water	78:16	0:0	5	)
water	79:4	0:0	4	}
return	80:2	80:12	2	(0)
water	80:9	0:0	3	(
water	80:10	0:0	3	0
water	80:11	0:0	3	)
