func	1:0	83:0	0	static int	ContigCompare
params	2:13	0:0	1	
param	2:14	2:24	2	int	sample
param	2:26	2:36	2	uint32	row
param	3:7	3:24	2	unsigned char *	p1
param	3:26	3:43	2	unsigned char *	p2
param	3:45	3:57	2	tsize_t	size
stmnts	0:0	82:12	1	
decl	5:4	5:14	2	uint32	pix
decl	6:4	6:31	2	int	ppb
op	6:12	0:0	2	=
water	6:14	0:0	2	8
op	6:16	0:0	2	/
water	6:18	0:0	2	bitspersample
decl	7:4	7:24	2	int	samples_to_test
if	8:4	9:16	2	(memcmp (p1 ,p2 ,size ) == 0)
cond	8:8	8:32	3	memcmp (p1 ,p2 ,size ) == 0
call	8:8	8:27	4	memcmp
arg	8:15	8:17	5	p1
water	8:15	0:0	6	p1
arg	8:19	8:21	5	p2
water	8:19	0:0	6	p2
arg	8:23	8:27	5	size
water	8:23	0:0	6	size
op	8:29	0:0	4	==
water	8:32	0:0	4	0
stmts	9:8	9:16	3	
return	9:8	9:16	4	0
water	9:15	0:0	5	0
water	10:4	0:0	2	samples_to_test
op	10:20	0:0	2	=
water	10:22	0:0	2	(
water	10:23	0:0	2	sample
op	10:30	0:0	2	==
op	10:33	0:0	2	-
water	10:34	0:0	2	1
water	10:35	0:0	2	)
water	10:37	0:0	2	?
water	10:39	0:0	2	samplesperpixel
water	10:55	0:0	2	:
water	10:57	0:0	2	1
water	10:58	0:0	2	;
switch	11:4	81:4	2	(bitspersample)
cond	11:12	11:12	3	bitspersample
water	11:12	0:0	4	bitspersample
stmts	11:27	81:4	3	
water	11:27	0:0	4	{
label	12:6	12:12	4	case 1 :
label	12:14	12:20	4	case 2 :
label	12:22	12:28	4	case 4 :
label	12:30	12:36	4	case 8 :
water	13:6	0:0	4	{
decl	14:10	14:46	4	unsigned char	*pix1
op	14:30	0:0	4	=
water	14:32	0:0	4	p1
water	14:34	0:0	4	,
decl	14:10	14:46	4	unsigned char	*pix2
op	14:42	0:0	4	=
water	14:44	0:0	4	p2
for	15:10	27:10	4	(pix = 0 ;pix < imagewidth;pix += ppb)
forinit	15:15	15:22	5	pix = 0 ;
water	15:15	0:0	6	pix
op	15:19	0:0	6	=
water	15:21	0:0	6	0
water	15:22	0:0	6	;
cond	15:24	15:30	5	pix < imagewidth
water	15:24	0:0	6	pix
op	15:28	0:0	6	<
water	15:30	0:0	6	imagewidth
forexpr	15:42	15:49	5	pix += ppb
water	15:42	0:0	6	pix
op	15:46	0:0	6	+=
water	15:49	0:0	6	ppb
stmts	15:54	27:10	5	
water	15:54	0:0	6	{
decl	16:14	16:20	6	int	s
for	17:14	26:14	6	(s = 0 ;s < samples_to_test;s ++)
forinit	17:18	17:23	7	s = 0 ;
water	17:18	0:0	8	s
op	17:20	0:0	8	=
water	17:22	0:0	8	0
water	17:23	0:0	8	;
cond	17:25	17:29	7	s < samples_to_test
water	17:25	0:0	8	s
op	17:27	0:0	8	<
water	17:29	0:0	8	samples_to_test
forexpr	17:46	17:47	7	s ++
water	17:46	0:0	8	s
op	17:47	0:0	8	++
stmts	17:51	26:14	7	
water	17:51	0:0	8	{
if	18:18	23:18	8	(* pix1 != * pix2)
cond	18:22	18:32	9	* pix1 != * pix2
op	18:22	0:0	10	*
water	18:23	0:0	10	pix1
op	18:28	0:0	10	!=
op	18:31	0:0	10	*
water	18:32	0:0	10	pix2
stmts	18:38	23:18	9	
water	18:38	0:0	10	{
if	19:22	20:65	10	(sample == - 1)
cond	19:26	19:37	11	sample == - 1
water	19:26	0:0	12	sample
op	19:33	0:0	12	==
op	19:36	0:0	12	-
water	19:37	0:0	12	1
stmts	20:26	20:65	11	
call	20:26	20:64	12	PrintIntDiff
arg	20:39	20:42	13	row
water	20:39	0:0	14	row
arg	20:44	20:45	13	s
water	20:44	0:0	14	s
arg	20:47	20:50	13	pix
water	20:47	0:0	14	pix
arg	20:52	20:57	13	*pix1
op	20:52	0:0	14	*
water	20:53	0:0	14	pix1
arg	20:59	20:64	13	*pix2
op	20:59	0:0	14	*
water	20:60	0:0	14	pix2
water	20:65	0:0	12	;
else	21:22	22:70	10
stmts	22:26	22:70	11	
call	22:26	22:69	12	PrintIntDiff
arg	22:39	22:42	13	row
water	22:39	0:0	14	row
arg	22:44	22:50	13	sample
water	22:44	0:0	14	sample
arg	22:52	22:55	13	pix
water	22:52	0:0	14	pix
arg	22:57	22:62	13	*pix1
op	22:57	0:0	14	*
water	22:58	0:0	14	pix1
arg	22:64	22:69	13	*pix2
op	22:64	0:0	14	*
water	22:65	0:0	14	pix2
water	22:70	0:0	12	;
water	23:18	0:0	10	}
water	24:18	0:0	8	pix1
op	24:22	0:0	8	++
water	24:24	0:0	8	;
water	25:18	0:0	8	pix2
op	25:22	0:0	8	++
water	25:24	0:0	8	;
water	26:14	0:0	8	}
water	27:10	0:0	6	}
break	28:10	28:15	4	
water	29:6	0:0	4	}
label	30:6	30:13	4	case 16 :
water	31:6	0:0	4	{
decl	32:10	32:59	4	uint16	*pix1
op	32:23	0:0	4	=
water	32:25	0:0	4	(
water	32:26	0:0	4	uint16
op	32:33	0:0	4	*
water	32:34	0:0	4	)
water	32:35	0:0	4	p1
water	32:37	0:0	4	,
decl	32:10	32:59	4	uint16	*pix2
op	32:45	0:0	4	=
water	32:47	0:0	4	(
water	32:48	0:0	4	uint16
op	32:55	0:0	4	*
water	32:56	0:0	4	)
water	32:57	0:0	4	p2
for	33:10	41:10	4	(pix = 0 ;pix < imagewidth;pix ++)
forinit	33:15	33:22	5	pix = 0 ;
water	33:15	0:0	6	pix
op	33:19	0:0	6	=
water	33:21	0:0	6	0
water	33:22	0:0	6	;
cond	33:24	33:30	5	pix < imagewidth
water	33:24	0:0	6	pix
op	33:28	0:0	6	<
water	33:30	0:0	6	imagewidth
forexpr	33:42	33:45	5	pix ++
water	33:42	0:0	6	pix
op	33:45	0:0	6	++
stmts	33:49	41:10	5	
water	33:49	0:0	6	{
decl	34:14	34:19	6	int	s
for	35:14	40:14	6	(s = 0 ;s < samples_to_test;s ++)
forinit	35:18	35:23	7	s = 0 ;
water	35:18	0:0	8	s
op	35:20	0:0	8	=
water	35:22	0:0	8	0
water	35:23	0:0	8	;
cond	35:25	35:29	7	s < samples_to_test
water	35:25	0:0	8	s
op	35:27	0:0	8	<
water	35:29	0:0	8	samples_to_test
forexpr	35:46	35:47	7	s ++
water	35:46	0:0	8	s
op	35:47	0:0	8	++
stmts	35:51	40:14	7	
water	35:51	0:0	8	{
if	36:18	37:66	8	(* pix1 != * pix2)
cond	36:22	36:32	9	* pix1 != * pix2
op	36:22	0:0	10	*
water	36:23	0:0	10	pix1
op	36:28	0:0	10	!=
op	36:31	0:0	10	*
water	36:32	0:0	10	pix2
stmts	37:22	37:66	9	
call	37:22	37:65	10	PrintIntDiff
arg	37:35	37:38	11	row
water	37:35	0:0	12	row
arg	37:40	37:46	11	sample
water	37:40	0:0	12	sample
arg	37:48	37:51	11	pix
water	37:48	0:0	12	pix
arg	37:53	37:58	11	*pix1
op	37:53	0:0	12	*
water	37:54	0:0	12	pix1
arg	37:60	37:65	11	*pix2
op	37:60	0:0	12	*
water	37:61	0:0	12	pix2
water	37:66	0:0	10	;
water	38:18	0:0	8	pix1
op	38:22	0:0	8	++
water	38:24	0:0	8	;
water	39:18	0:0	8	pix2
op	39:22	0:0	8	++
water	39:24	0:0	8	;
water	40:14	0:0	8	}
water	41:10	0:0	6	}
break	42:10	42:15	4	
water	43:6	0:0	4	}
label	44:6	44:13	4	case 32 :
if	45:1	59:1	4	(sampleformat == SAMPLEFORMAT_UINT || sampleformat == SAMPLEFORMAT_INT)
cond	45:5	46:24	5	sampleformat == SAMPLEFORMAT_UINT || sampleformat == SAMPLEFORMAT_INT
water	45:5	0:0	6	sampleformat
op	45:18	0:0	6	==
water	45:21	0:0	6	SAMPLEFORMAT_UINT
op	46:5	0:0	6	||
water	46:8	0:0	6	sampleformat
op	46:21	0:0	6	==
water	46:24	0:0	6	SAMPLEFORMAT_INT
stmts	46:42	59:1	5	
water	46:42	0:0	6	{
decl	47:2	47:51	6	uint32	*pix1
op	47:15	0:0	6	=
water	47:17	0:0	6	(
water	47:18	0:0	6	uint32
op	47:25	0:0	6	*
water	47:26	0:0	6	)
water	47:27	0:0	6	p1
water	47:29	0:0	6	,
decl	47:2	47:51	6	uint32	*pix2
op	47:37	0:0	6	=
water	47:39	0:0	6	(
water	47:40	0:0	6	uint32
op	47:47	0:0	6	*
water	47:48	0:0	6	)
water	47:49	0:0	6	p2
for	48:2	58:2	6	(pix = 0 ;pix < imagewidth;pix ++)
forinit	48:7	48:14	7	pix = 0 ;
water	48:7	0:0	8	pix
op	48:11	0:0	8	=
water	48:13	0:0	8	0
water	48:14	0:0	8	;
cond	48:16	48:22	7	pix < imagewidth
water	48:16	0:0	8	pix
op	48:20	0:0	8	<
water	48:22	0:0	8	imagewidth
forexpr	48:34	48:37	7	pix ++
water	48:34	0:0	8	pix
op	48:37	0:0	8	++
stmts	48:41	58:2	7	
water	48:41	0:0	8	{
decl	49:3	49:8	8	int	s
for	50:3	57:3	8	(s = 0 ;s < samples_to_test;s ++)
forinit	50:7	50:12	9	s = 0 ;
water	50:7	0:0	10	s
op	50:9	0:0	10	=
water	50:11	0:0	10	0
water	50:12	0:0	10	;
cond	50:14	50:18	9	s < samples_to_test
water	50:14	0:0	10	s
op	50:16	0:0	10	<
water	50:18	0:0	10	samples_to_test
forexpr	50:35	50:36	9	s ++
water	50:35	0:0	10	s
op	50:36	0:0	10	++
stmts	50:40	57:3	9	
water	50:40	0:0	10	{
if	51:4	54:4	10	(* pix1 != * pix2)
cond	51:8	51:18	11	* pix1 != * pix2
op	51:8	0:0	12	*
water	51:9	0:0	12	pix1
op	51:14	0:0	12	!=
op	51:17	0:0	12	*
water	51:18	0:0	12	pix2
stmts	51:24	54:4	11	
water	51:24	0:0	12	{
call	52:5	53:23	12	PrintIntDiff
arg	52:18	52:21	13	row
water	52:18	0:0	14	row
arg	52:23	52:29	13	sample
water	52:23	0:0	14	sample
arg	52:31	52:34	13	pix
water	52:31	0:0	14	pix
arg	53:11	53:16	13	*pix1
op	53:11	0:0	14	*
water	53:12	0:0	14	pix1
arg	53:18	53:23	13	*pix2
op	53:18	0:0	14	*
water	53:19	0:0	14	pix2
water	53:24	0:0	12	;
water	54:4	0:0	12	}
water	55:4	0:0	10	pix1
op	55:8	0:0	10	++
water	55:10	0:0	10	;
water	56:4	0:0	10	pix2
op	56:8	0:0	10	++
water	56:10	0:0	10	;
water	57:3	0:0	10	}
water	58:2	0:0	8	}
water	59:1	0:0	6	}
else	59:3	72:1	4
stmts	59:8	72:1	5	
if	59:8	72:1	6	(sampleformat == SAMPLEFORMAT_IEEEFP)
cond	59:12	59:28	7	sampleformat == SAMPLEFORMAT_IEEEFP
water	59:12	0:0	8	sampleformat
op	59:25	0:0	8	==
water	59:28	0:0	8	SAMPLEFORMAT_IEEEFP
stmts	59:49	72:1	7	
water	59:49	0:0	8	{
decl	60:2	60:48	8	float	*pix1
op	60:14	0:0	8	=
water	60:16	0:0	8	(
water	60:17	0:0	8	float
op	60:23	0:0	8	*
water	60:24	0:0	8	)
water	60:25	0:0	8	p1
water	60:27	0:0	8	,
decl	60:2	60:48	8	float	*pix2
op	60:35	0:0	8	=
water	60:37	0:0	8	(
water	60:38	0:0	8	float
op	60:44	0:0	8	*
water	60:45	0:0	8	)
water	60:46	0:0	8	p2
for	61:2	71:2	8	(pix = 0 ;pix < imagewidth;pix ++)
forinit	61:7	61:14	9	pix = 0 ;
water	61:7	0:0	10	pix
op	61:11	0:0	10	=
water	61:13	0:0	10	0
water	61:14	0:0	10	;
cond	61:16	61:22	9	pix < imagewidth
water	61:16	0:0	10	pix
op	61:20	0:0	10	<
water	61:22	0:0	10	imagewidth
forexpr	61:34	61:37	9	pix ++
water	61:34	0:0	10	pix
op	61:37	0:0	10	++
stmts	61:41	71:2	9	
water	61:41	0:0	10	{
decl	62:3	62:8	10	int	s
for	63:3	70:3	10	(s = 0 ;s < samples_to_test;s ++)
forinit	63:7	63:12	11	s = 0 ;
water	63:7	0:0	12	s
op	63:9	0:0	12	=
water	63:11	0:0	12	0
water	63:12	0:0	12	;
cond	63:14	63:18	11	s < samples_to_test
water	63:14	0:0	12	s
op	63:16	0:0	12	<
water	63:18	0:0	12	samples_to_test
forexpr	63:35	63:36	11	s ++
water	63:35	0:0	12	s
op	63:36	0:0	12	++
stmts	63:40	70:3	11	
water	63:40	0:0	12	{
if	64:4	67:4	12	(fabs (* pix1 - * pix2 ) < 0 . 000000000001)
cond	64:8	64:32	13	fabs (* pix1 - * pix2 ) < 0 . 000000000001
call	64:8	64:26	14	fabs
arg	64:13	64:26	15	*pix1-*pix2
op	64:13	0:0	16	*
water	64:14	0:0	16	pix1
op	64:19	0:0	16	-
op	64:21	0:0	16	*
water	64:22	0:0	16	pix2
op	64:28	0:0	14	<
water	64:30	0:0	14	0
op	64:31	0:0	14	.
water	64:32	0:0	14	000000000001
stmts	64:46	67:4	13	
water	64:46	0:0	14	{
call	65:5	66:25	14	PrintFloatDiff
arg	65:20	65:23	15	row
water	65:20	0:0	16	row
arg	65:25	65:31	15	sample
water	65:25	0:0	16	sample
arg	65:33	65:36	15	pix
water	65:33	0:0	16	pix
arg	66:13	66:18	15	*pix1
op	66:13	0:0	16	*
water	66:14	0:0	16	pix1
arg	66:20	66:25	15	*pix2
op	66:20	0:0	16	*
water	66:21	0:0	16	pix2
water	66:26	0:0	14	;
water	67:4	0:0	14	}
water	68:4	0:0	12	pix1
op	68:8	0:0	12	++
water	68:10	0:0	12	;
water	69:4	0:0	12	pix2
op	69:8	0:0	12	++
water	69:10	0:0	12	;
water	70:3	0:0	12	}
water	71:2	0:0	10	}
water	72:1	0:0	8	}
else	72:3	76:1	4
stmts	72:8	76:1	5	
water	72:8	0:0	6	{
call	73:4	74:17	6	fprintf
arg	73:12	73:18	7	stderr
water	73:12	0:0	8	stderr
arg	73:20	73:58	7	"Sample format %d is not supported.\n"
water	73:20	0:0	8	"Sample format %d is not supported.\n"
arg	74:5	74:17	7	sampleformat
water	74:5	0:0	8	sampleformat
water	74:18	0:0	6	;
return	75:4	75:13	6	-1
op	75:11	0:0	7	-
water	75:12	0:0	7	1
water	76:1	0:0	6	}
break	77:8	77:13	4	
label	78:6	78:13	4	default :
call	79:1	79:66	4	fprintf
arg	79:9	79:15	5	stderr
water	79:9	0:0	6	stderr
arg	79:17	79:51	5	"Bit depth %d is not supported.\n"
water	79:17	0:0	6	"Bit depth %d is not supported.\n"
arg	79:53	79:66	5	bitspersample
water	79:53	0:0	6	bitspersample
water	79:67	0:0	4	;
return	80:1	80:10	4	-1
op	80:8	0:0	5	-
water	80:9	0:0	5	1
water	81:4	0:0	4	}
return	82:4	82:12	2	0
water	82:11	0:0	3	0
