func	1:0	135:0	0	static int	PixarLogDecode
params	2:14	0:0	1	
param	2:15	2:24	2	TIFF *	tif
param	2:26	2:35	2	uint8 *	op
param	2:37	2:49	2	tmsize_t	occ
param	2:51	2:59	2	uint16	s
stmnts	4:1	134:11	1	
water	4:1	0:0	2	static
water	4:8	0:0	2	const
water	4:14	0:0	2	char
water	4:19	0:0	2	module
op	4:25	0:0	2	[
op	4:26	0:0	2	]
op	4:28	0:0	2	=
water	4:30	0:0	2	"PixarLogDecode"
water	4:46	0:0	2	;
decl	5:1	5:34	2	TIFFDirectory	*td
op	5:19	0:0	2	=
op	5:21	0:0	2	&
water	5:22	0:0	2	tif
op	5:25	0:0	2	->
water	5:27	0:0	2	tif_dir
decl	6:1	6:38	2	PixarLogState	*sp
op	6:19	0:0	2	=
call	6:21	6:37	3	DecoderState
arg	6:34	6:37	4	tif
water	6:34	0:0	5	tif
decl	7:1	7:11	2	tmsize_t	i
decl	8:1	8:18	2	tmsize_t	nsamples
decl	9:1	9:9	2	int	llen
decl	10:1	10:11	2	uint16	*up
switch	11:1	29:1	2	(sp -> user_datafmt)
cond	11:9	11:13	3	sp -> user_datafmt
water	11:9	0:0	4	sp
op	11:11	0:0	4	->
water	11:13	0:0	4	user_datafmt
stmts	11:27	29:1	3	
water	11:27	0:0	4	{
label	12:1	12:27	4	case PIXARLOGDATAFMT_FLOAT :
water	13:2	0:0	4	nsamples
op	13:11	0:0	4	=
water	13:13	0:0	4	occ
op	13:17	0:0	4	/
op	13:19	0:0	4	sizeof
water	13:25	0:0	4	(
water	13:26	0:0	4	float
water	13:31	0:0	4	)
water	13:32	0:0	4	;
break	14:2	14:7	4	
label	15:1	15:27	4	case PIXARLOGDATAFMT_16BIT :
label	16:1	16:32	4	case PIXARLOGDATAFMT_12BITPICIO :
label	17:1	17:30	4	case PIXARLOGDATAFMT_11BITLOG :
water	18:2	0:0	4	nsamples
op	18:11	0:0	4	=
water	18:13	0:0	4	occ
op	18:17	0:0	4	/
op	18:19	0:0	4	sizeof
water	18:25	0:0	4	(
water	18:26	0:0	4	uint16
water	18:32	0:0	4	)
water	18:33	0:0	4	;
break	19:2	19:7	4	
label	20:1	20:26	4	case PIXARLOGDATAFMT_8BIT :
label	21:1	21:30	4	case PIXARLOGDATAFMT_8BITABGR :
water	22:2	0:0	4	nsamples
op	22:11	0:0	4	=
water	22:13	0:0	4	occ
water	22:16	0:0	4	;
break	23:2	23:7	4	
label	24:1	24:8	4	default :
call	25:2	27:23	4	TIFFErrorExt
arg	25:15	25:34	5	tif->tif_clientdata
water	25:15	0:0	6	tif
op	25:18	0:0	6	->
water	25:20	0:0	6	tif_clientdata
arg	25:36	25:42	5	module
water	25:36	0:0	6	module
arg	26:3	26:43	5	"%d bit input not supported in PixarLog"
water	26:3	0:0	6	"%d bit input not supported in PixarLog"
arg	27:3	27:23	5	td->td_bitspersample
water	27:3	0:0	6	td
op	27:5	0:0	6	->
water	27:7	0:0	6	td_bitspersample
water	27:24	0:0	4	;
return	28:2	28:10	4	0
water	28:9	0:0	5	0
water	29:1	0:0	4	}
water	30:1	0:0	2	llen
op	30:6	0:0	2	=
water	30:8	0:0	2	sp
op	30:10	0:0	2	->
water	30:12	0:0	2	stride
op	30:19	0:0	2	*
water	30:21	0:0	2	td
op	30:23	0:0	2	->
water	30:25	0:0	2	td_imagewidth
water	30:38	0:0	2	;
water	31:1	0:0	2	(
water	31:2	0:0	2	void
water	31:6	0:0	2	)
water	31:8	0:0	2	s
water	31:9	0:0	2	;
call	32:1	32:18	2	assert
arg	32:8	32:18	3	sp!=NULL
water	32:8	0:0	4	sp
op	32:11	0:0	4	!=
water	32:14	0:0	4	NULL
water	32:19	0:0	2	;
water	33:8	0:0	2	sp
op	33:10	0:0	2	->
water	33:12	0:0	2	stream
op	33:18	0:0	2	.
water	33:19	0:0	2	next_in
op	33:27	0:0	2	=
water	33:29	0:0	2	tif
op	33:32	0:0	2	->
water	33:34	0:0	2	tif_rawcp
water	33:43	0:0	2	;
water	34:1	0:0	2	sp
op	34:3	0:0	2	->
water	34:5	0:0	2	stream
op	34:11	0:0	2	.
water	34:12	0:0	2	avail_in
op	34:21	0:0	2	=
water	34:23	0:0	2	(
water	34:24	0:0	2	uInt
water	34:28	0:0	2	)
water	34:30	0:0	2	tif
op	34:33	0:0	2	->
water	34:35	0:0	2	tif_rawcc
water	34:44	0:0	2	;
water	35:1	0:0	2	sp
op	35:3	0:0	2	->
water	35:5	0:0	2	stream
op	35:11	0:0	2	.
water	35:12	0:0	2	next_out
op	35:21	0:0	2	=
water	35:23	0:0	2	(
water	35:24	0:0	2	unsigned
water	35:33	0:0	2	char
op	35:38	0:0	2	*
water	35:39	0:0	2	)
water	35:41	0:0	2	sp
op	35:43	0:0	2	->
water	35:45	0:0	2	tbuf
water	35:49	0:0	2	;
call	36:1	36:39	2	assert
arg	36:8	36:39	3	sizeof(sp->stream.avail_out)==4
op	36:8	0:0	4	sizeof
water	36:14	0:0	4	(
water	36:15	0:0	4	sp
op	36:17	0:0	4	->
water	36:19	0:0	4	stream
op	36:25	0:0	4	.
water	36:26	0:0	4	avail_out
water	36:35	0:0	4	)
op	36:36	0:0	4	==
water	36:38	0:0	4	4
water	36:40	0:0	2	;
water	40:1	0:0	2	sp
op	40:3	0:0	2	->
water	40:5	0:0	2	stream
op	40:11	0:0	2	.
water	40:12	0:0	2	avail_out
op	40:22	0:0	2	=
call	40:24	40:57	2	(uInt)
arg	40:32	40:57	3	nsamples*sizeof(uint16)
water	40:32	0:0	4	nsamples
op	40:41	0:0	4	*
op	40:43	0:0	4	sizeof
water	40:49	0:0	4	(
water	40:50	0:0	4	uint16
water	40:56	0:0	4	)
water	40:58	0:0	2	;
if	41:1	45:1	2	(sp -> stream . avail_out != nsamples * sizeof ( uint16 ))
cond	41:5	41:53	3	sp -> stream . avail_out != nsamples * sizeof ( uint16 )
water	41:5	0:0	4	sp
op	41:7	0:0	4	->
water	41:9	0:0	4	stream
op	41:15	0:0	4	.
water	41:16	0:0	4	avail_out
op	41:26	0:0	4	!=
water	41:29	0:0	4	nsamples
op	41:38	0:0	4	*
op	41:40	0:0	4	sizeof
water	41:46	0:0	4	(
water	41:47	0:0	4	uint16
water	41:53	0:0	4	)
stmts	42:1	45:1	3	
water	42:1	0:0	4	{
call	43:2	43:85	4	TIFFErrorExt
arg	43:15	43:34	5	tif->tif_clientdata
water	43:15	0:0	6	tif
op	43:18	0:0	6	->
water	43:20	0:0	6	tif_clientdata
arg	43:36	43:42	5	module
water	43:36	0:0	6	module
arg	43:44	43:85	5	"ZLib cannot deal with buffers this size"
water	43:44	0:0	6	"ZLib cannot deal with buffers this size"
water	43:86	0:0	4	;
return	44:2	44:12	4	(0)
water	44:9	0:0	5	(
water	44:10	0:0	5	0
water	44:11	0:0	5	)
water	45:1	0:0	4	}
if	47:1	51:1	2	(( tmsize_t ) sp -> stream . avail_out > sp -> tbuf_size)
cond	47:5	47:42	3	( tmsize_t ) sp -> stream . avail_out > sp -> tbuf_size
water	47:5	0:0	4	(
water	47:6	0:0	4	tmsize_t
water	47:14	0:0	4	)
water	47:15	0:0	4	sp
op	47:17	0:0	4	->
water	47:19	0:0	4	stream
op	47:25	0:0	4	.
water	47:26	0:0	4	avail_out
op	47:36	0:0	4	>
water	47:38	0:0	4	sp
op	47:40	0:0	4	->
water	47:42	0:0	4	tbuf_size
stmts	48:1	51:1	3	
water	48:1	0:0	4	{
call	49:2	49:82	4	TIFFErrorExt
arg	49:15	49:34	5	tif->tif_clientdata
water	49:15	0:0	6	tif
op	49:18	0:0	6	->
water	49:20	0:0	6	tif_clientdata
arg	49:36	49:42	5	module
water	49:36	0:0	6	module
arg	49:44	49:82	5	"sp->stream.avail_out > sp->tbuf_size"
water	49:44	0:0	6	"sp->stream.avail_out > sp->tbuf_size"
water	49:83	0:0	4	;
return	50:2	50:12	4	(0)
water	50:9	0:0	5	(
water	50:10	0:0	5	0
water	50:11	0:0	5	)
water	51:1	0:0	4	}
do	52:1	70:1	2	(sp -> stream . avail_out > 0)
cond	70:10	70:33	3	sp -> stream . avail_out > 0
water	70:10	0:0	4	sp
op	70:12	0:0	4	->
water	70:14	0:0	4	stream
op	70:20	0:0	4	.
water	70:21	0:0	4	avail_out
op	70:31	0:0	4	>
water	70:33	0:0	4	0
stmts	52:4	70:1	3	
water	52:4	0:0	4	{
decl	53:2	53:51	4	int	state
op	53:12	0:0	4	=
call	53:14	53:50	5	inflate
arg	53:22	53:33	6	&sp->stream
op	53:22	0:0	7	&
water	53:23	0:0	7	sp
op	53:25	0:0	7	->
water	53:27	0:0	7	stream
arg	53:35	53:50	6	Z_PARTIAL_FLUSH
water	53:35	0:0	7	Z_PARTIAL_FLUSH
if	54:2	56:2	4	(state == Z_STREAM_END)
cond	54:6	54:15	5	state == Z_STREAM_END
water	54:6	0:0	6	state
op	54:12	0:0	6	==
water	54:15	0:0	6	Z_STREAM_END
stmts	54:29	56:2	5	
water	54:29	0:0	6	{
break	55:3	55:8	6	
water	56:2	0:0	6	}
if	57:2	64:2	4	(state == Z_DATA_ERROR)
cond	57:6	57:15	5	state == Z_DATA_ERROR
water	57:6	0:0	6	state
op	57:12	0:0	6	==
water	57:15	0:0	6	Z_DATA_ERROR
stmts	57:29	64:2	5	
water	57:29	0:0	6	{
call	58:3	60:79	6	TIFFErrorExt
arg	58:16	58:35	7	tif->tif_clientdata
water	58:16	0:0	8	tif
op	58:19	0:0	8	->
water	58:21	0:0	8	tif_clientdata
arg	58:37	58:43	7	module
water	58:37	0:0	8	module
arg	59:7	59:43	7	"Decoding error at scanline %lu, %s"
water	59:7	0:0	8	"Decoding error at scanline %lu, %s"
arg	60:7	60:35	7	(unsignedlong)tif->tif_row
water	60:7	0:0	8	(
water	60:8	0:0	8	unsigned
water	60:17	0:0	8	long
water	60:21	0:0	8	)
water	60:23	0:0	8	tif
op	60:26	0:0	8	->
water	60:28	0:0	8	tif_row
arg	60:37	60:79	7	sp->stream.msg?sp->stream.msg:"(null)"
water	60:37	0:0	8	sp
op	60:39	0:0	8	->
water	60:41	0:0	8	stream
op	60:47	0:0	8	.
water	60:48	0:0	8	msg
water	60:52	0:0	8	?
water	60:54	0:0	8	sp
op	60:56	0:0	8	->
water	60:58	0:0	8	stream
op	60:64	0:0	8	.
water	60:65	0:0	8	msg
water	60:69	0:0	8	:
water	60:71	0:0	8	"(null)"
water	60:80	0:0	6	;
if	61:3	62:14	6	(inflateSync (& sp -> stream ) != Z_OK)
cond	61:7	61:35	7	inflateSync (& sp -> stream ) != Z_OK
call	61:7	61:30	8	inflateSync
arg	61:19	61:30	9	&sp->stream
op	61:19	0:0	10	&
water	61:20	0:0	10	sp
op	61:22	0:0	10	->
water	61:24	0:0	10	stream
op	61:32	0:0	8	!=
water	61:35	0:0	8	Z_OK
stmts	62:4	62:14	7	
return	62:4	62:14	8	(0)
water	62:11	0:0	9	(
water	62:12	0:0	9	0
water	62:13	0:0	9	)
continue	63:3	63:11	6	
water	64:2	0:0	6	}
if	65:2	69:2	4	(state != Z_OK)
cond	65:6	65:15	5	state != Z_OK
water	65:6	0:0	6	state
op	65:12	0:0	6	!=
water	65:15	0:0	6	Z_OK
stmts	65:21	69:2	5	
water	65:21	0:0	6	{
call	66:3	67:49	6	TIFFErrorExt
arg	66:16	66:35	7	tif->tif_clientdata
water	66:16	0:0	8	tif
op	66:19	0:0	8	->
water	66:21	0:0	8	tif_clientdata
arg	66:37	66:43	7	module
water	66:37	0:0	8	module
arg	66:45	66:61	7	"ZLib error: %s"
water	66:45	0:0	8	"ZLib error: %s"
arg	67:7	67:49	7	sp->stream.msg?sp->stream.msg:"(null)"
water	67:7	0:0	8	sp
op	67:9	0:0	8	->
water	67:11	0:0	8	stream
op	67:17	0:0	8	.
water	67:18	0:0	8	msg
water	67:22	0:0	8	?
water	67:24	0:0	8	sp
op	67:26	0:0	8	->
water	67:28	0:0	8	stream
op	67:34	0:0	8	.
water	67:35	0:0	8	msg
water	67:39	0:0	8	:
water	67:41	0:0	8	"(null)"
water	67:50	0:0	6	;
return	68:3	68:13	6	(0)
water	68:10	0:0	7	(
water	68:11	0:0	7	0
water	68:12	0:0	7	)
water	69:2	0:0	6	}
water	70:1	0:0	4	}
water	70:35	0:0	2	;
if	72:1	77:1	2	(sp -> stream . avail_out != 0)
cond	72:5	72:29	3	sp -> stream . avail_out != 0
water	72:5	0:0	4	sp
op	72:7	0:0	4	->
water	72:9	0:0	4	stream
op	72:15	0:0	4	.
water	72:16	0:0	4	avail_out
op	72:26	0:0	4	!=
water	72:29	0:0	4	0
stmts	72:32	77:1	3	
water	72:32	0:0	4	{
call	73:2	75:72	4	TIFFErrorExt
arg	73:15	73:34	5	tif->tif_clientdata
water	73:15	0:0	6	tif
op	73:18	0:0	6	->
water	73:20	0:0	6	tif_clientdata
arg	73:36	73:42	5	module
water	73:36	0:0	6	module
arg	74:6	74:76	5	"Not enough data at scanline %lu (short "TIFF_UINT64_FORMAT" bytes)"
water	74:6	0:0	6	"Not enough data at scanline %lu (short "
water	74:48	0:0	6	TIFF_UINT64_FORMAT
water	74:67	0:0	6	" bytes)"
arg	75:6	75:34	5	(unsignedlong)tif->tif_row
water	75:6	0:0	6	(
water	75:7	0:0	6	unsigned
water	75:16	0:0	6	long
water	75:20	0:0	6	)
water	75:22	0:0	6	tif
op	75:25	0:0	6	->
water	75:27	0:0	6	tif_row
arg	75:36	75:72	5	(TIFF_UINT64_T)sp->stream.avail_out
water	75:36	0:0	6	(
water	75:37	0:0	6	TIFF_UINT64_T
water	75:50	0:0	6	)
water	75:52	0:0	6	sp
op	75:54	0:0	6	->
water	75:56	0:0	6	stream
op	75:62	0:0	6	.
water	75:63	0:0	6	avail_out
water	75:73	0:0	4	;
return	76:2	76:12	4	(0)
water	76:9	0:0	5	(
water	76:10	0:0	5	0
water	76:11	0:0	5	)
water	77:1	0:0	4	}
water	78:8	0:0	2	tif
op	78:11	0:0	2	->
water	78:13	0:0	2	tif_rawcp
op	78:23	0:0	2	=
water	78:25	0:0	2	sp
op	78:27	0:0	2	->
water	78:29	0:0	2	stream
op	78:35	0:0	2	.
water	78:36	0:0	2	next_in
water	78:43	0:0	2	;
water	79:8	0:0	2	tif
op	79:11	0:0	2	->
water	79:13	0:0	2	tif_rawcc
op	79:23	0:0	2	=
water	79:25	0:0	2	sp
op	79:27	0:0	2	->
water	79:29	0:0	2	stream
op	79:35	0:0	2	.
water	79:36	0:0	2	avail_in
water	79:44	0:0	2	;
water	80:1	0:0	2	up
op	80:4	0:0	2	=
water	80:6	0:0	2	sp
op	80:8	0:0	2	->
water	80:10	0:0	2	tbuf
water	80:14	0:0	2	;
if	82:1	83:36	2	(tif -> tif_flags & TIFF_SWAB)
cond	82:5	82:22	3	tif -> tif_flags & TIFF_SWAB
water	82:5	0:0	4	tif
op	82:8	0:0	4	->
water	82:10	0:0	4	tif_flags
op	82:20	0:0	4	&
water	82:22	0:0	4	TIFF_SWAB
stmts	83:2	83:36	3	
call	83:2	83:35	4	TIFFSwabArrayOfShort
arg	83:23	83:25	5	up
water	83:23	0:0	6	up
arg	83:27	83:35	5	nsamples
water	83:27	0:0	6	nsamples
water	83:36	0:0	4	;
if	89:1	94:1	2	(nsamples % llen)
cond	89:5	89:16	3	nsamples % llen
water	89:5	0:0	4	nsamples
op	89:14	0:0	4	%
water	89:16	0:0	4	llen
stmts	89:22	94:1	3	
water	89:22	0:0	4	{
call	90:2	92:73	4	TIFFWarningExt
arg	90:17	90:36	5	tif->tif_clientdata
water	90:17	0:0	6	tif
op	90:20	0:0	6	->
water	90:22	0:0	6	tif_clientdata
arg	90:38	90:44	5	module
water	90:38	0:0	6	module
arg	91:3	92:25	5	"stride %lu is not a multiple of sample count, ""%lu, data truncated."
water	91:3	0:0	6	"stride %lu is not a multiple of sample count, "
water	92:3	0:0	6	"%lu, data truncated."
arg	92:27	92:47	5	(unsignedlong)llen
water	92:27	0:0	6	(
water	92:28	0:0	6	unsigned
water	92:37	0:0	6	long
water	92:41	0:0	6	)
water	92:43	0:0	6	llen
arg	92:49	92:73	5	(unsignedlong)nsamples
water	92:49	0:0	6	(
water	92:50	0:0	6	unsigned
water	92:59	0:0	6	long
water	92:63	0:0	6	)
water	92:65	0:0	6	nsamples
water	92:74	0:0	4	;
water	93:2	0:0	4	nsamples
op	93:11	0:0	4	-=
water	93:14	0:0	4	nsamples
op	93:23	0:0	4	%
water	93:25	0:0	4	llen
water	93:29	0:0	4	;
water	94:1	0:0	4	}
for	95:1	133:1	2	(i = 0 ;i < nsamples;i += llen , up += llen)
forinit	95:6	95:11	3	i = 0 ;
water	95:6	0:0	4	i
op	95:8	0:0	4	=
water	95:10	0:0	4	0
water	95:11	0:0	4	;
cond	95:13	95:17	3	i < nsamples
water	95:13	0:0	4	i
op	95:15	0:0	4	<
water	95:17	0:0	4	nsamples
forexpr	95:27	95:44	3	i += llen , up += llen
water	95:27	0:0	4	i
op	95:29	0:0	4	+=
water	95:32	0:0	4	llen
water	95:36	0:0	4	,
water	95:38	0:0	4	up
op	95:41	0:0	4	+=
water	95:44	0:0	4	llen
stmts	95:50	133:1	3	
water	95:50	0:0	4	{
switch	96:2	132:2	4	(sp -> user_datafmt)
cond	96:10	96:14	5	sp -> user_datafmt
water	96:10	0:0	6	sp
op	96:12	0:0	6	->
water	96:14	0:0	6	user_datafmt
stmts	96:29	132:2	5	
water	96:29	0:0	6	{
label	97:2	97:28	6	case PIXARLOGDATAFMT_FLOAT :
call	98:3	99:31	6	horizontalAccumulateF
arg	98:25	98:27	7	up
water	98:25	0:0	8	up
arg	98:29	98:33	7	llen
water	98:29	0:0	8	llen
arg	98:35	98:45	7	sp->stride
water	98:35	0:0	8	sp
op	98:37	0:0	8	->
water	98:39	0:0	8	stride
arg	99:5	99:16	7	(float*)op
water	99:5	0:0	8	(
water	99:6	0:0	8	float
op	99:12	0:0	8	*
water	99:13	0:0	8	)
water	99:14	0:0	8	op
arg	99:18	99:31	7	sp->ToLinearF
water	99:18	0:0	8	sp
op	99:20	0:0	8	->
water	99:22	0:0	8	ToLinearF
water	99:32	0:0	6	;
water	100:3	0:0	6	op
op	100:6	0:0	6	+=
water	100:9	0:0	6	llen
op	100:14	0:0	6	*
op	100:16	0:0	6	sizeof
water	100:22	0:0	6	(
water	100:23	0:0	6	float
water	100:28	0:0	6	)
water	100:29	0:0	6	;
break	101:3	101:8	6	
label	102:2	102:28	6	case PIXARLOGDATAFMT_16BIT :
call	103:3	104:33	6	horizontalAccumulate16
arg	103:26	103:28	7	up
water	103:26	0:0	8	up
arg	103:30	103:34	7	llen
water	103:30	0:0	8	llen
arg	103:36	103:46	7	sp->stride
water	103:36	0:0	8	sp
op	103:38	0:0	8	->
water	103:40	0:0	8	stride
arg	104:5	104:17	7	(uint16*)op
water	104:5	0:0	8	(
water	104:6	0:0	8	uint16
op	104:13	0:0	8	*
water	104:14	0:0	8	)
water	104:15	0:0	8	op
arg	104:19	104:33	7	sp->ToLinear16
water	104:19	0:0	8	sp
op	104:21	0:0	8	->
water	104:23	0:0	8	ToLinear16
water	104:34	0:0	6	;
water	105:3	0:0	6	op
op	105:6	0:0	6	+=
water	105:9	0:0	6	llen
op	105:14	0:0	6	*
op	105:16	0:0	6	sizeof
water	105:22	0:0	6	(
water	105:23	0:0	6	uint16
water	105:29	0:0	6	)
water	105:30	0:0	6	;
break	106:3	106:8	6	
label	107:2	107:33	6	case PIXARLOGDATAFMT_12BITPICIO :
call	108:3	109:31	6	horizontalAccumulate12
arg	108:26	108:28	7	up
water	108:26	0:0	8	up
arg	108:30	108:34	7	llen
water	108:30	0:0	8	llen
arg	108:36	108:46	7	sp->stride
water	108:36	0:0	8	sp
op	108:38	0:0	8	->
water	108:40	0:0	8	stride
arg	109:5	109:16	7	(int16*)op
water	109:5	0:0	8	(
water	109:6	0:0	8	int16
op	109:12	0:0	8	*
water	109:13	0:0	8	)
water	109:14	0:0	8	op
arg	109:18	109:31	7	sp->ToLinearF
water	109:18	0:0	8	sp
op	109:20	0:0	8	->
water	109:22	0:0	8	ToLinearF
water	109:32	0:0	6	;
water	110:3	0:0	6	op
op	110:6	0:0	6	+=
water	110:9	0:0	6	llen
op	110:14	0:0	6	*
op	110:16	0:0	6	sizeof
water	110:22	0:0	6	(
water	110:23	0:0	6	int16
water	110:28	0:0	6	)
water	110:29	0:0	6	;
break	111:3	111:8	6	
label	112:2	112:31	6	case PIXARLOGDATAFMT_11BITLOG :
call	113:3	114:17	6	horizontalAccumulate11
arg	113:26	113:28	7	up
water	113:26	0:0	8	up
arg	113:30	113:34	7	llen
water	113:30	0:0	8	llen
arg	113:36	113:46	7	sp->stride
water	113:36	0:0	8	sp
op	113:38	0:0	8	->
water	113:40	0:0	8	stride
arg	114:5	114:17	7	(uint16*)op
water	114:5	0:0	8	(
water	114:6	0:0	8	uint16
op	114:13	0:0	8	*
water	114:14	0:0	8	)
water	114:15	0:0	8	op
water	114:18	0:0	6	;
water	115:3	0:0	6	op
op	115:6	0:0	6	+=
water	115:9	0:0	6	llen
op	115:14	0:0	6	*
op	115:16	0:0	6	sizeof
water	115:22	0:0	6	(
water	115:23	0:0	6	uint16
water	115:29	0:0	6	)
water	115:30	0:0	6	;
break	116:3	116:8	6	
label	117:2	117:27	6	case PIXARLOGDATAFMT_8BIT :
call	118:3	119:39	6	horizontalAccumulate8
arg	118:25	118:27	7	up
water	118:25	0:0	8	up
arg	118:29	118:33	7	llen
water	118:29	0:0	8	llen
arg	118:35	118:45	7	sp->stride
water	118:35	0:0	8	sp
op	118:37	0:0	8	->
water	118:39	0:0	8	stride
arg	119:5	119:24	7	(unsignedchar*)op
water	119:5	0:0	8	(
water	119:6	0:0	8	unsigned
water	119:15	0:0	8	char
op	119:20	0:0	8	*
water	119:21	0:0	8	)
water	119:22	0:0	8	op
arg	119:26	119:39	7	sp->ToLinear8
water	119:26	0:0	8	sp
op	119:28	0:0	8	->
water	119:30	0:0	8	ToLinear8
water	119:40	0:0	6	;
water	120:3	0:0	6	op
op	120:6	0:0	6	+=
water	120:9	0:0	6	llen
op	120:14	0:0	6	*
op	120:16	0:0	6	sizeof
water	120:22	0:0	6	(
water	120:23	0:0	6	unsigned
water	120:32	0:0	6	char
water	120:36	0:0	6	)
water	120:37	0:0	6	;
break	121:3	121:8	6	
label	122:2	122:31	6	case PIXARLOGDATAFMT_8BITABGR :
call	123:3	124:39	6	horizontalAccumulate8abgr
arg	123:29	123:31	7	up
water	123:29	0:0	8	up
arg	123:33	123:37	7	llen
water	123:33	0:0	8	llen
arg	123:39	123:49	7	sp->stride
water	123:39	0:0	8	sp
op	123:41	0:0	8	->
water	123:43	0:0	8	stride
arg	124:5	124:24	7	(unsignedchar*)op
water	124:5	0:0	8	(
water	124:6	0:0	8	unsigned
water	124:15	0:0	8	char
op	124:20	0:0	8	*
water	124:21	0:0	8	)
water	124:22	0:0	8	op
arg	124:26	124:39	7	sp->ToLinear8
water	124:26	0:0	8	sp
op	124:28	0:0	8	->
water	124:30	0:0	8	ToLinear8
water	124:40	0:0	6	;
water	125:3	0:0	6	op
op	125:6	0:0	6	+=
water	125:9	0:0	6	llen
op	125:14	0:0	6	*
op	125:16	0:0	6	sizeof
water	125:22	0:0	6	(
water	125:23	0:0	6	unsigned
water	125:32	0:0	6	char
water	125:36	0:0	6	)
water	125:37	0:0	6	;
break	126:3	126:8	6	
label	127:2	127:9	6	default :
call	128:3	130:26	6	TIFFErrorExt
arg	128:16	128:35	7	tif->tif_clientdata
water	128:16	0:0	8	tif
op	128:19	0:0	8	->
water	128:21	0:0	8	tif_clientdata
arg	128:37	128:43	7	module
water	128:37	0:0	8	module
arg	129:6	129:35	7	"Unsupported bits/sample: %d"
water	129:6	0:0	8	"Unsupported bits/sample: %d"
arg	130:6	130:26	7	td->td_bitspersample
water	130:6	0:0	8	td
op	130:8	0:0	8	->
water	130:10	0:0	8	td_bitspersample
water	130:27	0:0	6	;
return	131:3	131:13	6	(0)
water	131:10	0:0	7	(
water	131:11	0:0	7	0
water	131:12	0:0	7	)
water	132:2	0:0	6	}
water	133:1	0:0	4	}
return	134:1	134:11	2	(1)
water	134:8	0:0	3	(
water	134:9	0:0	3	1
water	134:10	0:0	3	)
