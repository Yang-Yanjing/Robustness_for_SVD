func	1:0	75:2	0	static int	rotateContigSamples16bits
params	2:25	0:0	1	
param	2:26	2:41	2	uint16	rotation
param	2:43	2:53	2	uint16	spp
param	2:55	2:65	2	uint16	bps
param	2:67	2:79	2	uint32	width
param	3:25	3:38	2	uint32	length
param	3:42	3:52	2	uint32	col
param	3:54	3:64	2	uint8 *	src
param	3:66	3:76	2	uint8 *	dst
stmnts	0:0	74:12	1	
decl	5:2	5:25	2	int	ready_bits
op	5:22	0:0	2	=
water	5:24	0:0	2	0
decl	6:2	6:35	2	uint32	row
water	6:14	0:0	2	,
decl	6:2	6:35	2	uint32	rowsize
water	6:23	0:0	2	,
decl	6:2	6:35	2	uint32	bit_offset
decl	7:2	7:36	2	uint32	src_byte
op	7:20	0:0	2	=
water	7:22	0:0	2	0
water	7:23	0:0	2	,
decl	7:2	7:36	2	uint32	src_bit
op	7:33	0:0	2	=
water	7:35	0:0	2	0
decl	8:2	8:38	2	uint16	matchbits
op	8:21	0:0	2	=
water	8:23	0:0	2	0
water	8:24	0:0	2	,
decl	8:2	8:38	2	uint16	maskbits
op	8:35	0:0	2	=
water	8:37	0:0	2	0
decl	9:2	9:31	2	uint16	buff1
op	9:17	0:0	2	=
water	9:19	0:0	2	0
water	9:20	0:0	2	,
decl	9:2	9:31	2	uint16	buff2
op	9:28	0:0	2	=
water	9:30	0:0	2	0
decl	10:2	10:23	2	uint8	bytebuff
op	10:20	0:0	2	=
water	10:22	0:0	2	0
decl	11:2	11:15	2	uint8	*next
decl	12:2	12:18	2	tsample_t	sample
if	13:2	17:4	2	(( src == NULL ) || ( dst == NULL ))
cond	13:6	13:35	3	( src == NULL ) || ( dst == NULL )
water	13:6	0:0	4	(
water	13:7	0:0	4	src
op	13:11	0:0	4	==
water	13:14	0:0	4	NULL
water	13:18	0:0	4	)
op	13:20	0:0	4	||
water	13:23	0:0	4	(
water	13:24	0:0	4	dst
op	13:28	0:0	4	==
water	13:31	0:0	4	NULL
water	13:35	0:0	4	)
stmts	14:4	17:4	3	
water	14:4	0:0	4	{
call	15:4	15:77	4	TIFFError
arg	15:14	15:41	5	"rotateContigSamples16bits"
water	15:14	0:0	6	"rotateContigSamples16bits"
arg	15:42	15:77	5	"Invalid src or destination buffer"
water	15:42	0:0	6	"Invalid src or destination buffer"
water	15:78	0:0	4	;
return	16:4	16:14	4	(1)
water	16:11	0:0	5	(
water	16:12	0:0	5	1
water	16:13	0:0	5	)
water	17:4	0:0	4	}
water	18:2	0:0	2	rowsize
op	18:10	0:0	2	=
water	18:12	0:0	2	(
water	18:13	0:0	2	(
water	18:14	0:0	2	bps
op	18:18	0:0	2	*
water	18:20	0:0	2	spp
op	18:24	0:0	2	*
water	18:26	0:0	2	width
water	18:31	0:0	2	)
op	18:33	0:0	2	+
water	18:35	0:0	2	7
water	18:36	0:0	2	)
op	18:38	0:0	2	/
water	18:40	0:0	2	8
water	18:41	0:0	2	;
water	19:2	0:0	2	ready_bits
op	19:13	0:0	2	=
water	19:15	0:0	2	0
water	19:16	0:0	2	;
water	20:2	0:0	2	maskbits
op	20:11	0:0	2	=
water	20:14	0:0	2	(
water	20:15	0:0	2	uint16
water	20:21	0:0	2	)
op	20:22	0:0	2	-
water	20:23	0:0	2	1
op	20:25	0:0	2	>>
water	20:28	0:0	2	(
water	20:29	0:0	2	16
op	20:32	0:0	2	-
water	20:34	0:0	2	bps
water	20:37	0:0	2	)
water	20:38	0:0	2	;
water	21:2	0:0	2	buff1
op	21:8	0:0	2	=
water	21:10	0:0	2	buff2
op	21:16	0:0	2	=
water	21:18	0:0	2	0
water	21:19	0:0	2	;
for	22:2	68:4	2	(row = 0 ;row < length;row ++)
forinit	22:7	22:14	3	row = 0 ;
water	22:7	0:0	4	row
op	22:11	0:0	4	=
water	22:13	0:0	4	0
water	22:14	0:0	4	;
cond	22:16	22:22	3	row < length
water	22:16	0:0	4	row
op	22:20	0:0	4	<
water	22:22	0:0	4	length
forexpr	22:30	22:33	3	row ++
water	22:30	0:0	4	row
op	22:33	0:0	4	++
stmts	23:4	68:4	3	
water	23:4	0:0	4	{
water	24:4	0:0	4	bit_offset
op	24:15	0:0	4	=
water	24:17	0:0	4	col
op	24:21	0:0	4	*
water	24:23	0:0	4	bps
op	24:27	0:0	4	*
water	24:29	0:0	4	spp
water	24:32	0:0	4	;
for	25:4	67:6	4	(sample = 0 ;sample < spp;sample ++)
forinit	25:9	25:19	5	sample = 0 ;
water	25:9	0:0	6	sample
op	25:16	0:0	6	=
water	25:18	0:0	6	0
water	25:19	0:0	6	;
cond	25:21	25:30	5	sample < spp
water	25:21	0:0	6	sample
op	25:28	0:0	6	<
water	25:30	0:0	6	spp
forexpr	25:35	25:41	5	sample ++
water	25:35	0:0	6	sample
op	25:41	0:0	6	++
stmts	26:6	67:6	5	
water	26:6	0:0	6	{
if	27:6	31:8	6	(sample == 0)
cond	27:10	27:20	7	sample == 0
water	27:10	0:0	8	sample
op	27:17	0:0	8	==
water	27:20	0:0	8	0
stmts	28:8	31:8	7	
water	28:8	0:0	8	{
water	29:8	0:0	8	src_byte
op	29:17	0:0	8	=
water	29:19	0:0	8	bit_offset
op	29:30	0:0	8	/
water	29:32	0:0	8	8
water	29:33	0:0	8	;
water	30:8	0:0	8	src_bit
op	30:17	0:0	8	=
water	30:19	0:0	8	bit_offset
op	30:30	0:0	8	%
water	30:32	0:0	8	8
water	30:33	0:0	8	;
water	31:8	0:0	8	}
else	32:6	36:8	6
stmts	33:8	36:8	7	
water	33:8	0:0	8	{
water	34:8	0:0	8	src_byte
op	34:17	0:0	8	=
water	34:19	0:0	8	(
water	34:20	0:0	8	bit_offset
op	34:31	0:0	8	+
water	34:33	0:0	8	(
water	34:34	0:0	8	sample
op	34:41	0:0	8	*
water	34:43	0:0	8	bps
water	34:46	0:0	8	)
water	34:47	0:0	8	)
op	34:49	0:0	8	/
water	34:51	0:0	8	8
water	34:52	0:0	8	;
water	35:8	0:0	8	src_bit
op	35:17	0:0	8	=
water	35:19	0:0	8	(
water	35:20	0:0	8	bit_offset
op	35:31	0:0	8	+
water	35:33	0:0	8	(
water	35:34	0:0	8	sample
op	35:41	0:0	8	*
water	35:43	0:0	8	bps
water	35:46	0:0	8	)
water	35:47	0:0	8	)
op	35:49	0:0	8	%
water	35:51	0:0	8	8
water	35:52	0:0	8	;
water	36:8	0:0	8	}
switch	37:6	45:8	6	(rotation)
cond	37:14	37:14	7	rotation
water	37:14	0:0	8	rotation
stmts	38:1	45:8	7	
water	38:1	0:0	8	{
label	39:8	39:16	8	case 90 :
water	39:18	0:0	8	next
op	39:23	0:0	8	=
water	39:25	0:0	8	src
op	39:29	0:0	8	+
water	39:31	0:0	8	src_byte
op	39:40	0:0	8	-
water	39:42	0:0	8	(
water	39:43	0:0	8	row
op	39:47	0:0	8	*
water	39:49	0:0	8	rowsize
water	39:56	0:0	8	)
water	39:57	0:0	8	;
break	40:18	40:23	8	
label	41:8	41:16	8	case 270 :
water	41:18	0:0	8	next
op	41:23	0:0	8	=
water	41:25	0:0	8	src
op	41:29	0:0	8	+
water	41:31	0:0	8	src_byte
op	41:40	0:0	8	+
water	41:42	0:0	8	(
water	41:43	0:0	8	row
op	41:47	0:0	8	*
water	41:49	0:0	8	rowsize
water	41:56	0:0	8	)
water	41:57	0:0	8	;
break	42:11	42:16	8	
label	43:1	43:8	8	default :
call	43:11	43:80	8	TIFFError
arg	43:21	43:47	9	"rotateContigSamples8bits"
water	43:21	0:0	10	"rotateContigSamples8bits"
arg	43:49	43:70	9	"Invalid rotation %d"
water	43:49	0:0	10	"Invalid rotation %d"
arg	43:72	43:80	9	rotation
water	43:72	0:0	10	rotation
water	43:81	0:0	8	;
return	44:18	44:28	8	(1)
water	44:25	0:0	9	(
water	44:26	0:0	9	1
water	44:27	0:0	9	)
water	45:8	0:0	8	}
water	46:6	0:0	6	matchbits
op	46:16	0:0	6	=
water	46:18	0:0	6	maskbits
op	46:27	0:0	6	<<
water	46:30	0:0	6	(
water	46:31	0:0	6	16
op	46:34	0:0	6	-
water	46:36	0:0	6	src_bit
op	46:44	0:0	6	-
water	46:46	0:0	6	bps
water	46:49	0:0	6	)
water	46:50	0:0	6	;
if	47:6	48:40	6	(little_endian)
cond	47:10	47:10	7	little_endian
water	47:10	0:0	8	little_endian
stmts	48:8	48:40	7	
water	48:8	0:0	8	buff1
op	48:14	0:0	8	=
water	48:16	0:0	8	(
water	48:17	0:0	8	next
op	48:21	0:0	8	[
water	48:22	0:0	8	0
op	48:23	0:0	8	]
op	48:25	0:0	8	<<
water	48:28	0:0	8	8
water	48:29	0:0	8	)
op	48:31	0:0	8	|
water	48:33	0:0	8	next
op	48:37	0:0	8	[
water	48:38	0:0	8	1
op	48:39	0:0	8	]
water	48:40	0:0	8	;
else	49:6	50:40	6
stmts	50:8	50:40	7	
water	50:8	0:0	8	buff1
op	50:14	0:0	8	=
water	50:16	0:0	8	(
water	50:17	0:0	8	next
op	50:21	0:0	8	[
water	50:22	0:0	8	1
op	50:23	0:0	8	]
op	50:25	0:0	8	<<
water	50:28	0:0	8	8
water	50:29	0:0	8	)
op	50:31	0:0	8	|
water	50:33	0:0	8	next
op	50:37	0:0	8	[
water	50:38	0:0	8	0
op	50:39	0:0	8	]
water	50:40	0:0	8	;
water	51:6	0:0	6	buff1
op	51:12	0:0	6	=
water	51:14	0:0	6	(
water	51:15	0:0	6	buff1
op	51:21	0:0	6	&
water	51:23	0:0	6	matchbits
water	51:32	0:0	6	)
op	51:34	0:0	6	<<
water	51:37	0:0	6	(
water	51:38	0:0	6	src_bit
water	51:45	0:0	6	)
water	51:46	0:0	6	;
if	53:6	60:8	6	(ready_bits >= 8)
cond	53:10	53:24	7	ready_bits >= 8
water	53:10	0:0	8	ready_bits
op	53:21	0:0	8	>=
water	53:24	0:0	8	8
stmts	54:8	60:8	7	
water	54:8	0:0	8	{
water	55:8	0:0	8	bytebuff
op	55:17	0:0	8	=
water	55:19	0:0	8	(
water	55:20	0:0	8	buff2
op	55:26	0:0	8	>>
water	55:29	0:0	8	8
water	55:30	0:0	8	)
water	55:31	0:0	8	;
op	56:8	0:0	8	*
water	56:9	0:0	8	dst
op	56:12	0:0	8	++
op	56:15	0:0	8	=
water	56:17	0:0	8	bytebuff
water	56:25	0:0	8	;
water	57:8	0:0	8	ready_bits
op	57:19	0:0	8	-=
water	57:22	0:0	8	8
water	57:23	0:0	8	;
water	59:8	0:0	8	buff2
op	59:14	0:0	8	=
water	59:16	0:0	8	(
water	59:17	0:0	8	(
water	59:18	0:0	8	buff2
op	59:24	0:0	8	<<
water	59:27	0:0	8	8
water	59:28	0:0	8	)
op	59:30	0:0	8	|
water	59:32	0:0	8	(
water	59:33	0:0	8	buff1
op	59:39	0:0	8	>>
water	59:42	0:0	8	ready_bits
water	59:52	0:0	8	)
water	59:53	0:0	8	)
water	59:54	0:0	8	;
water	60:8	0:0	8	}
else	61:6	65:8	6
stmts	62:8	65:8	7	
water	62:8	0:0	8	{
water	63:8	0:0	8	bytebuff
op	63:17	0:0	8	=
water	63:19	0:0	8	0
water	63:20	0:0	8	;
water	64:8	0:0	8	buff2
op	64:14	0:0	8	=
water	64:16	0:0	8	(
water	64:17	0:0	8	buff2
op	64:23	0:0	8	|
water	64:25	0:0	8	(
water	64:26	0:0	8	buff1
op	64:32	0:0	8	>>
water	64:35	0:0	8	ready_bits
water	64:45	0:0	8	)
water	64:46	0:0	8	)
water	64:47	0:0	8	;
water	65:8	0:0	8	}
water	66:6	0:0	6	ready_bits
op	66:17	0:0	6	+=
water	66:20	0:0	6	bps
water	66:23	0:0	6	;
water	67:6	0:0	6	}
water	68:4	0:0	4	}
if	69:2	73:4	2	(ready_bits > 0)
cond	69:6	69:19	3	ready_bits > 0
water	69:6	0:0	4	ready_bits
op	69:17	0:0	4	>
water	69:19	0:0	4	0
stmts	70:4	73:4	3	
water	70:4	0:0	4	{
water	71:4	0:0	4	bytebuff
op	71:13	0:0	4	=
water	71:15	0:0	4	(
water	71:16	0:0	4	buff2
op	71:22	0:0	4	>>
water	71:25	0:0	4	8
water	71:26	0:0	4	)
water	71:27	0:0	4	;
op	72:4	0:0	4	*
water	72:5	0:0	4	dst
op	72:8	0:0	4	++
op	72:11	0:0	4	=
water	72:13	0:0	4	bytebuff
water	72:21	0:0	4	;
water	73:4	0:0	4	}
return	74:2	74:12	2	(0)
water	74:9	0:0	3	(
water	74:10	0:0	3	0
water	74:11	0:0	3	)
