
static int
OJPEGVSetField(register TIFF *tif,ttag_t tag,va_list ap)
{
    uint32 v32;
    register OJPEGState *sp = OJState(tif);
#   define td (&tif->tif_dir)
    toff_t tiffoff=0;
    uint32 bufoff=0;
    uint32 code_count=0;
    int i2=0;
    int k2=0;

    switch (tag)
      {

     



        case TIFFTAG_REFERENCEBLACKWHITE   : if (td->td_refblackwhite)
                                               {
                                                 _TIFFfree(td->td_refblackwhite);
                                                 td->td_refblackwhite = 0;
                                               };
        default                            : return
                                               (*sp->vsetparent)(tif,tag,ap);

     














        case TIFFTAG_PHOTOMETRIC           :
          if (   (v32 = (*sp->vsetparent)(tif,tag,ap))
              && td->td_photometric == PHOTOMETRIC_YCBCR
             )
	  {
            if ( (td->td_refblackwhite = _TIFFmalloc(6*sizeof(float))) )
              { register long top = 1 << td->td_bitspersample;

                td->td_refblackwhite[0] = 0;
                td->td_refblackwhite[1] = td->td_refblackwhite[3] =
                td->td_refblackwhite[5] = top - 1;
                td->td_refblackwhite[2] = td->td_refblackwhite[4] = top >> 1;
              }
            else
              {
                TIFFError(tif->tif_name,
                  "Cannot set default reference black and white levels");
                v32 = 0;
              };
	  }
          return v32;

     









        case TIFFTAG_SOFTWARE              :
        {
            char *software;

            v32 = (*sp->vsetparent)(tif,tag,ap);
            if( TIFFGetField( tif, TIFFTAG_SOFTWARE, &software )
                && strstr( software, "Wang Labs" ) )
                sp->is_WANG = 1;
            return v32;
        }

        case TIFFTAG_JPEGPROC              :
        case TIFFTAG_JPEGIFOFFSET          :
        case TIFFTAG_JPEGIFBYTECOUNT       :
        case TIFFTAG_JPEGRESTARTINTERVAL   :
        case TIFFTAG_JPEGLOSSLESSPREDICTORS:
        case TIFFTAG_JPEGPOINTTRANSFORM    :
        case TIFFTAG_JPEGQTABLES           :
        case TIFFTAG_JPEGDCTABLES          :
        case TIFFTAG_JPEGACTABLES          :
        case TIFFTAG_WANG_PAGECONTROL      :
        case TIFFTAG_JPEGCOLORMODE         : ;
      };
    v32 = va_arg(ap,uint32); 

    
    if(v32 !=0){
        switch(tag){
            case TIFFTAG_JPEGPROC:
                sp->jpegproc=v32;
                break;
            case TIFFTAG_JPEGIFOFFSET:
                sp->jpegifoffset=v32;
		break;
            case TIFFTAG_JPEGIFBYTECOUNT:
		sp->jpegifbytecount=v32;
		break;
            case TIFFTAG_JPEGRESTARTINTERVAL:
		sp->jpegrestartinterval=v32;
		break;
            case TIFFTAG_JPEGLOSSLESSPREDICTORS:
		sp->jpeglosslesspredictors_length=v32;
		break;
            case TIFFTAG_JPEGPOINTTRANSFORM:
		sp->jpegpointtransform_length=v32;
		break;
            case TIFFTAG_JPEGQTABLES:
		sp->jpegqtables_length=v32;
		break;
            case TIFFTAG_JPEGACTABLES:
		sp->jpegactables_length=v32;
		break;
            case TIFFTAG_JPEGDCTABLES:
		sp->jpegdctables_length=v32;
		break;
            default:
		break;
        }
    }

 








    switch (tag)
      { JHUFF_TBL **h;

     

        case TIFFTAG_JPEGPROC              :
          switch (v32)
            {
              default               : TIFFError(tif->tif_name,
                                        "Unknown JPEG process");
                                      return 0;
#             ifdef C_LOSSLESS_SUPPORTED

           

              case JPEGPROC_BASELINE: sp->cinfo.d.process = JPROC_SEQUENTIAL;
                                      sp->cinfo.d.data_unit = DCTSIZE;
                                      break;

           

              case JPEGPROC_LOSSLESS: sp->cinfo.d.process = JPROC_LOSSLESS;
                                      sp->cinfo.d.data_unit = 1;
#             else 
              case JPEGPROC_LOSSLESS: TIFFError(JPEGLib_name,
                                        "Does not support lossless Huffman coding");
                                      return 0;
              case JPEGPROC_BASELINE: ;
#             endif 
            };
          break;

     






        case TIFFTAG_JPEGIFOFFSET          :
          if (v32)
            {
              sp->src.next_input_byte = tif->tif_base + v32;
              break;
            };
          return 1;
        case TIFFTAG_JPEGIFBYTECOUNT       :
          sp->src.bytes_in_buffer = v32;
          break;

     




     



        case TIFFTAG_JPEGRESTARTINTERVAL   :
          if (v32)
              sp->cinfo.d.restart_interval = v32;
              break;
     







        case TIFFTAG_JPEGLOSSLESSPREDICTORS:
           if (v32)
             {
               sp->cinfo.d.Ss = *va_arg(ap,uint16 *);
               sp->jpeglosslesspredictors = 
		    _TIFFmalloc(sp->jpeglosslesspredictors_length
				* sizeof(uint16));
               if(sp->jpeglosslesspredictors==NULL){return(0);}
               for(i2=0;i2<sp->jpeglosslesspredictors_length;i2++){
                ((uint16*)sp->jpeglosslesspredictors)[i2] =
			((uint16*)sp->cinfo.d.Ss)[i2];
               }
               sp->jpeglosslesspredictors_length*=sizeof(uint16);
               break;
             };
           return v32;

     







        case TIFFTAG_JPEGPOINTTRANSFORM    :
           if (v32)
             {
               sp->cinfo.d.Al = *va_arg(ap,uint16 *);
               sp->jpegpointtransform =
		    _TIFFmalloc(sp->jpegpointtransform_length*sizeof(uint16));
               if(sp->jpegpointtransform==NULL){return(0);}
               for(i2=0;i2<sp->jpegpointtransform_length;i2++) {
                ((uint16*)sp->jpegpointtransform)[i2] =
			((uint16*)sp->cinfo.d.Al)[i2];
               }
               sp->jpegpointtransform_length*=sizeof(uint16);
               break;
             }
           return v32;

     

        case TIFFTAG_JPEGQTABLES           :
          if (v32)
            { uint32 *v;
              int i;
              if (v32 > NUM_QUANT_TBLS)
                {
                  TIFFError(tif->tif_name,"Too many quantization tables");
                  return 0;
                };
              i = 0;
              v = va_arg(ap,uint32 *);
                sp->jpegqtables=_TIFFmalloc(64*sp->jpegqtables_length);
                if(sp->jpegqtables==NULL){return(0);}
                tiffoff = TIFFSeekFile(tif, 0, SEEK_CUR);
                bufoff=0;
                for(i2=0;i2<sp->jpegqtables_length;i2++){
                    TIFFSeekFile(tif, v[i2], SEEK_SET);
                    TIFFReadFile(tif, &(((u_char*)(sp->jpegqtables))[bufoff]),
				 64);
                    bufoff+=64;
                }
                sp->jpegqtables_length=bufoff;
                TIFFSeekFile(tif, tiffoff, SEEK_SET);

              do 
                { register UINT8 *from = tif->tif_base + *v++;
                  register UINT16 *to;
                  register int j = DCTSIZE2;

                  if (!( sp->cinfo.d.quant_tbl_ptrs[i]
                       = CALLJPEG(sp,0,jpeg_alloc_quant_table(&sp->cinfo.comm))
                       )
                     )
                    {
                      TIFFError(JPEGLib_name,"No space for quantization table");
                      return 0;
                    };
                  to = sp->cinfo.d.quant_tbl_ptrs[i]->quantval;
                  do *to++ = *from++; while (--j > 0);
                }
              while (++i < v32);
              sp->jpegtablesmode |= JPEGTABLESMODE_QUANT;
            };
          break;

     

        case TIFFTAG_JPEGDCTABLES          :
          h = sp->cinfo.d.dc_huff_tbl_ptrs;
          goto L;

     

        case TIFFTAG_JPEGACTABLES          :
          h = sp->cinfo.d.ac_huff_tbl_ptrs;
       L: if (v32)
            { uint32 *v;
              int i;
              if (v32 > NUM_HUFF_TBLS)
                {
                  TIFFError(tif->tif_name,"Too many Huffman tables");
                  return 0;
                };
              v = va_arg(ap,uint32 *);
                if(tag == TIFFTAG_JPEGDCTABLES) {
                    sp->jpegdctables=_TIFFmalloc(272*sp->jpegdctables_length);
                    if(sp->jpegdctables==NULL){return(0);}
                    tiffoff = TIFFSeekFile(tif, 0, SEEK_CUR);
                    bufoff=0;
                    code_count=0;                
                    for(i2=0;i2<sp->jpegdctables_length;i2++){
                        TIFFSeekFile(tif, v[i2], SEEK_SET);
                        TIFFReadFile(tif,
				     &(((u_char*)(sp->jpegdctables))[bufoff]),
				     16);
                        code_count=0;
                        for(k2=0;k2<16;k2++){
                            code_count+=((u_char*)(sp->jpegdctables))[k2+bufoff];
                        }
                        TIFFReadFile(tif,
				     &(((u_char*)(sp->jpegdctables))[bufoff+16]),
				     code_count);
                        bufoff+=16;
                        bufoff+=code_count;
                    }
                    sp->jpegdctables_length=bufoff;
                    TIFFSeekFile(tif, tiffoff, SEEK_SET);
                }
                if(tag==TIFFTAG_JPEGACTABLES){
                    sp->jpegactables=_TIFFmalloc(272*sp->jpegactables_length);
                    if(sp->jpegactables==NULL){return(0);}
                    tiffoff = TIFFSeekFile(tif, 0, SEEK_CUR);
                    bufoff=0;
                    code_count=0;                
                    for(i2=0;i2<sp->jpegactables_length;i2++){
                        TIFFSeekFile(tif, v[i2], SEEK_SET);
                        TIFFReadFile(tif, &(((unsigned char*)(sp->jpegactables))[bufoff]), 16);
                        code_count=0;
                        for(k2=0;k2<16;k2++){
                            code_count+=((unsigned char*)(sp->jpegactables))[k2+bufoff];
                        }
                        TIFFReadFile(tif, &(((unsigned char*)(sp->jpegactables))[bufoff+16]), code_count);
                        bufoff+=16;
                        bufoff+=code_count;
                    }
                    sp->jpegactables_length=bufoff;
                    TIFFSeekFile(tif, tiffoff, SEEK_SET);
                }
              i = 0;
              do 
                { int size = 0;
                  register UINT8 *from = tif->tif_base + *v++, *to;
                  register int j = sizeof (*h)->bits;

               






                  if (!( *h
                       = CALLJPEG(sp,0,jpeg_alloc_huff_table(&sp->cinfo.comm))
                       )
                     )
                    {
                      TIFFError(JPEGLib_name,"No space for Huffman table");
                      return 0;
                    };
                  to = (*h++)->bits;
                  *to++ = 0;
                  while (--j > 0) size += *to++ = *from++; 
                  if (size > sizeof (*h)->huffval/sizeof *(*h)->huffval)
                    {
                      TIFFError(tif->tif_name,"Huffman table too big");
                      return 0;
                    };
                  if ((j = size) > 0) do *to++ = *from++; while (--j > 0);
                  while (++size <= sizeof (*h)->huffval/sizeof *(*h)->huffval)
                    *to++ = 0; 
                }
              while (++i < v32);
              sp->jpegtablesmode |= JPEGTABLESMODE_HUFF;
            };
          break;

     






        case TIFFTAG_WANG_PAGECONTROL      :
          if (v32 == 0) v32 = -1;
          sp->is_WANG = v32;
          tag = TIFFTAG_JPEGPROC+FIELD_WANG_PAGECONTROL-FIELD_JPEGPROC;
          break;

     



        case TIFFTAG_JPEGCOLORMODE         :
          sp->jpegcolormode = v32;

       


          v32 = tif->tif_flags; 
          tif->tif_flags &= ~TIFF_UPSAMPLED;
          if (   td->td_photometric == PHOTOMETRIC_YCBCR
              &&    (td->td_ycbcrsubsampling[0]<<3 | td->td_ycbcrsubsampling[1])
                 != 011
              && sp->jpegcolormode == JPEGCOLORMODE_RGB
             ) tif->tif_flags |= TIFF_UPSAMPLED;

       

          if ((tif->tif_flags ^ v32) & TIFF_UPSAMPLED)
            {
              tif->tif_tilesize = TIFFTileSize(tif);
              tif->tif_flags |= TIFF_DIRTYDIRECT;
            };
          return 1;
      };
    TIFFSetFieldBit(tif,tag-TIFFTAG_JPEGPROC+FIELD_JPEGPROC);
    return 1;
#   undef td
  }