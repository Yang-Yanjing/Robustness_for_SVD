func	2:0	167:0	0	static int	LZWDecodeCompat
params	3:15	0:0	1	
param	3:16	3:25	2	TIFF *	tif
param	3:27	3:39	2	tidata_t	op0
param	3:41	3:53	2	tsize_t	occ0
param	3:55	3:66	2	tsample_t	s
stmnts	0:0	166:11	1	
decl	5:1	5:38	2	LZWCodecState	*sp
op	5:19	0:0	2	=
call	5:21	5:37	3	DecoderState
arg	5:34	5:37	4	tif
water	5:34	0:0	5	tif
decl	6:1	6:23	2	char	*op
op	6:10	0:0	2	=
water	6:12	0:0	2	(
water	6:13	0:0	2	char
op	6:17	0:0	2	*
water	6:18	0:0	2	)
water	6:20	0:0	2	op0
decl	7:1	7:23	2	long	occ
op	7:10	0:0	2	=
water	7:12	0:0	2	(
water	7:13	0:0	2	long
water	7:17	0:0	2	)
water	7:19	0:0	2	occ0
decl	8:1	8:9	2	char	*tp
decl	9:1	9:18	2	unsigned char	*bp
decl	10:1	10:16	2	int	code
water	10:9	0:0	2	,
decl	10:1	10:16	2	int	nbits
decl	11:1	11:35	2	long	nextbits
water	11:14	0:0	2	,
decl	11:1	11:35	2	long	nextdata
water	11:24	0:0	2	,
decl	11:1	11:35	2	long	nbitsmask
decl	12:1	12:48	2	code_t	*codep
water	12:14	0:0	2	,
decl	12:1	12:48	2	code_t	*free_entp
water	12:26	0:0	2	,
decl	12:1	12:48	2	code_t	*maxcodep
water	12:37	0:0	2	,
decl	12:1	12:48	2	code_t	*oldcodep
water	14:1	0:0	2	(
water	14:2	0:0	2	void
water	14:6	0:0	2	)
water	14:8	0:0	2	s
water	14:9	0:0	2	;
call	15:1	15:18	2	assert
arg	15:8	15:18	3	sp!=NULL
water	15:8	0:0	4	sp
op	15:11	0:0	4	!=
water	15:14	0:0	4	NULL
water	15:19	0:0	2	;
if	19:1	52:1	2	(sp -> dec_restart)
cond	19:5	19:9	3	sp -> dec_restart
water	19:5	0:0	4	sp
op	19:7	0:0	4	->
water	19:9	0:0	4	dec_restart
stmts	19:22	52:1	3	
water	19:22	0:0	4	{
decl	20:2	20:14	4	long	residue
water	22:2	0:0	4	codep
op	22:8	0:0	4	=
water	22:10	0:0	4	sp
op	22:12	0:0	4	->
water	22:14	0:0	4	dec_codep
water	22:23	0:0	4	;
water	23:2	0:0	4	residue
op	23:10	0:0	4	=
water	23:12	0:0	4	codep
op	23:17	0:0	4	->
water	23:19	0:0	4	length
op	23:26	0:0	4	-
water	23:28	0:0	4	sp
op	23:30	0:0	4	->
water	23:32	0:0	4	dec_restart
water	23:43	0:0	4	;
if	24:2	41:2	4	(residue > occ)
cond	24:6	24:16	5	residue > occ
water	24:6	0:0	6	residue
op	24:14	0:0	6	>
water	24:16	0:0	6	occ
stmts	24:21	41:2	5	
water	24:21	0:0	6	{
water	31:3	0:0	6	sp
op	31:5	0:0	6	->
water	31:7	0:0	6	dec_restart
op	31:19	0:0	6	+=
water	31:22	0:0	6	occ
water	31:25	0:0	6	;
do	32:3	34:3	6	(-- residue > occ)
cond	34:12	34:24	7	-- residue > occ
op	34:12	0:0	8	--
water	34:14	0:0	8	residue
op	34:22	0:0	8	>
water	34:24	0:0	8	occ
stmts	32:6	34:3	7	
water	32:6	0:0	8	{
water	33:4	0:0	8	codep
op	33:10	0:0	8	=
water	33:12	0:0	8	codep
op	33:17	0:0	8	->
water	33:19	0:0	8	next
water	33:23	0:0	8	;
water	34:3	0:0	8	}
water	34:28	0:0	6	;
water	35:3	0:0	6	tp
op	35:6	0:0	6	=
water	35:8	0:0	6	op
op	35:11	0:0	6	+
water	35:13	0:0	6	occ
water	35:16	0:0	6	;
do	36:3	39:3	6	(-- occ)
cond	39:12	39:14	7	-- occ
op	39:12	0:0	8	--
water	39:14	0:0	8	occ
stmts	36:6	39:3	7	
water	36:6	0:0	8	{
op	37:4	0:0	8	*
op	37:5	0:0	8	--
water	37:7	0:0	8	tp
op	37:10	0:0	8	=
water	37:12	0:0	8	codep
op	37:17	0:0	8	->
water	37:19	0:0	8	value
water	37:24	0:0	8	;
water	38:4	0:0	8	codep
op	38:10	0:0	8	=
water	38:12	0:0	8	codep
op	38:17	0:0	8	->
water	38:19	0:0	8	next
water	38:23	0:0	8	;
water	39:3	0:0	8	}
water	39:18	0:0	6	;
return	40:3	40:13	6	(1)
water	40:10	0:0	7	(
water	40:11	0:0	7	1
water	40:12	0:0	7	)
water	41:2	0:0	6	}
water	45:2	0:0	4	op
op	45:5	0:0	4	+=
water	45:8	0:0	4	residue
water	45:15	0:0	4	,
water	45:17	0:0	4	occ
op	45:21	0:0	4	-=
water	45:24	0:0	4	residue
water	45:31	0:0	4	;
water	46:2	0:0	4	tp
op	46:5	0:0	4	=
water	46:7	0:0	4	op
water	46:9	0:0	4	;
do	47:2	50:2	4	(-- residue)
cond	50:11	50:13	5	-- residue
op	50:11	0:0	6	--
water	50:13	0:0	6	residue
stmts	47:5	50:2	5	
water	47:5	0:0	6	{
op	48:3	0:0	6	*
op	48:4	0:0	6	--
water	48:6	0:0	6	tp
op	48:9	0:0	6	=
water	48:11	0:0	6	codep
op	48:16	0:0	6	->
water	48:18	0:0	6	value
water	48:23	0:0	6	;
water	49:3	0:0	6	codep
op	49:9	0:0	6	=
water	49:11	0:0	6	codep
op	49:16	0:0	6	->
water	49:18	0:0	6	next
water	49:22	0:0	6	;
water	50:2	0:0	6	}
water	50:21	0:0	4	;
water	51:2	0:0	4	sp
op	51:4	0:0	4	->
water	51:6	0:0	4	dec_restart
op	51:18	0:0	4	=
water	51:20	0:0	4	0
water	51:21	0:0	4	;
water	52:1	0:0	4	}
water	54:1	0:0	2	bp
op	54:4	0:0	2	=
water	54:6	0:0	2	(
water	54:7	0:0	2	unsigned
water	54:16	0:0	2	char
op	54:21	0:0	2	*
water	54:22	0:0	2	)
water	54:23	0:0	2	tif
op	54:26	0:0	2	->
water	54:28	0:0	2	tif_rawcp
water	54:37	0:0	2	;
water	55:1	0:0	2	nbits
op	55:7	0:0	2	=
water	55:9	0:0	2	sp
op	55:11	0:0	2	->
water	55:13	0:0	2	lzw_nbits
water	55:22	0:0	2	;
water	56:1	0:0	2	nextdata
op	56:10	0:0	2	=
water	56:12	0:0	2	sp
op	56:14	0:0	2	->
water	56:16	0:0	2	lzw_nextdata
water	56:28	0:0	2	;
water	57:1	0:0	2	nextbits
op	57:10	0:0	2	=
water	57:12	0:0	2	sp
op	57:14	0:0	2	->
water	57:16	0:0	2	lzw_nextbits
water	57:28	0:0	2	;
water	58:1	0:0	2	nbitsmask
op	58:11	0:0	2	=
water	58:13	0:0	2	sp
op	58:15	0:0	2	->
water	58:17	0:0	2	dec_nbitsmask
water	58:30	0:0	2	;
water	59:1	0:0	2	oldcodep
op	59:10	0:0	2	=
water	59:12	0:0	2	sp
op	59:14	0:0	2	->
water	59:16	0:0	2	dec_oldcodep
water	59:28	0:0	2	;
water	60:1	0:0	2	free_entp
op	60:11	0:0	2	=
water	60:13	0:0	2	sp
op	60:15	0:0	2	->
water	60:17	0:0	2	dec_free_entp
water	60:30	0:0	2	;
water	61:1	0:0	2	maxcodep
op	61:10	0:0	2	=
water	61:12	0:0	2	sp
op	61:14	0:0	2	->
water	61:16	0:0	2	dec_maxcodep
water	61:28	0:0	2	;
while	63:1	149:1	2	(occ > 0)
cond	63:8	63:14	3	occ > 0
water	63:8	0:0	4	occ
op	63:12	0:0	4	>
water	63:14	0:0	4	0
stmts	63:17	149:1	3	
water	63:17	0:0	4	{
call	64:2	64:47	4	NextCode
arg	64:11	64:14	5	tif
water	64:11	0:0	6	tif
arg	64:16	64:18	5	sp
water	64:16	0:0	6	sp
arg	64:20	64:22	5	bp
water	64:20	0:0	6	bp
arg	64:24	64:28	5	code
water	64:24	0:0	6	code
arg	64:30	64:47	5	GetNextCodeCompat
water	64:30	0:0	6	GetNextCodeCompat
water	64:48	0:0	4	;
if	65:2	66:8	4	(code == CODE_EOI)
cond	65:6	65:14	5	code == CODE_EOI
water	65:6	0:0	6	code
op	65:11	0:0	6	==
water	65:14	0:0	6	CODE_EOI
stmts	66:3	66:8	5	
break	66:3	66:8	6	
if	67:2	78:2	4	(code == CODE_CLEAR)
cond	67:6	67:14	5	code == CODE_CLEAR
water	67:6	0:0	6	code
op	67:11	0:0	6	==
water	67:14	0:0	6	CODE_CLEAR
stmts	67:26	78:2	5	
water	67:26	0:0	6	{
water	68:3	0:0	6	free_entp
op	68:13	0:0	6	=
water	68:15	0:0	6	sp
op	68:17	0:0	6	->
water	68:19	0:0	6	dec_codetab
op	68:31	0:0	6	+
water	68:33	0:0	6	CODE_FIRST
water	68:43	0:0	6	;
water	69:3	0:0	6	nbits
op	69:9	0:0	6	=
water	69:11	0:0	6	BITS_MIN
water	69:19	0:0	6	;
water	70:3	0:0	6	nbitsmask
op	70:13	0:0	6	=
call	70:15	70:31	6	MAXCODE
arg	70:23	70:31	7	BITS_MIN
water	70:23	0:0	8	BITS_MIN
water	70:32	0:0	6	;
water	71:3	0:0	6	maxcodep
op	71:12	0:0	6	=
water	71:14	0:0	6	sp
op	71:16	0:0	6	->
water	71:18	0:0	6	dec_codetab
op	71:30	0:0	6	+
water	71:32	0:0	6	nbitsmask
water	71:41	0:0	6	;
call	72:3	72:48	6	NextCode
arg	72:12	72:15	7	tif
water	72:12	0:0	8	tif
arg	72:17	72:19	7	sp
water	72:17	0:0	8	sp
arg	72:21	72:23	7	bp
water	72:21	0:0	8	bp
arg	72:25	72:29	7	code
water	72:25	0:0	8	code
arg	72:31	72:48	7	GetNextCodeCompat
water	72:31	0:0	8	GetNextCodeCompat
water	72:49	0:0	6	;
if	73:3	74:9	6	(code == CODE_EOI)
cond	73:7	73:15	7	code == CODE_EOI
water	73:7	0:0	8	code
op	73:12	0:0	8	==
water	73:15	0:0	8	CODE_EOI
stmts	74:4	74:9	7	
break	74:4	74:9	8	
op	75:3	0:0	6	*
water	75:4	0:0	6	op
op	75:6	0:0	6	++
op	75:9	0:0	6	=
water	75:11	0:0	6	code
water	75:15	0:0	6	,
water	75:17	0:0	6	occ
op	75:20	0:0	6	--
water	75:22	0:0	6	;
water	76:3	0:0	6	oldcodep
op	76:12	0:0	6	=
water	76:14	0:0	6	sp
op	76:16	0:0	6	->
water	76:18	0:0	6	dec_codetab
op	76:30	0:0	6	+
water	76:32	0:0	6	code
water	76:36	0:0	6	;
continue	77:3	77:11	6	
water	78:2	0:0	6	}
water	79:2	0:0	4	codep
op	79:8	0:0	4	=
water	79:10	0:0	4	sp
op	79:12	0:0	4	->
water	79:14	0:0	4	dec_codetab
op	79:26	0:0	4	+
water	79:28	0:0	4	code
water	79:32	0:0	4	;
if	84:2	90:2	4	(free_entp < & sp -> dec_codetab [ 0 ] || free_entp >= & sp -> dec_codetab [ CSIZE ])
cond	84:6	85:38	5	free_entp < & sp -> dec_codetab [ 0 ] || free_entp >= & sp -> dec_codetab [ CSIZE ]
water	84:6	0:0	6	free_entp
op	84:16	0:0	6	<
op	84:18	0:0	6	&
water	84:19	0:0	6	sp
op	84:21	0:0	6	->
water	84:23	0:0	6	dec_codetab
op	84:34	0:0	6	[
water	84:35	0:0	6	0
op	84:36	0:0	6	]
op	84:38	0:0	6	||
water	85:3	0:0	6	free_entp
op	85:13	0:0	6	>=
op	85:16	0:0	6	&
water	85:17	0:0	6	sp
op	85:19	0:0	6	->
water	85:21	0:0	6	dec_codetab
op	85:32	0:0	6	[
water	85:33	0:0	6	CSIZE
op	85:38	0:0	6	]
stmts	85:41	90:2	5	
water	85:41	0:0	6	{
call	86:3	88:15	6	TIFFErrorExt
arg	86:16	86:35	7	tif->tif_clientdata
water	86:16	0:0	8	tif
op	86:19	0:0	8	->
water	86:21	0:0	8	tif_clientdata
arg	86:37	86:50	7	tif->tif_name
water	86:37	0:0	8	tif
op	86:40	0:0	8	->
water	86:42	0:0	8	tif_name
arg	87:3	87:56	7	"LZWDecodeCompat: Corrupted LZW table at scanline %d"
water	87:3	0:0	8	"LZWDecodeCompat: Corrupted LZW table at scanline %d"
arg	88:3	88:15	7	tif->tif_row
water	88:3	0:0	8	tif
op	88:6	0:0	8	->
water	88:8	0:0	8	tif_row
water	88:16	0:0	6	;
return	89:3	89:13	6	(0)
water	89:10	0:0	7	(
water	89:11	0:0	7	0
water	89:12	0:0	7	)
water	90:2	0:0	6	}
water	92:2	0:0	4	free_entp
op	92:11	0:0	4	->
water	92:13	0:0	4	next
op	92:18	0:0	4	=
water	92:20	0:0	4	oldcodep
water	92:28	0:0	4	;
if	93:2	99:2	4	(free_entp -> next < & sp -> dec_codetab [ 0 ] || free_entp -> next >= & sp -> dec_codetab [ CSIZE ])
cond	93:6	94:44	5	free_entp -> next < & sp -> dec_codetab [ 0 ] || free_entp -> next >= & sp -> dec_codetab [ CSIZE ]
water	93:6	0:0	6	free_entp
op	93:15	0:0	6	->
water	93:17	0:0	6	next
op	93:22	0:0	6	<
op	93:24	0:0	6	&
water	93:25	0:0	6	sp
op	93:27	0:0	6	->
water	93:29	0:0	6	dec_codetab
op	93:40	0:0	6	[
water	93:41	0:0	6	0
op	93:42	0:0	6	]
op	93:44	0:0	6	||
water	94:3	0:0	6	free_entp
op	94:12	0:0	6	->
water	94:14	0:0	6	next
op	94:19	0:0	6	>=
op	94:22	0:0	6	&
water	94:23	0:0	6	sp
op	94:25	0:0	6	->
water	94:27	0:0	6	dec_codetab
op	94:38	0:0	6	[
water	94:39	0:0	6	CSIZE
op	94:44	0:0	6	]
stmts	94:47	99:2	5	
water	94:47	0:0	6	{
call	95:3	97:15	6	TIFFErrorExt
arg	95:16	95:35	7	tif->tif_clientdata
water	95:16	0:0	8	tif
op	95:19	0:0	8	->
water	95:21	0:0	8	tif_clientdata
arg	95:37	95:50	7	tif->tif_name
water	95:37	0:0	8	tif
op	95:40	0:0	8	->
water	95:42	0:0	8	tif_name
arg	96:3	96:56	7	"LZWDecodeCompat: Corrupted LZW table at scanline %d"
water	96:3	0:0	8	"LZWDecodeCompat: Corrupted LZW table at scanline %d"
arg	97:3	97:15	7	tif->tif_row
water	97:3	0:0	8	tif
op	97:6	0:0	8	->
water	97:8	0:0	8	tif_row
water	97:16	0:0	6	;
return	98:3	98:13	6	(0)
water	98:10	0:0	7	(
water	98:11	0:0	7	0
water	98:12	0:0	7	)
water	99:2	0:0	6	}
water	100:2	0:0	4	free_entp
op	100:11	0:0	4	->
water	100:13	0:0	4	firstchar
op	100:23	0:0	4	=
water	100:25	0:0	4	free_entp
op	100:34	0:0	4	->
water	100:36	0:0	4	next
op	100:40	0:0	4	->
water	100:42	0:0	4	firstchar
water	100:51	0:0	4	;
water	101:2	0:0	4	free_entp
op	101:11	0:0	4	->
water	101:13	0:0	4	length
op	101:20	0:0	4	=
water	101:22	0:0	4	free_entp
op	101:31	0:0	4	->
water	101:33	0:0	4	next
op	101:37	0:0	4	->
water	101:39	0:0	4	length
op	101:45	0:0	4	+
water	101:46	0:0	4	1
water	101:47	0:0	4	;
water	102:2	0:0	4	free_entp
op	102:11	0:0	4	->
water	102:13	0:0	4	value
op	102:19	0:0	4	=
water	102:21	0:0	4	(
water	102:22	0:0	4	codep
op	102:28	0:0	4	<
water	102:30	0:0	4	free_entp
water	102:39	0:0	4	)
water	102:41	0:0	4	?
water	103:6	0:0	4	codep
op	103:11	0:0	4	->
water	103:13	0:0	4	firstchar
water	103:23	0:0	4	:
water	103:25	0:0	4	free_entp
op	103:34	0:0	4	->
water	103:36	0:0	4	firstchar
water	103:45	0:0	4	;
if	104:2	109:2	4	(++ free_entp > maxcodep)
cond	104:6	104:20	5	++ free_entp > maxcodep
op	104:6	0:0	6	++
water	104:8	0:0	6	free_entp
op	104:18	0:0	6	>
water	104:20	0:0	6	maxcodep
stmts	104:30	109:2	5	
water	104:30	0:0	6	{
if	105:3	106:20	6	(++ nbits > BITS_MAX)
cond	105:7	105:17	7	++ nbits > BITS_MAX
op	105:7	0:0	8	++
water	105:9	0:0	8	nbits
op	105:15	0:0	8	>
water	105:17	0:0	8	BITS_MAX
stmts	106:4	106:20	7	
water	106:4	0:0	8	nbits
op	106:10	0:0	8	=
water	106:12	0:0	8	BITS_MAX
water	106:20	0:0	8	;
water	107:3	0:0	6	nbitsmask
op	107:13	0:0	6	=
call	107:15	107:28	6	MAXCODE
arg	107:23	107:28	7	nbits
water	107:23	0:0	8	nbits
water	107:29	0:0	6	;
water	108:3	0:0	6	maxcodep
op	108:12	0:0	6	=
water	108:14	0:0	6	sp
op	108:16	0:0	6	->
water	108:18	0:0	6	dec_codetab
op	108:30	0:0	6	+
water	108:32	0:0	6	nbitsmask
water	108:41	0:0	6	;
water	109:2	0:0	6	}
water	110:2	0:0	4	oldcodep
op	110:11	0:0	4	=
water	110:13	0:0	4	codep
water	110:18	0:0	4	;
if	111:2	147:2	4	(code >= 256)
cond	111:6	111:14	5	code >= 256
water	111:6	0:0	6	code
op	111:11	0:0	6	>=
water	111:14	0:0	6	256
stmts	111:19	147:2	5	
water	111:19	0:0	6	{
if	116:3	122:3	6	(codep -> length == 0)
cond	116:6	116:23	7	codep -> length == 0
water	116:6	0:0	8	codep
op	116:11	0:0	8	->
water	116:13	0:0	8	length
op	116:20	0:0	8	==
water	116:23	0:0	8	0
stmts	116:26	122:3	7	
water	116:26	0:0	8	{
call	117:4	120:19	8	TIFFErrorExt
arg	117:17	117:36	9	tif->tif_clientdata
water	117:17	0:0	10	tif
op	117:20	0:0	10	->
water	117:22	0:0	10	tif_clientdata
arg	117:38	117:51	9	tif->tif_name
water	117:38	0:0	10	tif
op	117:41	0:0	10	->
water	117:43	0:0	10	tif_name
arg	118:11	119:55	9	"LZWDecodeCompat: Wrong length of decoded ""string: data probably corrupted at scanline %d"
water	118:11	0:0	10	"LZWDecodeCompat: Wrong length of decoded "
water	119:7	0:0	10	"string: data probably corrupted at scanline %d"
arg	120:7	120:19	9	tif->tif_row
water	120:7	0:0	10	tif
op	120:10	0:0	10	->
water	120:12	0:0	10	tif_row
water	120:20	0:0	8	;
return	121:7	121:17	8	(0)
water	121:14	0:0	9	(
water	121:15	0:0	9	0
water	121:16	0:0	9	)
water	122:3	0:0	8	}
if	123:3	141:3	6	(codep -> length > occ)
cond	123:7	123:23	7	codep -> length > occ
water	123:7	0:0	8	codep
op	123:12	0:0	8	->
water	123:14	0:0	8	length
op	123:21	0:0	8	>
water	123:23	0:0	8	occ
stmts	123:28	141:3	7	
water	123:28	0:0	8	{
water	130:4	0:0	8	sp
op	130:6	0:0	8	->
water	130:8	0:0	8	dec_codep
op	130:18	0:0	8	=
water	130:20	0:0	8	codep
water	130:25	0:0	8	;
do	131:4	133:4	8	(codep -> length > occ)
cond	133:13	133:29	9	codep -> length > occ
water	133:13	0:0	10	codep
op	133:18	0:0	10	->
water	133:20	0:0	10	length
op	133:27	0:0	10	>
water	133:29	0:0	10	occ
stmts	131:7	133:4	9	
water	131:7	0:0	10	{
water	132:5	0:0	10	codep
op	132:11	0:0	10	=
water	132:13	0:0	10	codep
op	132:18	0:0	10	->
water	132:20	0:0	10	next
water	132:24	0:0	10	;
water	133:4	0:0	10	}
water	133:33	0:0	8	;
water	134:4	0:0	8	sp
op	134:6	0:0	8	->
water	134:8	0:0	8	dec_restart
op	134:20	0:0	8	=
water	134:22	0:0	8	occ
water	134:25	0:0	8	;
water	135:4	0:0	8	tp
op	135:7	0:0	8	=
water	135:9	0:0	8	op
op	135:12	0:0	8	+
water	135:14	0:0	8	occ
water	135:17	0:0	8	;
do	136:4	139:4	8	(-- occ)
cond	139:14	139:16	9	-- occ
op	139:14	0:0	10	--
water	139:16	0:0	10	occ
stmts	136:8	139:4	9	
water	136:8	0:0	10	{
op	137:5	0:0	10	*
op	137:6	0:0	10	--
water	137:8	0:0	10	tp
op	137:11	0:0	10	=
water	137:13	0:0	10	codep
op	137:18	0:0	10	->
water	137:20	0:0	10	value
water	137:25	0:0	10	;
water	138:5	0:0	10	codep
op	138:11	0:0	10	=
water	138:13	0:0	10	codep
op	138:18	0:0	10	->
water	138:20	0:0	10	next
water	138:24	0:0	10	;
water	139:4	0:0	10	}
water	139:20	0:0	8	;
break	140:4	140:9	8	
water	141:3	0:0	8	}
water	142:3	0:0	6	op
op	142:6	0:0	6	+=
water	142:9	0:0	6	codep
op	142:14	0:0	6	->
water	142:16	0:0	6	length
water	142:22	0:0	6	,
water	142:24	0:0	6	occ
op	142:28	0:0	6	-=
water	142:31	0:0	6	codep
op	142:36	0:0	6	->
water	142:38	0:0	6	length
water	142:44	0:0	6	;
water	143:3	0:0	6	tp
op	143:6	0:0	6	=
water	143:8	0:0	6	op
water	143:10	0:0	6	;
do	144:3	146:3	6	(( codep = codep -> next ) != NULL)
cond	146:12	146:37	7	( codep = codep -> next ) != NULL
water	146:12	0:0	8	(
water	146:13	0:0	8	codep
op	146:19	0:0	8	=
water	146:21	0:0	8	codep
op	146:26	0:0	8	->
water	146:28	0:0	8	next
water	146:32	0:0	8	)
op	146:34	0:0	8	!=
water	146:37	0:0	8	NULL
stmts	144:6	146:3	7	
water	144:6	0:0	8	{
op	145:4	0:0	8	*
op	145:5	0:0	8	--
water	145:7	0:0	8	tp
op	145:10	0:0	8	=
water	145:12	0:0	8	codep
op	145:17	0:0	8	->
water	145:19	0:0	8	value
water	145:24	0:0	8	;
water	146:3	0:0	8	}
water	146:42	0:0	6	;
water	147:2	0:0	6	}
else	147:4	148:22	4
stmts	148:3	148:22	5	
op	148:3	0:0	6	*
water	148:4	0:0	6	op
op	148:6	0:0	6	++
op	148:9	0:0	6	=
water	148:11	0:0	6	code
water	148:15	0:0	6	,
water	148:17	0:0	6	occ
op	148:20	0:0	6	--
water	148:22	0:0	6	;
water	149:1	0:0	4	}
water	151:1	0:0	2	tif
op	151:4	0:0	2	->
water	151:6	0:0	2	tif_rawcp
op	151:16	0:0	2	=
water	151:18	0:0	2	(
water	151:19	0:0	2	tidata_t
water	151:27	0:0	2	)
water	151:29	0:0	2	bp
water	151:31	0:0	2	;
water	152:1	0:0	2	sp
op	152:3	0:0	2	->
water	152:5	0:0	2	lzw_nbits
op	152:15	0:0	2	=
water	152:17	0:0	2	nbits
water	152:22	0:0	2	;
water	153:1	0:0	2	sp
op	153:3	0:0	2	->
water	153:5	0:0	2	lzw_nextdata
op	153:18	0:0	2	=
water	153:20	0:0	2	nextdata
water	153:28	0:0	2	;
water	154:1	0:0	2	sp
op	154:3	0:0	2	->
water	154:5	0:0	2	lzw_nextbits
op	154:18	0:0	2	=
water	154:20	0:0	2	nextbits
water	154:28	0:0	2	;
water	155:1	0:0	2	sp
op	155:3	0:0	2	->
water	155:5	0:0	2	dec_nbitsmask
op	155:19	0:0	2	=
water	155:21	0:0	2	nbitsmask
water	155:30	0:0	2	;
water	156:1	0:0	2	sp
op	156:3	0:0	2	->
water	156:5	0:0	2	dec_oldcodep
op	156:18	0:0	2	=
water	156:20	0:0	2	oldcodep
water	156:28	0:0	2	;
water	157:1	0:0	2	sp
op	157:3	0:0	2	->
water	157:5	0:0	2	dec_free_entp
op	157:19	0:0	2	=
water	157:21	0:0	2	free_entp
water	157:30	0:0	2	;
water	158:1	0:0	2	sp
op	158:3	0:0	2	->
water	158:5	0:0	2	dec_maxcodep
op	158:18	0:0	2	=
water	158:20	0:0	2	maxcodep
water	158:28	0:0	2	;
if	160:1	165:1	2	(occ > 0)
cond	160:5	160:11	3	occ > 0
water	160:5	0:0	4	occ
op	160:9	0:0	4	>
water	160:11	0:0	4	0
stmts	160:14	165:1	3	
water	160:14	0:0	4	{
call	161:2	163:23	4	TIFFErrorExt
arg	161:15	161:34	5	tif->tif_clientdata
water	161:15	0:0	6	tif
op	161:18	0:0	6	->
water	161:20	0:0	6	tif_clientdata
arg	161:36	161:49	5	tif->tif_name
water	161:36	0:0	6	tif
op	161:39	0:0	6	->
water	161:41	0:0	6	tif_name
arg	162:5	162:71	5	"LZWDecodeCompat: Not enough data at scanline %d (short %d bytes)"
water	162:5	0:0	6	"LZWDecodeCompat: Not enough data at scanline %d (short %d bytes)"
arg	163:6	163:18	5	tif->tif_row
water	163:6	0:0	6	tif
op	163:9	0:0	6	->
water	163:11	0:0	6	tif_row
arg	163:20	163:23	5	occ
water	163:20	0:0	6	occ
water	163:24	0:0	4	;
return	164:2	164:12	4	(0)
water	164:9	0:0	5	(
water	164:10	0:0	5	0
water	164:11	0:0	5	)
water	165:1	0:0	4	}
return	166:1	166:11	2	(1)
water	166:8	0:0	3	(
water	166:9	0:0	3	1
water	166:10	0:0	3	)
