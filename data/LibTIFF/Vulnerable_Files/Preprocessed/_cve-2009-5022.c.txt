func	2:0	55:0	0	static int	OJPEGDecodeRaw
params	3:14	0:0	1	
param	3:15	3:24	2	TIFF *	tif
param	3:26	3:38	2	tidata_t	buf
param	3:40	3:50	2	tsize_t	cc
stmnts	5:1	54:10	1	
water	5:1	0:0	2	static
water	5:8	0:0	2	const
water	5:14	0:0	2	char
water	5:19	0:0	2	module
op	5:25	0:0	2	[
op	5:26	0:0	2	]
op	5:27	0:0	2	=
water	5:28	0:0	2	"OJPEGDecodeRaw"
water	5:44	0:0	2	;
decl	6:1	6:42	2	OJPEGState	*sp
op	6:15	0:0	2	=
water	6:16	0:0	2	(
water	6:17	0:0	2	OJPEGState
op	6:27	0:0	2	*
water	6:28	0:0	2	)
water	6:29	0:0	2	tif
op	6:32	0:0	2	->
water	6:34	0:0	2	tif_data
decl	7:1	7:9	2	uint8	*m
decl	8:1	8:9	2	uint32	n
decl	9:1	9:10	2	uint8	*oy
decl	10:1	10:11	2	uint8	*ocb
decl	11:1	11:11	2	uint8	*ocr
decl	12:1	12:9	2	uint8	*p
decl	13:1	13:9	2	uint32	q
decl	14:1	14:9	2	uint8	*r
decl	15:1	15:12	2	uint8	sx
water	15:9	0:0	2	,
decl	15:1	15:12	2	uint8	sy
if	16:1	20:1	2	(cc % sp -> bytes_per_line != 0)
cond	16:5	16:28	3	cc % sp -> bytes_per_line != 0
water	16:5	0:0	4	cc
op	16:7	0:0	4	%
water	16:8	0:0	4	sp
op	16:10	0:0	4	->
water	16:12	0:0	4	bytes_per_line
op	16:26	0:0	4	!=
water	16:28	0:0	4	0
stmts	17:1	20:1	3	
water	17:1	0:0	4	{
call	18:2	18:72	4	TIFFErrorExt
arg	18:15	18:34	5	tif->tif_clientdata
water	18:15	0:0	6	tif
op	18:18	0:0	6	->
water	18:20	0:0	6	tif_clientdata
arg	18:35	18:41	5	module
water	18:35	0:0	6	module
arg	18:42	18:72	5	"Fractional scanline not read"
water	18:42	0:0	6	"Fractional scanline not read"
water	18:73	0:0	4	;
return	19:2	19:11	4	(0)
water	19:8	0:0	5	(
water	19:9	0:0	5	0
water	19:10	0:0	5	)
water	20:1	0:0	4	}
call	21:1	21:12	2	assert
arg	21:8	21:12	3	cc>0
water	21:8	0:0	4	cc
op	21:10	0:0	4	>
water	21:11	0:0	4	0
water	21:13	0:0	2	;
water	22:1	0:0	2	m
op	22:2	0:0	2	=
water	22:3	0:0	2	buf
water	22:6	0:0	2	;
water	23:1	0:0	2	n
op	23:2	0:0	2	=
water	23:3	0:0	2	cc
water	23:5	0:0	2	;
do	24:1	53:1	2	(n > 0)
cond	53:9	53:11	3	n > 0
water	53:9	0:0	4	n
op	53:10	0:0	4	>
water	53:11	0:0	4	0
stmts	25:1	53:1	3	
water	25:1	0:0	4	{
if	26:2	30:2	4	(sp -> subsampling_convert_state == 0)
cond	26:6	26:37	5	sp -> subsampling_convert_state == 0
water	26:6	0:0	6	sp
op	26:8	0:0	6	->
water	26:10	0:0	6	subsampling_convert_state
op	26:35	0:0	6	==
water	26:37	0:0	6	0
stmts	27:2	30:2	5	
water	27:2	0:0	6	{
if	28:3	29:13	6	(jpeg_read_raw_data_encap (sp ,& ( sp -> libjpeg_jpeg_decompress_struct ) ,sp -> subsampling_convert_ycbcrimage ,sp -> subsampling_ver * 8 ) == 0)
cond	28:7	28:132	7	jpeg_read_raw_data_encap (sp ,& ( sp -> libjpeg_jpeg_decompress_struct ) ,sp -> subsampling_convert_ycbcrimage ,sp -> subsampling_ver * 8 ) == 0
call	28:7	28:129	8	jpeg_read_raw_data_encap
arg	28:32	28:34	9	sp
water	28:32	0:0	10	sp
arg	28:35	28:72	9	&(sp->libjpeg_jpeg_decompress_struct)
op	28:35	0:0	10	&
water	28:36	0:0	10	(
water	28:37	0:0	10	sp
op	28:39	0:0	10	->
water	28:41	0:0	10	libjpeg_jpeg_decompress_struct
water	28:71	0:0	10	)
arg	28:73	28:107	9	sp->subsampling_convert_ycbcrimage
water	28:73	0:0	10	sp
op	28:75	0:0	10	->
water	28:77	0:0	10	subsampling_convert_ycbcrimage
arg	28:108	28:129	9	sp->subsampling_ver*8
water	28:108	0:0	10	sp
op	28:110	0:0	10	->
water	28:112	0:0	10	subsampling_ver
op	28:127	0:0	10	*
water	28:128	0:0	10	8
op	28:130	0:0	8	==
water	28:132	0:0	8	0
stmts	29:4	29:13	7	
return	29:4	29:13	8	(0)
water	29:10	0:0	9	(
water	29:11	0:0	9	0
water	29:12	0:0	9	)
water	30:2	0:0	6	}
water	31:2	0:0	4	oy
op	31:4	0:0	4	=
water	31:5	0:0	4	sp
op	31:7	0:0	4	->
water	31:9	0:0	4	subsampling_convert_ybuf
op	31:33	0:0	4	+
water	31:34	0:0	4	sp
op	31:36	0:0	4	->
water	31:38	0:0	4	subsampling_convert_state
op	31:63	0:0	4	*
water	31:64	0:0	4	sp
op	31:66	0:0	4	->
water	31:68	0:0	4	subsampling_ver
op	31:83	0:0	4	*
water	31:84	0:0	4	sp
op	31:86	0:0	4	->
water	31:88	0:0	4	subsampling_convert_ylinelen
water	31:116	0:0	4	;
water	32:2	0:0	4	ocb
op	32:5	0:0	4	=
water	32:6	0:0	4	sp
op	32:8	0:0	4	->
water	32:10	0:0	4	subsampling_convert_cbbuf
op	32:35	0:0	4	+
water	32:36	0:0	4	sp
op	32:38	0:0	4	->
water	32:40	0:0	4	subsampling_convert_state
op	32:65	0:0	4	*
water	32:66	0:0	4	sp
op	32:68	0:0	4	->
water	32:70	0:0	4	subsampling_convert_clinelen
water	32:98	0:0	4	;
water	33:2	0:0	4	ocr
op	33:5	0:0	4	=
water	33:6	0:0	4	sp
op	33:8	0:0	4	->
water	33:10	0:0	4	subsampling_convert_crbuf
op	33:35	0:0	4	+
water	33:36	0:0	4	sp
op	33:38	0:0	4	->
water	33:40	0:0	4	subsampling_convert_state
op	33:65	0:0	4	*
water	33:66	0:0	4	sp
op	33:68	0:0	4	->
water	33:70	0:0	4	subsampling_convert_clinelen
water	33:98	0:0	4	;
water	34:2	0:0	4	p
op	34:3	0:0	4	=
water	34:4	0:0	4	m
water	34:5	0:0	4	;
for	35:2	47:2	4	(q = 0 ;q < sp -> subsampling_convert_clinelenout;q ++)
forinit	35:7	35:10	5	q = 0 ;
water	35:7	0:0	6	q
op	35:8	0:0	6	=
water	35:9	0:0	6	0
water	35:10	0:0	6	;
cond	35:12	35:18	5	q < sp -> subsampling_convert_clinelenout
water	35:12	0:0	6	q
op	35:13	0:0	6	<
water	35:14	0:0	6	sp
op	35:16	0:0	6	->
water	35:18	0:0	6	subsampling_convert_clinelenout
forexpr	35:51	35:52	5	q ++
water	35:51	0:0	6	q
op	35:52	0:0	6	++
stmts	36:2	47:2	5	
water	36:2	0:0	6	{
water	37:3	0:0	6	r
op	37:4	0:0	6	=
water	37:5	0:0	6	oy
water	37:7	0:0	6	;
for	38:3	43:3	6	(sy = 0 ;sy < sp -> subsampling_ver;sy ++)
forinit	38:8	38:12	7	sy = 0 ;
water	38:8	0:0	8	sy
op	38:10	0:0	8	=
water	38:11	0:0	8	0
water	38:12	0:0	8	;
cond	38:14	38:21	7	sy < sp -> subsampling_ver
water	38:14	0:0	8	sy
op	38:16	0:0	8	<
water	38:17	0:0	8	sp
op	38:19	0:0	8	->
water	38:21	0:0	8	subsampling_ver
forexpr	38:38	38:40	7	sy ++
water	38:38	0:0	8	sy
op	38:40	0:0	8	++
stmts	39:3	43:3	7	
water	39:3	0:0	8	{
for	40:4	41:14	8	(sx = 0 ;sx < sp -> subsampling_hor;sx ++)
forinit	40:9	40:13	9	sx = 0 ;
water	40:9	0:0	10	sx
op	40:11	0:0	10	=
water	40:12	0:0	10	0
water	40:13	0:0	10	;
cond	40:15	40:22	9	sx < sp -> subsampling_hor
water	40:15	0:0	10	sx
op	40:17	0:0	10	<
water	40:18	0:0	10	sp
op	40:20	0:0	10	->
water	40:22	0:0	10	subsampling_hor
forexpr	40:39	40:41	9	sx ++
water	40:39	0:0	10	sx
op	40:41	0:0	10	++
stmts	41:5	41:14	9	
op	41:5	0:0	10	*
water	41:6	0:0	10	p
op	41:7	0:0	10	++
op	41:9	0:0	10	=
op	41:10	0:0	10	*
water	41:11	0:0	10	r
op	41:12	0:0	10	++
water	41:14	0:0	10	;
water	42:4	0:0	8	r
op	42:5	0:0	8	+=
water	42:7	0:0	8	sp
op	42:9	0:0	8	->
water	42:11	0:0	8	subsampling_convert_ylinelen
op	42:39	0:0	8	-
water	42:40	0:0	8	sp
op	42:42	0:0	8	->
water	42:44	0:0	8	subsampling_hor
water	42:59	0:0	8	;
water	43:3	0:0	8	}
water	44:3	0:0	6	oy
op	44:5	0:0	6	+=
water	44:7	0:0	6	sp
op	44:9	0:0	6	->
water	44:11	0:0	6	subsampling_hor
water	44:26	0:0	6	;
op	45:3	0:0	6	*
water	45:4	0:0	6	p
op	45:5	0:0	6	++
op	45:7	0:0	6	=
op	45:8	0:0	6	*
water	45:9	0:0	6	ocb
op	45:12	0:0	6	++
water	45:14	0:0	6	;
op	46:3	0:0	6	*
water	46:4	0:0	6	p
op	46:5	0:0	6	++
op	46:7	0:0	6	=
op	46:8	0:0	6	*
water	46:9	0:0	6	ocr
op	46:12	0:0	6	++
water	46:14	0:0	6	;
water	47:2	0:0	6	}
water	48:2	0:0	4	sp
op	48:4	0:0	4	->
water	48:6	0:0	4	subsampling_convert_state
op	48:31	0:0	4	++
water	48:33	0:0	4	;
if	49:2	50:34	4	(sp -> subsampling_convert_state == sp -> subsampling_convert_clines)
cond	49:6	49:41	5	sp -> subsampling_convert_state == sp -> subsampling_convert_clines
water	49:6	0:0	6	sp
op	49:8	0:0	6	->
water	49:10	0:0	6	subsampling_convert_state
op	49:35	0:0	6	==
water	49:37	0:0	6	sp
op	49:39	0:0	6	->
water	49:41	0:0	6	subsampling_convert_clines
stmts	50:3	50:34	5	
water	50:3	0:0	6	sp
op	50:5	0:0	6	->
water	50:7	0:0	6	subsampling_convert_state
op	50:32	0:0	6	=
water	50:33	0:0	6	0
water	50:34	0:0	6	;
water	51:2	0:0	4	m
op	51:3	0:0	4	+=
water	51:5	0:0	4	sp
op	51:7	0:0	4	->
water	51:9	0:0	4	bytes_per_line
water	51:23	0:0	4	;
water	52:2	0:0	4	n
op	52:3	0:0	4	-=
water	52:5	0:0	4	sp
op	52:7	0:0	4	->
water	52:9	0:0	4	bytes_per_line
water	52:23	0:0	4	;
water	53:1	0:0	4	}
water	53:13	0:0	2	;
return	54:1	54:10	2	(1)
water	54:7	0:0	3	(
water	54:8	0:0	3	1
water	54:9	0:0	3	)
