func	1:0	133:0	0	static int	PixarLogDecode
params	2:14	0:0	1	
param	2:15	2:24	2	TIFF *	tif
param	2:26	2:35	2	uint8 *	op
param	2:37	2:49	2	tmsize_t	occ
param	2:51	2:59	2	uint16	s
stmnts	4:1	132:11	1	
water	4:1	0:0	2	static
water	4:8	0:0	2	const
water	4:14	0:0	2	char
water	4:19	0:0	2	module
op	4:25	0:0	2	[
op	4:26	0:0	2	]
op	4:28	0:0	2	=
water	4:30	0:0	2	"PixarLogDecode"
water	4:46	0:0	2	;
decl	5:1	5:34	2	TIFFDirectory	*td
op	5:19	0:0	2	=
op	5:21	0:0	2	&
water	5:22	0:0	2	tif
op	5:25	0:0	2	->
water	5:27	0:0	2	tif_dir
decl	6:1	6:38	2	PixarLogState	*sp
op	6:19	0:0	2	=
call	6:21	6:37	3	DecoderState
arg	6:34	6:37	4	tif
water	6:34	0:0	5	tif
decl	7:1	7:11	2	tmsize_t	i
decl	8:1	8:18	2	tmsize_t	nsamples
decl	9:1	9:9	2	int	llen
decl	10:1	10:11	2	uint16	*up
switch	12:1	30:1	2	(sp -> user_datafmt)
cond	12:9	12:13	3	sp -> user_datafmt
water	12:9	0:0	4	sp
op	12:11	0:0	4	->
water	12:13	0:0	4	user_datafmt
stmts	12:27	30:1	3	
water	12:27	0:0	4	{
label	13:1	13:27	4	case PIXARLOGDATAFMT_FLOAT :
water	14:2	0:0	4	nsamples
op	14:11	0:0	4	=
water	14:13	0:0	4	occ
op	14:17	0:0	4	/
op	14:19	0:0	4	sizeof
water	14:25	0:0	4	(
water	14:26	0:0	4	float
water	14:31	0:0	4	)
water	14:32	0:0	4	;
break	15:2	15:7	4	
label	16:1	16:27	4	case PIXARLOGDATAFMT_16BIT :
label	17:1	17:32	4	case PIXARLOGDATAFMT_12BITPICIO :
label	18:1	18:30	4	case PIXARLOGDATAFMT_11BITLOG :
water	19:2	0:0	4	nsamples
op	19:11	0:0	4	=
water	19:13	0:0	4	occ
op	19:17	0:0	4	/
op	19:19	0:0	4	sizeof
water	19:25	0:0	4	(
water	19:26	0:0	4	uint16
water	19:32	0:0	4	)
water	19:33	0:0	4	;
break	20:2	20:7	4	
label	21:1	21:26	4	case PIXARLOGDATAFMT_8BIT :
label	22:1	22:30	4	case PIXARLOGDATAFMT_8BITABGR :
water	23:2	0:0	4	nsamples
op	23:11	0:0	4	=
water	23:13	0:0	4	occ
water	23:16	0:0	4	;
break	24:2	24:7	4	
label	25:1	25:8	4	default :
call	26:2	28:23	4	TIFFErrorExt
arg	26:15	26:34	5	tif->tif_clientdata
water	26:15	0:0	6	tif
op	26:18	0:0	6	->
water	26:20	0:0	6	tif_clientdata
arg	26:36	26:42	5	module
water	26:36	0:0	6	module
arg	27:3	27:43	5	"%d bit input not supported in PixarLog"
water	27:3	0:0	6	"%d bit input not supported in PixarLog"
arg	28:3	28:23	5	td->td_bitspersample
water	28:3	0:0	6	td
op	28:5	0:0	6	->
water	28:7	0:0	6	td_bitspersample
water	28:24	0:0	4	;
return	29:2	29:10	4	0
water	29:9	0:0	5	0
water	30:1	0:0	4	}
water	32:1	0:0	2	llen
op	32:6	0:0	2	=
water	32:8	0:0	2	sp
op	32:10	0:0	2	->
water	32:12	0:0	2	stride
op	32:19	0:0	2	*
water	32:21	0:0	2	td
op	32:23	0:0	2	->
water	32:25	0:0	2	td_imagewidth
water	32:38	0:0	2	;
water	34:1	0:0	2	(
water	34:2	0:0	2	void
water	34:6	0:0	2	)
water	34:8	0:0	2	s
water	34:9	0:0	2	;
call	35:1	35:18	2	assert
arg	35:8	35:18	3	sp!=NULL
water	35:8	0:0	4	sp
op	35:11	0:0	4	!=
water	35:14	0:0	4	NULL
water	35:19	0:0	2	;
water	36:1	0:0	2	sp
op	36:3	0:0	2	->
water	36:5	0:0	2	stream
op	36:11	0:0	2	.
water	36:12	0:0	2	next_out
op	36:21	0:0	2	=
water	36:23	0:0	2	(
water	36:24	0:0	2	unsigned
water	36:33	0:0	2	char
op	36:38	0:0	2	*
water	36:39	0:0	2	)
water	36:41	0:0	2	sp
op	36:43	0:0	2	->
water	36:45	0:0	2	tbuf
water	36:49	0:0	2	;
call	37:1	37:39	2	assert
arg	37:8	37:39	3	sizeof(sp->stream.avail_out)==4
op	37:8	0:0	4	sizeof
water	37:14	0:0	4	(
water	37:15	0:0	4	sp
op	37:17	0:0	4	->
water	37:19	0:0	4	stream
op	37:25	0:0	4	.
water	37:26	0:0	4	avail_out
water	37:35	0:0	4	)
op	37:36	0:0	4	==
water	37:38	0:0	4	4
water	37:40	0:0	2	;
water	41:1	0:0	2	sp
op	41:3	0:0	2	->
water	41:5	0:0	2	stream
op	41:11	0:0	2	.
water	41:12	0:0	2	avail_out
op	41:22	0:0	2	=
call	41:24	41:57	2	(uInt)
arg	41:32	41:57	3	nsamples*sizeof(uint16)
water	41:32	0:0	4	nsamples
op	41:41	0:0	4	*
op	41:43	0:0	4	sizeof
water	41:49	0:0	4	(
water	41:50	0:0	4	uint16
water	41:56	0:0	4	)
water	41:58	0:0	2	;
if	42:1	46:1	2	(sp -> stream . avail_out != nsamples * sizeof ( uint16 ))
cond	42:5	42:53	3	sp -> stream . avail_out != nsamples * sizeof ( uint16 )
water	42:5	0:0	4	sp
op	42:7	0:0	4	->
water	42:9	0:0	4	stream
op	42:15	0:0	4	.
water	42:16	0:0	4	avail_out
op	42:26	0:0	4	!=
water	42:29	0:0	4	nsamples
op	42:38	0:0	4	*
op	42:40	0:0	4	sizeof
water	42:46	0:0	4	(
water	42:47	0:0	4	uint16
water	42:53	0:0	4	)
stmts	43:1	46:1	3	
water	43:1	0:0	4	{
call	44:2	44:85	4	TIFFErrorExt
arg	44:15	44:34	5	tif->tif_clientdata
water	44:15	0:0	6	tif
op	44:18	0:0	6	->
water	44:20	0:0	6	tif_clientdata
arg	44:36	44:42	5	module
water	44:36	0:0	6	module
arg	44:44	44:85	5	"ZLib cannot deal with buffers this size"
water	44:44	0:0	6	"ZLib cannot deal with buffers this size"
water	44:86	0:0	4	;
return	45:2	45:12	4	(0)
water	45:9	0:0	5	(
water	45:10	0:0	5	0
water	45:11	0:0	5	)
water	46:1	0:0	4	}
do	47:1	65:1	2	(sp -> stream . avail_out > 0)
cond	65:10	65:33	3	sp -> stream . avail_out > 0
water	65:10	0:0	4	sp
op	65:12	0:0	4	->
water	65:14	0:0	4	stream
op	65:20	0:0	4	.
water	65:21	0:0	4	avail_out
op	65:31	0:0	4	>
water	65:33	0:0	4	0
stmts	47:4	65:1	3	
water	47:4	0:0	4	{
decl	48:2	48:51	4	int	state
op	48:12	0:0	4	=
call	48:14	48:50	5	inflate
arg	48:22	48:33	6	&sp->stream
op	48:22	0:0	7	&
water	48:23	0:0	7	sp
op	48:25	0:0	7	->
water	48:27	0:0	7	stream
arg	48:35	48:50	6	Z_PARTIAL_FLUSH
water	48:35	0:0	7	Z_PARTIAL_FLUSH
if	49:2	51:2	4	(state == Z_STREAM_END)
cond	49:6	49:15	5	state == Z_STREAM_END
water	49:6	0:0	6	state
op	49:12	0:0	6	==
water	49:15	0:0	6	Z_STREAM_END
stmts	49:29	51:2	5	
water	49:29	0:0	6	{
break	50:3	50:8	6	
water	51:2	0:0	6	}
if	52:2	59:2	4	(state == Z_DATA_ERROR)
cond	52:6	52:15	5	state == Z_DATA_ERROR
water	52:6	0:0	6	state
op	52:12	0:0	6	==
water	52:15	0:0	6	Z_DATA_ERROR
stmts	52:29	59:2	5	
water	52:29	0:0	6	{
call	53:3	55:51	6	TIFFErrorExt
arg	53:16	53:35	7	tif->tif_clientdata
water	53:16	0:0	8	tif
op	53:19	0:0	8	->
water	53:21	0:0	8	tif_clientdata
arg	53:37	53:43	7	module
water	53:37	0:0	8	module
arg	54:7	54:43	7	"Decoding error at scanline %lu, %s"
water	54:7	0:0	8	"Decoding error at scanline %lu, %s"
arg	55:7	55:35	7	(unsignedlong)tif->tif_row
water	55:7	0:0	8	(
water	55:8	0:0	8	unsigned
water	55:17	0:0	8	long
water	55:21	0:0	8	)
water	55:23	0:0	8	tif
op	55:26	0:0	8	->
water	55:28	0:0	8	tif_row
arg	55:37	55:51	7	sp->stream.msg
water	55:37	0:0	8	sp
op	55:39	0:0	8	->
water	55:41	0:0	8	stream
op	55:47	0:0	8	.
water	55:48	0:0	8	msg
water	55:52	0:0	6	;
if	56:3	57:14	6	(inflateSync (& sp -> stream ) != Z_OK)
cond	56:7	56:35	7	inflateSync (& sp -> stream ) != Z_OK
call	56:7	56:30	8	inflateSync
arg	56:19	56:30	9	&sp->stream
op	56:19	0:0	10	&
water	56:20	0:0	10	sp
op	56:22	0:0	10	->
water	56:24	0:0	10	stream
op	56:32	0:0	8	!=
water	56:35	0:0	8	Z_OK
stmts	57:4	57:14	7	
return	57:4	57:14	8	(0)
water	57:11	0:0	9	(
water	57:12	0:0	9	0
water	57:13	0:0	9	)
continue	58:3	58:11	6	
water	59:2	0:0	6	}
if	60:2	64:2	4	(state != Z_OK)
cond	60:6	60:15	5	state != Z_OK
water	60:6	0:0	6	state
op	60:12	0:0	6	!=
water	60:15	0:0	6	Z_OK
stmts	60:21	64:2	5	
water	60:21	0:0	6	{
call	61:3	62:21	6	TIFFErrorExt
arg	61:16	61:35	7	tif->tif_clientdata
water	61:16	0:0	8	tif
op	61:19	0:0	8	->
water	61:21	0:0	8	tif_clientdata
arg	61:37	61:43	7	module
water	61:37	0:0	8	module
arg	61:45	61:61	7	"ZLib error: %s"
water	61:45	0:0	8	"ZLib error: %s"
arg	62:7	62:21	7	sp->stream.msg
water	62:7	0:0	8	sp
op	62:9	0:0	8	->
water	62:11	0:0	8	stream
op	62:17	0:0	8	.
water	62:18	0:0	8	msg
water	62:22	0:0	6	;
return	63:3	63:13	6	(0)
water	63:10	0:0	7	(
water	63:11	0:0	7	0
water	63:12	0:0	7	)
water	64:2	0:0	6	}
water	65:1	0:0	4	}
water	65:35	0:0	2	;
if	68:1	73:1	2	(sp -> stream . avail_out != 0)
cond	68:5	68:29	3	sp -> stream . avail_out != 0
water	68:5	0:0	4	sp
op	68:7	0:0	4	->
water	68:9	0:0	4	stream
op	68:15	0:0	4	.
water	68:16	0:0	4	avail_out
op	68:26	0:0	4	!=
water	68:29	0:0	4	0
stmts	68:32	73:1	3	
water	68:32	0:0	4	{
call	69:2	71:72	4	TIFFErrorExt
arg	69:15	69:34	5	tif->tif_clientdata
water	69:15	0:0	6	tif
op	69:18	0:0	6	->
water	69:20	0:0	6	tif_clientdata
arg	69:36	69:42	5	module
water	69:36	0:0	6	module
arg	70:6	70:76	5	"Not enough data at scanline %lu (short "TIFF_UINT64_FORMAT" bytes)"
water	70:6	0:0	6	"Not enough data at scanline %lu (short "
water	70:48	0:0	6	TIFF_UINT64_FORMAT
water	70:67	0:0	6	" bytes)"
arg	71:6	71:34	5	(unsignedlong)tif->tif_row
water	71:6	0:0	6	(
water	71:7	0:0	6	unsigned
water	71:16	0:0	6	long
water	71:20	0:0	6	)
water	71:22	0:0	6	tif
op	71:25	0:0	6	->
water	71:27	0:0	6	tif_row
arg	71:36	71:72	5	(TIFF_UINT64_T)sp->stream.avail_out
water	71:36	0:0	6	(
water	71:37	0:0	6	TIFF_UINT64_T
water	71:50	0:0	6	)
water	71:52	0:0	6	sp
op	71:54	0:0	6	->
water	71:56	0:0	6	stream
op	71:62	0:0	6	.
water	71:63	0:0	6	avail_out
water	71:73	0:0	4	;
return	72:2	72:12	4	(0)
water	72:9	0:0	5	(
water	72:10	0:0	5	0
water	72:11	0:0	5	)
water	73:1	0:0	4	}
water	75:1	0:0	2	up
op	75:4	0:0	2	=
water	75:6	0:0	2	sp
op	75:8	0:0	2	->
water	75:10	0:0	2	tbuf
water	75:14	0:0	2	;
if	77:1	78:36	2	(tif -> tif_flags & TIFF_SWAB)
cond	77:5	77:22	3	tif -> tif_flags & TIFF_SWAB
water	77:5	0:0	4	tif
op	77:8	0:0	4	->
water	77:10	0:0	4	tif_flags
op	77:20	0:0	4	&
water	77:22	0:0	4	TIFF_SWAB
stmts	78:2	78:36	3	
call	78:2	78:35	4	TIFFSwabArrayOfShort
arg	78:23	78:25	5	up
water	78:23	0:0	6	up
arg	78:27	78:35	5	nsamples
water	78:27	0:0	6	nsamples
water	78:36	0:0	4	;
if	85:1	90:1	2	(nsamples % llen)
cond	85:5	85:16	3	nsamples % llen
water	85:5	0:0	4	nsamples
op	85:14	0:0	4	%
water	85:16	0:0	4	llen
stmts	85:22	90:1	3	
water	85:22	0:0	4	{
call	86:2	88:73	4	TIFFWarningExt
arg	86:17	86:36	5	tif->tif_clientdata
water	86:17	0:0	6	tif
op	86:20	0:0	6	->
water	86:22	0:0	6	tif_clientdata
arg	86:38	86:44	5	module
water	86:38	0:0	6	module
arg	87:3	88:25	5	"stride %lu is not a multiple of sample count, ""%lu, data truncated."
water	87:3	0:0	6	"stride %lu is not a multiple of sample count, "
water	88:3	0:0	6	"%lu, data truncated."
arg	88:27	88:47	5	(unsignedlong)llen
water	88:27	0:0	6	(
water	88:28	0:0	6	unsigned
water	88:37	0:0	6	long
water	88:41	0:0	6	)
water	88:43	0:0	6	llen
arg	88:49	88:73	5	(unsignedlong)nsamples
water	88:49	0:0	6	(
water	88:50	0:0	6	unsigned
water	88:59	0:0	6	long
water	88:63	0:0	6	)
water	88:65	0:0	6	nsamples
water	88:74	0:0	4	;
water	89:2	0:0	4	nsamples
op	89:11	0:0	4	-=
water	89:14	0:0	4	nsamples
op	89:23	0:0	4	%
water	89:25	0:0	4	llen
water	89:29	0:0	4	;
water	90:1	0:0	4	}
for	92:1	130:1	2	(i = 0 ;i < nsamples;i += llen , up += llen)
forinit	92:6	92:11	3	i = 0 ;
water	92:6	0:0	4	i
op	92:8	0:0	4	=
water	92:10	0:0	4	0
water	92:11	0:0	4	;
cond	92:13	92:17	3	i < nsamples
water	92:13	0:0	4	i
op	92:15	0:0	4	<
water	92:17	0:0	4	nsamples
forexpr	92:27	92:44	3	i += llen , up += llen
water	92:27	0:0	4	i
op	92:29	0:0	4	+=
water	92:32	0:0	4	llen
water	92:36	0:0	4	,
water	92:38	0:0	4	up
op	92:41	0:0	4	+=
water	92:44	0:0	4	llen
stmts	92:50	130:1	3	
water	92:50	0:0	4	{
switch	93:2	129:2	4	(sp -> user_datafmt)
cond	93:10	93:14	5	sp -> user_datafmt
water	93:10	0:0	6	sp
op	93:12	0:0	6	->
water	93:14	0:0	6	user_datafmt
stmts	93:29	129:2	5	
water	93:29	0:0	6	{
label	94:2	94:28	6	case PIXARLOGDATAFMT_FLOAT :
call	95:3	96:31	6	horizontalAccumulateF
arg	95:25	95:27	7	up
water	95:25	0:0	8	up
arg	95:29	95:33	7	llen
water	95:29	0:0	8	llen
arg	95:35	95:45	7	sp->stride
water	95:35	0:0	8	sp
op	95:37	0:0	8	->
water	95:39	0:0	8	stride
arg	96:5	96:16	7	(float*)op
water	96:5	0:0	8	(
water	96:6	0:0	8	float
op	96:12	0:0	8	*
water	96:13	0:0	8	)
water	96:14	0:0	8	op
arg	96:18	96:31	7	sp->ToLinearF
water	96:18	0:0	8	sp
op	96:20	0:0	8	->
water	96:22	0:0	8	ToLinearF
water	96:32	0:0	6	;
water	97:3	0:0	6	op
op	97:6	0:0	6	+=
water	97:9	0:0	6	llen
op	97:14	0:0	6	*
op	97:16	0:0	6	sizeof
water	97:22	0:0	6	(
water	97:23	0:0	6	float
water	97:28	0:0	6	)
water	97:29	0:0	6	;
break	98:3	98:8	6	
label	99:2	99:28	6	case PIXARLOGDATAFMT_16BIT :
call	100:3	101:33	6	horizontalAccumulate16
arg	100:26	100:28	7	up
water	100:26	0:0	8	up
arg	100:30	100:34	7	llen
water	100:30	0:0	8	llen
arg	100:36	100:46	7	sp->stride
water	100:36	0:0	8	sp
op	100:38	0:0	8	->
water	100:40	0:0	8	stride
arg	101:5	101:17	7	(uint16*)op
water	101:5	0:0	8	(
water	101:6	0:0	8	uint16
op	101:13	0:0	8	*
water	101:14	0:0	8	)
water	101:15	0:0	8	op
arg	101:19	101:33	7	sp->ToLinear16
water	101:19	0:0	8	sp
op	101:21	0:0	8	->
water	101:23	0:0	8	ToLinear16
water	101:34	0:0	6	;
water	102:3	0:0	6	op
op	102:6	0:0	6	+=
water	102:9	0:0	6	llen
op	102:14	0:0	6	*
op	102:16	0:0	6	sizeof
water	102:22	0:0	6	(
water	102:23	0:0	6	uint16
water	102:29	0:0	6	)
water	102:30	0:0	6	;
break	103:3	103:8	6	
label	104:2	104:33	6	case PIXARLOGDATAFMT_12BITPICIO :
call	105:3	106:31	6	horizontalAccumulate12
arg	105:26	105:28	7	up
water	105:26	0:0	8	up
arg	105:30	105:34	7	llen
water	105:30	0:0	8	llen
arg	105:36	105:46	7	sp->stride
water	105:36	0:0	8	sp
op	105:38	0:0	8	->
water	105:40	0:0	8	stride
arg	106:5	106:16	7	(int16*)op
water	106:5	0:0	8	(
water	106:6	0:0	8	int16
op	106:12	0:0	8	*
water	106:13	0:0	8	)
water	106:14	0:0	8	op
arg	106:18	106:31	7	sp->ToLinearF
water	106:18	0:0	8	sp
op	106:20	0:0	8	->
water	106:22	0:0	8	ToLinearF
water	106:32	0:0	6	;
water	107:3	0:0	6	op
op	107:6	0:0	6	+=
water	107:9	0:0	6	llen
op	107:14	0:0	6	*
op	107:16	0:0	6	sizeof
water	107:22	0:0	6	(
water	107:23	0:0	6	int16
water	107:28	0:0	6	)
water	107:29	0:0	6	;
break	108:3	108:8	6	
label	109:2	109:31	6	case PIXARLOGDATAFMT_11BITLOG :
call	110:3	111:17	6	horizontalAccumulate11
arg	110:26	110:28	7	up
water	110:26	0:0	8	up
arg	110:30	110:34	7	llen
water	110:30	0:0	8	llen
arg	110:36	110:46	7	sp->stride
water	110:36	0:0	8	sp
op	110:38	0:0	8	->
water	110:40	0:0	8	stride
arg	111:5	111:17	7	(uint16*)op
water	111:5	0:0	8	(
water	111:6	0:0	8	uint16
op	111:13	0:0	8	*
water	111:14	0:0	8	)
water	111:15	0:0	8	op
water	111:18	0:0	6	;
water	112:3	0:0	6	op
op	112:6	0:0	6	+=
water	112:9	0:0	6	llen
op	112:14	0:0	6	*
op	112:16	0:0	6	sizeof
water	112:22	0:0	6	(
water	112:23	0:0	6	uint16
water	112:29	0:0	6	)
water	112:30	0:0	6	;
break	113:3	113:8	6	
label	114:2	114:27	6	case PIXARLOGDATAFMT_8BIT :
call	115:3	116:39	6	horizontalAccumulate8
arg	115:25	115:27	7	up
water	115:25	0:0	8	up
arg	115:29	115:33	7	llen
water	115:29	0:0	8	llen
arg	115:35	115:45	7	sp->stride
water	115:35	0:0	8	sp
op	115:37	0:0	8	->
water	115:39	0:0	8	stride
arg	116:5	116:24	7	(unsignedchar*)op
water	116:5	0:0	8	(
water	116:6	0:0	8	unsigned
water	116:15	0:0	8	char
op	116:20	0:0	8	*
water	116:21	0:0	8	)
water	116:22	0:0	8	op
arg	116:26	116:39	7	sp->ToLinear8
water	116:26	0:0	8	sp
op	116:28	0:0	8	->
water	116:30	0:0	8	ToLinear8
water	116:40	0:0	6	;
water	117:3	0:0	6	op
op	117:6	0:0	6	+=
water	117:9	0:0	6	llen
op	117:14	0:0	6	*
op	117:16	0:0	6	sizeof
water	117:22	0:0	6	(
water	117:23	0:0	6	unsigned
water	117:32	0:0	6	char
water	117:36	0:0	6	)
water	117:37	0:0	6	;
break	118:3	118:8	6	
label	119:2	119:31	6	case PIXARLOGDATAFMT_8BITABGR :
call	120:3	121:39	6	horizontalAccumulate8abgr
arg	120:29	120:31	7	up
water	120:29	0:0	8	up
arg	120:33	120:37	7	llen
water	120:33	0:0	8	llen
arg	120:39	120:49	7	sp->stride
water	120:39	0:0	8	sp
op	120:41	0:0	8	->
water	120:43	0:0	8	stride
arg	121:5	121:24	7	(unsignedchar*)op
water	121:5	0:0	8	(
water	121:6	0:0	8	unsigned
water	121:15	0:0	8	char
op	121:20	0:0	8	*
water	121:21	0:0	8	)
water	121:22	0:0	8	op
arg	121:26	121:39	7	sp->ToLinear8
water	121:26	0:0	8	sp
op	121:28	0:0	8	->
water	121:30	0:0	8	ToLinear8
water	121:40	0:0	6	;
water	122:3	0:0	6	op
op	122:6	0:0	6	+=
water	122:9	0:0	6	llen
op	122:14	0:0	6	*
op	122:16	0:0	6	sizeof
water	122:22	0:0	6	(
water	122:23	0:0	6	unsigned
water	122:32	0:0	6	char
water	122:36	0:0	6	)
water	122:37	0:0	6	;
break	123:3	123:8	6	
label	124:2	124:9	6	default :
call	125:3	127:26	6	TIFFErrorExt
arg	125:16	125:35	7	tif->tif_clientdata
water	125:16	0:0	8	tif
op	125:19	0:0	8	->
water	125:21	0:0	8	tif_clientdata
arg	125:37	125:43	7	module
water	125:37	0:0	8	module
arg	126:6	126:35	7	"Unsupported bits/sample: %d"
water	126:6	0:0	8	"Unsupported bits/sample: %d"
arg	127:6	127:26	7	td->td_bitspersample
water	127:6	0:0	8	td
op	127:8	0:0	8	->
water	127:10	0:0	8	td_bitspersample
water	127:27	0:0	6	;
return	128:3	128:13	6	(0)
water	128:10	0:0	7	(
water	128:11	0:0	7	0
water	128:12	0:0	7	)
water	129:2	0:0	6	}
water	130:1	0:0	4	}
return	132:1	132:11	2	(1)
water	132:8	0:0	3	(
water	132:9	0:0	3	1
water	132:10	0:0	3	)
