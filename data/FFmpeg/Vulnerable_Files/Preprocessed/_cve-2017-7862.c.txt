func	2:0	159:0	0	static int	decode_frame
params	2:23	0:0	1	
param	2:24	2:45	2	AVCodecContext *	avctx
param	3:24	3:34	2	void *	data
param	3:36	3:50	2	int *	got_frame
param	4:24	4:39	2	AVPacket *	avpkt
stmnts	0:0	158:22	1	
decl	6:4	6:36	2	PicContext	*s
op	6:18	0:0	2	=
water	6:20	0:0	2	avctx
op	6:25	0:0	2	->
water	6:27	0:0	2	priv_data
decl	7:4	7:25	2	AVFrame	*frame
op	7:19	0:0	2	=
water	7:21	0:0	2	data
decl	8:4	8:21	2	uint32_t	*palette
decl	9:4	9:62	2	int	bits_per_plane
water	9:22	0:0	2	,
decl	9:4	9:62	2	int	bpp
water	9:27	0:0	2	,
decl	9:4	9:62	2	int	etype
water	9:34	0:0	2	,
decl	9:4	9:62	2	int	esize
water	9:41	0:0	2	,
decl	9:4	9:62	2	int	npal
water	9:47	0:0	2	,
decl	9:4	9:62	2	int	pos_after_pal
decl	10:4	10:37	2	int	i
water	10:9	0:0	2	,
decl	10:4	10:37	2	int	x
water	10:12	0:0	2	,
decl	10:4	10:37	2	int	y
water	10:15	0:0	2	,
decl	10:4	10:37	2	int	plane
water	10:22	0:0	2	,
decl	10:4	10:37	2	int	tmp
water	10:27	0:0	2	,
decl	10:4	10:37	2	int	ret
water	10:32	0:0	2	,
decl	10:4	10:37	2	int	val
call	12:4	12:52	2	bytestream2_init
arg	12:21	12:26	3	&s->g
op	12:21	0:0	4	&
water	12:22	0:0	4	s
op	12:23	0:0	4	->
water	12:25	0:0	4	g
arg	12:28	12:39	3	avpkt->data
water	12:28	0:0	4	avpkt
op	12:33	0:0	4	->
water	12:35	0:0	4	data
arg	12:41	12:52	3	avpkt->size
water	12:41	0:0	4	avpkt
op	12:46	0:0	4	->
water	12:48	0:0	4	size
water	12:53	0:0	2	;
if	14:4	15:34	2	(bytestream2_get_bytes_left (& s -> g ) < 11)
cond	14:8	14:44	3	bytestream2_get_bytes_left (& s -> g ) < 11
call	14:8	14:40	4	bytestream2_get_bytes_left
arg	14:35	14:40	5	&s->g
op	14:35	0:0	6	&
water	14:36	0:0	6	s
op	14:37	0:0	6	->
water	14:39	0:0	6	g
op	14:42	0:0	4	<
water	14:44	0:0	4	11
stmts	15:8	15:34	3	
return	15:8	15:34	4	AVERROR_INVALIDDATA
water	15:15	0:0	5	AVERROR_INVALIDDATA
if	17:4	18:34	2	(bytestream2_get_le16u (& s -> g ) != 0 x1234)
cond	17:8	17:41	3	bytestream2_get_le16u (& s -> g ) != 0 x1234
call	17:8	17:35	4	bytestream2_get_le16u
arg	17:30	17:35	5	&s->g
op	17:30	0:0	6	&
water	17:31	0:0	6	s
op	17:32	0:0	6	->
water	17:34	0:0	6	g
op	17:37	0:0	4	!=
water	17:40	0:0	4	0
water	17:41	0:0	4	x1234
stmts	18:8	18:34	3	
return	18:8	18:34	4	AVERROR_INVALIDDATA
water	18:15	0:0	5	AVERROR_INVALIDDATA
water	20:4	0:0	2	s
op	20:5	0:0	2	->
water	20:7	0:0	2	width
op	20:19	0:0	2	=
call	20:21	20:48	2	bytestream2_get_le16u
arg	20:43	20:48	3	&s->g
op	20:43	0:0	4	&
water	20:44	0:0	4	s
op	20:45	0:0	4	->
water	20:47	0:0	4	g
water	20:49	0:0	2	;
water	21:4	0:0	2	s
op	21:5	0:0	2	->
water	21:7	0:0	2	height
op	21:19	0:0	2	=
call	21:21	21:48	2	bytestream2_get_le16u
arg	21:43	21:48	3	&s->g
op	21:43	0:0	4	&
water	21:44	0:0	4	s
op	21:45	0:0	4	->
water	21:47	0:0	4	g
water	21:49	0:0	2	;
call	22:4	22:29	2	bytestream2_skip
arg	22:21	22:26	3	&s->g
op	22:21	0:0	4	&
water	22:22	0:0	4	s
op	22:23	0:0	4	->
water	22:25	0:0	4	g
arg	22:28	22:29	3	4
water	22:28	0:0	4	4
water	22:30	0:0	2	;
water	23:4	0:0	2	tmp
op	23:19	0:0	2	=
call	23:21	23:48	2	bytestream2_get_byteu
arg	23:43	23:48	3	&s->g
op	23:43	0:0	4	&
water	23:44	0:0	4	s
op	23:45	0:0	4	->
water	23:47	0:0	4	g
water	23:49	0:0	2	;
water	24:4	0:0	2	bits_per_plane
op	24:19	0:0	2	=
water	24:21	0:0	2	tmp
op	24:25	0:0	2	&
water	24:27	0:0	2	0
water	24:28	0:0	2	xF
water	24:30	0:0	2	;
water	25:4	0:0	2	s
op	25:5	0:0	2	->
water	25:7	0:0	2	nb_planes
op	25:19	0:0	2	=
water	25:21	0:0	2	(
water	25:22	0:0	2	tmp
op	25:26	0:0	2	>>
water	25:29	0:0	2	4
water	25:30	0:0	2	)
op	25:32	0:0	2	+
water	25:34	0:0	2	1
water	25:35	0:0	2	;
water	26:4	0:0	2	bpp
op	26:19	0:0	2	=
water	26:21	0:0	2	bits_per_plane
op	26:36	0:0	2	*
water	26:38	0:0	2	s
op	26:39	0:0	2	->
water	26:41	0:0	2	nb_planes
water	26:50	0:0	2	;
if	27:4	30:4	2	(bits_per_plane > 8 || bpp < 1 || bpp > 32)
cond	27:8	27:47	3	bits_per_plane > 8 || bpp < 1 || bpp > 32
water	27:8	0:0	4	bits_per_plane
op	27:23	0:0	4	>
water	27:25	0:0	4	8
op	27:27	0:0	4	||
water	27:30	0:0	4	bpp
op	27:34	0:0	4	<
water	27:36	0:0	4	1
op	27:38	0:0	4	||
water	27:41	0:0	4	bpp
op	27:45	0:0	4	>
water	27:47	0:0	4	32
stmts	27:51	30:4	3	
water	27:51	0:0	4	{
call	28:8	28:60	4	avpriv_request_sample
arg	28:30	28:35	5	avctx
water	28:30	0:0	6	avctx
arg	28:37	28:60	5	"Unsupported bit depth"
water	28:37	0:0	6	"Unsupported bit depth"
water	28:61	0:0	4	;
return	29:8	29:35	4	AVERROR_PATCHWELCOME
water	29:15	0:0	5	AVERROR_PATCHWELCOME
water	30:4	0:0	4	}
if	32:4	38:4	2	(bytestream2_peek_byte (& s -> g ) == 0 xFF || bpp == 1 || bpp == 4 || bpp == 8)
cond	32:8	32:79	3	bytestream2_peek_byte (& s -> g ) == 0 xFF || bpp == 1 || bpp == 4 || bpp == 8
call	32:8	32:35	4	bytestream2_peek_byte
arg	32:30	32:35	5	&s->g
op	32:30	0:0	6	&
water	32:31	0:0	6	s
op	32:32	0:0	6	->
water	32:34	0:0	6	g
op	32:37	0:0	4	==
water	32:40	0:0	4	0
water	32:41	0:0	4	xFF
op	32:45	0:0	4	||
water	32:48	0:0	4	bpp
op	32:52	0:0	4	==
water	32:55	0:0	4	1
op	32:57	0:0	4	||
water	32:60	0:0	4	bpp
op	32:64	0:0	4	==
water	32:67	0:0	4	4
op	32:69	0:0	4	||
water	32:72	0:0	4	bpp
op	32:76	0:0	4	==
water	32:79	0:0	4	8
stmts	32:82	38:4	3	
water	32:82	0:0	4	{
call	33:8	33:33	4	bytestream2_skip
arg	33:25	33:30	5	&s->g
op	33:25	0:0	6	&
water	33:26	0:0	6	s
op	33:27	0:0	6	->
water	33:29	0:0	6	g
arg	33:32	33:33	5	2
water	33:32	0:0	6	2
water	33:34	0:0	4	;
water	34:8	0:0	4	etype
op	34:14	0:0	4	=
call	34:16	34:42	4	bytestream2_get_le16
arg	34:37	34:42	5	&s->g
op	34:37	0:0	6	&
water	34:38	0:0	6	s
op	34:39	0:0	6	->
water	34:41	0:0	6	g
water	34:43	0:0	4	;
water	35:8	0:0	4	esize
op	35:14	0:0	4	=
call	35:16	35:42	4	bytestream2_get_le16
arg	35:37	35:42	5	&s->g
op	35:37	0:0	6	&
water	35:38	0:0	6	s
op	35:39	0:0	6	->
water	35:41	0:0	6	g
water	35:43	0:0	4	;
if	36:8	37:38	4	(bytestream2_get_bytes_left (& s -> g ) < esize)
cond	36:12	36:48	5	bytestream2_get_bytes_left (& s -> g ) < esize
call	36:12	36:44	6	bytestream2_get_bytes_left
arg	36:39	36:44	7	&s->g
op	36:39	0:0	8	&
water	36:40	0:0	8	s
op	36:41	0:0	8	->
water	36:43	0:0	8	g
op	36:46	0:0	6	<
water	36:48	0:0	6	esize
stmts	37:12	37:38	5	
return	37:12	37:38	6	AVERROR_INVALIDDATA
water	37:19	0:0	7	AVERROR_INVALIDDATA
water	38:4	0:0	4	}
else	38:6	41:4	2
stmts	38:11	41:4	3	
water	38:11	0:0	4	{
water	39:8	0:0	4	etype
op	39:14	0:0	4	=
op	39:16	0:0	4	-
water	39:17	0:0	4	1
water	39:18	0:0	4	;
water	40:8	0:0	4	esize
op	40:14	0:0	4	=
water	40:16	0:0	4	0
water	40:17	0:0	4	;
water	41:4	0:0	4	}
water	43:4	0:0	2	avctx
op	43:9	0:0	2	->
water	43:11	0:0	2	pix_fmt
op	43:19	0:0	2	=
water	43:21	0:0	2	AV_PIX_FMT_PAL8
water	43:36	0:0	2	;
if	45:4	46:17	2	(av_image_check_size (s -> width ,s -> height ,0 ,avctx ) < 0)
cond	45:8	45:61	3	av_image_check_size (s -> width ,s -> height ,0 ,avctx ) < 0
call	45:8	45:57	4	av_image_check_size
arg	45:28	45:36	5	s->width
water	45:28	0:0	6	s
op	45:29	0:0	6	->
water	45:31	0:0	6	width
arg	45:38	45:47	5	s->height
water	45:38	0:0	6	s
op	45:39	0:0	6	->
water	45:41	0:0	6	height
arg	45:49	45:50	5	0
water	45:49	0:0	6	0
arg	45:52	45:57	5	avctx
water	45:52	0:0	6	avctx
op	45:59	0:0	4	<
water	45:61	0:0	4	0
stmts	46:8	46:17	3	
return	46:8	46:17	4	-1
op	46:15	0:0	5	-
water	46:16	0:0	5	1
if	47:4	51:4	2	(s -> width != avctx -> width && s -> height != avctx -> height)
cond	47:8	47:56	3	s -> width != avctx -> width && s -> height != avctx -> height
water	47:8	0:0	4	s
op	47:9	0:0	4	->
water	47:11	0:0	4	width
op	47:17	0:0	4	!=
water	47:20	0:0	4	avctx
op	47:25	0:0	4	->
water	47:27	0:0	4	width
op	47:33	0:0	4	&&
water	47:36	0:0	4	s
op	47:37	0:0	4	->
water	47:39	0:0	4	height
op	47:46	0:0	4	!=
water	47:49	0:0	4	avctx
op	47:54	0:0	4	->
water	47:56	0:0	4	height
stmts	47:64	51:4	3	
water	47:64	0:0	4	{
water	48:8	0:0	4	ret
op	48:12	0:0	4	=
call	48:14	48:58	4	ff_set_dimensions
arg	48:32	48:37	5	avctx
water	48:32	0:0	6	avctx
arg	48:39	48:47	5	s->width
water	48:39	0:0	6	s
op	48:40	0:0	6	->
water	48:42	0:0	6	width
arg	48:49	48:58	5	s->height
water	48:49	0:0	6	s
op	48:50	0:0	6	->
water	48:52	0:0	6	height
water	48:59	0:0	4	;
if	49:8	50:22	4	(ret < 0)
cond	49:12	49:18	5	ret < 0
water	49:12	0:0	6	ret
op	49:16	0:0	6	<
water	49:18	0:0	6	0
stmts	50:12	50:22	5	
return	50:12	50:22	6	ret
water	50:19	0:0	7	ret
water	51:4	0:0	4	}
if	53:4	54:18	2	(( ret =ff_get_buffer (avctx ,frame ,0 ) ) < 0)
cond	53:8	53:49	3	( ret =ff_get_buffer (avctx ,frame ,0 ) ) < 0
water	53:8	0:0	4	(
water	53:9	0:0	4	ret
op	53:13	0:0	4	=
call	53:15	53:44	4	ff_get_buffer
arg	53:29	53:34	5	avctx
water	53:29	0:0	6	avctx
arg	53:36	53:41	5	frame
water	53:36	0:0	6	frame
arg	53:43	53:44	5	0
water	53:43	0:0	6	0
water	53:45	0:0	4	)
op	53:47	0:0	4	<
water	53:49	0:0	4	0
stmts	54:8	54:18	3	
return	54:8	54:18	4	ret
water	54:15	0:0	5	ret
call	55:4	55:60	2	memset
arg	55:11	55:25	3	frame->data[0]
water	55:11	0:0	4	frame
op	55:16	0:0	4	->
water	55:18	0:0	4	data
op	55:22	0:0	4	[
water	55:23	0:0	4	0
op	55:24	0:0	4	]
arg	55:27	55:28	3	0
water	55:27	0:0	4	0
arg	55:30	55:60	3	s->height*frame->linesize[0]
water	55:30	0:0	4	s
op	55:31	0:0	4	->
water	55:33	0:0	4	height
op	55:40	0:0	4	*
water	55:42	0:0	4	frame
op	55:47	0:0	4	->
water	55:49	0:0	4	linesize
op	55:57	0:0	4	[
water	55:58	0:0	4	0
op	55:59	0:0	4	]
water	55:61	0:0	2	;
water	56:4	0:0	2	frame
op	56:9	0:0	2	->
water	56:11	0:0	2	pict_type
op	56:31	0:0	2	=
water	56:33	0:0	2	AV_PICTURE_TYPE_I
water	56:50	0:0	2	;
water	57:4	0:0	2	frame
op	57:9	0:0	2	->
water	57:11	0:0	2	palette_has_changed
op	57:31	0:0	2	=
water	57:33	0:0	2	1
water	57:34	0:0	2	;
water	59:4	0:0	2	pos_after_pal
op	59:18	0:0	2	=
call	59:20	59:42	2	bytestream2_tell
arg	59:37	59:42	3	&s->g
op	59:37	0:0	4	&
water	59:38	0:0	4	s
op	59:39	0:0	4	->
water	59:41	0:0	4	g
op	59:44	0:0	2	+
water	59:46	0:0	2	esize
water	59:51	0:0	2	;
water	60:4	0:0	2	palette
op	60:12	0:0	2	=
water	60:14	0:0	2	(
water	60:15	0:0	2	uint32_t
op	60:23	0:0	2	*
water	60:24	0:0	2	)
water	60:25	0:0	2	frame
op	60:30	0:0	2	->
water	60:32	0:0	2	data
op	60:36	0:0	2	[
water	60:37	0:0	2	1
op	60:38	0:0	2	]
water	60:39	0:0	2	;
if	61:4	66:4	2	(etype == 1 && esize > 1 &&bytestream2_peek_byte (& s -> g ) < 6)
cond	61:8	61:66	3	etype == 1 && esize > 1 &&bytestream2_peek_byte (& s -> g ) < 6
water	61:8	0:0	4	etype
op	61:14	0:0	4	==
water	61:17	0:0	4	1
op	61:19	0:0	4	&&
water	61:22	0:0	4	esize
op	61:28	0:0	4	>
water	61:30	0:0	4	1
op	61:32	0:0	4	&&
call	61:35	61:62	4	bytestream2_peek_byte
arg	61:57	61:62	5	&s->g
op	61:57	0:0	6	&
water	61:58	0:0	6	s
op	61:59	0:0	6	->
water	61:61	0:0	6	g
op	61:64	0:0	4	<
water	61:66	0:0	4	6
stmts	61:69	66:4	3	
water	61:69	0:0	4	{
decl	62:8	62:45	4	int	idx
op	62:16	0:0	4	=
call	62:18	62:44	5	bytestream2_get_byte
arg	62:39	62:44	6	&s->g
op	62:39	0:0	7	&
water	62:40	0:0	7	s
op	62:41	0:0	7	->
water	62:43	0:0	7	g
water	63:8	0:0	4	npal
op	63:13	0:0	4	=
water	63:15	0:0	4	4
water	63:16	0:0	4	;
for	64:8	65:67	4	(i = 0 ;i < npal;i ++)
forinit	64:13	64:18	5	i = 0 ;
water	64:13	0:0	6	i
op	64:15	0:0	6	=
water	64:17	0:0	6	0
water	64:18	0:0	6	;
cond	64:20	64:24	5	i < npal
water	64:20	0:0	6	i
op	64:22	0:0	6	<
water	64:24	0:0	6	npal
forexpr	64:30	64:31	5	i ++
water	64:30	0:0	6	i
op	64:31	0:0	6	++
stmts	65:12	65:67	5	
water	65:12	0:0	6	palette
op	65:19	0:0	6	[
water	65:20	0:0	6	i
op	65:21	0:0	6	]
op	65:23	0:0	6	=
water	65:25	0:0	6	ff_cga_palette
op	65:39	0:0	6	[
water	65:41	0:0	6	cga_mode45_index
op	65:57	0:0	6	[
water	65:58	0:0	6	idx
op	65:61	0:0	6	]
op	65:62	0:0	6	[
water	65:63	0:0	6	i
op	65:64	0:0	6	]
op	65:66	0:0	6	]
water	65:67	0:0	6	;
water	66:4	0:0	4	}
else	66:6	72:4	2
stmts	66:11	72:4	3	
if	66:11	72:4	4	(etype == 2)
cond	66:15	66:24	5	etype == 2
water	66:15	0:0	6	etype
op	66:21	0:0	6	==
water	66:24	0:0	6	2
stmts	66:27	72:4	5	
water	66:27	0:0	6	{
water	67:8	0:0	6	npal
op	67:13	0:0	6	=
call	67:15	67:30	6	FFMIN
arg	67:21	67:26	7	esize
water	67:21	0:0	8	esize
arg	67:28	67:30	7	16
water	67:28	0:0	8	16
water	67:31	0:0	6	;
for	68:8	71:8	6	(i = 0 ;i < npal;i ++)
forinit	68:13	68:18	7	i = 0 ;
water	68:13	0:0	8	i
op	68:15	0:0	8	=
water	68:17	0:0	8	0
water	68:18	0:0	8	;
cond	68:20	68:24	7	i < npal
water	68:20	0:0	8	i
op	68:22	0:0	8	<
water	68:24	0:0	8	npal
forexpr	68:30	68:31	7	i ++
water	68:30	0:0	8	i
op	68:31	0:0	8	++
stmts	68:35	71:8	7	
water	68:35	0:0	8	{
decl	69:12	69:53	8	int	pal_idx
op	69:24	0:0	8	=
call	69:26	69:52	9	bytestream2_get_byte
arg	69:47	69:52	10	&s->g
op	69:47	0:0	11	&
water	69:48	0:0	11	s
op	69:49	0:0	11	->
water	69:51	0:0	11	g
water	70:12	0:0	8	palette
op	70:19	0:0	8	[
water	70:20	0:0	8	i
op	70:21	0:0	8	]
op	70:24	0:0	8	=
water	70:26	0:0	8	ff_cga_palette
op	70:40	0:0	8	[
call	70:41	70:58	8	FFMIN
arg	70:47	70:54	9	pal_idx
water	70:47	0:0	10	pal_idx
arg	70:56	70:58	9	15
water	70:56	0:0	10	15
op	70:59	0:0	8	]
water	70:60	0:0	8	;
water	71:8	0:0	8	}
water	72:4	0:0	6	}
else	72:6	78:4	2
stmts	72:11	78:4	3	
if	72:11	78:4	4	(etype == 3)
cond	72:15	72:24	5	etype == 3
water	72:15	0:0	6	etype
op	72:21	0:0	6	==
water	72:24	0:0	6	3
stmts	72:27	78:4	5	
water	72:27	0:0	6	{
water	73:8	0:0	6	npal
op	73:13	0:0	6	=
call	73:15	73:30	6	FFMIN
arg	73:21	73:26	7	esize
water	73:21	0:0	8	esize
arg	73:28	73:30	7	16
water	73:28	0:0	8	16
water	73:31	0:0	6	;
for	74:8	77:8	6	(i = 0 ;i < npal;i ++)
forinit	74:13	74:18	7	i = 0 ;
water	74:13	0:0	8	i
op	74:15	0:0	8	=
water	74:17	0:0	8	0
water	74:18	0:0	8	;
cond	74:20	74:24	7	i < npal
water	74:20	0:0	8	i
op	74:22	0:0	8	<
water	74:24	0:0	8	npal
forexpr	74:30	74:31	7	i ++
water	74:30	0:0	8	i
op	74:31	0:0	8	++
stmts	74:35	77:8	7	
water	74:35	0:0	8	{
decl	75:12	75:53	8	int	pal_idx
op	75:24	0:0	8	=
call	75:26	75:52	9	bytestream2_get_byte
arg	75:47	75:52	10	&s->g
op	75:47	0:0	11	&
water	75:48	0:0	11	s
op	75:49	0:0	11	->
water	75:51	0:0	11	g
water	76:12	0:0	8	palette
op	76:19	0:0	8	[
water	76:20	0:0	8	i
op	76:21	0:0	8	]
op	76:24	0:0	8	=
water	76:26	0:0	8	ff_ega_palette
op	76:40	0:0	8	[
call	76:41	76:58	8	FFMIN
arg	76:47	76:54	9	pal_idx
water	76:47	0:0	10	pal_idx
arg	76:56	76:58	9	63
water	76:56	0:0	10	63
op	76:59	0:0	8	]
water	76:60	0:0	8	;
water	77:8	0:0	8	}
water	78:4	0:0	6	}
else	78:6	84:4	2
stmts	78:11	84:4	3	
if	78:11	84:4	4	(etype == 4 || etype == 5)
cond	78:15	78:38	5	etype == 4 || etype == 5
water	78:15	0:0	6	etype
op	78:21	0:0	6	==
water	78:24	0:0	6	4
op	78:26	0:0	6	||
water	78:29	0:0	6	etype
op	78:35	0:0	6	==
water	78:38	0:0	6	5
stmts	78:41	84:4	5	
water	78:41	0:0	6	{
water	79:8	0:0	6	npal
op	79:13	0:0	6	=
call	79:15	79:35	6	FFMIN
arg	79:21	79:30	7	esize/3
water	79:21	0:0	8	esize
op	79:27	0:0	8	/
water	79:29	0:0	8	3
arg	79:32	79:35	7	256
water	79:32	0:0	8	256
water	79:36	0:0	6	;
for	80:8	83:8	6	(i = 0 ;i < npal;i ++)
forinit	80:13	80:18	7	i = 0 ;
water	80:13	0:0	8	i
op	80:15	0:0	8	=
water	80:17	0:0	8	0
water	80:18	0:0	8	;
cond	80:20	80:24	7	i < npal
water	80:20	0:0	8	i
op	80:22	0:0	8	<
water	80:24	0:0	8	npal
forexpr	80:30	80:31	7	i ++
water	80:30	0:0	8	i
op	80:31	0:0	8	++
stmts	80:35	83:8	7	
water	80:35	0:0	8	{
water	81:12	0:0	8	palette
op	81:19	0:0	8	[
water	81:20	0:0	8	i
op	81:21	0:0	8	]
op	81:23	0:0	8	=
call	81:25	81:51	8	bytestream2_get_be24
arg	81:46	81:51	9	&s->g
op	81:46	0:0	10	&
water	81:47	0:0	10	s
op	81:48	0:0	10	->
water	81:50	0:0	10	g
op	81:53	0:0	8	<<
water	81:56	0:0	8	2
water	81:57	0:0	8	;
water	82:12	0:0	8	palette
op	82:19	0:0	8	[
water	82:20	0:0	8	i
op	82:21	0:0	8	]
op	82:23	0:0	8	|=
water	82:26	0:0	8	0
water	82:27	0:0	8	xFFU
op	82:32	0:0	8	<<
water	82:35	0:0	8	24
op	82:38	0:0	8	|
water	82:40	0:0	8	palette
op	82:47	0:0	8	[
water	82:48	0:0	8	i
op	82:49	0:0	8	]
op	82:51	0:0	8	>>
water	82:54	0:0	8	6
op	82:56	0:0	8	&
water	82:58	0:0	8	0
water	82:59	0:0	8	x30303
water	82:65	0:0	8	;
water	83:8	0:0	8	}
water	84:4	0:0	6	}
else	84:6	97:4	2
stmts	84:11	97:4	3	
water	84:11	0:0	4	{
if	85:8	89:8	4	(bpp == 1)
cond	85:12	85:19	5	bpp == 1
water	85:12	0:0	6	bpp
op	85:16	0:0	6	==
water	85:19	0:0	6	1
stmts	85:22	89:8	5	
water	85:22	0:0	6	{
water	86:12	0:0	6	npal
op	86:17	0:0	6	=
water	86:19	0:0	6	2
water	86:20	0:0	6	;
water	87:12	0:0	6	palette
op	87:19	0:0	6	[
water	87:20	0:0	6	0
op	87:21	0:0	6	]
op	87:23	0:0	6	=
water	87:25	0:0	6	0
water	87:26	0:0	6	xFF000000
water	87:35	0:0	6	;
water	88:12	0:0	6	palette
op	88:19	0:0	6	[
water	88:20	0:0	6	1
op	88:21	0:0	6	]
op	88:23	0:0	6	=
water	88:25	0:0	6	0
water	88:26	0:0	6	xFFFFFFFF
water	88:35	0:0	6	;
water	89:8	0:0	6	}
else	89:10	93:8	4
stmts	89:15	93:8	5	
if	89:15	93:8	6	(bpp == 2)
cond	89:19	89:26	7	bpp == 2
water	89:19	0:0	8	bpp
op	89:23	0:0	8	==
water	89:26	0:0	8	2
stmts	89:29	93:8	7	
water	89:29	0:0	8	{
water	90:12	0:0	8	npal
op	90:17	0:0	8	=
water	90:19	0:0	8	4
water	90:20	0:0	8	;
for	91:12	92:69	8	(i = 0 ;i < npal;i ++)
forinit	91:17	91:22	9	i = 0 ;
water	91:17	0:0	10	i
op	91:19	0:0	10	=
water	91:21	0:0	10	0
water	91:22	0:0	10	;
cond	91:24	91:28	9	i < npal
water	91:24	0:0	10	i
op	91:26	0:0	10	<
water	91:28	0:0	10	npal
forexpr	91:34	91:35	9	i ++
water	91:34	0:0	10	i
op	91:35	0:0	10	++
stmts	92:16	92:69	9	
water	92:16	0:0	10	palette
op	92:23	0:0	10	[
water	92:24	0:0	10	i
op	92:25	0:0	10	]
op	92:27	0:0	10	=
water	92:29	0:0	10	ff_cga_palette
op	92:43	0:0	10	[
water	92:45	0:0	10	cga_mode45_index
op	92:61	0:0	10	[
water	92:62	0:0	10	0
op	92:63	0:0	10	]
op	92:64	0:0	10	[
water	92:65	0:0	10	i
op	92:66	0:0	10	]
op	92:68	0:0	10	]
water	92:69	0:0	10	;
water	93:8	0:0	8	}
else	93:10	96:8	4
stmts	93:15	96:8	5	
water	93:15	0:0	6	{
water	94:12	0:0	6	npal
op	94:17	0:0	6	=
water	94:19	0:0	6	16
water	94:21	0:0	6	;
call	95:12	95:52	6	memcpy
arg	95:19	95:26	7	palette
water	95:19	0:0	8	palette
arg	95:28	95:42	7	ff_cga_palette
water	95:28	0:0	8	ff_cga_palette
arg	95:44	95:52	7	npal*4
water	95:44	0:0	8	npal
op	95:49	0:0	8	*
water	95:51	0:0	8	4
water	95:53	0:0	6	;
water	96:8	0:0	6	}
water	97:4	0:0	4	}
call	99:4	99:55	2	memset
arg	99:11	99:25	3	palette+npal
water	99:11	0:0	4	palette
op	99:19	0:0	4	+
water	99:21	0:0	4	npal
arg	99:27	99:28	3	0
water	99:27	0:0	4	0
arg	99:30	99:55	3	AVPALETTE_SIZE-npal*4
water	99:30	0:0	4	AVPALETTE_SIZE
op	99:45	0:0	4	-
water	99:47	0:0	4	npal
op	99:52	0:0	4	*
water	99:54	0:0	4	4
water	99:56	0:0	2	;
call	101:4	101:51	2	bytestream2_seek
arg	101:21	101:26	3	&s->g
op	101:21	0:0	4	&
water	101:22	0:0	4	s
op	101:23	0:0	4	->
water	101:25	0:0	4	g
arg	101:28	101:41	3	pos_after_pal
water	101:28	0:0	4	pos_after_pal
arg	101:43	101:51	3	SEEK_SET
water	101:43	0:0	4	SEEK_SET
water	101:52	0:0	2	;
water	103:4	0:0	2	val
op	103:8	0:0	2	=
water	103:10	0:0	2	0
water	103:11	0:0	2	;
water	104:4	0:0	2	y
op	104:6	0:0	2	=
water	104:8	0:0	2	s
op	104:9	0:0	2	->
water	104:11	0:0	2	height
op	104:18	0:0	2	-
water	104:20	0:0	2	1
water	104:21	0:0	2	;
if	105:4	148:4	2	(bytestream2_get_le16 (& s -> g ))
cond	105:8	105:34	3	bytestream2_get_le16 (& s -> g )
call	105:8	105:34	4	bytestream2_get_le16
arg	105:29	105:34	5	&s->g
op	105:29	0:0	6	&
water	105:30	0:0	6	s
op	105:31	0:0	6	->
water	105:33	0:0	6	g
stmts	105:37	148:4	3	
water	105:37	0:0	4	{
water	106:8	0:0	4	x
op	106:10	0:0	4	=
water	106:12	0:0	4	0
water	106:13	0:0	4	;
water	107:8	0:0	4	plane
op	107:14	0:0	4	=
water	107:16	0:0	4	0
water	107:17	0:0	4	;
while	108:8	139:8	4	(bytestream2_get_bytes_left (& s -> g ) >= 6)
cond	108:15	108:52	5	bytestream2_get_bytes_left (& s -> g ) >= 6
call	108:15	108:47	6	bytestream2_get_bytes_left
arg	108:42	108:47	7	&s->g
op	108:42	0:0	8	&
water	108:43	0:0	8	s
op	108:44	0:0	8	->
water	108:46	0:0	8	g
op	108:49	0:0	6	>=
water	108:52	0:0	6	6
stmts	108:55	139:8	5	
water	108:55	0:0	6	{
decl	109:12	109:41	6	int	stop_size
water	109:25	0:0	6	,
decl	109:12	109:41	6	int	marker
water	109:33	0:0	6	,
decl	109:12	109:41	6	int	t1
water	109:37	0:0	6	,
decl	109:12	109:41	6	int	t2
water	111:12	0:0	6	t1
op	111:22	0:0	6	=
call	111:24	111:56	6	bytestream2_get_bytes_left
arg	111:51	111:56	7	&s->g
op	111:51	0:0	8	&
water	111:52	0:0	8	s
op	111:53	0:0	8	->
water	111:55	0:0	8	g
water	111:57	0:0	6	;
water	112:12	0:0	6	t2
op	112:22	0:0	6	=
call	112:24	112:50	6	bytestream2_get_le16
arg	112:45	112:50	7	&s->g
op	112:45	0:0	8	&
water	112:46	0:0	8	s
op	112:47	0:0	8	->
water	112:49	0:0	8	g
water	112:51	0:0	6	;
water	113:12	0:0	6	stop_size
op	113:22	0:0	6	=
water	113:24	0:0	6	t1
op	113:27	0:0	6	-
call	113:29	113:41	6	FFMIN
arg	113:35	113:37	7	t1
water	113:35	0:0	8	t1
arg	113:39	113:41	7	t2
water	113:39	0:0	8	t2
water	113:42	0:0	6	;
call	115:12	115:37	6	bytestream2_skip
arg	115:29	115:34	7	&s->g
op	115:29	0:0	8	&
water	115:30	0:0	8	s
op	115:31	0:0	8	->
water	115:33	0:0	8	g
arg	115:36	115:37	7	2
water	115:36	0:0	8	2
water	115:38	0:0	6	;
water	116:12	0:0	6	marker
op	116:22	0:0	6	=
call	116:24	116:50	6	bytestream2_get_byte
arg	116:45	116:50	7	&s->g
op	116:45	0:0	8	&
water	116:46	0:0	8	s
op	116:47	0:0	8	->
water	116:49	0:0	8	g
water	116:51	0:0	6	;
while	118:12	138:12	6	(plane < s -> nb_planes &&bytestream2_get_bytes_left (& s -> g ) > stop_size)
cond	118:19	119:55	7	plane < s -> nb_planes &&bytestream2_get_bytes_left (& s -> g ) > stop_size
water	118:19	0:0	8	plane
op	118:25	0:0	8	<
water	118:27	0:0	8	s
op	118:28	0:0	8	->
water	118:30	0:0	8	nb_planes
op	118:40	0:0	8	&&
call	119:19	119:51	8	bytestream2_get_bytes_left
arg	119:46	119:51	9	&s->g
op	119:46	0:0	10	&
water	119:47	0:0	10	s
op	119:48	0:0	10	->
water	119:50	0:0	10	g
op	119:53	0:0	8	>
water	119:55	0:0	8	stop_size
stmts	119:66	138:12	7	
water	119:66	0:0	8	{
decl	120:16	120:27	8	int	run
op	120:24	0:0	8	=
water	120:26	0:0	8	1
water	121:16	0:0	8	val
op	121:20	0:0	8	=
call	121:22	121:48	8	bytestream2_get_byte
arg	121:43	121:48	9	&s->g
op	121:43	0:0	10	&
water	121:44	0:0	10	s
op	121:45	0:0	10	->
water	121:47	0:0	10	g
water	121:49	0:0	8	;
if	122:16	127:16	8	(val == marker)
cond	122:20	122:27	9	val == marker
water	122:20	0:0	10	val
op	122:24	0:0	10	==
water	122:27	0:0	10	marker
stmts	122:35	127:16	9	
water	122:35	0:0	10	{
water	123:20	0:0	10	run
op	123:24	0:0	10	=
call	123:26	123:52	10	bytestream2_get_byte
arg	123:47	123:52	11	&s->g
op	123:47	0:0	12	&
water	123:48	0:0	12	s
op	123:49	0:0	12	->
water	123:51	0:0	12	g
water	123:53	0:0	10	;
if	124:20	125:57	10	(run == 0)
cond	124:24	124:31	11	run == 0
water	124:24	0:0	12	run
op	124:28	0:0	12	==
water	124:31	0:0	12	0
stmts	125:24	125:57	11	
water	125:24	0:0	12	run
op	125:28	0:0	12	=
call	125:30	125:56	12	bytestream2_get_le16
arg	125:51	125:56	13	&s->g
op	125:51	0:0	14	&
water	125:52	0:0	14	s
op	125:53	0:0	14	->
water	125:55	0:0	14	g
water	125:57	0:0	12	;
water	126:20	0:0	10	val
op	126:24	0:0	10	=
call	126:26	126:52	10	bytestream2_get_byte
arg	126:47	126:52	11	&s->g
op	126:47	0:0	12	&
water	126:48	0:0	12	s
op	126:49	0:0	12	->
water	126:51	0:0	12	g
water	126:53	0:0	10	;
water	127:16	0:0	10	}
if	128:16	129:25	8	(!bytestream2_get_bytes_left (& s -> g ))
cond	128:20	128:53	9	!bytestream2_get_bytes_left (& s -> g )
op	128:20	0:0	10	!
call	128:21	128:53	10	bytestream2_get_bytes_left
arg	128:48	128:53	11	&s->g
op	128:48	0:0	12	&
water	128:49	0:0	12	s
op	128:50	0:0	12	->
water	128:52	0:0	12	g
stmts	129:20	129:25	9	
break	129:20	129:25	10	
if	131:16	135:16	8	(bits_per_plane == 8)
cond	131:20	131:38	9	bits_per_plane == 8
water	131:20	0:0	10	bits_per_plane
op	131:35	0:0	10	==
water	131:38	0:0	10	8
stmts	131:41	135:16	9	
water	131:41	0:0	10	{
call	132:20	132:61	10	picmemset_8bpp
arg	132:35	132:36	11	s
water	132:35	0:0	12	s
arg	132:38	132:43	11	frame
water	132:38	0:0	12	frame
arg	132:45	132:48	11	val
water	132:45	0:0	12	val
arg	132:50	132:53	11	run
water	132:50	0:0	12	run
arg	132:55	132:57	11	&x
op	132:55	0:0	12	&
water	132:56	0:0	12	x
arg	132:59	132:61	11	&y
op	132:59	0:0	12	&
water	132:60	0:0	12	y
water	132:62	0:0	10	;
if	133:20	134:35	10	(y < 0)
cond	133:24	133:28	11	y < 0
water	133:24	0:0	12	y
op	133:26	0:0	12	<
water	133:28	0:0	12	0
stmts	134:24	134:35	11	
goto	134:24	134:35	12	finish
water	134:29	0:0	13	finish
water	135:16	0:0	10	}
else	135:18	137:16	8
stmts	135:23	137:16	9	
water	135:23	0:0	10	{
call	136:20	136:80	10	picmemset
arg	136:30	136:31	11	s
water	136:30	0:0	12	s
arg	136:33	136:38	11	frame
water	136:33	0:0	12	frame
arg	136:40	136:43	11	val
water	136:40	0:0	12	val
arg	136:45	136:48	11	run
water	136:45	0:0	12	run
arg	136:50	136:52	11	&x
op	136:50	0:0	12	&
water	136:51	0:0	12	x
arg	136:54	136:56	11	&y
op	136:54	0:0	12	&
water	136:55	0:0	12	y
arg	136:58	136:64	11	&plane
op	136:58	0:0	12	&
water	136:59	0:0	12	plane
arg	136:66	136:80	11	bits_per_plane
water	136:66	0:0	12	bits_per_plane
water	136:81	0:0	10	;
water	137:16	0:0	10	}
water	138:12	0:0	8	}
water	139:8	0:0	6	}
if	141:8	147:8	4	(x < avctx -> width)
cond	141:12	141:23	5	x < avctx -> width
water	141:12	0:0	6	x
op	141:14	0:0	6	<
water	141:16	0:0	6	avctx
op	141:21	0:0	6	->
water	141:23	0:0	6	width
stmts	141:30	147:8	5	
water	141:30	0:0	6	{
decl	142:12	142:48	6	int	run
op	142:20	0:0	6	=
water	142:22	0:0	6	(
water	142:23	0:0	6	y
op	142:25	0:0	6	+
water	142:27	0:0	6	1
water	142:28	0:0	6	)
op	142:30	0:0	6	*
water	142:32	0:0	6	avctx
op	142:37	0:0	6	->
water	142:39	0:0	6	width
op	142:45	0:0	6	-
water	142:47	0:0	6	x
if	143:12	144:58	6	(bits_per_plane == 8)
cond	143:16	143:34	7	bits_per_plane == 8
water	143:16	0:0	8	bits_per_plane
op	143:31	0:0	8	==
water	143:34	0:0	8	8
stmts	144:16	144:58	7	
call	144:16	144:57	8	picmemset_8bpp
arg	144:31	144:32	9	s
water	144:31	0:0	10	s
arg	144:34	144:39	9	frame
water	144:34	0:0	10	frame
arg	144:41	144:44	9	val
water	144:41	0:0	10	val
arg	144:46	144:49	9	run
water	144:46	0:0	10	run
arg	144:51	144:53	9	&x
op	144:51	0:0	10	&
water	144:52	0:0	10	x
arg	144:55	144:57	9	&y
op	144:55	0:0	10	&
water	144:56	0:0	10	y
water	144:58	0:0	8	;
else	145:12	146:100	6
stmts	146:16	146:100	7	
call	146:16	146:99	8	picmemset
arg	146:26	146:27	9	s
water	146:26	0:0	10	s
arg	146:29	146:34	9	frame
water	146:29	0:0	10	frame
arg	146:36	146:39	9	val
water	146:36	0:0	10	val
arg	146:41	146:67	9	run/(8/bits_per_plane)
water	146:41	0:0	10	run
op	146:45	0:0	10	/
water	146:47	0:0	10	(
water	146:48	0:0	10	8
op	146:50	0:0	10	/
water	146:52	0:0	10	bits_per_plane
water	146:66	0:0	10	)
arg	146:69	146:71	9	&x
op	146:69	0:0	10	&
water	146:70	0:0	10	x
arg	146:73	146:75	9	&y
op	146:73	0:0	10	&
water	146:74	0:0	10	y
arg	146:77	146:83	9	&plane
op	146:77	0:0	10	&
water	146:78	0:0	10	plane
arg	146:85	146:99	9	bits_per_plane
water	146:85	0:0	10	bits_per_plane
water	146:100	0:0	8	;
water	147:8	0:0	6	}
water	148:4	0:0	4	}
else	148:6	154:4	2
stmts	148:11	154:4	3	
water	148:11	0:0	4	{
while	149:8	153:8	4	(y >= 0 &&bytestream2_get_bytes_left (& s -> g ) > 0)
cond	149:15	149:61	5	y >= 0 &&bytestream2_get_bytes_left (& s -> g ) > 0
water	149:15	0:0	6	y
op	149:17	0:0	6	>=
water	149:20	0:0	6	0
op	149:22	0:0	6	&&
call	149:25	149:57	6	bytestream2_get_bytes_left
arg	149:52	149:57	7	&s->g
op	149:52	0:0	8	&
water	149:53	0:0	8	s
op	149:54	0:0	8	->
water	149:56	0:0	8	g
op	149:59	0:0	6	>
water	149:61	0:0	6	0
stmts	149:64	153:8	5	
water	149:64	0:0	6	{
call	150:12	150:127	6	memcpy
arg	150:19	150:58	7	frame->data[0]+y*frame->linesize[0]
water	150:19	0:0	8	frame
op	150:24	0:0	8	->
water	150:26	0:0	8	data
op	150:30	0:0	8	[
water	150:31	0:0	8	0
op	150:32	0:0	8	]
op	150:34	0:0	8	+
water	150:36	0:0	8	y
op	150:38	0:0	8	*
water	150:40	0:0	8	frame
op	150:45	0:0	8	->
water	150:47	0:0	8	linesize
op	150:55	0:0	8	[
water	150:56	0:0	8	0
op	150:57	0:0	8	]
arg	150:60	150:71	7	s->g.buffer
water	150:60	0:0	8	s
op	150:61	0:0	8	->
water	150:63	0:0	8	g
op	150:64	0:0	8	.
water	150:65	0:0	8	buffer
arg	150:73	150:127	7	FFMIN(avctx->width,bytestream2_get_bytes_left(&s->g))
call	150:73	150:126	8	FFMIN
arg	150:79	150:91	9	avctx->width
water	150:79	0:0	10	avctx
op	150:84	0:0	10	->
water	150:86	0:0	10	width
arg	150:93	150:126	9	bytestream2_get_bytes_left(&s->g)
call	150:93	150:125	10	bytestream2_get_bytes_left
arg	150:120	150:125	11	&s->g
op	150:120	0:0	12	&
water	150:121	0:0	12	s
op	150:122	0:0	12	->
water	150:124	0:0	12	g
water	150:128	0:0	6	;
call	151:12	151:48	6	bytestream2_skip
arg	151:29	151:34	7	&s->g
op	151:29	0:0	8	&
water	151:30	0:0	8	s
op	151:31	0:0	8	->
water	151:33	0:0	8	g
arg	151:36	151:48	7	avctx->width
water	151:36	0:0	8	avctx
op	151:41	0:0	8	->
water	151:43	0:0	8	width
water	151:49	0:0	6	;
water	152:12	0:0	6	y
op	152:13	0:0	6	--
water	152:15	0:0	6	;
water	153:8	0:0	6	}
water	154:4	0:0	4	}
label	155:0	155:6	2	finish :
op	157:4	0:0	2	*
water	157:5	0:0	2	got_frame
op	157:20	0:0	2	=
water	157:22	0:0	2	1
water	157:23	0:0	2	;
return	158:4	158:22	2	avpkt->size
water	158:11	0:0	3	avpkt
op	158:16	0:0	3	->
water	158:18	0:0	3	size
