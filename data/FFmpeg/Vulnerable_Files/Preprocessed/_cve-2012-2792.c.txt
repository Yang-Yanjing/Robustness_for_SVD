func	7:15	100:0	0	int	decode_init
params	7:30	0:0	1	
param	7:31	7:52	2	AVCodecContext *	avctx
stmnts	0:0	99:12	1	
decl	9:4	9:40	2	WmallDecodeCtx	*s
op	9:22	0:0	2	=
water	9:24	0:0	2	avctx
op	9:29	0:0	2	->
water	9:31	0:0	2	priv_data
decl	10:4	10:41	2	uint8_t	*edata_ptr
op	10:23	0:0	2	=
water	10:25	0:0	2	avctx
op	10:30	0:0	2	->
water	10:32	0:0	2	extradata
decl	11:4	11:29	2	unsigned int	channel_mask
decl	12:4	12:9	2	int	i
decl	13:4	13:30	2	int	log2_max_num_subframes
decl	14:4	14:32	2	int	num_possible_block_sizes
water	16:4	0:0	2	s
op	16:5	0:0	2	->
water	16:7	0:0	2	avctx
op	16:13	0:0	2	=
water	16:15	0:0	2	avctx
water	16:20	0:0	2	;
call	17:4	17:31	2	dsputil_init
arg	17:17	17:24	3	&s->dsp
op	17:17	0:0	4	&
water	17:18	0:0	4	s
op	17:19	0:0	4	->
water	17:21	0:0	4	dsp
arg	17:26	17:31	3	avctx
water	17:26	0:0	4	avctx
water	17:32	0:0	2	;
call	18:4	18:54	2	init_put_bits
arg	18:18	18:24	3	&s->pb
op	18:18	0:0	4	&
water	18:19	0:0	4	s
op	18:20	0:0	4	->
water	18:22	0:0	4	pb
arg	18:26	18:39	3	s->frame_data
water	18:26	0:0	4	s
op	18:27	0:0	4	->
water	18:29	0:0	4	frame_data
arg	18:41	18:54	3	MAX_FRAMESIZE
water	18:41	0:0	4	MAX_FRAMESIZE
water	18:55	0:0	2	;
if	20:4	38:4	2	(avctx -> extradata_size >= 18)
cond	20:8	20:33	3	avctx -> extradata_size >= 18
water	20:8	0:0	4	avctx
op	20:13	0:0	4	->
water	20:15	0:0	4	extradata_size
op	20:30	0:0	4	>=
water	20:33	0:0	4	18
stmts	20:37	38:4	3	
water	20:37	0:0	4	{
water	21:8	0:0	4	s
op	21:9	0:0	4	->
water	21:11	0:0	4	decode_flags
op	21:27	0:0	4	=
call	21:29	21:49	4	AV_RL16
arg	21:37	21:49	5	edata_ptr+14
water	21:37	0:0	6	edata_ptr
op	21:46	0:0	6	+
water	21:47	0:0	6	14
water	21:50	0:0	4	;
water	22:8	0:0	4	channel_mask
op	22:27	0:0	4	=
call	22:29	22:48	4	AV_RL32
arg	22:37	22:48	5	edata_ptr+2
water	22:37	0:0	6	edata_ptr
op	22:46	0:0	6	+
water	22:47	0:0	6	2
water	22:49	0:0	4	;
water	23:8	0:0	4	s
op	23:9	0:0	4	->
water	23:11	0:0	4	bits_per_sample
op	23:27	0:0	4	=
call	23:29	23:46	4	AV_RL16
arg	23:37	23:46	5	edata_ptr
water	23:37	0:0	6	edata_ptr
water	23:47	0:0	4	;
if	24:8	25:49	4	(s -> bits_per_sample == 16)
cond	24:12	24:34	5	s -> bits_per_sample == 16
water	24:12	0:0	6	s
op	24:13	0:0	6	->
water	24:15	0:0	6	bits_per_sample
op	24:31	0:0	6	==
water	24:34	0:0	6	16
stmts	25:12	25:49	5	
water	25:12	0:0	6	avctx
op	25:17	0:0	6	->
water	25:19	0:0	6	sample_fmt
op	25:30	0:0	6	=
water	25:32	0:0	6	AV_SAMPLE_FMT_S16
water	25:49	0:0	6	;
else	26:8	27:49	4
stmts	26:13	27:49	5	
if	26:13	27:49	6	(s -> bits_per_sample == 24)
cond	26:17	26:39	7	s -> bits_per_sample == 24
water	26:17	0:0	8	s
op	26:18	0:0	8	->
water	26:20	0:0	8	bits_per_sample
op	26:36	0:0	8	==
water	26:39	0:0	8	24
stmts	27:12	27:49	7	
water	27:12	0:0	8	avctx
op	27:17	0:0	8	->
water	27:19	0:0	8	sample_fmt
op	27:30	0:0	8	=
water	27:32	0:0	8	AV_SAMPLE_FMT_S32
water	27:49	0:0	8	;
else	28:8	32:8	4
stmts	28:13	32:8	5	
water	28:13	0:0	6	{
call	29:12	30:37	6	av_log
arg	29:19	29:24	7	avctx
water	29:19	0:0	8	avctx
arg	29:26	29:38	7	AV_LOG_ERROR
water	29:26	0:0	8	AV_LOG_ERROR
arg	29:40	29:65	7	"Unknown bit-depth: %d\n"
water	29:40	0:0	8	"Unknown bit-depth: %d\n"
arg	30:19	30:37	7	s->bits_per_sample
water	30:19	0:0	8	s
op	30:20	0:0	8	->
water	30:22	0:0	8	bits_per_sample
water	30:38	0:0	6	;
return	31:12	31:38	6	AVERROR_INVALIDDATA
water	31:19	0:0	7	AVERROR_INVALIDDATA
water	32:8	0:0	6	}
for	34:8	35:56	4	(i = 0 ;i < avctx -> extradata_size;i ++)
forinit	34:13	34:18	5	i = 0 ;
water	34:13	0:0	6	i
op	34:15	0:0	6	=
water	34:17	0:0	6	0
water	34:18	0:0	6	;
cond	34:20	34:31	5	i < avctx -> extradata_size
water	34:20	0:0	6	i
op	34:22	0:0	6	<
water	34:24	0:0	6	avctx
op	34:29	0:0	6	->
water	34:31	0:0	6	extradata_size
forexpr	34:47	34:48	5	i ++
water	34:47	0:0	6	i
op	34:48	0:0	6	++
stmts	35:12	35:56	5	
call	35:12	35:55	6	dprintf
arg	35:20	35:25	7	avctx
water	35:20	0:0	8	avctx
arg	35:27	35:34	7	"[%x] "
water	35:27	0:0	8	"[%x] "
arg	35:36	35:55	7	avctx->extradata[i]
water	35:36	0:0	8	avctx
op	35:41	0:0	8	->
water	35:43	0:0	8	extradata
op	35:52	0:0	8	[
water	35:53	0:0	8	i
op	35:54	0:0	8	]
water	35:56	0:0	6	;
call	36:8	36:27	4	dprintf
arg	36:16	36:21	5	avctx
water	36:16	0:0	6	avctx
arg	36:23	36:27	5	"\n"
water	36:23	0:0	6	"\n"
water	36:28	0:0	4	;
water	38:4	0:0	4	}
else	38:6	41:4	2
stmts	38:11	41:4	3	
water	38:11	0:0	4	{
call	39:8	39:63	4	av_log_ask_for_sample
arg	39:30	39:35	5	avctx
water	39:30	0:0	6	avctx
arg	39:37	39:63	5	"Unknown extradata size\n"
water	39:37	0:0	6	"Unknown extradata size\n"
water	39:64	0:0	4	;
return	40:8	40:34	4	AVERROR_INVALIDDATA
water	40:15	0:0	5	AVERROR_INVALIDDATA
water	41:4	0:0	4	}
water	44:4	0:0	2	s
op	44:5	0:0	2	->
water	44:7	0:0	2	log2_frame_size
op	44:23	0:0	2	=
call	44:25	44:51	2	av_log2
arg	44:33	44:51	3	avctx->block_align
water	44:33	0:0	4	avctx
op	44:38	0:0	4	->
water	44:40	0:0	4	block_align
op	44:53	0:0	2	+
water	44:55	0:0	2	4
water	44:56	0:0	2	;
water	47:4	0:0	2	s
op	47:5	0:0	2	->
water	47:7	0:0	2	skip_frame
op	47:19	0:0	2	=
water	47:21	0:0	2	1
water	47:22	0:0	2	;
water	48:4	0:0	2	s
op	48:5	0:0	2	->
water	48:7	0:0	2	packet_loss
op	48:19	0:0	2	=
water	48:21	0:0	2	1
water	48:22	0:0	2	;
water	49:4	0:0	2	s
op	49:5	0:0	2	->
water	49:7	0:0	2	len_prefix
op	49:19	0:0	2	=
water	49:21	0:0	2	(
water	49:22	0:0	2	s
op	49:23	0:0	2	->
water	49:25	0:0	2	decode_flags
op	49:38	0:0	2	&
water	49:40	0:0	2	0
water	49:41	0:0	2	x40
water	49:44	0:0	2	)
water	49:45	0:0	2	;
water	52:4	0:0	2	s
op	52:5	0:0	2	->
water	52:7	0:0	2	samples_per_frame
op	52:25	0:0	2	=
water	52:27	0:0	2	1
op	52:29	0:0	2	<<
call	52:32	53:76	2	ff_wma_get_frame_len_bits
arg	52:58	52:76	3	avctx->sample_rate
water	52:58	0:0	4	avctx
op	52:63	0:0	4	->
water	52:65	0:0	4	sample_rate
arg	53:58	53:59	3	3
water	53:58	0:0	4	3
arg	53:61	53:76	3	s->decode_flags
water	53:61	0:0	4	s
op	53:62	0:0	4	->
water	53:64	0:0	4	decode_flags
water	53:77	0:0	2	;
for	56:4	57:59	2	(i = 0 ;i < avctx -> channels;i ++)
forinit	56:9	56:14	3	i = 0 ;
water	56:9	0:0	4	i
op	56:11	0:0	4	=
water	56:13	0:0	4	0
water	56:14	0:0	4	;
cond	56:16	56:27	3	i < avctx -> channels
water	56:16	0:0	4	i
op	56:18	0:0	4	<
water	56:20	0:0	4	avctx
op	56:25	0:0	4	->
water	56:27	0:0	4	channels
forexpr	56:37	56:38	3	i ++
water	56:37	0:0	4	i
op	56:38	0:0	4	++
stmts	57:8	57:59	3	
water	57:8	0:0	4	s
op	57:9	0:0	4	->
water	57:11	0:0	4	channel
op	57:18	0:0	4	[
water	57:19	0:0	4	i
op	57:20	0:0	4	]
op	57:21	0:0	4	.
water	57:22	0:0	4	prev_block_len
op	57:37	0:0	4	=
water	57:39	0:0	4	s
op	57:40	0:0	4	->
water	57:42	0:0	4	samples_per_frame
water	57:59	0:0	4	;
water	60:4	0:0	2	log2_max_num_subframes
op	60:28	0:0	2	=
water	60:30	0:0	2	(
water	60:31	0:0	2	(
water	60:32	0:0	2	s
op	60:33	0:0	2	->
water	60:35	0:0	2	decode_flags
op	60:48	0:0	2	&
water	60:50	0:0	2	0
water	60:51	0:0	2	x38
water	60:54	0:0	2	)
op	60:56	0:0	2	>>
water	60:59	0:0	2	3
water	60:60	0:0	2	)
water	60:61	0:0	2	;
water	61:4	0:0	2	s
op	61:5	0:0	2	->
water	61:7	0:0	2	max_num_subframes
op	61:28	0:0	2	=
water	61:30	0:0	2	1
op	61:32	0:0	2	<<
water	61:35	0:0	2	log2_max_num_subframes
water	61:57	0:0	2	;
water	62:4	0:0	2	s
op	62:5	0:0	2	->
water	62:7	0:0	2	max_subframe_len_bit
op	62:28	0:0	2	=
water	62:30	0:0	2	0
water	62:31	0:0	2	;
water	63:4	0:0	2	s
op	63:5	0:0	2	->
water	63:7	0:0	2	subframe_len_bits
op	63:28	0:0	2	=
call	63:30	63:60	2	av_log2
arg	63:38	63:60	3	log2_max_num_subframes
water	63:38	0:0	4	log2_max_num_subframes
op	63:62	0:0	2	+
water	63:64	0:0	2	1
water	63:65	0:0	2	;
water	65:4	0:0	2	num_possible_block_sizes
op	65:33	0:0	2	=
water	65:35	0:0	2	log2_max_num_subframes
op	65:58	0:0	2	+
water	65:60	0:0	2	1
water	65:61	0:0	2	;
water	66:4	0:0	2	s
op	66:5	0:0	2	->
water	66:7	0:0	2	min_samples_per_subframe
op	66:33	0:0	2	=
water	66:35	0:0	2	s
op	66:36	0:0	2	->
water	66:38	0:0	2	samples_per_frame
op	66:56	0:0	2	/
water	66:58	0:0	2	s
op	66:59	0:0	2	->
water	66:61	0:0	2	max_num_subframes
water	66:78	0:0	2	;
water	67:4	0:0	2	s
op	67:5	0:0	2	->
water	67:7	0:0	2	dynamic_range_compression
op	67:33	0:0	2	=
water	67:35	0:0	2	(
water	67:36	0:0	2	s
op	67:37	0:0	2	->
water	67:39	0:0	2	decode_flags
op	67:52	0:0	2	&
water	67:54	0:0	2	0
water	67:55	0:0	2	x80
water	67:58	0:0	2	)
water	67:59	0:0	2	;
water	69:4	0:0	2	s
op	69:5	0:0	2	->
water	69:7	0:0	2	bV3RTM
op	69:14	0:0	2	=
water	69:16	0:0	2	s
op	69:17	0:0	2	->
water	69:19	0:0	2	decode_flags
op	69:32	0:0	2	&
water	69:34	0:0	2	0
water	69:35	0:0	2	x100
water	69:39	0:0	2	;
if	71:4	75:4	2	(s -> max_num_subframes > MAX_SUBFRAMES)
cond	71:8	71:31	3	s -> max_num_subframes > MAX_SUBFRAMES
water	71:8	0:0	4	s
op	71:9	0:0	4	->
water	71:11	0:0	4	max_num_subframes
op	71:29	0:0	4	>
water	71:31	0:0	4	MAX_SUBFRAMES
stmts	71:46	75:4	3	
water	71:46	0:0	4	{
call	72:8	73:35	4	av_log
arg	72:15	72:20	5	avctx
water	72:15	0:0	6	avctx
arg	72:22	72:34	5	AV_LOG_ERROR
water	72:22	0:0	6	AV_LOG_ERROR
arg	72:36	72:70	5	"invalid number of subframes %i\n"
water	72:36	0:0	6	"invalid number of subframes %i\n"
arg	73:15	73:35	5	s->max_num_subframes
water	73:15	0:0	6	s
op	73:16	0:0	6	->
water	73:18	0:0	6	max_num_subframes
water	73:36	0:0	4	;
return	74:8	74:34	4	AVERROR_INVALIDDATA
water	74:15	0:0	5	AVERROR_INVALIDDATA
water	75:4	0:0	4	}
water	77:4	0:0	2	s
op	77:5	0:0	2	->
water	77:7	0:0	2	num_channels
op	77:20	0:0	2	=
water	77:22	0:0	2	avctx
op	77:27	0:0	2	->
water	77:29	0:0	2	channels
water	77:37	0:0	2	;
water	80:4	0:0	2	s
op	80:5	0:0	2	->
water	80:7	0:0	2	lfe_channel
op	80:19	0:0	2	=
op	80:21	0:0	2	-
water	80:22	0:0	2	1
water	80:23	0:0	2	;
if	82:4	88:4	2	(channel_mask & 8)
cond	82:8	82:23	3	channel_mask & 8
water	82:8	0:0	4	channel_mask
op	82:21	0:0	4	&
water	82:23	0:0	4	8
stmts	82:26	88:4	3	
water	82:26	0:0	4	{
decl	83:8	83:25	4	unsigned int	mask
for	84:8	87:8	4	(mask = 1 ;mask < 16;mask <<= 1)
forinit	84:13	84:21	5	mask = 1 ;
water	84:13	0:0	6	mask
op	84:18	0:0	6	=
water	84:20	0:0	6	1
water	84:21	0:0	6	;
cond	84:23	84:30	5	mask < 16
water	84:23	0:0	6	mask
op	84:28	0:0	6	<
water	84:30	0:0	6	16
forexpr	84:34	84:43	5	mask <<= 1
water	84:34	0:0	6	mask
op	84:39	0:0	6	<<=
water	84:43	0:0	6	1
stmts	84:46	87:8	5	
water	84:46	0:0	6	{
if	85:12	86:32	6	(channel_mask & mask)
cond	85:16	85:31	7	channel_mask & mask
water	85:16	0:0	8	channel_mask
op	85:29	0:0	8	&
water	85:31	0:0	8	mask
stmts	86:16	86:32	7	
op	86:16	0:0	8	++
water	86:18	0:0	8	s
op	86:19	0:0	8	->
water	86:21	0:0	8	lfe_channel
water	86:32	0:0	8	;
water	87:8	0:0	6	}
water	88:4	0:0	4	}
if	90:4	93:4	2	(s -> num_channels < 0)
cond	90:8	90:26	3	s -> num_channels < 0
water	90:8	0:0	4	s
op	90:9	0:0	4	->
water	90:11	0:0	4	num_channels
op	90:24	0:0	4	<
water	90:26	0:0	4	0
stmts	90:29	93:4	3	
water	90:29	0:0	4	{
call	91:8	91:86	4	av_log
arg	91:15	91:20	5	avctx
water	91:15	0:0	6	avctx
arg	91:22	91:34	5	AV_LOG_ERROR
water	91:22	0:0	6	AV_LOG_ERROR
arg	91:36	91:69	5	"invalid number of channels %d\n"
water	91:36	0:0	6	"invalid number of channels %d\n"
arg	91:71	91:86	5	s->num_channels
water	91:71	0:0	6	s
op	91:72	0:0	6	->
water	91:74	0:0	6	num_channels
water	91:87	0:0	4	;
return	92:8	92:34	4	AVERROR_INVALIDDATA
water	92:15	0:0	5	AVERROR_INVALIDDATA
water	93:4	0:0	4	}
else	93:6	96:4	2
stmts	93:11	96:4	3	
if	93:11	96:4	4	(s -> num_channels > WMALL_MAX_CHANNELS)
cond	93:15	93:33	5	s -> num_channels > WMALL_MAX_CHANNELS
water	93:15	0:0	6	s
op	93:16	0:0	6	->
water	93:18	0:0	6	num_channels
op	93:31	0:0	6	>
water	93:33	0:0	6	WMALL_MAX_CHANNELS
stmts	93:53	96:4	5	
water	93:53	0:0	6	{
call	94:8	94:71	6	av_log_ask_for_sample
arg	94:30	94:35	7	avctx
water	94:30	0:0	8	avctx
arg	94:37	94:71	7	"unsupported number of channels\n"
water	94:37	0:0	8	"unsupported number of channels\n"
water	94:72	0:0	6	;
return	95:8	95:35	6	AVERROR_PATCHWELCOME
water	95:15	0:0	7	AVERROR_PATCHWELCOME
water	96:4	0:0	6	}
water	98:4	0:0	2	avctx
op	98:9	0:0	2	->
water	98:11	0:0	2	channel_layout
op	98:26	0:0	2	=
water	98:28	0:0	2	channel_mask
water	98:40	0:0	2	;
return	99:4	99:12	2	0
water	99:11	0:0	3	0
