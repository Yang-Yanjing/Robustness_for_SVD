func	1:0	271:0	0	static void	mov_build_index
params	1:27	0:0	1	
param	1:28	1:43	2	MOVContext *	mov
param	1:45	1:57	2	AVStream *	st
stmnts	0:0	270:4	1	
decl	3:4	3:40	2	MOVStreamContext	*sc
op	3:25	0:0	2	=
water	3:27	0:0	2	st
op	3:29	0:0	2	->
water	3:31	0:0	2	priv_data
decl	4:4	4:26	2	int64_t	current_offset
decl	5:4	5:27	2	int64_t	current_dts
op	5:24	0:0	2	=
water	5:26	0:0	2	0
decl	6:4	6:31	2	unsigned int	stts_index
op	6:28	0:0	2	=
water	6:30	0:0	2	0
decl	7:4	7:31	2	unsigned int	stsc_index
op	7:28	0:0	2	=
water	7:30	0:0	2	0
decl	8:4	8:31	2	unsigned int	stss_index
op	8:28	0:0	2	=
water	8:30	0:0	2	0
decl	9:4	9:31	2	unsigned int	stps_index
op	9:28	0:0	2	=
water	9:30	0:0	2	0
decl	10:4	10:21	2	unsigned int	i
water	10:18	0:0	2	,
decl	10:4	10:21	2	unsigned int	j
decl	11:4	11:28	2	uint64_t	stream_size
op	11:25	0:0	2	=
water	11:27	0:0	2	0
if	13:4	48:4	2	(sc -> elst_count)
cond	13:8	13:12	3	sc -> elst_count
water	13:8	0:0	4	sc
op	13:10	0:0	4	->
water	13:12	0:0	4	elst_count
stmts	13:24	48:4	3	
water	13:24	0:0	4	{
decl	14:8	14:52	4	int	i
water	14:13	0:0	4	,
decl	14:8	14:52	4	int	edit_start_index
op	14:32	0:0	4	=
water	14:34	0:0	4	0
water	14:35	0:0	4	,
decl	14:8	14:52	4	int	unsupported
op	14:49	0:0	4	=
water	14:51	0:0	4	0
decl	15:8	15:34	4	int64_t	empty_duration
op	15:31	0:0	4	=
water	15:33	0:0	4	0
decl	16:8	16:30	4	int64_t	start_time
op	16:27	0:0	4	=
water	16:29	0:0	4	0
for	18:8	29:8	4	(i = 0 ;i < sc -> elst_count;i ++)
forinit	18:13	18:18	5	i = 0 ;
water	18:13	0:0	6	i
op	18:15	0:0	6	=
water	18:17	0:0	6	0
water	18:18	0:0	6	;
cond	18:20	18:28	5	i < sc -> elst_count
water	18:20	0:0	6	i
op	18:22	0:0	6	<
water	18:24	0:0	6	sc
op	18:26	0:0	6	->
water	18:28	0:0	6	elst_count
forexpr	18:40	18:41	5	i ++
water	18:40	0:0	6	i
op	18:41	0:0	6	++
stmts	18:45	29:8	5	
water	18:45	0:0	6	{
decl	19:12	19:48	6	const MOVElst	*e
op	19:29	0:0	6	=
op	19:31	0:0	6	&
water	19:32	0:0	6	sc
op	19:34	0:0	6	->
water	19:36	0:0	6	elst_data
op	19:45	0:0	6	[
water	19:46	0:0	6	i
op	19:47	0:0	6	]
if	20:12	25:12	6	(i == 0 && e -> time == - 1)
cond	20:16	20:38	7	i == 0 && e -> time == - 1
water	20:16	0:0	8	i
op	20:18	0:0	8	==
water	20:21	0:0	8	0
op	20:23	0:0	8	&&
water	20:26	0:0	8	e
op	20:27	0:0	8	->
water	20:29	0:0	8	time
op	20:34	0:0	8	==
op	20:37	0:0	8	-
water	20:38	0:0	8	1
stmts	20:41	25:12	7	
water	20:41	0:0	8	{
water	23:16	0:0	8	empty_duration
op	23:31	0:0	8	=
water	23:33	0:0	8	e
op	23:34	0:0	8	->
water	23:36	0:0	8	duration
water	23:44	0:0	8	;
water	24:16	0:0	8	edit_start_index
op	24:33	0:0	8	=
water	24:35	0:0	8	1
water	24:36	0:0	8	;
water	25:12	0:0	8	}
else	25:14	27:12	6
stmts	25:19	27:12	7	
if	25:19	27:12	8	(i == edit_start_index && e -> time >= 0)
cond	25:23	25:59	9	i == edit_start_index && e -> time >= 0
water	25:23	0:0	10	i
op	25:25	0:0	10	==
water	25:28	0:0	10	edit_start_index
op	25:45	0:0	10	&&
water	25:48	0:0	10	e
op	25:49	0:0	10	->
water	25:51	0:0	10	time
op	25:56	0:0	10	>=
water	25:59	0:0	10	0
stmts	25:62	27:12	9	
water	25:62	0:0	10	{
water	26:16	0:0	10	start_time
op	26:27	0:0	10	=
water	26:29	0:0	10	e
op	26:30	0:0	10	->
water	26:32	0:0	10	time
water	26:36	0:0	10	;
water	27:12	0:0	10	}
else	27:14	28:31	6
stmts	28:16	28:31	7	
water	28:16	0:0	8	unsupported
op	28:28	0:0	8	=
water	28:30	0:0	8	1
water	28:31	0:0	8	;
water	29:8	0:0	6	}
if	30:8	32:61	4	(unsupported)
cond	30:12	30:12	5	unsupported
water	30:12	0:0	6	unsupported
stmts	31:12	32:61	5	
call	31:12	32:60	6	av_log
arg	31:19	31:26	7	mov->fc
water	31:19	0:0	8	mov
op	31:22	0:0	8	->
water	31:24	0:0	8	fc
arg	31:28	31:42	7	AV_LOG_WARNING
water	31:28	0:0	8	AV_LOG_WARNING
arg	31:44	32:60	7	"multiple edit list entries, ""a/v desync might occur, patch welcome\n"
water	31:44	0:0	8	"multiple edit list entries, "
water	32:19	0:0	8	"a/v desync might occur, patch welcome\n"
water	32:61	0:0	6	;
if	35:8	47:8	4	(( empty_duration || start_time ) && mov -> time_scale > 0)
cond	35:12	35:64	5	( empty_duration || start_time ) && mov -> time_scale > 0
water	35:12	0:0	6	(
water	35:13	0:0	6	empty_duration
op	35:28	0:0	6	||
water	35:31	0:0	6	start_time
water	35:41	0:0	6	)
op	35:43	0:0	6	&&
water	35:46	0:0	6	mov
op	35:49	0:0	6	->
water	35:51	0:0	6	time_scale
op	35:62	0:0	6	>
water	35:64	0:0	6	0
stmts	35:67	47:8	5	
water	35:67	0:0	6	{
if	36:12	37:92	6	(empty_duration)
cond	36:16	36:16	7	empty_duration
water	36:16	0:0	8	empty_duration
stmts	37:16	37:92	7	
water	37:16	0:0	8	empty_duration
op	37:31	0:0	8	=
call	37:33	37:91	8	av_rescale
arg	37:44	37:58	9	empty_duration
water	37:44	0:0	10	empty_duration
arg	37:60	37:74	9	sc->time_scale
water	37:60	0:0	10	sc
op	37:62	0:0	10	->
water	37:64	0:0	10	time_scale
arg	37:76	37:91	9	mov->time_scale
water	37:76	0:0	10	mov
op	37:79	0:0	10	->
water	37:81	0:0	10	time_scale
water	37:92	0:0	8	;
water	38:12	0:0	6	sc
op	38:14	0:0	6	->
water	38:16	0:0	6	time_offset
op	38:28	0:0	6	=
water	38:30	0:0	6	start_time
op	38:41	0:0	6	-
water	38:43	0:0	6	empty_duration
water	38:57	0:0	6	;
water	39:12	0:0	6	current_dts
op	39:24	0:0	6	=
op	39:26	0:0	6	-
water	39:27	0:0	6	sc
op	39:29	0:0	6	->
water	39:31	0:0	6	time_offset
water	39:42	0:0	6	;
if	40:12	46:12	6	(sc -> ctts_count > 0 && sc -> stts_count > 0 && sc -> ctts_data [ 0 ] . duration /FFMAX (sc -> stts_data [ 0 ] . duration ,1 ) > 16)
cond	40:16	41:82	7	sc -> ctts_count > 0 && sc -> stts_count > 0 && sc -> ctts_data [ 0 ] . duration /FFMAX (sc -> stts_data [ 0 ] . duration ,1 ) > 16
water	40:16	0:0	8	sc
op	40:18	0:0	8	->
water	40:20	0:0	8	ctts_count
op	40:30	0:0	8	>
water	40:31	0:0	8	0
op	40:33	0:0	8	&&
water	40:36	0:0	8	sc
op	40:38	0:0	8	->
water	40:40	0:0	8	stts_count
op	40:50	0:0	8	>
water	40:51	0:0	8	0
op	40:53	0:0	8	&&
water	41:16	0:0	8	sc
op	41:18	0:0	8	->
water	41:20	0:0	8	ctts_data
op	41:29	0:0	8	[
water	41:30	0:0	8	0
op	41:31	0:0	8	]
op	41:32	0:0	8	.
water	41:33	0:0	8	duration
op	41:42	0:0	8	/
call	41:44	41:78	8	FFMAX
arg	41:50	41:75	9	sc->stts_data[0].duration
water	41:50	0:0	10	sc
op	41:52	0:0	10	->
water	41:54	0:0	10	stts_data
op	41:63	0:0	10	[
water	41:64	0:0	10	0
op	41:65	0:0	10	]
op	41:66	0:0	10	.
water	41:67	0:0	10	duration
arg	41:77	41:78	9	1
water	41:77	0:0	10	1
op	41:80	0:0	8	>
water	41:82	0:0	8	16
stmts	41:86	46:12	7	
water	41:86	0:0	8	{
water	44:16	0:0	8	sc
op	44:18	0:0	8	->
water	44:20	0:0	8	wrong_dts
op	44:30	0:0	8	=
water	44:32	0:0	8	1
water	44:33	0:0	8	;
water	45:16	0:0	8	st
op	45:18	0:0	8	->
water	45:20	0:0	8	codec
op	45:25	0:0	8	->
water	45:27	0:0	8	has_b_frames
op	45:40	0:0	8	=
water	45:42	0:0	8	1
water	45:43	0:0	8	;
water	46:12	0:0	8	}
water	47:8	0:0	6	}
water	48:4	0:0	4	}
if	51:4	177:4	2	(! ( st -> codec -> codec_type == AVMEDIA_TYPE_AUDIO && sc -> stts_count == 1 && sc -> stts_data [ 0 ] . duration == 1 ))
cond	51:8	52:63	3	! ( st -> codec -> codec_type == AVMEDIA_TYPE_AUDIO && sc -> stts_count == 1 && sc -> stts_data [ 0 ] . duration == 1 )
op	51:8	0:0	4	!
water	51:9	0:0	4	(
water	51:10	0:0	4	st
op	51:12	0:0	4	->
water	51:14	0:0	4	codec
op	51:19	0:0	4	->
water	51:21	0:0	4	codec_type
op	51:32	0:0	4	==
water	51:35	0:0	4	AVMEDIA_TYPE_AUDIO
op	51:54	0:0	4	&&
water	52:10	0:0	4	sc
op	52:12	0:0	4	->
water	52:14	0:0	4	stts_count
op	52:25	0:0	4	==
water	52:28	0:0	4	1
op	52:30	0:0	4	&&
water	52:33	0:0	4	sc
op	52:35	0:0	4	->
water	52:37	0:0	4	stts_data
op	52:46	0:0	4	[
water	52:47	0:0	4	0
op	52:48	0:0	4	]
op	52:49	0:0	4	.
water	52:50	0:0	4	duration
op	52:59	0:0	4	==
water	52:62	0:0	4	1
water	52:63	0:0	4	)
stmts	52:66	177:4	3	
water	52:66	0:0	4	{
decl	53:8	53:39	4	unsigned int	current_sample
op	53:36	0:0	4	=
water	53:38	0:0	4	0
decl	54:8	54:36	4	unsigned int	stts_sample
op	54:33	0:0	4	=
water	54:35	0:0	4	0
decl	55:8	55:32	4	unsigned int	sample_size
decl	56:8	56:33	4	unsigned int	distance
op	56:30	0:0	4	=
water	56:32	0:0	4	0
decl	57:8	57:40	4	unsigned int	rap_group_index
op	57:37	0:0	4	=
water	57:39	0:0	4	0
decl	58:8	58:41	4	unsigned int	rap_group_sample
op	58:38	0:0	4	=
water	58:40	0:0	4	0
decl	59:8	59:28	4	int64_t	last_dts
op	59:25	0:0	4	=
water	59:27	0:0	4	0
decl	60:8	60:34	4	int64_t	dts_correction
op	60:31	0:0	4	=
water	60:33	0:0	4	0
decl	61:8	61:68	4	int	rap_group_present
op	61:30	0:0	4	=
water	61:32	0:0	4	sc
op	61:34	0:0	4	->
water	61:36	0:0	4	rap_group_count
op	61:52	0:0	4	&&
water	61:55	0:0	4	sc
op	61:57	0:0	4	->
water	61:59	0:0	4	rap_group
decl	62:8	62:110	4	int	key_off
op	62:20	0:0	4	=
water	62:22	0:0	4	(
water	62:23	0:0	4	sc
op	62:25	0:0	4	->
water	62:27	0:0	4	keyframe_count
op	62:42	0:0	4	&&
water	62:45	0:0	4	sc
op	62:47	0:0	4	->
water	62:49	0:0	4	keyframes
op	62:58	0:0	4	[
water	62:59	0:0	4	0
op	62:60	0:0	4	]
op	62:62	0:0	4	>
water	62:64	0:0	4	0
water	62:65	0:0	4	)
op	62:67	0:0	4	||
water	62:70	0:0	4	(
water	62:71	0:0	4	sc
op	62:73	0:0	4	->
water	62:75	0:0	4	stps_count
op	62:86	0:0	4	&&
water	62:89	0:0	4	sc
op	62:91	0:0	4	->
water	62:93	0:0	4	stps_data
op	62:102	0:0	4	[
water	62:103	0:0	4	0
op	62:104	0:0	4	]
op	62:106	0:0	4	>
water	62:108	0:0	4	0
water	62:109	0:0	4	)
water	64:8	0:0	4	current_dts
op	64:20	0:0	4	-=
water	64:23	0:0	4	sc
op	64:25	0:0	4	->
water	64:27	0:0	4	dts_shift
water	64:36	0:0	4	;
water	65:8	0:0	4	last_dts
op	65:21	0:0	4	=
water	65:23	0:0	4	current_dts
water	65:34	0:0	4	;
if	67:8	68:18	4	(! sc -> sample_count || st -> nb_index_entries)
cond	67:12	67:37	5	! sc -> sample_count || st -> nb_index_entries
op	67:12	0:0	6	!
water	67:13	0:0	6	sc
op	67:15	0:0	6	->
water	67:17	0:0	6	sample_count
op	67:30	0:0	6	||
water	67:33	0:0	6	st
op	67:35	0:0	6	->
water	67:37	0:0	6	nb_index_entries
stmts	68:12	68:18	5	
return	68:12	68:18	6	
if	69:8	70:18	4	(sc -> sample_count >= UINT_MAX / sizeof ( * st -> index_entries ) - st -> nb_index_entries)
cond	69:12	69:76	5	sc -> sample_count >= UINT_MAX / sizeof ( * st -> index_entries ) - st -> nb_index_entries
water	69:12	0:0	6	sc
op	69:14	0:0	6	->
water	69:16	0:0	6	sample_count
op	69:29	0:0	6	>=
water	69:32	0:0	6	UINT_MAX
op	69:41	0:0	6	/
op	69:43	0:0	6	sizeof
water	69:49	0:0	6	(
op	69:50	0:0	6	*
water	69:51	0:0	6	st
op	69:53	0:0	6	->
water	69:55	0:0	6	index_entries
water	69:68	0:0	6	)
op	69:70	0:0	6	-
water	69:72	0:0	6	st
op	69:74	0:0	6	->
water	69:76	0:0	6	nb_index_entries
stmts	70:12	70:18	5	
return	70:12	70:18	6	
if	71:8	76:8	4	(av_reallocp_array (& st -> index_entries ,st -> nb_index_entries + sc -> sample_count ,sizeof ( * st -> index_entries ) ) < 0)
cond	71:12	73:60	5	av_reallocp_array (& st -> index_entries ,st -> nb_index_entries + sc -> sample_count ,sizeof ( * st -> index_entries ) ) < 0
call	71:12	73:56	6	av_reallocp_array
arg	71:30	71:48	7	&st->index_entries
op	71:30	0:0	8	&
water	71:31	0:0	8	st
op	71:33	0:0	8	->
water	71:35	0:0	8	index_entries
arg	72:30	72:69	7	st->nb_index_entries+sc->sample_count
water	72:30	0:0	8	st
op	72:32	0:0	8	->
water	72:34	0:0	8	nb_index_entries
op	72:51	0:0	8	+
water	72:53	0:0	8	sc
op	72:55	0:0	8	->
water	72:57	0:0	8	sample_count
arg	73:30	73:56	7	sizeof(*st->index_entries)
op	73:30	0:0	8	sizeof
water	73:36	0:0	8	(
op	73:37	0:0	8	*
water	73:38	0:0	8	st
op	73:40	0:0	8	->
water	73:42	0:0	8	index_entries
water	73:55	0:0	8	)
op	73:58	0:0	6	<
water	73:60	0:0	6	0
stmts	73:63	76:8	5	
water	73:63	0:0	6	{
water	74:12	0:0	6	st
op	74:14	0:0	6	->
water	74:16	0:0	6	nb_index_entries
op	74:33	0:0	6	=
water	74:35	0:0	6	0
water	74:36	0:0	6	;
return	75:12	75:18	6	
water	76:8	0:0	6	}
water	77:8	0:0	4	st
op	77:10	0:0	4	->
water	77:12	0:0	4	index_entries_allocated_size
op	77:41	0:0	4	=
water	77:43	0:0	4	(
water	77:44	0:0	4	st
op	77:46	0:0	4	->
water	77:48	0:0	4	nb_index_entries
op	77:65	0:0	4	+
water	77:67	0:0	4	sc
op	77:69	0:0	4	->
water	77:71	0:0	4	sample_count
water	77:83	0:0	4	)
op	77:85	0:0	4	*
op	77:87	0:0	4	sizeof
water	77:93	0:0	4	(
op	77:94	0:0	4	*
water	77:95	0:0	4	st
op	77:97	0:0	4	->
water	77:99	0:0	4	index_entries
water	77:112	0:0	4	)
water	77:113	0:0	4	;
for	79:8	174:8	4	(i = 0 ;i < sc -> chunk_count;i ++)
forinit	79:13	79:18	5	i = 0 ;
water	79:13	0:0	6	i
op	79:15	0:0	6	=
water	79:17	0:0	6	0
water	79:18	0:0	6	;
cond	79:20	79:28	5	i < sc -> chunk_count
water	79:20	0:0	6	i
op	79:22	0:0	6	<
water	79:24	0:0	6	sc
op	79:26	0:0	6	->
water	79:28	0:0	6	chunk_count
forexpr	79:41	79:42	5	i ++
water	79:41	0:0	6	i
op	79:42	0:0	6	++
stmts	79:46	174:8	5	
water	79:46	0:0	6	{
decl	80:12	80:92	6	int64_t	next_offset
op	80:32	0:0	6	=
water	80:34	0:0	6	i
op	80:35	0:0	6	+
water	80:36	0:0	6	1
op	80:38	0:0	6	<
water	80:40	0:0	6	sc
op	80:42	0:0	6	->
water	80:44	0:0	6	chunk_count
water	80:56	0:0	6	?
water	80:58	0:0	6	sc
op	80:60	0:0	6	->
water	80:62	0:0	6	chunk_offsets
op	80:75	0:0	6	[
water	80:76	0:0	6	i
op	80:77	0:0	6	+
water	80:78	0:0	6	1
op	80:79	0:0	6	]
water	80:81	0:0	6	:
water	80:83	0:0	6	INT64_MAX
water	81:12	0:0	6	current_offset
op	81:27	0:0	6	=
water	81:29	0:0	6	sc
op	81:31	0:0	6	->
water	81:33	0:0	6	chunk_offsets
op	81:46	0:0	6	[
water	81:47	0:0	6	i
op	81:48	0:0	6	]
water	81:49	0:0	6	;
while	82:12	84:28	6	(stsc_index + 1 < sc -> stsc_count && i + 1 == sc -> stsc_data [ stsc_index + 1 ] . first)
cond	82:19	83:55	7	stsc_index + 1 < sc -> stsc_count && i + 1 == sc -> stsc_data [ stsc_index + 1 ] . first
water	82:19	0:0	8	stsc_index
op	82:30	0:0	8	+
water	82:32	0:0	8	1
op	82:34	0:0	8	<
water	82:36	0:0	8	sc
op	82:38	0:0	8	->
water	82:40	0:0	8	stsc_count
op	82:51	0:0	8	&&
water	83:16	0:0	8	i
op	83:18	0:0	8	+
water	83:20	0:0	8	1
op	83:22	0:0	8	==
water	83:25	0:0	8	sc
op	83:27	0:0	8	->
water	83:29	0:0	8	stsc_data
op	83:38	0:0	8	[
water	83:39	0:0	8	stsc_index
op	83:50	0:0	8	+
water	83:52	0:0	8	1
op	83:53	0:0	8	]
op	83:54	0:0	8	.
water	83:55	0:0	8	first
stmts	84:16	84:28	7	
water	84:16	0:0	8	stsc_index
op	84:26	0:0	8	++
water	84:28	0:0	8	;
if	86:12	90:12	6	(next_offset > current_offset && sc -> sample_size > 0 && sc -> sample_size < sc -> stsz_sample_size && sc -> stsc_data [ stsc_index ] . count * ( int64_t ) sc -> stsz_sample_size > next_offset - current_offset)
cond	86:16	87:96	7	next_offset > current_offset && sc -> sample_size > 0 && sc -> sample_size < sc -> stsz_sample_size && sc -> stsc_data [ stsc_index ] . count * ( int64_t ) sc -> stsz_sample_size > next_offset - current_offset
water	86:16	0:0	8	next_offset
op	86:28	0:0	8	>
water	86:30	0:0	8	current_offset
op	86:45	0:0	8	&&
water	86:48	0:0	8	sc
op	86:50	0:0	8	->
water	86:52	0:0	8	sample_size
op	86:63	0:0	8	>
water	86:64	0:0	8	0
op	86:66	0:0	8	&&
water	86:69	0:0	8	sc
op	86:71	0:0	8	->
water	86:73	0:0	8	sample_size
op	86:85	0:0	8	<
water	86:87	0:0	8	sc
op	86:89	0:0	8	->
water	86:91	0:0	8	stsz_sample_size
op	86:108	0:0	8	&&
water	87:16	0:0	8	sc
op	87:18	0:0	8	->
water	87:20	0:0	8	stsc_data
op	87:29	0:0	8	[
water	87:30	0:0	8	stsc_index
op	87:40	0:0	8	]
op	87:41	0:0	8	.
water	87:42	0:0	8	count
op	87:48	0:0	8	*
water	87:50	0:0	8	(
water	87:51	0:0	8	int64_t
water	87:58	0:0	8	)
water	87:59	0:0	8	sc
op	87:61	0:0	8	->
water	87:63	0:0	8	stsz_sample_size
op	87:80	0:0	8	>
water	87:82	0:0	8	next_offset
op	87:94	0:0	8	-
water	87:96	0:0	8	current_offset
stmts	87:112	90:12	7	
water	87:112	0:0	8	{
call	88:16	88:123	8	av_log
arg	88:23	88:30	9	mov->fc
water	88:23	0:0	10	mov
op	88:26	0:0	10	->
water	88:28	0:0	10	fc
arg	88:32	88:46	9	AV_LOG_WARNING
water	88:32	0:0	10	AV_LOG_WARNING
arg	88:48	88:101	9	"STSZ sample size %d invalid (too large), ignoring\n"
water	88:48	0:0	10	"STSZ sample size %d invalid (too large), ignoring\n"
arg	88:103	88:123	9	sc->stsz_sample_size
water	88:103	0:0	10	sc
op	88:105	0:0	10	->
water	88:107	0:0	10	stsz_sample_size
water	88:124	0:0	8	;
water	89:16	0:0	8	sc
op	89:18	0:0	8	->
water	89:20	0:0	8	stsz_sample_size
op	89:37	0:0	8	=
water	89:39	0:0	8	sc
op	89:41	0:0	8	->
water	89:43	0:0	8	sample_size
water	89:54	0:0	8	;
water	90:12	0:0	8	}
if	91:12	94:12	6	(sc -> stsz_sample_size > 0 && sc -> stsz_sample_size < sc -> sample_size)
cond	91:16	91:69	7	sc -> stsz_sample_size > 0 && sc -> stsz_sample_size < sc -> sample_size
water	91:16	0:0	8	sc
op	91:18	0:0	8	->
water	91:20	0:0	8	stsz_sample_size
op	91:36	0:0	8	>
water	91:37	0:0	8	0
op	91:39	0:0	8	&&
water	91:42	0:0	8	sc
op	91:44	0:0	8	->
water	91:46	0:0	8	stsz_sample_size
op	91:63	0:0	8	<
water	91:65	0:0	8	sc
op	91:67	0:0	8	->
water	91:69	0:0	8	sample_size
stmts	91:82	94:12	7	
water	91:82	0:0	8	{
call	92:16	92:123	8	av_log
arg	92:23	92:30	9	mov->fc
water	92:23	0:0	10	mov
op	92:26	0:0	10	->
water	92:28	0:0	10	fc
arg	92:32	92:46	9	AV_LOG_WARNING
water	92:32	0:0	10	AV_LOG_WARNING
arg	92:48	92:101	9	"STSZ sample size %d invalid (too small), ignoring\n"
water	92:48	0:0	10	"STSZ sample size %d invalid (too small), ignoring\n"
arg	92:103	92:123	9	sc->stsz_sample_size
water	92:103	0:0	10	sc
op	92:105	0:0	10	->
water	92:107	0:0	10	stsz_sample_size
water	92:124	0:0	8	;
water	93:16	0:0	8	sc
op	93:18	0:0	8	->
water	93:20	0:0	8	stsz_sample_size
op	93:37	0:0	8	=
water	93:39	0:0	8	sc
op	93:41	0:0	8	->
water	93:43	0:0	8	sample_size
water	93:54	0:0	8	;
water	94:12	0:0	8	}
for	96:12	173:12	6	(j = 0 ;j < sc -> stsc_data [ stsc_index ] . count;j ++)
forinit	96:17	96:22	7	j = 0 ;
water	96:17	0:0	8	j
op	96:19	0:0	8	=
water	96:21	0:0	8	0
water	96:22	0:0	8	;
cond	96:24	96:54	7	j < sc -> stsc_data [ stsc_index ] . count
water	96:24	0:0	8	j
op	96:26	0:0	8	<
water	96:28	0:0	8	sc
op	96:30	0:0	8	->
water	96:32	0:0	8	stsc_data
op	96:41	0:0	8	[
water	96:42	0:0	8	stsc_index
op	96:52	0:0	8	]
op	96:53	0:0	8	.
water	96:54	0:0	8	count
forexpr	96:61	96:62	7	j ++
water	96:61	0:0	8	j
op	96:62	0:0	8	++
stmts	96:66	173:12	7	
water	96:66	0:0	8	{
decl	97:16	97:32	8	int	keyframe
op	97:29	0:0	8	=
water	97:31	0:0	8	0
if	98:16	101:16	8	(current_sample >= sc -> sample_count)
cond	98:20	98:42	9	current_sample >= sc -> sample_count
water	98:20	0:0	10	current_sample
op	98:35	0:0	10	>=
water	98:38	0:0	10	sc
op	98:40	0:0	10	->
water	98:42	0:0	10	sample_count
stmts	98:56	101:16	9	
water	98:56	0:0	10	{
call	99:20	99:72	10	av_log
arg	99:27	99:34	11	mov->fc
water	99:27	0:0	12	mov
op	99:30	0:0	12	->
water	99:32	0:0	12	fc
arg	99:36	99:48	11	AV_LOG_ERROR
water	99:36	0:0	12	AV_LOG_ERROR
arg	99:50	99:72	11	"wrong sample count\n"
water	99:50	0:0	12	"wrong sample count\n"
water	99:73	0:0	10	;
return	100:20	100:26	10	
water	101:16	0:0	10	}
if	103:16	107:16	8	(! sc -> keyframe_absent && ( ! sc -> keyframe_count || current_sample + key_off == sc -> keyframes [ stss_index ] ))
cond	103:20	103:119	9	! sc -> keyframe_absent && ( ! sc -> keyframe_count || current_sample + key_off == sc -> keyframes [ stss_index ] )
op	103:20	0:0	10	!
water	103:21	0:0	10	sc
op	103:23	0:0	10	->
water	103:25	0:0	10	keyframe_absent
op	103:41	0:0	10	&&
water	103:44	0:0	10	(
op	103:45	0:0	10	!
water	103:46	0:0	10	sc
op	103:48	0:0	10	->
water	103:50	0:0	10	keyframe_count
op	103:65	0:0	10	||
water	103:68	0:0	10	current_sample
op	103:82	0:0	10	+
water	103:83	0:0	10	key_off
op	103:91	0:0	10	==
water	103:94	0:0	10	sc
op	103:96	0:0	10	->
water	103:98	0:0	10	keyframes
op	103:107	0:0	10	[
water	103:108	0:0	10	stss_index
op	103:118	0:0	10	]
water	103:119	0:0	10	)
stmts	103:122	107:16	9	
water	103:122	0:0	10	{
water	104:20	0:0	10	keyframe
op	104:29	0:0	10	=
water	104:31	0:0	10	1
water	104:32	0:0	10	;
if	105:20	106:36	10	(stss_index + 1 < sc -> keyframe_count)
cond	105:24	105:45	11	stss_index + 1 < sc -> keyframe_count
water	105:24	0:0	12	stss_index
op	105:35	0:0	12	+
water	105:37	0:0	12	1
op	105:39	0:0	12	<
water	105:41	0:0	12	sc
op	105:43	0:0	12	->
water	105:45	0:0	12	keyframe_count
stmts	106:24	106:36	11	
water	106:24	0:0	12	stss_index
op	106:34	0:0	12	++
water	106:36	0:0	12	;
water	107:16	0:0	10	}
else	107:18	111:16	8
stmts	107:23	111:16	9	
if	107:23	111:16	10	(sc -> stps_count && current_sample + key_off == sc -> stps_data [ stps_index ])
cond	107:27	107:95	11	sc -> stps_count && current_sample + key_off == sc -> stps_data [ stps_index ]
water	107:27	0:0	12	sc
op	107:29	0:0	12	->
water	107:31	0:0	12	stps_count
op	107:42	0:0	12	&&
water	107:45	0:0	12	current_sample
op	107:59	0:0	12	+
water	107:60	0:0	12	key_off
op	107:68	0:0	12	==
water	107:71	0:0	12	sc
op	107:73	0:0	12	->
water	107:75	0:0	12	stps_data
op	107:84	0:0	12	[
water	107:85	0:0	12	stps_index
op	107:95	0:0	12	]
stmts	107:98	111:16	11	
water	107:98	0:0	12	{
water	108:20	0:0	12	keyframe
op	108:29	0:0	12	=
water	108:31	0:0	12	1
water	108:32	0:0	12	;
if	109:20	110:36	12	(stps_index + 1 < sc -> stps_count)
cond	109:24	109:45	13	stps_index + 1 < sc -> stps_count
water	109:24	0:0	14	stps_index
op	109:35	0:0	14	+
water	109:37	0:0	14	1
op	109:39	0:0	14	<
water	109:41	0:0	14	sc
op	109:43	0:0	14	->
water	109:45	0:0	14	stps_count
stmts	110:24	110:36	13	
water	110:24	0:0	14	stps_index
op	110:34	0:0	14	++
water	110:36	0:0	14	;
water	111:16	0:0	12	}
if	112:16	119:16	8	(rap_group_present && rap_group_index < sc -> rap_group_count)
cond	112:20	112:63	9	rap_group_present && rap_group_index < sc -> rap_group_count
water	112:20	0:0	10	rap_group_present
op	112:38	0:0	10	&&
water	112:41	0:0	10	rap_group_index
op	112:57	0:0	10	<
water	112:59	0:0	10	sc
op	112:61	0:0	10	->
water	112:63	0:0	10	rap_group_count
stmts	112:80	119:16	9	
water	112:80	0:0	10	{
if	113:20	114:36	10	(sc -> rap_group [ rap_group_index ] . index > 0)
cond	113:24	113:63	11	sc -> rap_group [ rap_group_index ] . index > 0
water	113:24	0:0	12	sc
op	113:26	0:0	12	->
water	113:28	0:0	12	rap_group
op	113:37	0:0	12	[
water	113:38	0:0	12	rap_group_index
op	113:53	0:0	12	]
op	113:54	0:0	12	.
water	113:55	0:0	12	index
op	113:61	0:0	12	>
water	113:63	0:0	12	0
stmts	114:24	114:36	11	
water	114:24	0:0	12	keyframe
op	114:33	0:0	12	=
water	114:35	0:0	12	1
water	114:36	0:0	12	;
if	115:20	118:20	10	(++ rap_group_sample == sc -> rap_group [ rap_group_index ] . count)
cond	115:24	115:77	11	++ rap_group_sample == sc -> rap_group [ rap_group_index ] . count
op	115:24	0:0	12	++
water	115:26	0:0	12	rap_group_sample
op	115:43	0:0	12	==
water	115:46	0:0	12	sc
op	115:48	0:0	12	->
water	115:50	0:0	12	rap_group
op	115:59	0:0	12	[
water	115:60	0:0	12	rap_group_index
op	115:75	0:0	12	]
op	115:76	0:0	12	.
water	115:77	0:0	12	count
stmts	115:84	118:20	11	
water	115:84	0:0	12	{
water	116:24	0:0	12	rap_group_sample
op	116:41	0:0	12	=
water	116:43	0:0	12	0
water	116:44	0:0	12	;
water	117:24	0:0	12	rap_group_index
op	117:39	0:0	12	++
water	117:41	0:0	12	;
water	118:20	0:0	12	}
water	119:16	0:0	10	}
if	120:16	124:33	8	(sc -> keyframe_absent && ! sc -> stps_count && ! rap_group_present && ( st -> codec -> codec_type == AVMEDIA_TYPE_AUDIO || ( i == 0 && j == 0 ) ))
cond	120:20	123:85	9	sc -> keyframe_absent && ! sc -> stps_count && ! rap_group_present && ( st -> codec -> codec_type == AVMEDIA_TYPE_AUDIO || ( i == 0 && j == 0 ) )
water	120:20	0:0	10	sc
op	120:22	0:0	10	->
water	120:24	0:0	10	keyframe_absent
op	121:20	0:0	10	&&
op	121:23	0:0	10	!
water	121:24	0:0	10	sc
op	121:26	0:0	10	->
water	121:28	0:0	10	stps_count
op	122:20	0:0	10	&&
op	122:23	0:0	10	!
water	122:24	0:0	10	rap_group_present
op	123:20	0:0	10	&&
water	123:23	0:0	10	(
water	123:24	0:0	10	st
op	123:26	0:0	10	->
water	123:28	0:0	10	codec
op	123:33	0:0	10	->
water	123:35	0:0	10	codec_type
op	123:46	0:0	10	==
water	123:49	0:0	10	AVMEDIA_TYPE_AUDIO
op	123:68	0:0	10	||
water	123:71	0:0	10	(
water	123:72	0:0	10	i
op	123:73	0:0	10	==
water	123:75	0:0	10	0
op	123:77	0:0	10	&&
water	123:80	0:0	10	j
op	123:81	0:0	10	==
water	123:83	0:0	10	0
water	123:84	0:0	10	)
water	123:85	0:0	10	)
stmts	124:21	124:33	9	
water	124:21	0:0	10	keyframe
op	124:30	0:0	10	=
water	124:32	0:0	10	1
water	124:33	0:0	10	;
if	125:16	126:32	8	(keyframe)
cond	125:20	125:20	9	keyframe
water	125:20	0:0	10	keyframe
stmts	126:20	126:32	9	
water	126:20	0:0	10	distance
op	126:29	0:0	10	=
water	126:31	0:0	10	0
water	126:32	0:0	10	;
water	127:16	0:0	8	sample_size
op	127:28	0:0	8	=
water	127:30	0:0	8	sc
op	127:32	0:0	8	->
water	127:34	0:0	8	stsz_sample_size
op	127:51	0:0	8	>
water	127:53	0:0	8	0
water	127:55	0:0	8	?
water	127:57	0:0	8	sc
op	127:59	0:0	8	->
water	127:61	0:0	8	stsz_sample_size
water	127:78	0:0	8	:
water	127:80	0:0	8	sc
op	127:82	0:0	8	->
water	127:84	0:0	8	sample_sizes
op	127:96	0:0	8	[
water	127:97	0:0	8	current_sample
op	127:111	0:0	8	]
water	127:112	0:0	8	;
if	128:16	141:16	8	(sc -> pseudo_stream_id == - 1 || sc -> stsc_data [ stsc_index ] . id - 1 == sc -> pseudo_stream_id)
cond	128:20	129:59	9	sc -> pseudo_stream_id == - 1 || sc -> stsc_data [ stsc_index ] . id - 1 == sc -> pseudo_stream_id
water	128:20	0:0	10	sc
op	128:22	0:0	10	->
water	128:24	0:0	10	pseudo_stream_id
op	128:41	0:0	10	==
op	128:44	0:0	10	-
water	128:45	0:0	10	1
op	128:47	0:0	10	||
water	129:19	0:0	10	sc
op	129:21	0:0	10	->
water	129:23	0:0	10	stsc_data
op	129:32	0:0	10	[
water	129:33	0:0	10	stsc_index
op	129:43	0:0	10	]
op	129:44	0:0	10	.
water	129:45	0:0	10	id
op	129:48	0:0	10	-
water	129:50	0:0	10	1
op	129:52	0:0	10	==
water	129:55	0:0	10	sc
op	129:57	0:0	10	->
water	129:59	0:0	10	pseudo_stream_id
stmts	129:77	141:16	9	
water	129:77	0:0	10	{
decl	130:20	130:80	10	AVIndexEntry	*e
op	130:36	0:0	10	=
op	130:38	0:0	10	&
water	130:39	0:0	10	st
op	130:41	0:0	10	->
water	130:43	0:0	10	index_entries
op	130:56	0:0	10	[
water	130:57	0:0	10	st
op	130:59	0:0	10	->
water	130:61	0:0	10	nb_index_entries
op	130:77	0:0	10	++
op	130:79	0:0	10	]
water	131:20	0:0	10	e
op	131:21	0:0	10	->
water	131:23	0:0	10	pos
op	131:27	0:0	10	=
water	131:29	0:0	10	current_offset
water	131:43	0:0	10	;
water	132:20	0:0	10	e
op	132:21	0:0	10	->
water	132:23	0:0	10	timestamp
op	132:33	0:0	10	=
water	132:35	0:0	10	current_dts
water	132:46	0:0	10	;
water	133:20	0:0	10	e
op	133:21	0:0	10	->
water	133:23	0:0	10	size
op	133:28	0:0	10	=
water	133:30	0:0	10	sample_size
water	133:41	0:0	10	;
water	134:20	0:0	10	e
op	134:21	0:0	10	->
water	134:23	0:0	10	min_distance
op	134:36	0:0	10	=
water	134:38	0:0	10	distance
water	134:46	0:0	10	;
water	135:20	0:0	10	e
op	135:21	0:0	10	->
water	135:23	0:0	10	flags
op	135:29	0:0	10	=
water	135:31	0:0	10	keyframe
water	135:40	0:0	10	?
water	135:42	0:0	10	AVINDEX_KEYFRAME
water	135:59	0:0	10	:
water	135:61	0:0	10	0
water	135:62	0:0	10	;
call	136:20	138:88	10	av_log
arg	136:27	136:34	11	mov->fc
water	136:27	0:0	12	mov
op	136:30	0:0	12	->
water	136:32	0:0	12	fc
arg	136:36	136:48	11	AV_LOG_TRACE
water	136:36	0:0	12	AV_LOG_TRACE
arg	136:50	137:65	11	"AVIndex stream %d, sample %d, offset %"PRIx64", dts %"PRId64", ""size %d, distance %d, keyframe %d\n"
water	136:50	0:0	12	"AVIndex stream %d, sample %d, offset %"
water	136:90	0:0	12	PRIx64
water	136:96	0:0	12	", dts %"
water	136:105	0:0	12	PRId64
water	136:111	0:0	12	", "
water	137:28	0:0	12	"size %d, distance %d, keyframe %d\n"
arg	137:67	137:76	11	st->index
water	137:67	0:0	12	st
op	137:69	0:0	12	->
water	137:71	0:0	12	index
arg	137:78	137:92	11	current_sample
water	137:78	0:0	12	current_sample
arg	138:28	138:42	11	current_offset
water	138:28	0:0	12	current_offset
arg	138:44	138:55	11	current_dts
water	138:44	0:0	12	current_dts
arg	138:57	138:68	11	sample_size
water	138:57	0:0	12	sample_size
arg	138:70	138:78	11	distance
water	138:70	0:0	12	distance
arg	138:80	138:88	11	keyframe
water	138:80	0:0	12	keyframe
water	138:89	0:0	10	;
if	139:20	140:67	10	(st -> codec -> codec_type == AVMEDIA_TYPE_VIDEO && st -> nb_index_entries < 100)
cond	139:24	139:94	11	st -> codec -> codec_type == AVMEDIA_TYPE_VIDEO && st -> nb_index_entries < 100
water	139:24	0:0	12	st
op	139:26	0:0	12	->
water	139:28	0:0	12	codec
op	139:33	0:0	12	->
water	139:35	0:0	12	codec_type
op	139:46	0:0	12	==
water	139:49	0:0	12	AVMEDIA_TYPE_VIDEO
op	139:68	0:0	12	&&
water	139:71	0:0	12	st
op	139:73	0:0	12	->
water	139:75	0:0	12	nb_index_entries
op	139:92	0:0	12	<
water	139:94	0:0	12	100
stmts	140:24	140:67	11	
call	140:24	140:66	12	ff_rfps_add_frame
arg	140:42	140:49	13	mov->fc
water	140:42	0:0	14	mov
op	140:45	0:0	14	->
water	140:47	0:0	14	fc
arg	140:51	140:53	13	st
water	140:51	0:0	14	st
arg	140:55	140:66	13	current_dts
water	140:55	0:0	14	current_dts
water	140:67	0:0	12	;
water	141:16	0:0	10	}
water	143:16	0:0	8	current_offset
op	143:31	0:0	8	+=
water	143:34	0:0	8	sample_size
water	143:45	0:0	8	;
water	144:16	0:0	8	stream_size
op	144:28	0:0	8	+=
water	144:31	0:0	8	sample_size
water	144:42	0:0	8	;
if	148:16	155:16	8	(sc -> stts_data [ stts_index ] . duration < 0)
cond	148:20	148:57	9	sc -> stts_data [ stts_index ] . duration < 0
water	148:20	0:0	10	sc
op	148:22	0:0	10	->
water	148:24	0:0	10	stts_data
op	148:33	0:0	10	[
water	148:34	0:0	10	stts_index
op	148:44	0:0	10	]
op	148:45	0:0	10	.
water	148:46	0:0	10	duration
op	148:55	0:0	10	<
water	148:57	0:0	10	0
stmts	148:60	155:16	9	
water	148:60	0:0	10	{
call	149:20	152:36	10	av_log
arg	149:27	149:34	11	mov->fc
water	149:27	0:0	12	mov
op	149:30	0:0	12	->
water	149:32	0:0	12	fc
arg	149:36	149:50	11	AV_LOG_WARNING
water	149:36	0:0	12	AV_LOG_WARNING
arg	150:27	150:74	11	"Invalid SampleDelta %d in STTS, at %d st:%d\n"
water	150:27	0:0	12	"Invalid SampleDelta %d in STTS, at %d st:%d\n"
arg	151:27	151:61	11	sc->stts_data[stts_index].duration
water	151:27	0:0	12	sc
op	151:29	0:0	12	->
water	151:31	0:0	12	stts_data
op	151:40	0:0	12	[
water	151:41	0:0	12	stts_index
op	151:51	0:0	12	]
op	151:52	0:0	12	.
water	151:53	0:0	12	duration
arg	151:63	151:73	11	stts_index
water	151:63	0:0	12	stts_index
arg	152:27	152:36	11	st->index
water	152:27	0:0	12	st
op	152:29	0:0	12	->
water	152:31	0:0	12	index
water	152:37	0:0	10	;
water	153:20	0:0	10	dts_correction
op	153:35	0:0	10	+=
water	153:38	0:0	10	sc
op	153:40	0:0	10	->
water	153:42	0:0	10	stts_data
op	153:51	0:0	10	[
water	153:52	0:0	10	stts_index
op	153:62	0:0	10	]
op	153:63	0:0	10	.
water	153:64	0:0	10	duration
op	153:73	0:0	10	-
water	153:75	0:0	10	1
water	153:76	0:0	10	;
water	154:20	0:0	10	sc
op	154:22	0:0	10	->
water	154:24	0:0	10	stts_data
op	154:33	0:0	10	[
water	154:34	0:0	10	stts_index
op	154:44	0:0	10	]
op	154:45	0:0	10	.
water	154:46	0:0	10	duration
op	154:55	0:0	10	=
water	154:57	0:0	10	1
water	154:58	0:0	10	;
water	155:16	0:0	10	}
water	156:16	0:0	8	current_dts
op	156:28	0:0	8	+=
water	156:31	0:0	8	sc
op	156:33	0:0	8	->
water	156:35	0:0	8	stts_data
op	156:44	0:0	8	[
water	156:45	0:0	8	stts_index
op	156:55	0:0	8	]
op	156:56	0:0	8	.
water	156:57	0:0	8	duration
water	156:65	0:0	8	;
if	157:16	160:16	8	(! dts_correction || current_dts + dts_correction > last_dts)
cond	157:20	157:70	9	! dts_correction || current_dts + dts_correction > last_dts
op	157:20	0:0	10	!
water	157:21	0:0	10	dts_correction
op	157:36	0:0	10	||
water	157:39	0:0	10	current_dts
op	157:51	0:0	10	+
water	157:53	0:0	10	dts_correction
op	157:68	0:0	10	>
water	157:70	0:0	10	last_dts
stmts	157:80	160:16	9	
water	157:80	0:0	10	{
water	158:20	0:0	10	current_dts
op	158:32	0:0	10	+=
water	158:35	0:0	10	dts_correction
water	158:49	0:0	10	;
water	159:20	0:0	10	dts_correction
op	159:35	0:0	10	=
water	159:37	0:0	10	0
water	159:38	0:0	10	;
water	160:16	0:0	10	}
else	160:18	164:16	8
stmts	160:23	164:16	9	
water	160:23	0:0	10	{
water	162:20	0:0	10	dts_correction
op	162:35	0:0	10	+=
water	162:38	0:0	10	current_dts
op	162:50	0:0	10	-
water	162:52	0:0	10	last_dts
op	162:61	0:0	10	-
water	162:63	0:0	10	1
water	162:64	0:0	10	;
water	163:20	0:0	10	current_dts
op	163:32	0:0	10	=
water	163:34	0:0	10	last_dts
op	163:43	0:0	10	+
water	163:45	0:0	10	1
water	163:46	0:0	10	;
water	164:16	0:0	10	}
water	165:16	0:0	8	last_dts
op	165:25	0:0	8	=
water	165:27	0:0	8	current_dts
water	165:38	0:0	8	;
water	166:16	0:0	8	distance
op	166:24	0:0	8	++
water	166:26	0:0	8	;
water	167:16	0:0	8	stts_sample
op	167:27	0:0	8	++
water	167:29	0:0	8	;
water	168:16	0:0	8	current_sample
op	168:30	0:0	8	++
water	168:32	0:0	8	;
if	169:16	172:16	8	(stts_index + 1 < sc -> stts_count && stts_sample == sc -> stts_data [ stts_index ] . count)
cond	169:20	169:96	9	stts_index + 1 < sc -> stts_count && stts_sample == sc -> stts_data [ stts_index ] . count
water	169:20	0:0	10	stts_index
op	169:31	0:0	10	+
water	169:33	0:0	10	1
op	169:35	0:0	10	<
water	169:37	0:0	10	sc
op	169:39	0:0	10	->
water	169:41	0:0	10	stts_count
op	169:52	0:0	10	&&
water	169:55	0:0	10	stts_sample
op	169:67	0:0	10	==
water	169:70	0:0	10	sc
op	169:72	0:0	10	->
water	169:74	0:0	10	stts_data
op	169:83	0:0	10	[
water	169:84	0:0	10	stts_index
op	169:94	0:0	10	]
op	169:95	0:0	10	.
water	169:96	0:0	10	count
stmts	169:103	172:16	9	
water	169:103	0:0	10	{
water	170:20	0:0	10	stts_sample
op	170:32	0:0	10	=
water	170:34	0:0	10	0
water	170:35	0:0	10	;
water	171:20	0:0	10	stts_index
op	171:30	0:0	10	++
water	171:32	0:0	10	;
water	172:16	0:0	10	}
water	173:12	0:0	8	}
water	174:8	0:0	6	}
if	175:8	176:75	4	(st -> duration > 0)
cond	175:12	175:27	5	st -> duration > 0
water	175:12	0:0	6	st
op	175:14	0:0	6	->
water	175:16	0:0	6	duration
op	175:25	0:0	6	>
water	175:27	0:0	6	0
stmts	176:12	176:75	5	
water	176:12	0:0	6	st
op	176:14	0:0	6	->
water	176:16	0:0	6	codec
op	176:21	0:0	6	->
water	176:23	0:0	6	bit_rate
op	176:32	0:0	6	=
water	176:34	0:0	6	stream_size
op	176:45	0:0	6	*
water	176:46	0:0	6	8
op	176:47	0:0	6	*
water	176:48	0:0	6	sc
op	176:50	0:0	6	->
water	176:52	0:0	6	time_scale
op	176:62	0:0	6	/
water	176:63	0:0	6	st
op	176:65	0:0	6	->
water	176:67	0:0	6	duration
water	176:75	0:0	6	;
water	177:4	0:0	4	}
else	177:6	270:4	2
stmts	177:11	270:4	3	
water	177:11	0:0	4	{
water	178:8	0:0	4	unsigned
water	178:17	0:0	4	chunk_samples
water	178:30	0:0	4	,
water	178:32	0:0	4	total
op	178:38	0:0	4	=
water	178:40	0:0	4	0
water	178:41	0:0	4	;
for	181:8	205:8	4	(i = 0 ;i < sc -> stsc_count;i ++)
forinit	181:13	181:18	5	i = 0 ;
water	181:13	0:0	6	i
op	181:15	0:0	6	=
water	181:17	0:0	6	0
water	181:18	0:0	6	;
cond	181:20	181:28	5	i < sc -> stsc_count
water	181:20	0:0	6	i
op	181:22	0:0	6	<
water	181:24	0:0	6	sc
op	181:26	0:0	6	->
water	181:28	0:0	6	stsc_count
forexpr	181:40	181:41	5	i ++
water	181:40	0:0	6	i
op	181:41	0:0	6	++
stmts	181:45	205:8	5	
water	181:45	0:0	6	{
water	182:12	0:0	6	unsigned
water	182:21	0:0	6	count
water	182:26	0:0	6	,
water	182:28	0:0	6	chunk_count
water	182:39	0:0	6	;
water	184:12	0:0	6	chunk_samples
op	184:26	0:0	6	=
water	184:28	0:0	6	sc
op	184:30	0:0	6	->
water	184:32	0:0	6	stsc_data
op	184:41	0:0	6	[
water	184:42	0:0	6	i
op	184:43	0:0	6	]
op	184:44	0:0	6	.
water	184:45	0:0	6	count
water	184:50	0:0	6	;
if	185:12	189:12	6	(i != sc -> stsc_count - 1 && sc -> samples_per_frame && chunk_samples % sc -> samples_per_frame)
cond	185:16	186:61	7	i != sc -> stsc_count - 1 && sc -> samples_per_frame && chunk_samples % sc -> samples_per_frame
water	185:16	0:0	8	i
op	185:18	0:0	8	!=
water	185:21	0:0	8	sc
op	185:23	0:0	8	->
water	185:25	0:0	8	stsc_count
op	185:36	0:0	8	-
water	185:38	0:0	8	1
op	185:40	0:0	8	&&
water	186:16	0:0	8	sc
op	186:18	0:0	8	->
water	186:20	0:0	8	samples_per_frame
op	186:38	0:0	8	&&
water	186:41	0:0	8	chunk_samples
op	186:55	0:0	8	%
water	186:57	0:0	8	sc
op	186:59	0:0	8	->
water	186:61	0:0	8	samples_per_frame
stmts	186:80	189:12	7	
water	186:80	0:0	8	{
call	187:16	187:71	8	av_log
arg	187:23	187:30	9	mov->fc
water	187:23	0:0	10	mov
op	187:26	0:0	10	->
water	187:28	0:0	10	fc
arg	187:32	187:44	9	AV_LOG_ERROR
water	187:32	0:0	10	AV_LOG_ERROR
arg	187:46	187:71	9	"error unaligned chunk\n"
water	187:46	0:0	10	"error unaligned chunk\n"
water	187:72	0:0	8	;
return	188:16	188:22	8	
water	189:12	0:0	8	}
if	191:12	193:12	6	(sc -> samples_per_frame >= 160)
cond	191:16	191:41	7	sc -> samples_per_frame >= 160
water	191:16	0:0	8	sc
op	191:18	0:0	8	->
water	191:20	0:0	8	samples_per_frame
op	191:38	0:0	8	>=
water	191:41	0:0	8	160
stmts	191:46	193:12	7	
water	191:46	0:0	8	{
water	192:16	0:0	8	count
op	192:22	0:0	8	=
water	192:24	0:0	8	chunk_samples
op	192:38	0:0	8	/
water	192:40	0:0	8	sc
op	192:42	0:0	8	->
water	192:44	0:0	8	samples_per_frame
water	192:61	0:0	8	;
water	193:12	0:0	8	}
else	193:14	196:12	6
stmts	193:19	196:12	7	
if	193:19	196:12	8	(sc -> samples_per_frame > 1)
cond	193:23	193:47	9	sc -> samples_per_frame > 1
water	193:23	0:0	10	sc
op	193:25	0:0	10	->
water	193:27	0:0	10	samples_per_frame
op	193:45	0:0	10	>
water	193:47	0:0	10	1
stmts	193:50	196:12	9	
water	193:50	0:0	10	{
water	194:16	0:0	10	unsigned
water	194:25	0:0	10	samples
op	194:33	0:0	10	=
water	194:35	0:0	10	(
water	194:36	0:0	10	1024
op	194:40	0:0	10	/
water	194:41	0:0	10	sc
op	194:43	0:0	10	->
water	194:45	0:0	10	samples_per_frame
water	194:62	0:0	10	)
op	194:63	0:0	10	*
water	194:64	0:0	10	sc
op	194:66	0:0	10	->
water	194:68	0:0	10	samples_per_frame
water	194:85	0:0	10	;
water	195:16	0:0	10	count
op	195:22	0:0	10	=
water	195:24	0:0	10	(
water	195:25	0:0	10	chunk_samples
op	195:38	0:0	10	+
water	195:39	0:0	10	samples
op	195:46	0:0	10	-
water	195:47	0:0	10	1
water	195:48	0:0	10	)
op	195:50	0:0	10	/
water	195:52	0:0	10	samples
water	195:59	0:0	10	;
water	196:12	0:0	10	}
else	196:14	198:12	6
stmts	196:19	198:12	7	
water	196:19	0:0	8	{
water	197:16	0:0	8	count
op	197:22	0:0	8	=
water	197:24	0:0	8	(
water	197:25	0:0	8	chunk_samples
op	197:38	0:0	8	+
water	197:39	0:0	8	1023
water	197:43	0:0	8	)
op	197:45	0:0	8	/
water	197:47	0:0	8	1024
water	197:51	0:0	8	;
water	198:12	0:0	8	}
if	200:12	201:79	6	(i < sc -> stsc_count - 1)
cond	200:16	200:37	7	i < sc -> stsc_count - 1
water	200:16	0:0	8	i
op	200:18	0:0	8	<
water	200:20	0:0	8	sc
op	200:22	0:0	8	->
water	200:24	0:0	8	stsc_count
op	200:35	0:0	8	-
water	200:37	0:0	8	1
stmts	201:16	201:79	7	
water	201:16	0:0	8	chunk_count
op	201:28	0:0	8	=
water	201:30	0:0	8	sc
op	201:32	0:0	8	->
water	201:34	0:0	8	stsc_data
op	201:43	0:0	8	[
water	201:44	0:0	8	i
op	201:45	0:0	8	+
water	201:46	0:0	8	1
op	201:47	0:0	8	]
op	201:48	0:0	8	.
water	201:49	0:0	8	first
op	201:55	0:0	8	-
water	201:57	0:0	8	sc
op	201:59	0:0	8	->
water	201:61	0:0	8	stsc_data
op	201:70	0:0	8	[
water	201:71	0:0	8	i
op	201:72	0:0	8	]
op	201:73	0:0	8	.
water	201:74	0:0	8	first
water	201:79	0:0	8	;
else	202:12	203:76	6
stmts	203:16	203:76	7	
water	203:16	0:0	8	chunk_count
op	203:28	0:0	8	=
water	203:30	0:0	8	sc
op	203:32	0:0	8	->
water	203:34	0:0	8	chunk_count
op	203:46	0:0	8	-
water	203:48	0:0	8	(
water	203:49	0:0	8	sc
op	203:51	0:0	8	->
water	203:53	0:0	8	stsc_data
op	203:62	0:0	8	[
water	203:63	0:0	8	i
op	203:64	0:0	8	]
op	203:65	0:0	8	.
water	203:66	0:0	8	first
op	203:72	0:0	8	-
water	203:74	0:0	8	1
water	203:75	0:0	8	)
water	203:76	0:0	8	;
water	204:12	0:0	6	total
op	204:18	0:0	6	+=
water	204:21	0:0	6	chunk_count
op	204:33	0:0	6	*
water	204:35	0:0	6	count
water	204:40	0:0	6	;
water	205:8	0:0	6	}
call	207:8	207:63	4	av_log
arg	207:15	207:22	5	mov->fc
water	207:15	0:0	6	mov
op	207:18	0:0	6	->
water	207:20	0:0	6	fc
arg	207:24	207:36	5	AV_LOG_TRACE
water	207:24	0:0	6	AV_LOG_TRACE
arg	207:38	207:56	5	"chunk count %d\n"
water	207:38	0:0	6	"chunk count %d\n"
arg	207:58	207:63	5	total
water	207:58	0:0	6	total
water	207:64	0:0	4	;
if	208:8	209:18	4	(total >= UINT_MAX / sizeof ( * st -> index_entries ) - st -> nb_index_entries)
cond	208:12	208:65	5	total >= UINT_MAX / sizeof ( * st -> index_entries ) - st -> nb_index_entries
water	208:12	0:0	6	total
op	208:18	0:0	6	>=
water	208:21	0:0	6	UINT_MAX
op	208:30	0:0	6	/
op	208:32	0:0	6	sizeof
water	208:38	0:0	6	(
op	208:39	0:0	6	*
water	208:40	0:0	6	st
op	208:42	0:0	6	->
water	208:44	0:0	6	index_entries
water	208:57	0:0	6	)
op	208:59	0:0	6	-
water	208:61	0:0	6	st
op	208:63	0:0	6	->
water	208:65	0:0	6	nb_index_entries
stmts	209:12	209:18	5	
return	209:12	209:18	6	
if	210:8	215:8	4	(av_reallocp_array (& st -> index_entries ,st -> nb_index_entries + total ,sizeof ( * st -> index_entries ) ) < 0)
cond	210:12	212:60	5	av_reallocp_array (& st -> index_entries ,st -> nb_index_entries + total ,sizeof ( * st -> index_entries ) ) < 0
call	210:12	212:56	6	av_reallocp_array
arg	210:30	210:48	7	&st->index_entries
op	210:30	0:0	8	&
water	210:31	0:0	8	st
op	210:33	0:0	8	->
water	210:35	0:0	8	index_entries
arg	211:30	211:58	7	st->nb_index_entries+total
water	211:30	0:0	8	st
op	211:32	0:0	8	->
water	211:34	0:0	8	nb_index_entries
op	211:51	0:0	8	+
water	211:53	0:0	8	total
arg	212:30	212:56	7	sizeof(*st->index_entries)
op	212:30	0:0	8	sizeof
water	212:36	0:0	8	(
op	212:37	0:0	8	*
water	212:38	0:0	8	st
op	212:40	0:0	8	->
water	212:42	0:0	8	index_entries
water	212:55	0:0	8	)
op	212:58	0:0	6	<
water	212:60	0:0	6	0
stmts	212:63	215:8	5	
water	212:63	0:0	6	{
water	213:12	0:0	6	st
op	213:14	0:0	6	->
water	213:16	0:0	6	nb_index_entries
op	213:33	0:0	6	=
water	213:35	0:0	6	0
water	213:36	0:0	6	;
return	214:12	214:18	6	
water	215:8	0:0	6	}
water	216:8	0:0	4	st
op	216:10	0:0	4	->
water	216:12	0:0	4	index_entries_allocated_size
op	216:41	0:0	4	=
water	216:43	0:0	4	(
water	216:44	0:0	4	st
op	216:46	0:0	4	->
water	216:48	0:0	4	nb_index_entries
op	216:65	0:0	4	+
water	216:67	0:0	4	total
water	216:72	0:0	4	)
op	216:74	0:0	4	*
op	216:76	0:0	4	sizeof
water	216:82	0:0	4	(
op	216:83	0:0	4	*
water	216:84	0:0	4	st
op	216:86	0:0	4	->
water	216:88	0:0	4	index_entries
water	216:101	0:0	4	)
water	216:102	0:0	4	;
for	219:8	269:8	4	(i = 0 ;i < sc -> chunk_count;i ++)
forinit	219:13	219:18	5	i = 0 ;
water	219:13	0:0	6	i
op	219:15	0:0	6	=
water	219:17	0:0	6	0
water	219:18	0:0	6	;
cond	219:20	219:28	5	i < sc -> chunk_count
water	219:20	0:0	6	i
op	219:22	0:0	6	<
water	219:24	0:0	6	sc
op	219:26	0:0	6	->
water	219:28	0:0	6	chunk_count
forexpr	219:41	219:42	5	i ++
water	219:41	0:0	6	i
op	219:42	0:0	6	++
stmts	219:46	269:8	5	
water	219:46	0:0	6	{
water	220:12	0:0	6	current_offset
op	220:27	0:0	6	=
water	220:29	0:0	6	sc
op	220:31	0:0	6	->
water	220:33	0:0	6	chunk_offsets
op	220:46	0:0	6	[
water	220:47	0:0	6	i
op	220:48	0:0	6	]
water	220:49	0:0	6	;
if	221:12	223:28	6	(stsc_index + 1 < sc -> stsc_count && i + 1 == sc -> stsc_data [ stsc_index + 1 ] . first)
cond	221:16	222:55	7	stsc_index + 1 < sc -> stsc_count && i + 1 == sc -> stsc_data [ stsc_index + 1 ] . first
water	221:16	0:0	8	stsc_index
op	221:27	0:0	8	+
water	221:29	0:0	8	1
op	221:31	0:0	8	<
water	221:33	0:0	8	sc
op	221:35	0:0	8	->
water	221:37	0:0	8	stsc_count
op	221:48	0:0	8	&&
water	222:16	0:0	8	i
op	222:18	0:0	8	+
water	222:20	0:0	8	1
op	222:22	0:0	8	==
water	222:25	0:0	8	sc
op	222:27	0:0	8	->
water	222:29	0:0	8	stsc_data
op	222:38	0:0	8	[
water	222:39	0:0	8	stsc_index
op	222:50	0:0	8	+
water	222:52	0:0	8	1
op	222:53	0:0	8	]
op	222:54	0:0	8	.
water	222:55	0:0	8	first
stmts	223:16	223:28	7	
water	223:16	0:0	8	stsc_index
op	223:26	0:0	8	++
water	223:28	0:0	8	;
water	224:12	0:0	6	chunk_samples
op	224:26	0:0	6	=
water	224:28	0:0	6	sc
op	224:30	0:0	6	->
water	224:32	0:0	6	stsc_data
op	224:41	0:0	6	[
water	224:42	0:0	6	stsc_index
op	224:52	0:0	6	]
op	224:53	0:0	6	.
water	224:54	0:0	6	count
water	224:59	0:0	6	;
while	226:12	268:12	6	(chunk_samples > 0)
cond	226:19	226:35	7	chunk_samples > 0
water	226:19	0:0	8	chunk_samples
op	226:33	0:0	8	>
water	226:35	0:0	8	0
stmts	226:38	268:12	7	
water	226:38	0:0	8	{
decl	227:16	227:31	8	AVIndexEntry	*e
water	228:16	0:0	8	unsigned
water	228:25	0:0	8	size
water	228:29	0:0	8	,
water	228:31	0:0	8	samples
water	228:38	0:0	8	;
if	230:16	235:16	8	(sc -> samples_per_frame > 1 && ! sc -> bytes_per_frame)
cond	230:20	230:54	9	sc -> samples_per_frame > 1 && ! sc -> bytes_per_frame
water	230:20	0:0	10	sc
op	230:22	0:0	10	->
water	230:24	0:0	10	samples_per_frame
op	230:42	0:0	10	>
water	230:44	0:0	10	1
op	230:46	0:0	10	&&
op	230:49	0:0	10	!
water	230:50	0:0	10	sc
op	230:52	0:0	10	->
water	230:54	0:0	10	bytes_per_frame
stmts	230:71	235:16	9	
water	230:71	0:0	10	{
call	231:20	233:48	10	avpriv_request_sample
arg	231:42	231:49	11	mov->fc
water	231:42	0:0	12	mov
op	231:45	0:0	12	->
water	231:47	0:0	12	fc
arg	232:27	232:75	11	"Zero bytes per frame, but %d samples per frame"
water	232:27	0:0	12	"Zero bytes per frame, but %d samples per frame"
arg	233:27	233:48	11	sc->samples_per_frame
water	233:27	0:0	12	sc
op	233:29	0:0	12	->
water	233:31	0:0	12	samples_per_frame
water	233:49	0:0	10	;
return	234:20	234:26	10	
water	235:16	0:0	10	}
if	237:16	240:16	8	(sc -> samples_per_frame >= 160)
cond	237:20	237:45	9	sc -> samples_per_frame >= 160
water	237:20	0:0	10	sc
op	237:22	0:0	10	->
water	237:24	0:0	10	samples_per_frame
op	237:42	0:0	10	>=
water	237:45	0:0	10	160
stmts	237:50	240:16	9	
water	237:50	0:0	10	{
water	238:20	0:0	10	samples
op	238:28	0:0	10	=
water	238:30	0:0	10	sc
op	238:32	0:0	10	->
water	238:34	0:0	10	samples_per_frame
water	238:51	0:0	10	;
water	239:20	0:0	10	size
op	239:25	0:0	10	=
water	239:27	0:0	10	sc
op	239:29	0:0	10	->
water	239:31	0:0	10	bytes_per_frame
water	239:46	0:0	10	;
water	240:16	0:0	10	}
else	240:18	249:16	8
stmts	240:23	249:16	9	
water	240:23	0:0	10	{
if	241:20	245:20	10	(sc -> samples_per_frame > 1)
cond	241:24	241:48	11	sc -> samples_per_frame > 1
water	241:24	0:0	12	sc
op	241:26	0:0	12	->
water	241:28	0:0	12	samples_per_frame
op	241:46	0:0	12	>
water	241:48	0:0	12	1
stmts	241:51	245:20	11	
water	241:51	0:0	12	{
water	242:24	0:0	12	samples
op	242:32	0:0	12	=
call	242:34	243:76	12	FFMIN
arg	242:40	243:61	13	(1024/sc->samples_per_frame)*sc->samples_per_frame
water	242:40	0:0	14	(
water	242:41	0:0	14	1024
op	242:46	0:0	14	/
water	242:48	0:0	14	sc
op	242:50	0:0	14	->
water	242:52	0:0	14	samples_per_frame
water	242:69	0:0	14	)
op	242:70	0:0	14	*
water	243:40	0:0	14	sc
op	243:42	0:0	14	->
water	243:44	0:0	14	samples_per_frame
arg	243:63	243:76	13	chunk_samples
water	243:63	0:0	14	chunk_samples
water	243:77	0:0	12	;
water	244:24	0:0	12	size
op	244:29	0:0	12	=
water	244:31	0:0	12	(
water	244:32	0:0	12	samples
op	244:40	0:0	12	/
water	244:42	0:0	12	sc
op	244:44	0:0	12	->
water	244:46	0:0	12	samples_per_frame
water	244:63	0:0	12	)
op	244:65	0:0	12	*
water	244:67	0:0	12	sc
op	244:69	0:0	12	->
water	244:71	0:0	12	bytes_per_frame
water	244:86	0:0	12	;
water	245:20	0:0	12	}
else	245:22	248:20	10
stmts	245:27	248:20	11	
water	245:27	0:0	12	{
water	246:24	0:0	12	samples
op	246:32	0:0	12	=
call	246:34	246:59	12	FFMIN
arg	246:40	246:44	13	1024
water	246:40	0:0	14	1024
arg	246:46	246:59	13	chunk_samples
water	246:46	0:0	14	chunk_samples
water	246:60	0:0	12	;
water	247:24	0:0	12	size
op	247:29	0:0	12	=
water	247:31	0:0	12	samples
op	247:39	0:0	12	*
water	247:41	0:0	12	sc
op	247:43	0:0	12	->
water	247:45	0:0	12	sample_size
water	247:56	0:0	12	;
water	248:20	0:0	12	}
water	249:16	0:0	10	}
if	251:16	254:16	8	(st -> nb_index_entries >= total)
cond	251:20	251:44	9	st -> nb_index_entries >= total
water	251:20	0:0	10	st
op	251:22	0:0	10	->
water	251:24	0:0	10	nb_index_entries
op	251:41	0:0	10	>=
water	251:44	0:0	10	total
stmts	251:51	254:16	9	
water	251:51	0:0	10	{
call	252:20	252:81	10	av_log
arg	252:27	252:34	11	mov->fc
water	252:27	0:0	12	mov
op	252:30	0:0	12	->
water	252:32	0:0	12	fc
arg	252:36	252:48	11	AV_LOG_ERROR
water	252:36	0:0	12	AV_LOG_ERROR
arg	252:50	252:74	11	"wrong chunk count %d\n"
water	252:50	0:0	12	"wrong chunk count %d\n"
arg	252:76	252:81	11	total
water	252:76	0:0	12	total
water	252:82	0:0	10	;
return	253:20	253:26	10	
water	254:16	0:0	10	}
water	255:16	0:0	8	e
op	255:18	0:0	8	=
op	255:20	0:0	8	&
water	255:21	0:0	8	st
op	255:23	0:0	8	->
water	255:25	0:0	8	index_entries
op	255:38	0:0	8	[
water	255:39	0:0	8	st
op	255:41	0:0	8	->
water	255:43	0:0	8	nb_index_entries
op	255:59	0:0	8	++
op	255:61	0:0	8	]
water	255:62	0:0	8	;
water	256:16	0:0	8	e
op	256:17	0:0	8	->
water	256:19	0:0	8	pos
op	256:23	0:0	8	=
water	256:25	0:0	8	current_offset
water	256:39	0:0	8	;
water	257:16	0:0	8	e
op	257:17	0:0	8	->
water	257:19	0:0	8	timestamp
op	257:29	0:0	8	=
water	257:31	0:0	8	current_dts
water	257:42	0:0	8	;
water	258:16	0:0	8	e
op	258:17	0:0	8	->
water	258:19	0:0	8	size
op	258:24	0:0	8	=
water	258:26	0:0	8	size
water	258:30	0:0	8	;
water	259:16	0:0	8	e
op	259:17	0:0	8	->
water	259:19	0:0	8	min_distance
op	259:32	0:0	8	=
water	259:34	0:0	8	0
water	259:35	0:0	8	;
water	260:16	0:0	8	e
op	260:17	0:0	8	->
water	260:19	0:0	8	flags
op	260:25	0:0	8	=
water	260:27	0:0	8	AVINDEX_KEYFRAME
water	260:43	0:0	8	;
call	261:16	263:37	8	av_log
arg	261:23	261:30	9	mov->fc
water	261:23	0:0	10	mov
op	261:26	0:0	10	->
water	261:28	0:0	10	fc
arg	261:32	261:44	9	AV_LOG_TRACE
water	261:32	0:0	10	AV_LOG_TRACE
arg	261:46	262:48	9	"AVIndex stream %d, chunk %d, offset %"PRIx64", dts %"PRId64", ""size %d, duration %d\n"
water	261:46	0:0	10	"AVIndex stream %d, chunk %d, offset %"
water	261:85	0:0	10	PRIx64
water	261:91	0:0	10	", dts %"
water	261:100	0:0	10	PRId64
water	261:106	0:0	10	", "
water	262:24	0:0	10	"size %d, duration %d\n"
arg	262:50	262:59	9	st->index
water	262:50	0:0	10	st
op	262:52	0:0	10	->
water	262:54	0:0	10	index
arg	262:61	262:62	9	i
water	262:61	0:0	10	i
arg	262:64	262:78	9	current_offset
water	262:64	0:0	10	current_offset
arg	262:80	262:91	9	current_dts
water	262:80	0:0	10	current_dts
arg	263:24	263:28	9	size
water	263:24	0:0	10	size
arg	263:30	263:37	9	samples
water	263:30	0:0	10	samples
water	263:38	0:0	8	;
water	265:16	0:0	8	current_offset
op	265:31	0:0	8	+=
water	265:34	0:0	8	size
water	265:38	0:0	8	;
water	266:16	0:0	8	current_dts
op	266:28	0:0	8	+=
water	266:31	0:0	8	samples
water	266:38	0:0	8	;
water	267:16	0:0	8	chunk_samples
op	267:30	0:0	8	-=
water	267:33	0:0	8	samples
water	267:40	0:0	8	;
water	268:12	0:0	8	}
water	269:8	0:0	6	}
water	270:4	0:0	4	}
