func	2:0	203:0	0	int	ff_rv34_decode_frame
params	2:24	0:0	1	
param	2:25	2:46	2	AVCodecContext *	avctx
param	3:28	3:38	2	void *	data
param	3:40	3:60	2	int *	got_picture_ptr
param	4:28	4:43	2	AVPacket *	avpkt
stmnts	0:0	202:22	1	
decl	6:4	6:36	2	const uint8_t	*buf
op	6:23	0:0	2	=
water	6:25	0:0	2	avpkt
op	6:30	0:0	2	->
water	6:32	0:0	2	data
decl	7:4	7:30	2	int	buf_size
op	7:17	0:0	2	=
water	7:19	0:0	2	avpkt
op	7:24	0:0	2	->
water	7:26	0:0	2	size
decl	8:4	8:40	2	RV34DecContext	*r
op	8:22	0:0	2	=
water	8:24	0:0	2	avctx
op	8:29	0:0	2	->
water	8:31	0:0	2	priv_data
decl	9:4	9:29	2	MpegEncContext	*s
op	9:22	0:0	2	=
op	9:24	0:0	2	&
water	9:25	0:0	2	r
op	9:26	0:0	2	->
water	9:28	0:0	2	s
decl	10:4	10:24	2	AVFrame	*pict
op	10:18	0:0	2	=
water	10:20	0:0	2	data
decl	11:4	11:16	2	SliceInfo	si
decl	12:4	12:14	2	int	i
water	12:9	0:0	2	,
decl	12:4	12:14	2	int	ret
decl	13:4	13:19	2	int	slice_count
decl	14:4	14:36	2	const uint8_t	*slices_hdr
op	14:30	0:0	2	=
water	14:32	0:0	2	NULL
decl	15:4	15:16	2	int	last
op	15:13	0:0	2	=
water	15:15	0:0	2	0
decl	16:4	16:20	2	int	faulty_b
op	16:17	0:0	2	=
water	16:19	0:0	2	0
decl	17:4	17:14	2	int	offset
if	20:4	30:4	2	(buf_size == 0)
cond	20:8	20:20	3	buf_size == 0
water	20:8	0:0	4	buf_size
op	20:17	0:0	4	==
water	20:20	0:0	4	0
stmts	20:23	30:4	3	
water	20:23	0:0	4	{
if	22:8	28:8	4	(s -> low_delay == 0 && s -> next_picture_ptr)
cond	22:12	22:34	5	s -> low_delay == 0 && s -> next_picture_ptr
water	22:12	0:0	6	s
op	22:13	0:0	6	->
water	22:15	0:0	6	low_delay
op	22:24	0:0	6	==
water	22:26	0:0	6	0
op	22:28	0:0	6	&&
water	22:31	0:0	6	s
op	22:32	0:0	6	->
water	22:34	0:0	6	next_picture_ptr
stmts	22:52	28:8	5	
water	22:52	0:0	6	{
if	23:12	24:26	6	(( ret =av_frame_ref (pict ,s -> next_picture_ptr -> f ) ) < 0)
cond	23:16	23:69	7	( ret =av_frame_ref (pict ,s -> next_picture_ptr -> f ) ) < 0
water	23:16	0:0	8	(
water	23:17	0:0	8	ret
op	23:21	0:0	8	=
call	23:23	23:64	8	av_frame_ref
arg	23:36	23:40	9	pict
water	23:36	0:0	10	pict
arg	23:42	23:64	9	s->next_picture_ptr->f
water	23:42	0:0	10	s
op	23:43	0:0	10	->
water	23:45	0:0	10	next_picture_ptr
op	23:61	0:0	10	->
water	23:63	0:0	10	f
water	23:65	0:0	8	)
op	23:67	0:0	8	<
water	23:69	0:0	8	0
stmts	24:16	24:26	7	
return	24:16	24:26	8	ret
water	24:23	0:0	9	ret
water	25:12	0:0	6	s
op	25:13	0:0	6	->
water	25:15	0:0	6	next_picture_ptr
op	25:32	0:0	6	=
water	25:34	0:0	6	NULL
water	25:38	0:0	6	;
op	27:12	0:0	6	*
water	27:13	0:0	6	got_picture_ptr
op	27:29	0:0	6	=
water	27:31	0:0	6	1
water	27:32	0:0	6	;
water	28:8	0:0	6	}
return	29:8	29:16	4	0
water	29:15	0:0	5	0
water	30:4	0:0	4	}
if	32:4	37:4	2	(! avctx -> slice_count)
cond	32:7	32:15	3	! avctx -> slice_count
op	32:7	0:0	4	!
water	32:8	0:0	4	avctx
op	32:13	0:0	4	->
water	32:15	0:0	4	slice_count
stmts	32:27	37:4	3	
water	32:27	0:0	4	{
water	33:8	0:0	4	slice_count
op	33:20	0:0	4	=
water	33:22	0:0	4	(
op	33:23	0:0	4	*
water	33:24	0:0	4	buf
op	33:27	0:0	4	++
water	33:29	0:0	4	)
op	33:31	0:0	4	+
water	33:33	0:0	4	1
water	33:34	0:0	4	;
water	34:8	0:0	4	slices_hdr
op	34:19	0:0	4	=
water	34:21	0:0	4	buf
op	34:25	0:0	4	+
water	34:27	0:0	4	4
water	34:28	0:0	4	;
water	35:8	0:0	4	buf
op	35:12	0:0	4	+=
water	35:15	0:0	4	8
op	35:17	0:0	4	*
water	35:19	0:0	4	slice_count
water	35:30	0:0	4	;
water	36:8	0:0	4	buf_size
op	36:17	0:0	4	-=
water	36:20	0:0	4	1
op	36:22	0:0	4	+
water	36:24	0:0	4	8
op	36:26	0:0	4	*
water	36:28	0:0	4	slice_count
water	36:39	0:0	4	;
water	37:4	0:0	4	}
else	37:5	38:40	2
stmts	38:8	38:40	3	
water	38:8	0:0	4	slice_count
op	38:20	0:0	4	=
water	38:22	0:0	4	avctx
op	38:27	0:0	4	->
water	38:29	0:0	4	slice_count
water	38:40	0:0	4	;
water	40:4	0:0	2	offset
op	40:11	0:0	2	=
call	40:13	40:73	2	get_slice_offset
arg	40:30	40:35	3	avctx
water	40:30	0:0	4	avctx
arg	40:37	40:47	3	slices_hdr
water	40:37	0:0	4	slices_hdr
arg	40:49	40:50	3	0
water	40:49	0:0	4	0
arg	40:52	40:63	3	slice_count
water	40:52	0:0	4	slice_count
arg	40:65	40:73	3	buf_size
water	40:65	0:0	4	buf_size
water	40:74	0:0	2	;
if	42:4	45:4	2	(offset < 0 || offset > buf_size)
cond	42:7	42:30	3	offset < 0 || offset > buf_size
water	42:7	0:0	4	offset
op	42:14	0:0	4	<
water	42:16	0:0	4	0
op	42:18	0:0	4	||
water	42:21	0:0	4	offset
op	42:28	0:0	4	>
water	42:30	0:0	4	buf_size
stmts	42:39	45:4	3	
water	42:39	0:0	4	{
call	43:8	43:63	4	av_log
arg	43:15	43:20	5	avctx
water	43:15	0:0	6	avctx
arg	43:22	43:34	5	AV_LOG_ERROR
water	43:22	0:0	6	AV_LOG_ERROR
arg	43:36	43:63	5	"Slice offset is invalid\n"
water	43:36	0:0	6	"Slice offset is invalid\n"
water	43:64	0:0	4	;
return	44:8	44:34	4	AVERROR_INVALIDDATA
water	44:15	0:0	5	AVERROR_INVALIDDATA
water	45:4	0:0	4	}
call	46:4	46:57	2	init_get_bits
arg	46:18	46:24	3	&s->gb
op	46:18	0:0	4	&
water	46:19	0:0	4	s
op	46:20	0:0	4	->
water	46:22	0:0	4	gb
arg	46:26	46:36	3	buf+offset
water	46:26	0:0	4	buf
op	46:29	0:0	4	+
water	46:30	0:0	4	offset
arg	46:38	46:57	3	(buf_size-offset)*8
water	46:38	0:0	4	(
water	46:39	0:0	4	buf_size
op	46:47	0:0	4	-
water	46:48	0:0	4	offset
water	46:54	0:0	4	)
op	46:55	0:0	4	*
water	46:56	0:0	4	8
water	46:58	0:0	2	;
if	47:4	50:4	2	(r -> parse_slice_header (r ,& r -> s . gb ,& si ) < 0 || si . start)
cond	47:7	47:57	3	r -> parse_slice_header (r ,& r -> s . gb ,& si ) < 0 || si . start
call	47:7	47:45	4	r->parse_slice_header
arg	47:29	47:30	5	r
water	47:29	0:0	6	r
arg	47:32	47:40	5	&r->s.gb
op	47:32	0:0	6	&
water	47:33	0:0	6	r
op	47:34	0:0	6	->
water	47:36	0:0	6	s
op	47:37	0:0	6	.
water	47:38	0:0	6	gb
arg	47:42	47:45	5	&si
op	47:42	0:0	6	&
water	47:43	0:0	6	si
op	47:47	0:0	4	<
water	47:49	0:0	4	0
op	47:51	0:0	4	||
water	47:54	0:0	4	si
op	47:56	0:0	4	.
water	47:57	0:0	4	start
stmts	47:63	50:4	3	
water	47:63	0:0	4	{
call	48:8	48:71	4	av_log
arg	48:15	48:20	5	avctx
water	48:15	0:0	6	avctx
arg	48:22	48:34	5	AV_LOG_ERROR
water	48:22	0:0	6	AV_LOG_ERROR
arg	48:36	48:71	5	"First slice header is incorrect\n"
water	48:36	0:0	6	"First slice header is incorrect\n"
water	48:72	0:0	4	;
return	49:8	49:34	4	AVERROR_INVALIDDATA
water	49:15	0:0	5	AVERROR_INVALIDDATA
water	50:4	0:0	4	}
if	51:4	56:4	2	(( ! s -> last_picture_ptr || ! s -> last_picture_ptr -> f -> data [ 0 ] ) && si . type == AV_PICTURE_TYPE_B)
cond	51:8	52:19	3	( ! s -> last_picture_ptr || ! s -> last_picture_ptr -> f -> data [ 0 ] ) && si . type == AV_PICTURE_TYPE_B
water	51:8	0:0	4	(
op	51:9	0:0	4	!
water	51:10	0:0	4	s
op	51:11	0:0	4	->
water	51:13	0:0	4	last_picture_ptr
op	51:30	0:0	4	||
op	51:33	0:0	4	!
water	51:34	0:0	4	s
op	51:35	0:0	4	->
water	51:37	0:0	4	last_picture_ptr
op	51:53	0:0	4	->
water	51:55	0:0	4	f
op	51:56	0:0	4	->
water	51:58	0:0	4	data
op	51:62	0:0	4	[
water	51:63	0:0	4	0
op	51:64	0:0	4	]
water	51:65	0:0	4	)
op	51:67	0:0	4	&&
water	52:8	0:0	4	si
op	52:10	0:0	4	.
water	52:11	0:0	4	type
op	52:16	0:0	4	==
water	52:19	0:0	4	AV_PICTURE_TYPE_B
stmts	52:38	56:4	3	
water	52:38	0:0	4	{
call	53:8	54:34	4	av_log
arg	53:15	53:20	5	avctx
water	53:15	0:0	6	avctx
arg	53:22	53:34	5	AV_LOG_ERROR
water	53:22	0:0	6	AV_LOG_ERROR
arg	53:36	54:34	5	"Invalid decoder state: B-frame without ""reference data.\n"
water	53:36	0:0	6	"Invalid decoder state: B-frame without "
water	54:15	0:0	6	"reference data.\n"
water	54:35	0:0	4	;
water	55:8	0:0	4	faulty_b
op	55:17	0:0	4	=
water	55:19	0:0	4	1
water	55:20	0:0	4	;
water	56:4	0:0	4	}
if	57:4	60:26	2	(( avctx -> skip_frame >= AVDISCARD_NONREF && si . type == AV_PICTURE_TYPE_B ) || ( avctx -> skip_frame >= AVDISCARD_NONKEY && si . type != AV_PICTURE_TYPE_I ) || avctx -> skip_frame >= AVDISCARD_ALL)
cond	57:10	59:32	3	( avctx -> skip_frame >= AVDISCARD_NONREF && si . type == AV_PICTURE_TYPE_B ) || ( avctx -> skip_frame >= AVDISCARD_NONKEY && si . type != AV_PICTURE_TYPE_I ) || avctx -> skip_frame >= AVDISCARD_ALL
water	57:10	0:0	4	(
water	57:11	0:0	4	avctx
op	57:16	0:0	4	->
water	57:18	0:0	4	skip_frame
op	57:29	0:0	4	>=
water	57:32	0:0	4	AVDISCARD_NONREF
op	57:49	0:0	4	&&
water	57:52	0:0	4	si
op	57:54	0:0	4	.
water	57:55	0:0	4	type
op	57:59	0:0	4	==
water	57:61	0:0	4	AV_PICTURE_TYPE_B
water	57:78	0:0	4	)
op	58:7	0:0	4	||
water	58:10	0:0	4	(
water	58:11	0:0	4	avctx
op	58:16	0:0	4	->
water	58:18	0:0	4	skip_frame
op	58:29	0:0	4	>=
water	58:32	0:0	4	AVDISCARD_NONKEY
op	58:49	0:0	4	&&
water	58:52	0:0	4	si
op	58:54	0:0	4	.
water	58:55	0:0	4	type
op	58:59	0:0	4	!=
water	58:61	0:0	4	AV_PICTURE_TYPE_I
water	58:78	0:0	4	)
op	59:7	0:0	4	||
water	59:11	0:0	4	avctx
op	59:16	0:0	4	->
water	59:18	0:0	4	skip_frame
op	59:29	0:0	4	>=
water	59:32	0:0	4	AVDISCARD_ALL
stmts	60:8	60:26	3	
return	60:8	60:26	4	avpkt->size
water	60:15	0:0	5	avpkt
op	60:20	0:0	5	->
water	60:22	0:0	5	size
if	63:4	139:4	2	(si . start == 0)
cond	63:8	63:20	3	si . start == 0
water	63:8	0:0	4	si
op	63:10	0:0	4	.
water	63:11	0:0	4	start
op	63:17	0:0	4	==
water	63:20	0:0	4	0
stmts	63:23	139:4	3	
water	63:23	0:0	4	{
if	64:8	69:8	4	(s -> mb_num_left > 0 && s -> current_picture_ptr)
cond	64:12	64:37	5	s -> mb_num_left > 0 && s -> current_picture_ptr
water	64:12	0:0	6	s
op	64:13	0:0	6	->
water	64:15	0:0	6	mb_num_left
op	64:27	0:0	6	>
water	64:29	0:0	6	0
op	64:31	0:0	6	&&
water	64:34	0:0	6	s
op	64:35	0:0	6	->
water	64:37	0:0	6	current_picture_ptr
stmts	64:58	69:8	5	
water	64:58	0:0	6	{
call	65:12	66:33	6	av_log
arg	65:19	65:24	7	avctx
water	65:19	0:0	8	avctx
arg	65:26	65:38	7	AV_LOG_ERROR
water	65:26	0:0	8	AV_LOG_ERROR
arg	65:40	65:75	7	"New frame but still %d MB left.\n"
water	65:40	0:0	8	"New frame but still %d MB left.\n"
arg	66:19	66:33	7	s->mb_num_left
water	66:19	0:0	8	s
op	66:20	0:0	8	->
water	66:22	0:0	8	mb_num_left
water	66:34	0:0	6	;
call	67:12	67:34	6	ff_er_frame_end
arg	67:28	67:34	7	&s->er
op	67:28	0:0	8	&
water	67:29	0:0	8	s
op	67:30	0:0	8	->
water	67:32	0:0	8	er
water	67:35	0:0	6	;
call	68:12	68:30	6	ff_mpv_frame_end
arg	68:29	68:30	7	s
water	68:29	0:0	8	s
water	68:31	0:0	6	;
water	69:8	0:0	6	}
if	71:8	94:8	4	(s -> width != si . width || s -> height != si . height)
cond	71:12	71:52	5	s -> width != si . width || s -> height != si . height
water	71:12	0:0	6	s
op	71:13	0:0	6	->
water	71:15	0:0	6	width
op	71:21	0:0	6	!=
water	71:24	0:0	6	si
op	71:26	0:0	6	.
water	71:27	0:0	6	width
op	71:33	0:0	6	||
water	71:36	0:0	6	s
op	71:37	0:0	6	->
water	71:39	0:0	6	height
op	71:46	0:0	6	!=
water	71:49	0:0	6	si
op	71:51	0:0	6	.
water	71:52	0:0	6	height
stmts	71:60	94:8	5	
water	71:60	0:0	6	{
decl	72:12	72:19	6	int	err
call	74:12	75:38	6	av_log
arg	74:19	74:27	7	s->avctx
water	74:19	0:0	8	s
op	74:20	0:0	8	->
water	74:22	0:0	8	avctx
arg	74:29	74:43	7	AV_LOG_WARNING
water	74:29	0:0	8	AV_LOG_WARNING
arg	74:45	74:77	7	"Changing dimensions to %dx%d\n"
water	74:45	0:0	8	"Changing dimensions to %dx%d\n"
arg	75:19	75:27	7	si.width
water	75:19	0:0	8	si
op	75:21	0:0	8	.
water	75:22	0:0	8	width
arg	75:29	75:38	7	si.height
water	75:29	0:0	8	si
op	75:31	0:0	8	.
water	75:32	0:0	8	height
water	75:39	0:0	6	;
if	77:12	78:42	6	(av_image_check_size (si . width ,si . height ,0 ,s -> avctx ))
cond	77:16	77:68	7	av_image_check_size (si . width ,si . height ,0 ,s -> avctx )
call	77:16	77:68	8	av_image_check_size
arg	77:36	77:44	9	si.width
water	77:36	0:0	10	si
op	77:38	0:0	10	.
water	77:39	0:0	10	width
arg	77:46	77:55	9	si.height
water	77:46	0:0	10	si
op	77:48	0:0	10	.
water	77:49	0:0	10	height
arg	77:57	77:58	9	0
water	77:57	0:0	10	0
arg	77:60	77:68	9	s->avctx
water	77:60	0:0	10	s
op	77:61	0:0	10	->
water	77:63	0:0	10	avctx
stmts	78:16	78:42	7	
return	78:16	78:42	8	AVERROR_INVALIDDATA
water	78:23	0:0	9	AVERROR_INVALIDDATA
water	80:12	0:0	6	s
op	80:13	0:0	6	->
water	80:15	0:0	6	avctx
op	80:20	0:0	6	->
water	80:22	0:0	6	sample_aspect_ratio
op	80:42	0:0	6	=
call	80:44	82:35	6	update_sar
arg	81:16	81:24	7	s->width
water	81:16	0:0	8	s
op	81:17	0:0	8	->
water	81:19	0:0	8	width
arg	81:26	81:35	7	s->height
water	81:26	0:0	8	s
op	81:27	0:0	8	->
water	81:29	0:0	8	height
arg	81:37	81:66	7	s->avctx->sample_aspect_ratio
water	81:37	0:0	8	s
op	81:38	0:0	8	->
water	81:40	0:0	8	avctx
op	81:45	0:0	8	->
water	81:47	0:0	8	sample_aspect_ratio
arg	82:16	82:24	7	si.width
water	82:16	0:0	8	si
op	82:18	0:0	8	.
water	82:19	0:0	8	width
arg	82:26	82:35	7	si.height
water	82:26	0:0	8	si
op	82:28	0:0	8	.
water	82:29	0:0	8	height
water	82:36	0:0	6	;
water	83:12	0:0	6	s
op	83:13	0:0	6	->
water	83:15	0:0	6	width
op	83:22	0:0	6	=
water	83:24	0:0	6	si
op	83:26	0:0	6	.
water	83:27	0:0	6	width
water	83:32	0:0	6	;
water	84:12	0:0	6	s
op	84:13	0:0	6	->
water	84:15	0:0	6	height
op	84:22	0:0	6	=
water	84:24	0:0	6	si
op	84:26	0:0	6	.
water	84:27	0:0	6	height
water	84:33	0:0	6	;
water	86:12	0:0	6	err
op	86:16	0:0	6	=
call	86:18	86:65	6	ff_set_dimensions
arg	86:36	86:44	7	s->avctx
water	86:36	0:0	8	s
op	86:37	0:0	8	->
water	86:39	0:0	8	avctx
arg	86:46	86:54	7	s->width
water	86:46	0:0	8	s
op	86:47	0:0	8	->
water	86:49	0:0	8	width
arg	86:56	86:65	7	s->height
water	86:56	0:0	8	s
op	86:57	0:0	8	->
water	86:59	0:0	8	height
water	86:66	0:0	6	;
if	87:12	88:26	6	(err < 0)
cond	87:16	87:22	7	err < 0
water	87:16	0:0	8	err
op	87:20	0:0	8	<
water	87:22	0:0	8	0
stmts	88:16	88:26	7	
return	88:16	88:26	8	err
water	88:23	0:0	9	err
if	90:12	91:26	6	(( err =ff_mpv_common_frame_size_change (s ) ) < 0)
cond	90:16	90:61	7	( err =ff_mpv_common_frame_size_change (s ) ) < 0
water	90:16	0:0	8	(
water	90:17	0:0	8	err
op	90:21	0:0	8	=
call	90:23	90:56	8	ff_mpv_common_frame_size_change
arg	90:55	90:56	9	s
water	90:55	0:0	10	s
water	90:57	0:0	8	)
op	90:59	0:0	8	<
water	90:61	0:0	8	0
stmts	91:16	91:26	7	
return	91:16	91:26	8	err
water	91:23	0:0	9	err
if	92:12	93:26	6	(( err =rv34_decoder_realloc (r ) ) < 0)
cond	92:16	92:50	7	( err =rv34_decoder_realloc (r ) ) < 0
water	92:16	0:0	8	(
water	92:17	0:0	8	err
op	92:21	0:0	8	=
call	92:23	92:45	8	rv34_decoder_realloc
arg	92:44	92:45	9	r
water	92:44	0:0	10	r
water	92:46	0:0	8	)
op	92:48	0:0	8	<
water	92:50	0:0	8	0
stmts	93:16	93:26	7	
return	93:16	93:26	8	err
water	93:23	0:0	9	err
water	94:8	0:0	6	}
water	95:8	0:0	4	s
op	95:9	0:0	4	->
water	95:11	0:0	4	pict_type
op	95:21	0:0	4	=
water	95:23	0:0	4	si
op	95:25	0:0	4	.
water	95:26	0:0	4	type
water	95:31	0:0	4	?
water	95:33	0:0	4	si
op	95:35	0:0	4	.
water	95:36	0:0	4	type
water	95:41	0:0	4	:
water	95:43	0:0	4	AV_PICTURE_TYPE_I
water	95:60	0:0	4	;
if	96:8	97:21	4	(ff_mpv_frame_start (s ,s -> avctx ) < 0)
cond	96:12	96:46	5	ff_mpv_frame_start (s ,s -> avctx ) < 0
call	96:12	96:42	6	ff_mpv_frame_start
arg	96:31	96:32	7	s
water	96:31	0:0	8	s
arg	96:34	96:42	7	s->avctx
water	96:34	0:0	8	s
op	96:35	0:0	8	->
water	96:37	0:0	8	avctx
op	96:44	0:0	6	<
water	96:46	0:0	6	0
stmts	97:12	97:21	5	
return	97:12	97:21	6	-1
op	97:19	0:0	7	-
water	97:20	0:0	7	1
call	98:8	98:32	4	ff_mpeg_er_frame_start
arg	98:31	98:32	5	s
water	98:31	0:0	6	s
water	98:33	0:0	4	;
if	99:8	110:8	4	(! r -> tmp_b_block_base)
cond	99:12	99:16	5	! r -> tmp_b_block_base
op	99:12	0:0	6	!
water	99:13	0:0	6	r
op	99:14	0:0	6	->
water	99:16	0:0	6	tmp_b_block_base
stmts	99:34	110:8	5	
water	99:34	0:0	6	{
decl	100:12	100:17	6	int	i
water	102:12	0:0	6	r
op	102:13	0:0	6	->
water	102:15	0:0	6	tmp_b_block_base
op	102:32	0:0	6	=
call	102:34	102:60	6	av_malloc
arg	102:44	102:60	7	s->linesize*48
water	102:44	0:0	8	s
op	102:45	0:0	8	->
water	102:47	0:0	8	linesize
op	102:56	0:0	8	*
water	102:58	0:0	8	48
water	102:61	0:0	6	;
for	103:12	105:60	6	(i = 0 ;i < 2;i ++)
forinit	103:17	103:22	7	i = 0 ;
water	103:17	0:0	8	i
op	103:19	0:0	8	=
water	103:21	0:0	8	0
water	103:22	0:0	8	;
cond	103:24	103:28	7	i < 2
water	103:24	0:0	8	i
op	103:26	0:0	8	<
water	103:28	0:0	8	2
forexpr	103:31	103:32	7	i ++
water	103:31	0:0	8	i
op	103:32	0:0	8	++
stmts	104:16	105:60	7	
water	104:16	0:0	8	r
op	104:17	0:0	8	->
water	104:19	0:0	8	tmp_b_block_y
op	104:32	0:0	8	[
water	104:33	0:0	8	i
op	104:34	0:0	8	]
op	104:36	0:0	8	=
water	104:38	0:0	8	r
op	104:39	0:0	8	->
water	104:41	0:0	8	tmp_b_block_base
op	105:38	0:0	8	+
water	105:40	0:0	8	i
op	105:42	0:0	8	*
water	105:44	0:0	8	16
op	105:47	0:0	8	*
water	105:49	0:0	8	s
op	105:50	0:0	8	->
water	105:52	0:0	8	linesize
water	105:60	0:0	8	;
for	106:12	109:54	6	(i = 0 ;i < 4;i ++)
forinit	106:17	106:22	7	i = 0 ;
water	106:17	0:0	8	i
op	106:19	0:0	8	=
water	106:21	0:0	8	0
water	106:22	0:0	8	;
cond	106:24	106:28	7	i < 4
water	106:24	0:0	8	i
op	106:26	0:0	8	<
water	106:28	0:0	8	4
forexpr	106:31	106:32	7	i ++
water	106:31	0:0	8	i
op	106:32	0:0	8	++
stmts	107:16	109:54	7	
water	107:16	0:0	8	r
op	107:17	0:0	8	->
water	107:19	0:0	8	tmp_b_block_uv
op	107:33	0:0	8	[
water	107:34	0:0	8	i
op	107:35	0:0	8	]
op	107:37	0:0	8	=
water	107:39	0:0	8	r
op	107:40	0:0	8	->
water	107:42	0:0	8	tmp_b_block_base
op	107:59	0:0	8	+
water	107:61	0:0	8	32
op	107:64	0:0	8	*
water	107:66	0:0	8	s
op	107:67	0:0	8	->
water	107:69	0:0	8	linesize
op	108:39	0:0	8	+
water	108:41	0:0	8	(
water	108:42	0:0	8	i
op	108:44	0:0	8	>>
water	108:47	0:0	8	1
water	108:48	0:0	8	)
op	108:50	0:0	8	*
water	108:52	0:0	8	8
op	108:54	0:0	8	*
water	108:56	0:0	8	s
op	108:57	0:0	8	->
water	108:59	0:0	8	uvlinesize
op	109:39	0:0	8	+
water	109:41	0:0	8	(
water	109:42	0:0	8	i
op	109:44	0:0	8	&
water	109:47	0:0	8	1
water	109:48	0:0	8	)
op	109:50	0:0	8	*
water	109:52	0:0	8	16
water	109:54	0:0	8	;
water	110:8	0:0	6	}
water	111:8	0:0	4	r
op	111:9	0:0	4	->
water	111:11	0:0	4	cur_pts
op	111:19	0:0	4	=
water	111:21	0:0	4	si
op	111:23	0:0	4	.
water	111:24	0:0	4	pts
water	111:27	0:0	4	;
if	112:8	115:8	4	(s -> pict_type != AV_PICTURE_TYPE_B)
cond	112:12	112:28	5	s -> pict_type != AV_PICTURE_TYPE_B
water	112:12	0:0	6	s
op	112:13	0:0	6	->
water	112:15	0:0	6	pict_type
op	112:25	0:0	6	!=
water	112:28	0:0	6	AV_PICTURE_TYPE_B
stmts	112:47	115:8	5	
water	112:47	0:0	6	{
water	113:12	0:0	6	r
op	113:13	0:0	6	->
water	113:15	0:0	6	last_pts
op	113:24	0:0	6	=
water	113:26	0:0	6	r
op	113:27	0:0	6	->
water	113:29	0:0	6	next_pts
water	113:37	0:0	6	;
water	114:12	0:0	6	r
op	114:13	0:0	6	->
water	114:15	0:0	6	next_pts
op	114:24	0:0	6	=
water	114:26	0:0	6	r
op	114:27	0:0	6	->
water	114:29	0:0	6	cur_pts
water	114:36	0:0	6	;
water	115:8	0:0	6	}
else	115:10	136:8	4
stmts	115:15	136:8	5	
water	115:15	0:0	6	{
decl	116:12	116:64	6	int	refdist
op	116:24	0:0	6	=
call	116:26	116:63	7	GET_PTS_DIFF
arg	116:39	116:50	8	r->next_pts
water	116:39	0:0	9	r
op	116:40	0:0	9	->
water	116:42	0:0	9	next_pts
arg	116:52	116:63	8	r->last_pts
water	116:52	0:0	9	r
op	116:53	0:0	9	->
water	116:55	0:0	9	last_pts
decl	117:12	117:64	6	int	dist0
op	117:24	0:0	6	=
call	117:26	117:63	7	GET_PTS_DIFF
arg	117:39	117:49	8	r->cur_pts
water	117:39	0:0	9	r
op	117:40	0:0	9	->
water	117:42	0:0	9	cur_pts
arg	117:52	117:63	8	r->last_pts
water	117:52	0:0	9	r
op	117:53	0:0	9	->
water	117:55	0:0	9	last_pts
decl	118:12	118:63	6	int	dist1
op	118:24	0:0	6	=
call	118:26	118:62	7	GET_PTS_DIFF
arg	118:39	118:50	8	r->next_pts
water	118:39	0:0	9	r
op	118:40	0:0	9	->
water	118:42	0:0	9	next_pts
arg	118:52	118:62	8	r->cur_pts
water	118:52	0:0	9	r
op	118:53	0:0	9	->
water	118:55	0:0	9	cur_pts
if	120:12	123:12	6	(! refdist)
cond	120:15	120:16	7	! refdist
op	120:15	0:0	8	!
water	120:16	0:0	8	refdist
stmts	120:24	123:12	7	
water	120:24	0:0	8	{
water	121:16	0:0	8	r
op	121:17	0:0	8	->
water	121:19	0:0	8	mv_weight1
op	121:30	0:0	8	=
water	121:32	0:0	8	r
op	121:33	0:0	8	->
water	121:35	0:0	8	mv_weight2
op	121:46	0:0	8	=
water	121:48	0:0	8	r
op	121:49	0:0	8	->
water	121:51	0:0	8	weight1
op	121:59	0:0	8	=
water	121:61	0:0	8	r
op	121:62	0:0	8	->
water	121:64	0:0	8	weight2
op	121:72	0:0	8	=
water	121:74	0:0	8	8192
water	121:78	0:0	8	;
water	122:16	0:0	8	r
op	122:17	0:0	8	->
water	122:19	0:0	8	scaled_weight
op	122:33	0:0	8	=
water	122:35	0:0	8	0
water	122:36	0:0	8	;
water	123:12	0:0	8	}
else	123:13	135:12	6
stmts	123:17	135:12	7	
water	123:17	0:0	8	{
water	124:16	0:0	8	r
op	124:17	0:0	8	->
water	124:19	0:0	8	mv_weight1
op	124:30	0:0	8	=
water	124:32	0:0	8	(
water	124:33	0:0	8	dist0
op	124:39	0:0	8	<<
water	124:42	0:0	8	14
water	124:44	0:0	8	)
op	124:46	0:0	8	/
water	124:48	0:0	8	refdist
water	124:55	0:0	8	;
water	125:16	0:0	8	r
op	125:17	0:0	8	->
water	125:19	0:0	8	mv_weight2
op	125:30	0:0	8	=
water	125:32	0:0	8	(
water	125:33	0:0	8	dist1
op	125:39	0:0	8	<<
water	125:42	0:0	8	14
water	125:44	0:0	8	)
op	125:46	0:0	8	/
water	125:48	0:0	8	refdist
water	125:55	0:0	8	;
if	126:16	130:16	8	(( r -> mv_weight1 | r -> mv_weight2 ) & 511)
cond	126:19	126:51	9	( r -> mv_weight1 | r -> mv_weight2 ) & 511
water	126:19	0:0	10	(
water	126:20	0:0	10	r
op	126:21	0:0	10	->
water	126:23	0:0	10	mv_weight1
op	126:33	0:0	10	|
water	126:34	0:0	10	r
op	126:35	0:0	10	->
water	126:37	0:0	10	mv_weight2
water	126:47	0:0	10	)
op	126:49	0:0	10	&
water	126:51	0:0	10	511
stmts	126:55	130:16	9	
water	126:55	0:0	10	{
water	127:20	0:0	10	r
op	127:21	0:0	10	->
water	127:23	0:0	10	weight1
op	127:31	0:0	10	=
water	127:33	0:0	10	r
op	127:34	0:0	10	->
water	127:36	0:0	10	mv_weight1
water	127:46	0:0	10	;
water	128:20	0:0	10	r
op	128:21	0:0	10	->
water	128:23	0:0	10	weight2
op	128:31	0:0	10	=
water	128:33	0:0	10	r
op	128:34	0:0	10	->
water	128:36	0:0	10	mv_weight2
water	128:46	0:0	10	;
water	129:20	0:0	10	r
op	129:21	0:0	10	->
water	129:23	0:0	10	scaled_weight
op	129:37	0:0	10	=
water	129:39	0:0	10	0
water	129:40	0:0	10	;
water	130:16	0:0	10	}
else	130:17	134:16	8
stmts	130:21	134:16	9	
water	130:21	0:0	10	{
water	131:20	0:0	10	r
op	131:21	0:0	10	->
water	131:23	0:0	10	weight1
op	131:31	0:0	10	=
water	131:33	0:0	10	r
op	131:34	0:0	10	->
water	131:36	0:0	10	mv_weight1
op	131:47	0:0	10	>>
water	131:50	0:0	10	9
water	131:51	0:0	10	;
water	132:20	0:0	10	r
op	132:21	0:0	10	->
water	132:23	0:0	10	weight2
op	132:31	0:0	10	=
water	132:33	0:0	10	r
op	132:34	0:0	10	->
water	132:36	0:0	10	mv_weight2
op	132:47	0:0	10	>>
water	132:50	0:0	10	9
water	132:51	0:0	10	;
water	133:20	0:0	10	r
op	133:21	0:0	10	->
water	133:23	0:0	10	scaled_weight
op	133:37	0:0	10	=
water	133:39	0:0	10	1
water	133:40	0:0	10	;
water	134:16	0:0	10	}
water	135:12	0:0	8	}
water	136:8	0:0	6	}
water	137:8	0:0	4	s
op	137:9	0:0	4	->
water	137:11	0:0	4	mb_x
op	137:16	0:0	4	=
water	137:18	0:0	4	s
op	137:19	0:0	4	->
water	137:21	0:0	4	mb_y
op	137:26	0:0	4	=
water	137:28	0:0	4	0
water	137:29	0:0	4	;
call	138:8	138:39	4	ff_thread_finish_setup
arg	138:31	138:39	5	s->avctx
water	138:31	0:0	6	s
op	138:32	0:0	6	->
water	138:34	0:0	6	avctx
water	138:40	0:0	4	;
water	139:4	0:0	4	}
else	139:6	144:4	2
stmts	139:11	144:4	3	
if	139:11	144:4	4	(HAVE_THREADS && ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ))
cond	139:15	140:62	5	HAVE_THREADS && ( s -> avctx -> active_thread_type & FF_THREAD_FRAME )
water	139:15	0:0	6	HAVE_THREADS
op	139:28	0:0	6	&&
water	140:15	0:0	6	(
water	140:16	0:0	6	s
op	140:17	0:0	6	->
water	140:19	0:0	6	avctx
op	140:24	0:0	6	->
water	140:26	0:0	6	active_thread_type
op	140:45	0:0	6	&
water	140:47	0:0	6	FF_THREAD_FRAME
water	140:62	0:0	6	)
stmts	140:65	144:4	5	
water	140:65	0:0	6	{
call	141:8	142:66	6	av_log
arg	141:15	141:23	7	s->avctx
water	141:15	0:0	8	s
op	141:16	0:0	8	->
water	141:18	0:0	8	avctx
arg	141:25	141:37	7	AV_LOG_ERROR
water	141:25	0:0	8	AV_LOG_ERROR
arg	141:39	142:56	7	"Decoder needs full frames in frame ""multithreading mode (start MB is %d).\n"
water	141:39	0:0	8	"Decoder needs full frames in frame "
water	142:15	0:0	8	"multithreading mode (start MB is %d).\n"
arg	142:58	142:66	7	si.start
water	142:58	0:0	8	si
op	142:60	0:0	8	.
water	142:61	0:0	8	start
water	142:67	0:0	6	;
return	143:8	143:34	6	AVERROR_INVALIDDATA
water	143:15	0:0	7	AVERROR_INVALIDDATA
water	144:4	0:0	6	}
if	145:4	146:34	2	(faulty_b)
cond	145:8	145:8	3	faulty_b
water	145:8	0:0	4	faulty_b
stmts	146:8	146:34	3	
return	146:8	146:34	4	AVERROR_INVALIDDATA
water	146:15	0:0	5	AVERROR_INVALIDDATA
for	148:4	178:4	2	(i = 0 ;i < slice_count;i ++)
forinit	148:8	148:13	3	i = 0 ;
water	148:8	0:0	4	i
op	148:10	0:0	4	=
water	148:12	0:0	4	0
water	148:13	0:0	4	;
cond	148:15	148:19	3	i < slice_count
water	148:15	0:0	4	i
op	148:17	0:0	4	<
water	148:19	0:0	4	slice_count
forexpr	148:32	148:33	3	i ++
water	148:32	0:0	4	i
op	148:33	0:0	4	++
stmts	148:36	178:4	3	
water	148:36	0:0	4	{
decl	149:8	149:85	4	int	offset
op	149:20	0:0	4	=
call	149:22	149:84	5	get_slice_offset
arg	149:39	149:44	6	avctx
water	149:39	0:0	7	avctx
arg	149:46	149:56	6	slices_hdr
water	149:46	0:0	7	slices_hdr
arg	149:58	149:61	6	i
water	149:58	0:0	7	i
arg	149:63	149:74	6	slice_count
water	149:63	0:0	7	slice_count
arg	149:76	149:84	6	buf_size
water	149:76	0:0	7	buf_size
decl	150:8	150:85	4	int	offset1
op	150:20	0:0	4	=
call	150:22	150:84	5	get_slice_offset
arg	150:39	150:44	6	avctx
water	150:39	0:0	7	avctx
arg	150:46	150:56	6	slices_hdr
water	150:46	0:0	7	slices_hdr
arg	150:58	150:61	6	i+1
water	150:58	0:0	7	i
op	150:59	0:0	7	+
water	150:60	0:0	7	1
arg	150:63	150:74	6	slice_count
water	150:63	0:0	7	slice_count
arg	150:76	150:84	6	buf_size
water	150:76	0:0	7	buf_size
decl	151:8	151:16	4	int	size
if	153:8	156:8	4	(offset < 0 || offset > offset1 || offset1 > buf_size)
cond	153:11	153:55	5	offset < 0 || offset > offset1 || offset1 > buf_size
water	153:11	0:0	6	offset
op	153:18	0:0	6	<
water	153:20	0:0	6	0
op	153:22	0:0	6	||
water	153:25	0:0	6	offset
op	153:32	0:0	6	>
water	153:34	0:0	6	offset1
op	153:42	0:0	6	||
water	153:45	0:0	6	offset1
op	153:53	0:0	6	>
water	153:55	0:0	6	buf_size
stmts	153:64	156:8	5	
water	153:64	0:0	6	{
call	154:12	154:67	6	av_log
arg	154:19	154:24	7	avctx
water	154:19	0:0	8	avctx
arg	154:26	154:38	7	AV_LOG_ERROR
water	154:26	0:0	8	AV_LOG_ERROR
arg	154:40	154:67	7	"Slice offset is invalid\n"
water	154:40	0:0	8	"Slice offset is invalid\n"
water	154:68	0:0	6	;
break	155:12	155:17	6	
water	156:8	0:0	6	}
water	157:8	0:0	4	size
op	157:13	0:0	4	=
water	157:15	0:0	4	offset1
op	157:23	0:0	4	-
water	157:25	0:0	4	offset
water	157:31	0:0	4	;
water	159:8	0:0	4	r
op	159:9	0:0	4	->
water	159:11	0:0	4	si
op	159:13	0:0	4	.
water	159:14	0:0	4	end
op	159:18	0:0	4	=
water	159:20	0:0	4	s
op	159:21	0:0	4	->
water	159:23	0:0	4	mb_width
op	159:32	0:0	4	*
water	159:34	0:0	4	s
op	159:35	0:0	4	->
water	159:37	0:0	4	mb_height
water	159:46	0:0	4	;
water	160:8	0:0	4	s
op	160:9	0:0	4	->
water	160:11	0:0	4	mb_num_left
op	160:23	0:0	4	=
water	160:25	0:0	4	r
op	160:26	0:0	4	->
water	160:28	0:0	4	s
op	160:29	0:0	4	.
water	160:30	0:0	4	mb_x
op	160:35	0:0	4	+
water	160:37	0:0	4	r
op	160:38	0:0	4	->
water	160:40	0:0	4	s
op	160:41	0:0	4	.
water	160:42	0:0	4	mb_y
op	160:46	0:0	4	*
water	160:47	0:0	4	r
op	160:48	0:0	4	->
water	160:50	0:0	4	s
op	160:51	0:0	4	.
water	160:52	0:0	4	mb_width
op	160:61	0:0	4	-
water	160:63	0:0	4	r
op	160:64	0:0	4	->
water	160:66	0:0	4	si
op	160:68	0:0	4	.
water	160:69	0:0	4	start
water	160:74	0:0	4	;
if	162:8	173:8	4	(i + 1 < slice_count)
cond	162:11	162:17	5	i + 1 < slice_count
water	162:11	0:0	6	i
op	162:12	0:0	6	+
water	162:13	0:0	6	1
op	162:15	0:0	6	<
water	162:17	0:0	6	slice_count
stmts	162:29	173:8	5	
water	162:29	0:0	6	{
decl	163:12	163:89	6	int	offset2
op	163:24	0:0	6	=
call	163:26	163:88	7	get_slice_offset
arg	163:43	163:48	8	avctx
water	163:43	0:0	9	avctx
arg	163:50	163:60	8	slices_hdr
water	163:50	0:0	9	slices_hdr
arg	163:62	163:65	8	i+2
water	163:62	0:0	9	i
op	163:63	0:0	9	+
water	163:64	0:0	9	2
arg	163:67	163:78	8	slice_count
water	163:67	0:0	9	slice_count
arg	163:80	163:88	8	buf_size
water	163:80	0:0	9	buf_size
if	164:12	167:12	6	(offset2 < offset1 || offset2 > buf_size)
cond	164:16	164:47	7	offset2 < offset1 || offset2 > buf_size
water	164:16	0:0	8	offset2
op	164:24	0:0	8	<
water	164:26	0:0	8	offset1
op	164:34	0:0	8	||
water	164:37	0:0	8	offset2
op	164:45	0:0	8	>
water	164:47	0:0	8	buf_size
stmts	164:57	167:12	7	
water	164:57	0:0	8	{
call	165:16	165:71	8	av_log
arg	165:23	165:28	9	avctx
water	165:23	0:0	10	avctx
arg	165:30	165:42	9	AV_LOG_ERROR
water	165:30	0:0	10	AV_LOG_ERROR
arg	165:44	165:71	9	"Slice offset is invalid\n"
water	165:44	0:0	10	"Slice offset is invalid\n"
water	165:72	0:0	8	;
break	166:16	166:21	8	
water	167:12	0:0	8	}
call	168:12	168:67	6	init_get_bits
arg	168:26	168:32	7	&s->gb
op	168:26	0:0	8	&
water	168:27	0:0	8	s
op	168:28	0:0	8	->
water	168:30	0:0	8	gb
arg	168:34	168:45	7	buf+offset1
water	168:34	0:0	8	buf
op	168:37	0:0	8	+
water	168:38	0:0	8	offset1
arg	168:47	168:67	7	(buf_size-offset1)*8
water	168:47	0:0	8	(
water	168:48	0:0	8	buf_size
op	168:56	0:0	8	-
water	168:57	0:0	8	offset1
water	168:64	0:0	8	)
op	168:65	0:0	8	*
water	168:66	0:0	8	8
water	168:68	0:0	6	;
if	169:12	171:12	6	(r -> parse_slice_header (r ,& r -> s . gb ,& si ) < 0)
cond	169:15	169:57	7	r -> parse_slice_header (r ,& r -> s . gb ,& si ) < 0
call	169:15	169:53	8	r->parse_slice_header
arg	169:37	169:38	9	r
water	169:37	0:0	10	r
arg	169:40	169:48	9	&r->s.gb
op	169:40	0:0	10	&
water	169:41	0:0	10	r
op	169:42	0:0	10	->
water	169:44	0:0	10	s
op	169:45	0:0	10	.
water	169:46	0:0	10	gb
arg	169:50	169:53	9	&si
op	169:50	0:0	10	&
water	169:51	0:0	10	si
op	169:55	0:0	8	<
water	169:57	0:0	8	0
stmts	169:59	171:12	7	
water	169:59	0:0	8	{
water	170:16	0:0	8	size
op	170:21	0:0	8	=
water	170:23	0:0	8	offset2
op	170:31	0:0	8	-
water	170:33	0:0	8	offset
water	170:39	0:0	8	;
water	171:12	0:0	8	}
else	171:13	172:36	6
stmts	172:16	172:36	7	
water	172:16	0:0	8	r
op	172:17	0:0	8	->
water	172:19	0:0	8	si
op	172:21	0:0	8	.
water	172:22	0:0	8	end
op	172:26	0:0	8	=
water	172:28	0:0	8	si
op	172:30	0:0	8	.
water	172:31	0:0	8	start
water	172:36	0:0	8	;
water	173:8	0:0	6	}
call	174:8	174:58	4	av_assert0
arg	174:20	174:58	5	size>=0&&size<=buf_size-offset
water	174:20	0:0	6	size
op	174:25	0:0	6	>=
water	174:28	0:0	6	0
op	174:30	0:0	6	&&
water	174:33	0:0	6	size
op	174:38	0:0	6	<=
water	174:41	0:0	6	buf_size
op	174:50	0:0	6	-
water	174:52	0:0	6	offset
water	174:59	0:0	4	;
water	175:8	0:0	4	last
op	175:13	0:0	4	=
call	175:15	175:65	4	rv34_decode_slice
arg	175:33	175:34	5	r
water	175:33	0:0	6	r
arg	175:36	175:45	5	r->si.end
water	175:36	0:0	6	r
op	175:37	0:0	6	->
water	175:39	0:0	6	si
op	175:41	0:0	6	.
water	175:42	0:0	6	end
arg	175:47	175:59	5	buf+offset
water	175:47	0:0	6	buf
op	175:51	0:0	6	+
water	175:53	0:0	6	offset
arg	175:61	175:65	5	size
water	175:61	0:0	6	size
water	175:66	0:0	4	;
if	176:8	177:17	4	(last)
cond	176:11	176:11	5	last
water	176:11	0:0	6	last
stmts	177:12	177:17	5	
break	177:12	177:17	6	
water	178:4	0:0	4	}
if	180:4	200:4	2	(s -> current_picture_ptr)
cond	180:8	180:11	3	s -> current_picture_ptr
water	180:8	0:0	4	s
op	180:9	0:0	4	->
water	180:11	0:0	4	current_picture_ptr
stmts	180:32	200:4	3	
water	180:32	0:0	4	{
if	181:8	189:8	4	(last)
cond	181:12	181:12	5	last
water	181:12	0:0	6	last
stmts	181:18	189:8	5	
water	181:18	0:0	6	{
if	182:12	183:51	6	(r -> loop_filter)
cond	182:15	182:18	7	r -> loop_filter
water	182:15	0:0	8	r
op	182:16	0:0	8	->
water	182:18	0:0	8	loop_filter
stmts	183:16	183:51	7	
call	183:16	183:50	8	r->loop_filter
arg	183:31	183:32	9	r
water	183:31	0:0	10	r
arg	183:34	183:50	9	s->mb_height-1
water	183:34	0:0	10	s
op	183:35	0:0	10	->
water	183:37	0:0	10	mb_height
op	183:47	0:0	10	-
water	183:49	0:0	10	1
water	183:51	0:0	8	;
water	185:12	0:0	6	ret
op	185:16	0:0	6	=
call	185:18	185:42	6	finish_frame
arg	185:31	185:36	7	avctx
water	185:31	0:0	8	avctx
arg	185:38	185:42	7	pict
water	185:38	0:0	8	pict
water	185:43	0:0	6	;
if	186:12	187:26	6	(ret < 0)
cond	186:16	186:22	7	ret < 0
water	186:16	0:0	8	ret
op	186:20	0:0	8	<
water	186:22	0:0	8	0
stmts	187:16	187:26	7	
return	187:16	187:26	8	ret
water	187:23	0:0	9	ret
op	188:12	0:0	6	*
water	188:13	0:0	6	got_picture_ptr
op	188:29	0:0	6	=
water	188:31	0:0	6	ret
water	188:34	0:0	6	;
water	189:8	0:0	6	}
else	189:10	199:8	4
stmts	189:15	199:8	5	
if	189:15	199:8	6	(HAVE_THREADS && ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ))
cond	189:19	190:66	7	HAVE_THREADS && ( s -> avctx -> active_thread_type & FF_THREAD_FRAME )
water	189:19	0:0	8	HAVE_THREADS
op	189:32	0:0	8	&&
water	190:19	0:0	8	(
water	190:20	0:0	8	s
op	190:21	0:0	8	->
water	190:23	0:0	8	avctx
op	190:28	0:0	8	->
water	190:30	0:0	8	active_thread_type
op	190:49	0:0	8	&
water	190:51	0:0	8	FF_THREAD_FRAME
water	190:66	0:0	8	)
stmts	190:69	199:8	7	
water	190:69	0:0	8	{
call	191:12	191:77	8	av_log
arg	191:19	191:24	9	avctx
water	191:19	0:0	10	avctx
arg	191:26	191:37	9	AV_LOG_INFO
water	191:26	0:0	10	AV_LOG_INFO
arg	191:39	191:77	9	"marking unfished frame as finished\n"
water	191:39	0:0	10	"marking unfished frame as finished\n"
water	191:78	0:0	8	;
call	194:12	194:34	8	ff_er_frame_end
arg	194:28	194:34	9	&s->er
op	194:28	0:0	10	&
water	194:29	0:0	10	s
op	194:30	0:0	10	->
water	194:32	0:0	10	er
water	194:35	0:0	8	;
call	195:12	195:30	8	ff_mpv_frame_end
arg	195:29	195:30	9	s
water	195:29	0:0	10	s
water	195:31	0:0	8	;
water	196:12	0:0	8	s
op	196:13	0:0	8	->
water	196:15	0:0	8	mb_num_left
op	196:27	0:0	8	=
water	196:29	0:0	8	0
water	196:30	0:0	8	;
call	197:12	197:77	8	ff_thread_report_progress
arg	197:38	197:65	9	&s->current_picture_ptr->tf
op	197:38	0:0	10	&
water	197:39	0:0	10	s
op	197:40	0:0	10	->
water	197:42	0:0	10	current_picture_ptr
op	197:61	0:0	10	->
water	197:63	0:0	10	tf
arg	197:67	197:74	9	INT_MAX
water	197:67	0:0	10	INT_MAX
arg	197:76	197:77	9	0
water	197:76	0:0	10	0
water	197:78	0:0	8	;
return	198:12	198:38	8	AVERROR_INVALIDDATA
water	198:19	0:0	9	AVERROR_INVALIDDATA
water	199:8	0:0	8	}
water	200:4	0:0	4	}
return	202:4	202:22	2	avpkt->size
water	202:11	0:0	3	avpkt
op	202:16	0:0	3	->
water	202:18	0:0	3	size
