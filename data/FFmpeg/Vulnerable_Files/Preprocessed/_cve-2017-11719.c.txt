func	2:0	150:0	0	static int	dnxhd_decode_header
params	2:30	0:0	1	
param	2:31	2:48	2	DNXHDContext *	ctx
param	2:50	2:64	2	AVFrame *	frame
param	3:31	3:49	2	const uint8_t *	buf
param	3:51	3:63	2	int	buf_size
param	4:31	4:46	2	int	first_field
stmnts	0:0	149:12	1	
decl	6:4	6:19	2	int	i
water	6:9	0:0	2	,
decl	6:4	6:19	2	int	cid
water	6:14	0:0	2	,
decl	6:4	6:19	2	int	ret
decl	7:4	7:48	2	int	old_bit_depth
op	7:22	0:0	2	=
water	7:24	0:0	2	ctx
op	7:27	0:0	2	->
water	7:29	0:0	2	bit_depth
water	7:38	0:0	2	,
decl	7:4	7:48	2	int	bitdepth
decl	8:4	8:26	2	uint64_t	header_prefix
if	9:4	13:4	2	(buf_size < 0 x280)
cond	9:8	9:20	3	buf_size < 0 x280
water	9:8	0:0	4	buf_size
op	9:17	0:0	4	<
water	9:19	0:0	4	0
water	9:20	0:0	4	x280
stmts	9:26	13:4	3	
water	9:26	0:0	4	{
call	10:8	11:57	4	av_log
arg	10:15	10:25	5	ctx->avctx
water	10:15	0:0	6	ctx
op	10:18	0:0	6	->
water	10:20	0:0	6	avctx
arg	10:27	10:39	5	AV_LOG_ERROR
water	10:27	0:0	6	AV_LOG_ERROR
arg	11:15	11:47	5	"buffer too small (%d < 640).\n"
water	11:15	0:0	6	"buffer too small (%d < 640).\n"
arg	11:49	11:57	5	buf_size
water	11:49	0:0	6	buf_size
water	11:58	0:0	4	;
return	12:8	12:34	4	AVERROR_INVALIDDATA
water	12:15	0:0	5	AVERROR_INVALIDDATA
water	13:4	0:0	4	}
water	15:4	0:0	2	header_prefix
op	15:18	0:0	2	=
call	15:20	15:56	2	avpriv_dnxhd_parse_header_prefix
arg	15:53	15:56	3	buf
water	15:53	0:0	4	buf
water	15:57	0:0	2	;
if	16:4	21:4	2	(header_prefix == 0)
cond	16:8	16:25	3	header_prefix == 0
water	16:8	0:0	4	header_prefix
op	16:22	0:0	4	==
water	16:25	0:0	4	0
stmts	16:28	21:4	3	
water	16:28	0:0	4	{
call	17:8	19:53	4	av_log
arg	17:15	17:25	5	ctx->avctx
water	17:15	0:0	6	ctx
op	17:18	0:0	6	->
water	17:20	0:0	6	avctx
arg	17:27	17:39	5	AV_LOG_ERROR
water	17:27	0:0	6	AV_LOG_ERROR
arg	18:15	18:68	5	"unknown header 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X\n"
water	18:15	0:0	6	"unknown header 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X\n"
arg	19:15	19:21	5	buf[0]
water	19:15	0:0	6	buf
op	19:18	0:0	6	[
water	19:19	0:0	6	0
op	19:20	0:0	6	]
arg	19:23	19:29	5	buf[1]
water	19:23	0:0	6	buf
op	19:26	0:0	6	[
water	19:27	0:0	6	1
op	19:28	0:0	6	]
arg	19:31	19:37	5	buf[2]
water	19:31	0:0	6	buf
op	19:34	0:0	6	[
water	19:35	0:0	6	2
op	19:36	0:0	6	]
arg	19:39	19:45	5	buf[3]
water	19:39	0:0	6	buf
op	19:42	0:0	6	[
water	19:43	0:0	6	3
op	19:44	0:0	6	]
arg	19:47	19:53	5	buf[4]
water	19:47	0:0	6	buf
op	19:50	0:0	6	[
water	19:51	0:0	6	4
op	19:52	0:0	6	]
water	19:54	0:0	4	;
return	20:8	20:34	4	AVERROR_INVALIDDATA
water	20:15	0:0	5	AVERROR_INVALIDDATA
water	21:4	0:0	4	}
if	22:4	28:4	2	(buf [ 5 ] & 2)
cond	22:8	22:17	3	buf [ 5 ] & 2
water	22:8	0:0	4	buf
op	22:11	0:0	4	[
water	22:12	0:0	4	5
op	22:13	0:0	4	]
op	22:15	0:0	4	&
water	22:17	0:0	4	2
stmts	22:20	28:4	3	
water	22:20	0:0	4	{
water	23:8	0:0	4	ctx
op	23:11	0:0	4	->
water	23:13	0:0	4	cur_field
op	23:23	0:0	4	=
water	23:25	0:0	4	buf
op	23:28	0:0	4	[
water	23:29	0:0	4	5
op	23:30	0:0	4	]
op	23:32	0:0	4	&
water	23:34	0:0	4	1
water	23:35	0:0	4	;
water	24:8	0:0	4	frame
op	24:13	0:0	4	->
water	24:15	0:0	4	interlaced_frame
op	24:32	0:0	4	=
water	24:34	0:0	4	1
water	24:35	0:0	4	;
water	25:8	0:0	4	frame
op	25:13	0:0	4	->
water	25:15	0:0	4	top_field_first
op	25:32	0:0	4	=
water	25:34	0:0	4	first_field
op	25:46	0:0	4	^
water	25:48	0:0	4	ctx
op	25:51	0:0	4	->
water	25:53	0:0	4	cur_field
water	25:62	0:0	4	;
call	26:8	27:74	4	av_log
arg	26:15	26:25	5	ctx->avctx
water	26:15	0:0	6	ctx
op	26:18	0:0	6	->
water	26:20	0:0	6	avctx
arg	26:27	26:39	5	AV_LOG_DEBUG
water	26:27	0:0	6	AV_LOG_DEBUG
arg	27:15	27:46	5	"interlaced %d, cur field %d\n"
water	27:15	0:0	6	"interlaced %d, cur field %d\n"
arg	27:48	27:58	5	buf[5]&3
water	27:48	0:0	6	buf
op	27:51	0:0	6	[
water	27:52	0:0	6	5
op	27:53	0:0	6	]
op	27:55	0:0	6	&
water	27:57	0:0	6	3
arg	27:60	27:74	5	ctx->cur_field
water	27:60	0:0	6	ctx
op	27:63	0:0	6	->
water	27:65	0:0	6	cur_field
water	27:75	0:0	4	;
water	28:4	0:0	4	}
else	28:6	30:4	2
stmts	28:11	30:4	3	
water	28:11	0:0	4	{
water	29:8	0:0	4	ctx
op	29:11	0:0	4	->
water	29:13	0:0	4	cur_field
op	29:23	0:0	4	=
water	29:25	0:0	4	0
water	29:26	0:0	4	;
water	30:4	0:0	4	}
water	31:4	0:0	2	ctx
op	31:7	0:0	2	->
water	31:9	0:0	2	mbaff
op	31:15	0:0	2	=
water	31:17	0:0	2	(
water	31:18	0:0	2	buf
op	31:21	0:0	2	[
water	31:22	0:0	2	0
water	31:23	0:0	2	x6
op	31:25	0:0	2	]
op	31:27	0:0	2	>>
water	31:30	0:0	2	5
water	31:31	0:0	2	)
op	31:33	0:0	2	&
water	31:35	0:0	2	1
water	31:36	0:0	2	;
water	33:4	0:0	2	ctx
op	33:7	0:0	2	->
water	33:9	0:0	2	height
op	33:16	0:0	2	=
call	33:18	33:36	2	AV_RB16
arg	33:26	33:36	3	buf+0x18
water	33:26	0:0	4	buf
op	33:30	0:0	4	+
water	33:32	0:0	4	0
water	33:33	0:0	4	x18
water	33:37	0:0	2	;
water	34:4	0:0	2	ctx
op	34:7	0:0	2	->
water	34:9	0:0	2	width
op	34:16	0:0	2	=
call	34:18	34:36	2	AV_RB16
arg	34:26	34:36	3	buf+0x1a
water	34:26	0:0	4	buf
op	34:30	0:0	4	+
water	34:32	0:0	4	0
water	34:33	0:0	4	x1a
water	34:37	0:0	2	;
switch	36:4	44:4	2	(buf [ 0 x21 ] >> 5)
cond	36:11	36:24	3	buf [ 0 x21 ] >> 5
water	36:11	0:0	4	buf
op	36:14	0:0	4	[
water	36:15	0:0	4	0
water	36:16	0:0	4	x21
op	36:19	0:0	4	]
op	36:21	0:0	4	>>
water	36:24	0:0	4	5
stmts	36:27	44:4	3	
water	36:27	0:0	4	{
label	37:4	37:10	4	case 1 :
water	37:12	0:0	4	bitdepth
op	37:21	0:0	4	=
water	37:23	0:0	4	8
water	37:24	0:0	4	;
break	37:26	37:31	4	
label	38:4	38:10	4	case 2 :
water	38:12	0:0	4	bitdepth
op	38:21	0:0	4	=
water	38:23	0:0	4	10
water	38:25	0:0	4	;
break	38:27	38:32	4	
label	39:4	39:10	4	case 3 :
water	39:12	0:0	4	bitdepth
op	39:21	0:0	4	=
water	39:23	0:0	4	12
water	39:25	0:0	4	;
break	39:27	39:32	4	
label	40:4	40:11	4	default :
call	41:8	42:66	4	av_log
arg	41:15	41:25	5	ctx->avctx
water	41:15	0:0	6	ctx
op	41:18	0:0	6	->
water	41:20	0:0	6	avctx
arg	41:27	41:39	5	AV_LOG_ERROR
water	41:27	0:0	6	AV_LOG_ERROR
arg	42:15	42:50	5	"Unknown bitdepth indicator (%d)\n"
water	42:15	0:0	6	"Unknown bitdepth indicator (%d)\n"
arg	42:52	42:66	5	buf[0x21]>>5
water	42:52	0:0	6	buf
op	42:55	0:0	6	[
water	42:56	0:0	6	0
water	42:57	0:0	6	x21
op	42:60	0:0	6	]
op	42:62	0:0	6	>>
water	42:65	0:0	6	5
water	42:67	0:0	4	;
return	43:8	43:34	4	AVERROR_INVALIDDATA
water	43:15	0:0	5	AVERROR_INVALIDDATA
water	44:4	0:0	4	}
water	46:4	0:0	2	cid
op	46:8	0:0	2	=
call	46:10	46:28	2	AV_RB32
arg	46:18	46:28	3	buf+0x28
water	46:18	0:0	4	buf
op	46:22	0:0	4	+
water	46:24	0:0	4	0
water	46:25	0:0	4	x28
water	46:29	0:0	2	;
if	47:4	48:18	2	(( ret =dnxhd_init_vlc (ctx ,cid ,bitdepth ) ) < 0)
cond	47:8	47:53	3	( ret =dnxhd_init_vlc (ctx ,cid ,bitdepth ) ) < 0
water	47:8	0:0	4	(
water	47:9	0:0	4	ret
op	47:13	0:0	4	=
call	47:15	47:48	4	dnxhd_init_vlc
arg	47:30	47:33	5	ctx
water	47:30	0:0	6	ctx
arg	47:35	47:38	5	cid
water	47:35	0:0	6	cid
arg	47:40	47:48	5	bitdepth
water	47:40	0:0	6	bitdepth
water	47:49	0:0	4	)
op	47:51	0:0	4	<
water	47:53	0:0	4	0
stmts	48:8	48:18	3	
return	48:8	48:18	4	ret
water	48:15	0:0	5	ret
if	49:4	51:73	2	(ctx -> mbaff && ctx -> cid_table -> cid != 1260)
cond	49:8	49:45	3	ctx -> mbaff && ctx -> cid_table -> cid != 1260
water	49:8	0:0	4	ctx
op	49:11	0:0	4	->
water	49:13	0:0	4	mbaff
op	49:19	0:0	4	&&
water	49:22	0:0	4	ctx
op	49:25	0:0	4	->
water	49:27	0:0	4	cid_table
op	49:36	0:0	4	->
water	49:38	0:0	4	cid
op	49:42	0:0	4	!=
water	49:45	0:0	4	1260
stmts	50:8	51:73	3	
call	50:8	51:72	4	av_log
arg	50:15	50:25	5	ctx->avctx
water	50:15	0:0	6	ctx
op	50:18	0:0	6	->
water	50:20	0:0	6	avctx
arg	50:27	50:41	5	AV_LOG_WARNING
water	50:27	0:0	6	AV_LOG_WARNING
arg	51:15	51:72	5	"Adaptive MB interlace flag in an unsupported profile.\n"
water	51:15	0:0	6	"Adaptive MB interlace flag in an unsupported profile.\n"
water	51:73	0:0	4	;
water	53:4	0:0	2	ctx
op	53:7	0:0	2	->
water	53:9	0:0	2	act
op	53:13	0:0	2	=
water	53:15	0:0	2	buf
op	53:18	0:0	2	[
water	53:19	0:0	2	0
water	53:20	0:0	2	x2C
op	53:23	0:0	2	]
op	53:25	0:0	2	&
water	53:27	0:0	2	7
water	53:28	0:0	2	;
if	54:4	56:71	2	(ctx -> act && ctx -> cid_table -> cid != 1256 && ctx -> cid_table -> cid != 1270)
cond	54:8	54:74	3	ctx -> act && ctx -> cid_table -> cid != 1256 && ctx -> cid_table -> cid != 1270
water	54:8	0:0	4	ctx
op	54:11	0:0	4	->
water	54:13	0:0	4	act
op	54:17	0:0	4	&&
water	54:20	0:0	4	ctx
op	54:23	0:0	4	->
water	54:25	0:0	4	cid_table
op	54:34	0:0	4	->
water	54:36	0:0	4	cid
op	54:40	0:0	4	!=
water	54:43	0:0	4	1256
op	54:48	0:0	4	&&
water	54:51	0:0	4	ctx
op	54:54	0:0	4	->
water	54:56	0:0	4	cid_table
op	54:65	0:0	4	->
water	54:67	0:0	4	cid
op	54:71	0:0	4	!=
water	54:74	0:0	4	1270
stmts	55:8	56:71	3	
call	55:8	56:70	4	av_log
arg	55:15	55:25	5	ctx->avctx
water	55:15	0:0	6	ctx
op	55:18	0:0	6	->
water	55:20	0:0	6	avctx
arg	55:27	55:41	5	AV_LOG_WARNING
water	55:27	0:0	6	AV_LOG_WARNING
arg	56:15	56:70	5	"Adaptive color transform in an unsupported profile.\n"
water	56:15	0:0	6	"Adaptive color transform in an unsupported profile.\n"
water	56:71	0:0	4	;
water	58:4	0:0	2	ctx
op	58:7	0:0	2	->
water	58:9	0:0	2	is_444
op	58:16	0:0	2	=
water	58:18	0:0	2	(
water	58:19	0:0	2	buf
op	58:22	0:0	2	[
water	58:23	0:0	2	0
water	58:24	0:0	2	x2C
op	58:27	0:0	2	]
op	58:29	0:0	2	>>
water	58:32	0:0	2	6
water	58:33	0:0	2	)
op	58:35	0:0	2	&
water	58:37	0:0	2	1
water	58:38	0:0	2	;
if	59:4	72:4	2	(ctx -> is_444)
cond	59:8	59:13	3	ctx -> is_444
water	59:8	0:0	4	ctx
op	59:11	0:0	4	->
water	59:13	0:0	4	is_444
stmts	59:21	72:4	3	
water	59:21	0:0	4	{
if	60:8	63:8	4	(bitdepth == 8)
cond	60:12	60:24	5	bitdepth == 8
water	60:12	0:0	6	bitdepth
op	60:21	0:0	6	==
water	60:24	0:0	6	8
stmts	60:27	63:8	5	
water	60:27	0:0	6	{
call	61:12	61:62	6	avpriv_request_sample
arg	61:34	61:44	7	ctx->avctx
water	61:34	0:0	8	ctx
op	61:37	0:0	8	->
water	61:39	0:0	8	avctx
arg	61:46	61:62	7	"4:4:4 8 bits\n"
water	61:46	0:0	8	"4:4:4 8 bits\n"
water	61:63	0:0	6	;
return	62:12	62:38	6	AVERROR_INVALIDDATA
water	62:19	0:0	7	AVERROR_INVALIDDATA
water	63:8	0:0	6	}
else	63:10	67:8	4
stmts	63:15	67:8	5	
if	63:15	67:8	6	(bitdepth == 10)
cond	63:19	63:31	7	bitdepth == 10
water	63:19	0:0	8	bitdepth
op	63:28	0:0	8	==
water	63:31	0:0	8	10
stmts	63:35	67:8	7	
water	63:35	0:0	8	{
water	64:12	0:0	8	ctx
op	64:15	0:0	8	->
water	64:17	0:0	8	decode_dct_block
op	64:34	0:0	8	=
water	64:36	0:0	8	dnxhd_decode_dct_block_10_444
water	64:65	0:0	8	;
water	65:12	0:0	8	ctx
op	65:15	0:0	8	->
water	65:17	0:0	8	pix_fmt
op	65:25	0:0	8	=
water	65:27	0:0	8	ctx
op	65:30	0:0	8	->
water	65:32	0:0	8	act
water	65:36	0:0	8	?
water	65:38	0:0	8	AV_PIX_FMT_YUV444P10
water	66:36	0:0	8	:
water	66:38	0:0	8	AV_PIX_FMT_GBRP10
water	66:55	0:0	8	;
water	67:8	0:0	8	}
else	67:10	71:8	4
stmts	67:15	71:8	5	
water	67:15	0:0	6	{
water	68:12	0:0	6	ctx
op	68:15	0:0	6	->
water	68:17	0:0	6	decode_dct_block
op	68:34	0:0	6	=
water	68:36	0:0	6	dnxhd_decode_dct_block_12_444
water	68:65	0:0	6	;
water	69:12	0:0	6	ctx
op	69:15	0:0	6	->
water	69:17	0:0	6	pix_fmt
op	69:25	0:0	6	=
water	69:27	0:0	6	ctx
op	69:30	0:0	6	->
water	69:32	0:0	6	act
water	69:36	0:0	6	?
water	69:38	0:0	6	AV_PIX_FMT_YUV444P12
water	70:36	0:0	6	:
water	70:38	0:0	6	AV_PIX_FMT_GBRP12
water	70:55	0:0	6	;
water	71:8	0:0	6	}
water	72:4	0:0	4	}
else	72:6	75:4	2
stmts	72:11	75:4	3	
if	72:11	75:4	4	(bitdepth == 12)
cond	72:15	72:27	5	bitdepth == 12
water	72:15	0:0	6	bitdepth
op	72:24	0:0	6	==
water	72:27	0:0	6	12
stmts	72:31	75:4	5	
water	72:31	0:0	6	{
water	73:8	0:0	6	ctx
op	73:11	0:0	6	->
water	73:13	0:0	6	decode_dct_block
op	73:30	0:0	6	=
water	73:32	0:0	6	dnxhd_decode_dct_block_12
water	73:57	0:0	6	;
water	74:8	0:0	6	ctx
op	74:11	0:0	6	->
water	74:13	0:0	6	pix_fmt
op	74:21	0:0	6	=
water	74:23	0:0	6	AV_PIX_FMT_YUV422P12
water	74:43	0:0	6	;
water	75:4	0:0	6	}
else	75:6	78:4	2
stmts	75:11	78:4	3	
if	75:11	78:4	4	(bitdepth == 10)
cond	75:15	75:27	5	bitdepth == 10
water	75:15	0:0	6	bitdepth
op	75:24	0:0	6	==
water	75:27	0:0	6	10
stmts	75:31	78:4	5	
water	75:31	0:0	6	{
water	76:8	0:0	6	ctx
op	76:11	0:0	6	->
water	76:13	0:0	6	decode_dct_block
op	76:30	0:0	6	=
water	76:32	0:0	6	dnxhd_decode_dct_block_10
water	76:57	0:0	6	;
water	77:8	0:0	6	ctx
op	77:11	0:0	6	->
water	77:13	0:0	6	pix_fmt
op	77:21	0:0	6	=
water	77:23	0:0	6	AV_PIX_FMT_YUV422P10
water	77:43	0:0	6	;
water	78:4	0:0	6	}
else	78:6	81:4	2
stmts	78:11	81:4	3	
water	78:11	0:0	4	{
water	79:8	0:0	4	ctx
op	79:11	0:0	4	->
water	79:13	0:0	4	decode_dct_block
op	79:30	0:0	4	=
water	79:32	0:0	4	dnxhd_decode_dct_block_8
water	79:56	0:0	4	;
water	80:8	0:0	4	ctx
op	80:11	0:0	4	->
water	80:13	0:0	4	pix_fmt
op	80:21	0:0	4	=
water	80:23	0:0	4	AV_PIX_FMT_YUV422P
water	80:41	0:0	4	;
water	81:4	0:0	4	}
water	83:4	0:0	2	ctx
op	83:7	0:0	2	->
water	83:9	0:0	2	avctx
op	83:14	0:0	2	->
water	83:16	0:0	2	bits_per_raw_sample
op	83:36	0:0	2	=
water	83:38	0:0	2	ctx
op	83:41	0:0	2	->
water	83:43	0:0	2	bit_depth
op	83:53	0:0	2	=
water	83:55	0:0	2	bitdepth
water	83:63	0:0	2	;
if	84:4	89:4	2	(ctx -> bit_depth != old_bit_depth)
cond	84:8	84:26	3	ctx -> bit_depth != old_bit_depth
water	84:8	0:0	4	ctx
op	84:11	0:0	4	->
water	84:13	0:0	4	bit_depth
op	84:23	0:0	4	!=
water	84:26	0:0	4	old_bit_depth
stmts	84:41	89:4	3	
water	84:41	0:0	4	{
call	85:8	85:47	4	ff_blockdsp_init
arg	85:25	85:35	5	&ctx->bdsp
op	85:25	0:0	6	&
water	85:26	0:0	6	ctx
op	85:29	0:0	6	->
water	85:31	0:0	6	bdsp
arg	85:37	85:47	5	ctx->avctx
water	85:37	0:0	6	ctx
op	85:40	0:0	6	->
water	85:42	0:0	6	avctx
water	85:48	0:0	4	;
call	86:8	86:46	4	ff_idctdsp_init
arg	86:24	86:34	5	&ctx->idsp
op	86:24	0:0	6	&
water	86:25	0:0	6	ctx
op	86:28	0:0	6	->
water	86:30	0:0	6	idsp
arg	86:36	86:46	5	ctx->avctx
water	86:36	0:0	6	ctx
op	86:39	0:0	6	->
water	86:41	0:0	6	avctx
water	86:47	0:0	4	;
call	87:8	88:42	4	ff_init_scantable
arg	87:26	87:52	5	ctx->idsp.idct_permutation
water	87:26	0:0	6	ctx
op	87:29	0:0	6	->
water	87:31	0:0	6	idsp
op	87:35	0:0	6	.
water	87:36	0:0	6	idct_permutation
arg	87:54	87:69	5	&ctx->scantable
op	87:54	0:0	6	&
water	87:55	0:0	6	ctx
op	87:58	0:0	6	->
water	87:60	0:0	6	scantable
arg	88:26	88:42	5	ff_zigzag_direct
water	88:26	0:0	6	ff_zigzag_direct
water	88:43	0:0	4	;
water	89:4	0:0	4	}
if	93:4	99:4	2	(ctx -> width != ctx -> cid_table -> width && ctx -> cid_table -> width != DNXHD_VARIABLE)
cond	93:8	94:33	3	ctx -> width != ctx -> cid_table -> width && ctx -> cid_table -> width != DNXHD_VARIABLE
water	93:8	0:0	4	ctx
op	93:11	0:0	4	->
water	93:13	0:0	4	width
op	93:19	0:0	4	!=
water	93:22	0:0	4	ctx
op	93:25	0:0	4	->
water	93:27	0:0	4	cid_table
op	93:36	0:0	4	->
water	93:38	0:0	4	width
op	93:44	0:0	4	&&
water	94:8	0:0	4	ctx
op	94:11	0:0	4	->
water	94:13	0:0	4	cid_table
op	94:22	0:0	4	->
water	94:24	0:0	4	width
op	94:30	0:0	4	!=
water	94:33	0:0	4	DNXHD_VARIABLE
stmts	94:49	99:4	3	
water	94:49	0:0	4	{
call	95:8	97:56	4	av_reduce
arg	95:18	95:54	5	&ctx->avctx->sample_aspect_ratio.num
op	95:18	0:0	6	&
water	95:19	0:0	6	ctx
op	95:22	0:0	6	->
water	95:24	0:0	6	avctx
op	95:29	0:0	6	->
water	95:31	0:0	6	sample_aspect_ratio
op	95:50	0:0	6	.
water	95:51	0:0	6	num
arg	96:18	96:54	5	&ctx->avctx->sample_aspect_ratio.den
op	96:18	0:0	6	&
water	96:19	0:0	6	ctx
op	96:22	0:0	6	->
water	96:24	0:0	6	avctx
op	96:29	0:0	6	->
water	96:31	0:0	6	sample_aspect_ratio
op	96:50	0:0	6	.
water	96:51	0:0	6	den
arg	97:18	97:28	5	ctx->width
water	97:18	0:0	6	ctx
op	97:21	0:0	6	->
water	97:23	0:0	6	width
arg	97:30	97:51	5	ctx->cid_table->width
water	97:30	0:0	6	ctx
op	97:33	0:0	6	->
water	97:35	0:0	6	cid_table
op	97:44	0:0	6	->
water	97:46	0:0	6	width
arg	97:53	97:56	5	255
water	97:53	0:0	6	255
water	97:57	0:0	4	;
water	98:8	0:0	4	ctx
op	98:11	0:0	4	->
water	98:13	0:0	4	width
op	98:19	0:0	4	=
water	98:21	0:0	4	ctx
op	98:24	0:0	4	->
water	98:26	0:0	4	cid_table
op	98:35	0:0	4	->
water	98:37	0:0	4	width
water	98:42	0:0	4	;
water	99:4	0:0	4	}
if	101:4	105:4	2	(buf_size < ctx -> cid_table -> coding_unit_size)
cond	101:8	101:35	3	buf_size < ctx -> cid_table -> coding_unit_size
water	101:8	0:0	4	buf_size
op	101:17	0:0	4	<
water	101:19	0:0	4	ctx
op	101:22	0:0	4	->
water	101:24	0:0	4	cid_table
op	101:33	0:0	4	->
water	101:35	0:0	4	coding_unit_size
stmts	101:53	105:4	3	
water	101:53	0:0	4	{
call	102:8	103:57	4	av_log
arg	102:15	102:25	5	ctx->avctx
water	102:15	0:0	6	ctx
op	102:18	0:0	6	->
water	102:20	0:0	6	avctx
arg	102:27	102:39	5	AV_LOG_ERROR
water	102:27	0:0	6	AV_LOG_ERROR
arg	102:41	102:76	5	"incorrect frame size (%d < %d).\n"
water	102:41	0:0	6	"incorrect frame size (%d < %d).\n"
arg	103:15	103:23	5	buf_size
water	103:15	0:0	6	buf_size
arg	103:25	103:57	5	ctx->cid_table->coding_unit_size
water	103:25	0:0	6	ctx
op	103:28	0:0	6	->
water	103:30	0:0	6	cid_table
op	103:39	0:0	6	->
water	103:41	0:0	6	coding_unit_size
water	103:58	0:0	4	;
return	104:8	104:34	4	AVERROR_INVALIDDATA
water	104:15	0:0	5	AVERROR_INVALIDDATA
water	105:4	0:0	4	}
water	107:4	0:0	2	ctx
op	107:7	0:0	2	->
water	107:9	0:0	2	mb_width
op	107:19	0:0	2	=
water	107:21	0:0	2	(
water	107:22	0:0	2	ctx
op	107:25	0:0	2	->
water	107:27	0:0	2	width
op	107:33	0:0	2	+
water	107:35	0:0	2	15
water	107:37	0:0	2	)
op	107:38	0:0	2	>>
water	107:41	0:0	2	4
water	107:42	0:0	2	;
water	108:4	0:0	2	ctx
op	108:7	0:0	2	->
water	108:9	0:0	2	mb_height
op	108:19	0:0	2	=
water	108:21	0:0	2	buf
op	108:24	0:0	2	[
water	108:25	0:0	2	0
water	108:26	0:0	2	x16d
op	108:30	0:0	2	]
water	108:31	0:0	2	;
if	110:4	111:25	2	(( ctx -> height + 15 ) >> 4 == ctx -> mb_height && frame -> interlaced_frame)
cond	110:8	110:60	3	( ctx -> height + 15 ) >> 4 == ctx -> mb_height && frame -> interlaced_frame
water	110:8	0:0	4	(
water	110:9	0:0	4	ctx
op	110:12	0:0	4	->
water	110:14	0:0	4	height
op	110:21	0:0	4	+
water	110:23	0:0	4	15
water	110:25	0:0	4	)
op	110:27	0:0	4	>>
water	110:30	0:0	4	4
op	110:32	0:0	4	==
water	110:35	0:0	4	ctx
op	110:38	0:0	4	->
water	110:40	0:0	4	mb_height
op	110:50	0:0	4	&&
water	110:53	0:0	4	frame
op	110:58	0:0	4	->
water	110:60	0:0	4	interlaced_frame
stmts	111:8	111:25	3	
water	111:8	0:0	4	ctx
op	111:11	0:0	4	->
water	111:13	0:0	4	height
op	111:20	0:0	4	<<=
water	111:24	0:0	4	1
water	111:25	0:0	4	;
call	113:4	115:47	2	av_log
arg	113:11	113:21	3	ctx->avctx
water	113:11	0:0	4	ctx
op	113:14	0:0	4	->
water	113:16	0:0	4	avctx
arg	113:23	113:37	3	AV_LOG_VERBOSE
water	113:23	0:0	4	AV_LOG_VERBOSE
arg	113:39	113:79	3	"%dx%d, 4:%s %d bits, MBAFF=%d ACT=%d\n"
water	113:39	0:0	4	"%dx%d, 4:%s %d bits, MBAFF=%d ACT=%d\n"
arg	114:11	114:21	3	ctx->width
water	114:11	0:0	4	ctx
op	114:14	0:0	4	->
water	114:16	0:0	4	width
arg	114:23	114:34	3	ctx->height
water	114:23	0:0	4	ctx
op	114:26	0:0	4	->
water	114:28	0:0	4	height
arg	114:36	114:63	3	ctx->is_444?"4:4":"2:2"
water	114:36	0:0	4	ctx
op	114:39	0:0	4	->
water	114:41	0:0	4	is_444
water	114:48	0:0	4	?
water	114:50	0:0	4	"4:4"
water	114:56	0:0	4	:
water	114:58	0:0	4	"2:2"
arg	115:11	115:25	3	ctx->bit_depth
water	115:11	0:0	4	ctx
op	115:14	0:0	4	->
water	115:16	0:0	4	bit_depth
arg	115:27	115:37	3	ctx->mbaff
water	115:27	0:0	4	ctx
op	115:30	0:0	4	->
water	115:32	0:0	4	mbaff
arg	115:39	115:47	3	ctx->act
water	115:39	0:0	4	ctx
op	115:42	0:0	4	->
water	115:44	0:0	4	act
water	115:48	0:0	2	;
if	118:4	120:4	2	(header_prefix == DNXHD_HEADER_HR2)
cond	118:8	118:25	3	header_prefix == DNXHD_HEADER_HR2
water	118:8	0:0	4	header_prefix
op	118:22	0:0	4	==
water	118:25	0:0	4	DNXHD_HEADER_HR2
stmts	118:43	120:4	3	
water	118:43	0:0	4	{
water	119:8	0:0	4	ctx
op	119:11	0:0	4	->
water	119:13	0:0	4	data_offset
op	119:25	0:0	4	=
water	119:27	0:0	4	0
water	119:28	0:0	4	x170
op	119:33	0:0	4	+
water	119:35	0:0	4	(
water	119:36	0:0	4	ctx
op	119:39	0:0	4	->
water	119:41	0:0	4	mb_height
op	119:51	0:0	4	<<
water	119:54	0:0	4	2
water	119:55	0:0	4	)
water	119:56	0:0	4	;
water	120:4	0:0	4	}
else	120:6	128:4	2
stmts	120:11	128:4	3	
water	120:11	0:0	4	{
if	121:8	126:8	4	(ctx -> mb_height > 68 || ( ctx -> mb_height << frame -> interlaced_frame ) > ( ctx -> height + 15 ) >> 4)
cond	121:12	122:80	5	ctx -> mb_height > 68 || ( ctx -> mb_height << frame -> interlaced_frame ) > ( ctx -> height + 15 ) >> 4
water	121:12	0:0	6	ctx
op	121:15	0:0	6	->
water	121:17	0:0	6	mb_height
op	121:27	0:0	6	>
water	121:29	0:0	6	68
op	121:32	0:0	6	||
water	122:12	0:0	6	(
water	122:13	0:0	6	ctx
op	122:16	0:0	6	->
water	122:18	0:0	6	mb_height
op	122:28	0:0	6	<<
water	122:31	0:0	6	frame
op	122:36	0:0	6	->
water	122:38	0:0	6	interlaced_frame
water	122:54	0:0	6	)
op	122:56	0:0	6	>
water	122:58	0:0	6	(
water	122:59	0:0	6	ctx
op	122:62	0:0	6	->
water	122:64	0:0	6	height
op	122:71	0:0	6	+
water	122:73	0:0	6	15
water	122:75	0:0	6	)
op	122:77	0:0	6	>>
water	122:80	0:0	6	4
stmts	122:83	126:8	5	
water	122:83	0:0	6	{
call	123:12	124:60	6	av_log
arg	123:19	123:29	7	ctx->avctx
water	123:19	0:0	8	ctx
op	123:22	0:0	8	->
water	123:24	0:0	8	avctx
arg	123:31	123:43	7	AV_LOG_ERROR
water	123:31	0:0	8	AV_LOG_ERROR
arg	124:19	124:44	7	"mb height too big: %d\n"
water	124:19	0:0	8	"mb height too big: %d\n"
arg	124:46	124:60	7	ctx->mb_height
water	124:46	0:0	8	ctx
op	124:49	0:0	8	->
water	124:51	0:0	8	mb_height
water	124:61	0:0	6	;
return	125:12	125:38	6	AVERROR_INVALIDDATA
water	125:19	0:0	7	AVERROR_INVALIDDATA
water	126:8	0:0	6	}
water	127:8	0:0	4	ctx
op	127:11	0:0	4	->
water	127:13	0:0	4	data_offset
op	127:25	0:0	4	=
water	127:27	0:0	4	0
water	127:28	0:0	4	x280
water	127:32	0:0	4	;
water	128:4	0:0	4	}
if	130:4	134:4	2	(buf_size < ctx -> data_offset)
cond	130:8	130:24	3	buf_size < ctx -> data_offset
water	130:8	0:0	4	buf_size
op	130:17	0:0	4	<
water	130:19	0:0	4	ctx
op	130:22	0:0	4	->
water	130:24	0:0	4	data_offset
stmts	130:37	134:4	3	
water	130:37	0:0	4	{
call	131:8	132:74	4	av_log
arg	131:15	131:25	5	ctx->avctx
water	131:15	0:0	6	ctx
op	131:18	0:0	6	->
water	131:20	0:0	6	avctx
arg	131:27	131:39	5	AV_LOG_ERROR
water	131:27	0:0	6	AV_LOG_ERROR
arg	132:15	132:46	5	"buffer too small (%d < %d).\n"
water	132:15	0:0	6	"buffer too small (%d < %d).\n"
arg	132:48	132:56	5	buf_size
water	132:48	0:0	6	buf_size
arg	132:58	132:74	5	ctx->data_offset
water	132:58	0:0	6	ctx
op	132:61	0:0	6	->
water	132:63	0:0	6	data_offset
water	132:75	0:0	4	;
return	133:8	133:34	4	AVERROR_INVALIDDATA
water	133:15	0:0	5	AVERROR_INVALIDDATA
water	134:4	0:0	4	}
call	136:4	136:77	2	av_assert0
arg	136:15	136:77	3	(unsigned)ctx->mb_height<=FF_ARRAY_ELEMS(ctx->mb_scan_index)
water	136:15	0:0	4	(
water	136:16	0:0	4	unsigned
water	136:24	0:0	4	)
water	136:25	0:0	4	ctx
op	136:28	0:0	4	->
water	136:30	0:0	4	mb_height
op	136:40	0:0	4	<=
call	136:43	136:76	4	FF_ARRAY_ELEMS
arg	136:58	136:76	5	ctx->mb_scan_index
water	136:58	0:0	6	ctx
op	136:61	0:0	6	->
water	136:63	0:0	6	mb_scan_index
water	136:78	0:0	2	;
for	138:4	147:4	2	(i = 0 ;i < ctx -> mb_height;i ++)
forinit	138:9	138:14	3	i = 0 ;
water	138:9	0:0	4	i
op	138:11	0:0	4	=
water	138:13	0:0	4	0
water	138:14	0:0	4	;
cond	138:16	138:25	3	i < ctx -> mb_height
water	138:16	0:0	4	i
op	138:18	0:0	4	<
water	138:20	0:0	4	ctx
op	138:23	0:0	4	->
water	138:25	0:0	4	mb_height
forexpr	138:36	138:37	3	i ++
water	138:36	0:0	4	i
op	138:37	0:0	4	++
stmts	138:41	147:4	3	
water	138:41	0:0	4	{
water	139:8	0:0	4	ctx
op	139:11	0:0	4	->
water	139:13	0:0	4	mb_scan_index
op	139:26	0:0	4	[
water	139:27	0:0	4	i
op	139:28	0:0	4	]
op	139:30	0:0	4	=
call	139:32	139:62	4	AV_RB32
arg	139:40	139:62	5	buf+0x170+(i<<2)
water	139:40	0:0	6	buf
op	139:44	0:0	6	+
water	139:46	0:0	6	0
water	139:47	0:0	6	x170
op	139:52	0:0	6	+
water	139:54	0:0	6	(
water	139:55	0:0	6	i
op	139:57	0:0	6	<<
water	139:60	0:0	6	2
water	139:61	0:0	6	)
water	139:63	0:0	4	;
call	140:8	140:104	4	ff_dlog
arg	140:16	140:26	5	ctx->avctx
water	140:16	0:0	6	ctx
op	140:19	0:0	6	->
water	140:21	0:0	6	avctx
arg	140:28	140:60	5	"mb scan index %d, pos %d: %u\n"
water	140:28	0:0	6	"mb scan index %d, pos %d: %u\n"
arg	140:62	140:63	5	i
water	140:62	0:0	6	i
arg	140:65	140:81	5	0x170+(i<<2)
water	140:65	0:0	6	0
water	140:66	0:0	6	x170
op	140:71	0:0	6	+
water	140:73	0:0	6	(
water	140:74	0:0	6	i
op	140:76	0:0	6	<<
water	140:79	0:0	6	2
water	140:80	0:0	6	)
arg	140:83	140:104	5	ctx->mb_scan_index[i]
water	140:83	0:0	6	ctx
op	140:86	0:0	6	->
water	140:88	0:0	6	mb_scan_index
op	140:101	0:0	6	[
water	140:102	0:0	6	i
op	140:103	0:0	6	]
water	140:105	0:0	4	;
if	141:8	146:8	4	(buf_size - ctx -> data_offset < ctx -> mb_scan_index [ i ])
cond	141:12	141:62	5	buf_size - ctx -> data_offset < ctx -> mb_scan_index [ i ]
water	141:12	0:0	6	buf_size
op	141:21	0:0	6	-
water	141:23	0:0	6	ctx
op	141:26	0:0	6	->
water	141:28	0:0	6	data_offset
op	141:40	0:0	6	<
water	141:42	0:0	6	ctx
op	141:45	0:0	6	->
water	141:47	0:0	6	mb_scan_index
op	141:60	0:0	6	[
water	141:61	0:0	6	i
op	141:62	0:0	6	]
stmts	141:65	146:8	5	
water	141:65	0:0	6	{
call	142:12	144:69	6	av_log
arg	142:19	142:29	7	ctx->avctx
water	142:19	0:0	8	ctx
op	142:22	0:0	8	->
water	142:24	0:0	8	avctx
arg	142:31	142:43	7	AV_LOG_ERROR
water	142:31	0:0	8	AV_LOG_ERROR
arg	143:19	143:56	7	"invalid mb scan index (%u vs %u).\n"
water	143:19	0:0	8	"invalid mb scan index (%u vs %u).\n"
arg	144:19	144:40	7	ctx->mb_scan_index[i]
water	144:19	0:0	8	ctx
op	144:22	0:0	8	->
water	144:24	0:0	8	mb_scan_index
op	144:37	0:0	8	[
water	144:38	0:0	8	i
op	144:39	0:0	8	]
arg	144:42	144:69	7	buf_size-ctx->data_offset
water	144:42	0:0	8	buf_size
op	144:51	0:0	8	-
water	144:53	0:0	8	ctx
op	144:56	0:0	8	->
water	144:58	0:0	8	data_offset
water	144:70	0:0	6	;
return	145:12	145:38	6	AVERROR_INVALIDDATA
water	145:19	0:0	7	AVERROR_INVALIDDATA
water	146:8	0:0	6	}
water	147:4	0:0	4	}
return	149:4	149:12	2	0
water	149:11	0:0	3	0
