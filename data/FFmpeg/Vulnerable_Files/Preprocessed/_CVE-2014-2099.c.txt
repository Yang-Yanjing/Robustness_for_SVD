func	1:0	64:0	0	static int	msrle_decode_frame
params	1:29	0:0	1	
param	1:30	1:51	2	AVCodecContext *	avctx
param	2:30	2:40	2	void *	data
param	2:42	2:56	2	int *	got_frame
param	3:30	3:45	2	AVPacket *	avpkt
stmnts	0:0	63:19	1	
decl	5:4	5:36	2	const uint8_t	*buf
op	5:23	0:0	2	=
water	5:25	0:0	2	avpkt
op	5:30	0:0	2	->
water	5:32	0:0	2	data
decl	6:4	6:30	2	int	buf_size
op	6:17	0:0	2	=
water	6:19	0:0	2	avpkt
op	6:24	0:0	2	->
water	6:26	0:0	2	size
decl	7:4	7:38	2	MsrleContext	*s
op	7:20	0:0	2	=
water	7:22	0:0	2	avctx
op	7:27	0:0	2	->
water	7:29	0:0	2	priv_data
decl	8:4	8:76	2	int	istride
op	8:16	0:0	2	=
call	8:18	8:71	3	FFALIGN
arg	8:26	8:67	4	avctx->width*avctx->bits_per_coded_sample
water	8:26	0:0	5	avctx
op	8:31	0:0	5	->
water	8:33	0:0	5	width
op	8:38	0:0	5	*
water	8:39	0:0	5	avctx
op	8:44	0:0	5	->
water	8:46	0:0	5	bits_per_coded_sample
arg	8:69	8:71	4	32
water	8:69	0:0	5	32
op	8:73	0:0	2	/
water	8:75	0:0	2	8
decl	9:4	9:11	2	int	ret
water	11:4	0:0	2	s
op	11:5	0:0	2	->
water	11:7	0:0	2	buf
op	11:11	0:0	2	=
water	11:13	0:0	2	buf
water	11:16	0:0	2	;
water	12:4	0:0	2	s
op	12:5	0:0	2	->
water	12:7	0:0	2	size
op	12:12	0:0	2	=
water	12:14	0:0	2	buf_size
water	12:22	0:0	2	;
if	14:4	15:18	2	(( ret =ff_reget_buffer (avctx ,& s -> frame ) ) < 0)
cond	14:8	14:52	3	( ret =ff_reget_buffer (avctx ,& s -> frame ) ) < 0
water	14:8	0:0	4	(
water	14:9	0:0	4	ret
op	14:13	0:0	4	=
call	14:15	14:47	4	ff_reget_buffer
arg	14:31	14:36	5	avctx
water	14:31	0:0	6	avctx
arg	14:38	14:47	5	&s->frame
op	14:38	0:0	6	&
water	14:39	0:0	6	s
op	14:40	0:0	6	->
water	14:42	0:0	6	frame
water	14:48	0:0	4	)
op	14:50	0:0	4	<
water	14:52	0:0	4	0
stmts	15:8	15:18	3	
return	15:8	15:18	4	ret
water	15:15	0:0	5	ret
if	17:4	26:4	2	(avctx -> bits_per_coded_sample > 1 && avctx -> bits_per_coded_sample <= 8)
cond	17:8	17:76	3	avctx -> bits_per_coded_sample > 1 && avctx -> bits_per_coded_sample <= 8
water	17:8	0:0	4	avctx
op	17:13	0:0	4	->
water	17:15	0:0	4	bits_per_coded_sample
op	17:37	0:0	4	>
water	17:39	0:0	4	1
op	17:41	0:0	4	&&
water	17:44	0:0	4	avctx
op	17:49	0:0	4	->
water	17:51	0:0	4	bits_per_coded_sample
op	17:73	0:0	4	<=
water	17:76	0:0	4	8
stmts	17:79	26:4	3	
water	17:79	0:0	4	{
decl	18:8	18:86	4	const uint8_t	*pal
op	18:27	0:0	4	=
call	18:29	18:85	5	av_packet_get_side_data
arg	18:53	18:58	6	avpkt
water	18:53	0:0	7	avpkt
arg	18:60	18:79	6	AV_PKT_DATA_PALETTE
water	18:60	0:0	7	AV_PKT_DATA_PALETTE
arg	18:81	18:85	6	NULL
water	18:81	0:0	7	NULL
if	20:8	23:8	4	(pal)
cond	20:12	20:12	5	pal
water	20:12	0:0	6	pal
stmts	20:17	23:8	5	
water	20:17	0:0	6	{
water	21:12	0:0	6	s
op	21:13	0:0	6	->
water	21:15	0:0	6	frame
op	21:20	0:0	6	.
water	21:21	0:0	6	palette_has_changed
op	21:41	0:0	6	=
water	21:43	0:0	6	1
water	21:44	0:0	6	;
call	22:12	22:46	6	memcpy
arg	22:19	22:25	7	s->pal
water	22:19	0:0	8	s
op	22:20	0:0	8	->
water	22:22	0:0	8	pal
arg	22:27	22:30	7	pal
water	22:27	0:0	8	pal
arg	22:32	22:46	7	AVPALETTE_SIZE
water	22:32	0:0	8	AVPALETTE_SIZE
water	22:47	0:0	6	;
water	23:8	0:0	6	}
call	25:8	25:55	4	memcpy
arg	25:15	25:31	5	s->frame.data[1]
water	25:15	0:0	6	s
op	25:16	0:0	6	->
water	25:18	0:0	6	frame
op	25:23	0:0	6	.
water	25:24	0:0	6	data
op	25:28	0:0	6	[
water	25:29	0:0	6	1
op	25:30	0:0	6	]
arg	25:33	25:39	5	s->pal
water	25:33	0:0	6	s
op	25:34	0:0	6	->
water	25:36	0:0	6	pal
arg	25:41	25:55	5	AVPALETTE_SIZE
water	25:41	0:0	6	AVPALETTE_SIZE
water	25:56	0:0	4	;
water	26:4	0:0	4	}
if	29:4	52:4	2	(avctx -> height * istride == avpkt -> size)
cond	29:8	29:42	3	avctx -> height * istride == avpkt -> size
water	29:8	0:0	4	avctx
op	29:13	0:0	4	->
water	29:15	0:0	4	height
op	29:22	0:0	4	*
water	29:24	0:0	4	istride
op	29:32	0:0	4	==
water	29:35	0:0	4	avpkt
op	29:40	0:0	4	->
water	29:42	0:0	4	size
stmts	29:48	52:4	3	
water	29:48	0:0	4	{
decl	30:8	30:77	4	int	linesize
op	30:21	0:0	4	=
call	30:23	30:76	5	av_image_get_linesize
arg	30:45	30:59	6	avctx->pix_fmt
water	30:45	0:0	7	avctx
op	30:50	0:0	7	->
water	30:52	0:0	7	pix_fmt
arg	30:61	30:73	6	avctx->width
water	30:61	0:0	7	avctx
op	30:66	0:0	7	->
water	30:68	0:0	7	width
arg	30:75	30:76	6	0
water	30:75	0:0	7	0
decl	31:8	31:39	4	uint8_t	*ptr
op	31:21	0:0	4	=
water	31:23	0:0	4	s
op	31:24	0:0	4	->
water	31:26	0:0	4	frame
op	31:31	0:0	4	.
water	31:32	0:0	4	data
op	31:36	0:0	4	[
water	31:37	0:0	4	0
op	31:38	0:0	4	]
decl	32:8	32:62	4	uint8_t	*buf
op	32:21	0:0	4	=
water	32:23	0:0	4	avpkt
op	32:28	0:0	4	->
water	32:30	0:0	4	data
op	32:35	0:0	4	+
water	32:37	0:0	4	(
water	32:38	0:0	4	avctx
op	32:43	0:0	4	->
water	32:45	0:0	4	height
op	32:51	0:0	4	-
water	32:52	0:0	4	1
water	32:53	0:0	4	)
op	32:54	0:0	4	*
water	32:55	0:0	4	istride
decl	33:8	33:16	4	int	i
water	33:13	0:0	4	,
decl	33:8	33:16	4	int	j
if	35:8	36:27	4	(linesize < 0)
cond	35:12	35:23	5	linesize < 0
water	35:12	0:0	6	linesize
op	35:21	0:0	6	<
water	35:23	0:0	6	0
stmts	36:12	36:27	5	
return	36:12	36:27	6	linesize
water	36:19	0:0	7	linesize
for	38:8	51:8	4	(i = 0 ;i < avctx -> height;i ++)
forinit	38:13	38:18	5	i = 0 ;
water	38:13	0:0	6	i
op	38:15	0:0	6	=
water	38:17	0:0	6	0
water	38:18	0:0	6	;
cond	38:20	38:31	5	i < avctx -> height
water	38:20	0:0	6	i
op	38:22	0:0	6	<
water	38:24	0:0	6	avctx
op	38:29	0:0	6	->
water	38:31	0:0	6	height
forexpr	38:39	38:40	5	i ++
water	38:39	0:0	6	i
op	38:40	0:0	6	++
stmts	38:44	51:8	5	
water	38:44	0:0	6	{
if	39:12	46:12	6	(avctx -> bits_per_coded_sample == 4)
cond	39:16	39:48	7	avctx -> bits_per_coded_sample == 4
water	39:16	0:0	8	avctx
op	39:21	0:0	8	->
water	39:23	0:0	8	bits_per_coded_sample
op	39:45	0:0	8	==
water	39:48	0:0	8	4
stmts	39:51	46:12	7	
water	39:51	0:0	8	{
for	40:16	43:16	8	(j = 0 ;j < avctx -> width - 1;j += 2)
forinit	40:21	40:26	9	j = 0 ;
water	40:21	0:0	10	j
op	40:23	0:0	10	=
water	40:25	0:0	10	0
water	40:26	0:0	10	;
cond	40:28	40:47	9	j < avctx -> width - 1
water	40:28	0:0	10	j
op	40:30	0:0	10	<
water	40:32	0:0	10	avctx
op	40:37	0:0	10	->
water	40:39	0:0	10	width
op	40:45	0:0	10	-
water	40:47	0:0	10	1
forexpr	40:50	40:55	9	j += 2
water	40:50	0:0	10	j
op	40:52	0:0	10	+=
water	40:55	0:0	10	2
stmts	40:58	43:16	9	
water	40:58	0:0	10	{
water	41:20	0:0	10	ptr
op	41:23	0:0	10	[
water	41:24	0:0	10	j
op	41:25	0:0	10	+
water	41:26	0:0	10	0
op	41:27	0:0	10	]
op	41:29	0:0	10	=
water	41:31	0:0	10	buf
op	41:34	0:0	10	[
water	41:35	0:0	10	j
op	41:36	0:0	10	>>
water	41:38	0:0	10	1
op	41:39	0:0	10	]
op	41:41	0:0	10	>>
water	41:44	0:0	10	4
water	41:45	0:0	10	;
water	42:20	0:0	10	ptr
op	42:23	0:0	10	[
water	42:24	0:0	10	j
op	42:25	0:0	10	+
water	42:26	0:0	10	1
op	42:27	0:0	10	]
op	42:29	0:0	10	=
water	42:31	0:0	10	buf
op	42:34	0:0	10	[
water	42:35	0:0	10	j
op	42:36	0:0	10	>>
water	42:38	0:0	10	1
op	42:39	0:0	10	]
op	42:41	0:0	10	&
water	42:43	0:0	10	0
water	42:44	0:0	10	xF
water	42:46	0:0	10	;
water	43:16	0:0	10	}
if	44:16	45:45	8	(avctx -> width & 1)
cond	44:20	44:35	9	avctx -> width & 1
water	44:20	0:0	10	avctx
op	44:25	0:0	10	->
water	44:27	0:0	10	width
op	44:33	0:0	10	&
water	44:35	0:0	10	1
stmts	45:20	45:45	9	
water	45:20	0:0	10	ptr
op	45:23	0:0	10	[
water	45:24	0:0	10	j
op	45:25	0:0	10	+
water	45:26	0:0	10	0
op	45:27	0:0	10	]
op	45:29	0:0	10	=
water	45:31	0:0	10	buf
op	45:34	0:0	10	[
water	45:35	0:0	10	j
op	45:36	0:0	10	>>
water	45:38	0:0	10	1
op	45:39	0:0	10	]
op	45:41	0:0	10	>>
water	45:44	0:0	10	4
water	45:45	0:0	10	;
water	46:12	0:0	8	}
else	46:14	48:12	6
stmts	46:19	48:12	7	
water	46:19	0:0	8	{
call	47:16	47:41	8	memcpy
arg	47:23	47:26	9	ptr
water	47:23	0:0	10	ptr
arg	47:28	47:31	9	buf
water	47:28	0:0	10	buf
arg	47:33	47:41	9	linesize
water	47:33	0:0	10	linesize
water	47:42	0:0	8	;
water	48:12	0:0	8	}
water	49:12	0:0	6	buf
op	49:16	0:0	6	-=
water	49:19	0:0	6	istride
water	49:26	0:0	6	;
water	50:12	0:0	6	ptr
op	50:16	0:0	6	+=
water	50:19	0:0	6	s
op	50:20	0:0	6	->
water	50:22	0:0	6	frame
op	50:27	0:0	6	.
water	50:28	0:0	6	linesize
op	50:36	0:0	6	[
water	50:37	0:0	6	0
op	50:38	0:0	6	]
water	50:39	0:0	6	;
water	51:8	0:0	6	}
water	52:4	0:0	4	}
else	52:6	55:4	2
stmts	52:11	55:4	3	
water	52:11	0:0	4	{
call	53:8	53:46	4	bytestream2_init
arg	53:25	53:31	5	&s->gb
op	53:25	0:0	6	&
water	53:26	0:0	6	s
op	53:27	0:0	6	->
water	53:29	0:0	6	gb
arg	53:33	53:36	5	buf
water	53:33	0:0	6	buf
arg	53:38	53:46	5	buf_size
water	53:38	0:0	6	buf_size
water	53:47	0:0	4	;
call	54:8	54:90	4	ff_msrle_decode
arg	54:24	54:29	5	avctx
water	54:24	0:0	6	avctx
arg	54:31	54:52	5	(AVPicture*)&s->frame
water	54:31	0:0	6	(
water	54:32	0:0	6	AVPicture
op	54:41	0:0	6	*
water	54:42	0:0	6	)
op	54:43	0:0	6	&
water	54:44	0:0	6	s
op	54:45	0:0	6	->
water	54:47	0:0	6	frame
arg	54:54	54:82	5	avctx->bits_per_coded_sample
water	54:54	0:0	6	avctx
op	54:59	0:0	6	->
water	54:61	0:0	6	bits_per_coded_sample
arg	54:84	54:90	5	&s->gb
op	54:84	0:0	6	&
water	54:85	0:0	6	s
op	54:86	0:0	6	->
water	54:88	0:0	6	gb
water	54:91	0:0	4	;
water	55:4	0:0	4	}
if	57:4	58:18	2	(( ret =av_frame_ref (data ,& s -> frame ) ) < 0)
cond	57:8	57:48	3	( ret =av_frame_ref (data ,& s -> frame ) ) < 0
water	57:8	0:0	4	(
water	57:9	0:0	4	ret
op	57:13	0:0	4	=
call	57:15	57:43	4	av_frame_ref
arg	57:28	57:32	5	data
water	57:28	0:0	6	data
arg	57:34	57:43	5	&s->frame
op	57:34	0:0	6	&
water	57:35	0:0	6	s
op	57:36	0:0	6	->
water	57:38	0:0	6	frame
water	57:44	0:0	4	)
op	57:46	0:0	4	<
water	57:48	0:0	4	0
stmts	58:8	58:18	3	
return	58:8	58:18	4	ret
water	58:15	0:0	5	ret
op	60:4	0:0	2	*
water	60:5	0:0	2	got_frame
op	60:20	0:0	2	=
water	60:22	0:0	2	1
water	60:23	0:0	2	;
return	63:4	63:19	2	buf_size
water	63:11	0:0	3	buf_size
