func	2:0	150:0	0	static int	ape_decode_frame
params	2:27	0:0	1	
param	2:28	2:49	2	AVCodecContext *	avctx
param	2:51	2:61	2	void *	data
param	3:28	3:46	2	int *	got_frame_ptr
param	3:48	3:63	2	AVPacket *	avpkt
stmnts	0:0	149:40	1	
decl	5:4	5:29	2	AVFrame	*frame
op	5:23	0:0	2	=
water	5:25	0:0	2	data
decl	6:4	6:36	2	const uint8_t	*buf
op	6:23	0:0	2	=
water	6:25	0:0	2	avpkt
op	6:30	0:0	2	->
water	6:32	0:0	2	data
decl	7:4	7:36	2	APEContext	*s
op	7:18	0:0	2	=
water	7:20	0:0	2	avctx
op	7:25	0:0	2	->
water	7:27	0:0	2	priv_data
decl	8:4	8:20	2	uint8_t	*sample8
decl	9:4	9:21	2	int16_t	*sample16
decl	10:4	10:21	2	int32_t	*sample24
decl	11:4	11:18	2	int	i
water	11:9	0:0	2	,
decl	11:4	11:18	2	int	ch
water	11:13	0:0	2	,
decl	11:4	11:18	2	int	ret
decl	12:4	12:22	2	int	blockstodecode
call	16:4	16:30	2	av_assert0
arg	16:15	16:30	3	s->samples>=0
water	16:15	0:0	4	s
op	16:16	0:0	4	->
water	16:18	0:0	4	samples
op	16:26	0:0	4	>=
water	16:29	0:0	4	0
water	16:31	0:0	2	;
if	18:4	80:4	2	(! s -> samples)
cond	18:7	18:11	3	! s -> samples
op	18:7	0:0	4	!
water	18:8	0:0	4	s
op	18:9	0:0	4	->
water	18:11	0:0	4	samples
stmts	18:19	80:4	3	
water	18:19	0:0	4	{
decl	19:8	19:32	4	uint32_t	nblocks
water	19:24	0:0	4	,
decl	19:8	19:32	4	uint32_t	offset
decl	20:8	20:20	4	int	buf_size
if	22:8	25:8	4	(! avpkt -> size)
cond	22:12	22:20	5	! avpkt -> size
op	22:12	0:0	6	!
water	22:13	0:0	6	avpkt
op	22:18	0:0	6	->
water	22:20	0:0	6	size
stmts	22:26	25:8	5	
water	22:26	0:0	6	{
op	23:12	0:0	6	*
water	23:13	0:0	6	got_frame_ptr
op	23:27	0:0	6	=
water	23:29	0:0	6	0
water	23:30	0:0	6	;
return	24:12	24:20	6	0
water	24:19	0:0	7	0
water	25:8	0:0	6	}
if	26:8	29:8	4	(avpkt -> size < 8)
cond	26:12	26:26	5	avpkt -> size < 8
water	26:12	0:0	6	avpkt
op	26:17	0:0	6	->
water	26:19	0:0	6	size
op	26:24	0:0	6	<
water	26:26	0:0	6	8
stmts	26:29	29:8	5	
water	26:29	0:0	6	{
call	27:12	27:63	6	av_log
arg	27:19	27:24	7	avctx
water	27:19	0:0	8	avctx
arg	27:26	27:38	7	AV_LOG_ERROR
water	27:26	0:0	8	AV_LOG_ERROR
arg	27:40	27:63	7	"Packet is too small\n"
water	27:40	0:0	8	"Packet is too small\n"
water	27:64	0:0	6	;
return	28:12	28:38	6	AVERROR_INVALIDDATA
water	28:19	0:0	7	AVERROR_INVALIDDATA
water	29:8	0:0	6	}
water	30:8	0:0	4	buf_size
op	30:17	0:0	4	=
water	30:19	0:0	4	avpkt
op	30:24	0:0	4	->
water	30:26	0:0	4	size
op	30:31	0:0	4	&
water	30:33	0:0	4	~3
water	30:35	0:0	4	;
if	31:8	34:8	4	(buf_size != avpkt -> size)
cond	31:12	31:31	5	buf_size != avpkt -> size
water	31:12	0:0	6	buf_size
op	31:21	0:0	6	!=
water	31:24	0:0	6	avpkt
op	31:29	0:0	6	->
water	31:31	0:0	6	size
stmts	31:37	34:8	5	
water	31:37	0:0	6	{
call	32:12	33:62	6	av_log
arg	32:19	32:24	7	avctx
water	32:19	0:0	8	avctx
arg	32:26	32:40	7	AV_LOG_WARNING
water	32:26	0:0	8	AV_LOG_WARNING
arg	32:42	33:62	7	"packet size is not a multiple of 4. ""extra bytes at the end will be skipped.\n"
water	32:42	0:0	8	"packet size is not a multiple of 4. "
water	33:19	0:0	8	"extra bytes at the end will be skipped.\n"
water	33:63	0:0	6	;
water	34:8	0:0	6	}
if	35:8	36:25	4	(s -> fileversion < 3950)
cond	35:12	35:29	5	s -> fileversion < 3950
water	35:12	0:0	6	s
op	35:13	0:0	6	->
water	35:15	0:0	6	fileversion
op	35:27	0:0	6	<
water	35:29	0:0	6	3950
stmts	36:12	36:25	5	
water	36:12	0:0	6	buf_size
op	36:21	0:0	6	+=
water	36:24	0:0	6	2
water	36:25	0:0	6	;
call	37:8	37:63	4	av_fast_padded_malloc
arg	37:30	37:38	5	&s->data
op	37:30	0:0	6	&
water	37:31	0:0	6	s
op	37:32	0:0	6	->
water	37:34	0:0	6	data
arg	37:40	37:53	5	&s->data_size
op	37:40	0:0	6	&
water	37:41	0:0	6	s
op	37:42	0:0	6	->
water	37:44	0:0	6	data_size
arg	37:55	37:63	5	buf_size
water	37:55	0:0	6	buf_size
water	37:64	0:0	4	;
if	38:8	39:34	4	(! s -> data)
cond	38:12	38:16	5	! s -> data
op	38:12	0:0	6	!
water	38:13	0:0	6	s
op	38:14	0:0	6	->
water	38:16	0:0	6	data
stmts	39:12	39:34	5	
return	39:12	39:34	6	AVERROR(ENOMEM)
call	39:19	39:33	7	AVERROR
arg	39:27	39:33	8	ENOMEM
water	39:27	0:0	9	ENOMEM
call	40:8	41:39	4	s->bdsp.bswap_buf
arg	40:26	40:46	5	(uint32_t*)s->data
water	40:26	0:0	6	(
water	40:27	0:0	6	uint32_t
op	40:36	0:0	6	*
water	40:37	0:0	6	)
water	40:39	0:0	6	s
op	40:40	0:0	6	->
water	40:42	0:0	6	data
arg	40:48	40:70	5	(constuint32_t*)buf
water	40:48	0:0	6	(
water	40:49	0:0	6	const
water	40:55	0:0	6	uint32_t
op	40:64	0:0	6	*
water	40:65	0:0	6	)
water	40:67	0:0	6	buf
arg	41:26	41:39	5	buf_size>>2
water	41:26	0:0	6	buf_size
op	41:35	0:0	6	>>
water	41:38	0:0	6	2
water	41:40	0:0	4	;
call	42:8	42:57	4	memset
arg	42:15	42:40	5	s->data+(buf_size&~3)
water	42:15	0:0	6	s
op	42:16	0:0	6	->
water	42:18	0:0	6	data
op	42:23	0:0	6	+
water	42:25	0:0	6	(
water	42:26	0:0	6	buf_size
op	42:35	0:0	6	&
water	42:37	0:0	6	~3
water	42:39	0:0	6	)
arg	42:42	42:43	5	0
water	42:42	0:0	6	0
arg	42:45	42:57	5	buf_size&3
water	42:45	0:0	6	buf_size
op	42:54	0:0	6	&
water	42:56	0:0	6	3
water	42:58	0:0	4	;
water	43:8	0:0	4	s
op	43:9	0:0	4	->
water	43:11	0:0	4	ptr
op	43:15	0:0	4	=
water	43:17	0:0	4	s
op	43:18	0:0	4	->
water	43:20	0:0	4	data
water	43:24	0:0	4	;
water	44:8	0:0	4	s
op	44:9	0:0	4	->
water	44:11	0:0	4	data_end
op	44:20	0:0	4	=
water	44:22	0:0	4	s
op	44:23	0:0	4	->
water	44:25	0:0	4	data
op	44:30	0:0	4	+
water	44:32	0:0	4	buf_size
water	44:40	0:0	4	;
water	46:8	0:0	4	nblocks
op	46:16	0:0	4	=
call	46:18	46:45	4	bytestream_get_be32
arg	46:38	46:45	5	&s->ptr
op	46:38	0:0	6	&
water	46:39	0:0	6	s
op	46:40	0:0	6	->
water	46:42	0:0	6	ptr
water	46:46	0:0	4	;
water	47:8	0:0	4	offset
op	47:16	0:0	4	=
call	47:18	47:45	4	bytestream_get_be32
arg	47:38	47:45	5	&s->ptr
op	47:38	0:0	6	&
water	47:39	0:0	6	s
op	47:40	0:0	6	->
water	47:42	0:0	6	ptr
water	47:46	0:0	4	;
if	48:8	59:8	4	(s -> fileversion >= 3900)
cond	48:12	48:30	5	s -> fileversion >= 3900
water	48:12	0:0	6	s
op	48:13	0:0	6	->
water	48:15	0:0	6	fileversion
op	48:27	0:0	6	>=
water	48:30	0:0	6	3900
stmts	48:36	59:8	5	
water	48:36	0:0	6	{
if	49:12	53:12	6	(offset > 3)
cond	49:16	49:25	7	offset > 3
water	49:16	0:0	8	offset
op	49:23	0:0	8	>
water	49:25	0:0	8	3
stmts	49:28	53:12	7	
water	49:28	0:0	8	{
call	50:16	50:71	8	av_log
arg	50:23	50:28	9	avctx
water	50:23	0:0	10	avctx
arg	50:30	50:42	9	AV_LOG_ERROR
water	50:30	0:0	10	AV_LOG_ERROR
arg	50:44	50:71	9	"Incorrect offset passed\n"
water	50:44	0:0	10	"Incorrect offset passed\n"
water	50:72	0:0	8	;
water	51:16	0:0	8	s
op	51:17	0:0	8	->
water	51:19	0:0	8	data
op	51:24	0:0	8	=
water	51:26	0:0	8	NULL
water	51:30	0:0	8	;
return	52:16	52:42	8	AVERROR_INVALIDDATA
water	52:23	0:0	9	AVERROR_INVALIDDATA
water	53:12	0:0	8	}
if	54:12	57:12	6	(s -> data_end - s -> ptr < offset)
cond	54:16	54:39	7	s -> data_end - s -> ptr < offset
water	54:16	0:0	8	s
op	54:17	0:0	8	->
water	54:19	0:0	8	data_end
op	54:28	0:0	8	-
water	54:30	0:0	8	s
op	54:31	0:0	8	->
water	54:33	0:0	8	ptr
op	54:37	0:0	8	<
water	54:39	0:0	8	offset
stmts	54:47	57:12	7	
water	54:47	0:0	8	{
call	55:16	55:67	8	av_log
arg	55:23	55:28	9	avctx
water	55:23	0:0	10	avctx
arg	55:30	55:42	9	AV_LOG_ERROR
water	55:30	0:0	10	AV_LOG_ERROR
arg	55:44	55:67	9	"Packet is too small\n"
water	55:44	0:0	10	"Packet is too small\n"
water	55:68	0:0	8	;
return	56:16	56:42	8	AVERROR_INVALIDDATA
water	56:23	0:0	9	AVERROR_INVALIDDATA
water	57:12	0:0	8	}
water	58:12	0:0	6	s
op	58:13	0:0	6	->
water	58:15	0:0	6	ptr
op	58:19	0:0	6	+=
water	58:22	0:0	6	offset
water	58:28	0:0	6	;
water	59:8	0:0	6	}
else	59:10	66:8	4
stmts	59:15	66:8	5	
water	59:15	0:0	6	{
if	60:12	61:26	6	(( ret =init_get_bits8 (& s -> gb ,s -> ptr ,s -> data_end - s -> ptr ) ) < 0)
cond	60:16	60:79	7	( ret =init_get_bits8 (& s -> gb ,s -> ptr ,s -> data_end - s -> ptr ) ) < 0
water	60:16	0:0	8	(
water	60:17	0:0	8	ret
op	60:21	0:0	8	=
call	60:23	60:74	8	init_get_bits8
arg	60:38	60:44	9	&s->gb
op	60:38	0:0	10	&
water	60:39	0:0	10	s
op	60:40	0:0	10	->
water	60:42	0:0	10	gb
arg	60:46	60:52	9	s->ptr
water	60:46	0:0	10	s
op	60:47	0:0	10	->
water	60:49	0:0	10	ptr
arg	60:54	60:74	9	s->data_end-s->ptr
water	60:54	0:0	10	s
op	60:55	0:0	10	->
water	60:57	0:0	10	data_end
op	60:66	0:0	10	-
water	60:68	0:0	10	s
op	60:69	0:0	10	->
water	60:71	0:0	10	ptr
water	60:75	0:0	8	)
op	60:77	0:0	8	<
water	60:79	0:0	8	0
stmts	61:16	61:26	7	
return	61:16	61:26	8	ret
water	61:23	0:0	9	ret
if	62:12	63:50	6	(s -> fileversion > 3800)
cond	62:16	62:33	7	s -> fileversion > 3800
water	62:16	0:0	8	s
op	62:17	0:0	8	->
water	62:19	0:0	8	fileversion
op	62:31	0:0	8	>
water	62:33	0:0	8	3800
stmts	63:16	63:50	7	
call	63:16	63:49	8	skip_bits_long
arg	63:31	63:37	9	&s->gb
op	63:31	0:0	10	&
water	63:32	0:0	10	s
op	63:33	0:0	10	->
water	63:35	0:0	10	gb
arg	63:39	63:49	9	offset*8
water	63:39	0:0	10	offset
op	63:46	0:0	10	*
water	63:48	0:0	10	8
water	63:50	0:0	8	;
else	64:12	65:46	6
stmts	65:16	65:46	7	
call	65:16	65:45	8	skip_bits_long
arg	65:31	65:37	9	&s->gb
op	65:31	0:0	10	&
water	65:32	0:0	10	s
op	65:33	0:0	10	->
water	65:35	0:0	10	gb
arg	65:39	65:45	9	offset
water	65:39	0:0	10	offset
water	65:46	0:0	8	;
water	66:8	0:0	6	}
if	68:8	72:8	4	(! nblocks || nblocks > INT_MAX)
cond	68:12	68:34	5	! nblocks || nblocks > INT_MAX
op	68:12	0:0	6	!
water	68:13	0:0	6	nblocks
op	68:21	0:0	6	||
water	68:24	0:0	6	nblocks
op	68:32	0:0	6	>
water	68:34	0:0	6	INT_MAX
stmts	68:43	72:8	5	
water	68:43	0:0	6	{
call	69:12	70:26	6	av_log
arg	69:19	69:24	7	avctx
water	69:19	0:0	8	avctx
arg	69:26	69:38	7	AV_LOG_ERROR
water	69:26	0:0	8	AV_LOG_ERROR
arg	69:40	69:76	7	"Invalid sample count: %"PRIu32".\n"
water	69:40	0:0	8	"Invalid sample count: %"
water	69:65	0:0	8	PRIu32
water	69:71	0:0	8	".\n"
arg	70:19	70:26	7	nblocks
water	70:19	0:0	8	nblocks
water	70:27	0:0	6	;
return	71:12	71:38	6	AVERROR_INVALIDDATA
water	71:19	0:0	7	AVERROR_INVALIDDATA
water	72:8	0:0	6	}
if	75:8	78:8	4	(init_frame_decoder (s ) < 0)
cond	75:12	75:36	5	init_frame_decoder (s ) < 0
call	75:12	75:32	6	init_frame_decoder
arg	75:31	75:32	7	s
water	75:31	0:0	8	s
op	75:34	0:0	6	<
water	75:36	0:0	6	0
stmts	75:39	78:8	5	
water	75:39	0:0	6	{
call	76:12	76:70	6	av_log
arg	76:19	76:24	7	avctx
water	76:19	0:0	8	avctx
arg	76:26	76:38	7	AV_LOG_ERROR
water	76:26	0:0	8	AV_LOG_ERROR
arg	76:40	76:70	7	"Error reading frame header\n"
water	76:40	0:0	8	"Error reading frame header\n"
water	76:71	0:0	6	;
return	77:12	77:38	6	AVERROR_INVALIDDATA
water	77:19	0:0	7	AVERROR_INVALIDDATA
water	78:8	0:0	6	}
water	79:8	0:0	4	s
op	79:9	0:0	4	->
water	79:11	0:0	4	samples
op	79:19	0:0	4	=
water	79:21	0:0	4	nblocks
water	79:28	0:0	4	;
water	80:4	0:0	4	}
if	82:4	85:4	2	(! s -> data)
cond	82:8	82:12	3	! s -> data
op	82:8	0:0	4	!
water	82:9	0:0	4	s
op	82:10	0:0	4	->
water	82:12	0:0	4	data
stmts	82:18	85:4	3	
water	82:18	0:0	4	{
op	83:8	0:0	4	*
water	83:9	0:0	4	got_frame_ptr
op	83:23	0:0	4	=
water	83:25	0:0	4	0
water	83:26	0:0	4	;
return	84:8	84:26	4	avpkt->size
water	84:15	0:0	5	avpkt
op	84:20	0:0	5	->
water	84:22	0:0	5	size
water	85:4	0:0	4	}
water	87:4	0:0	2	blockstodecode
op	87:19	0:0	2	=
call	87:21	87:57	2	FFMIN
arg	87:27	87:45	3	s->blocks_per_loop
water	87:27	0:0	4	s
op	87:28	0:0	4	->
water	87:30	0:0	4	blocks_per_loop
arg	87:47	87:57	3	s->samples
water	87:47	0:0	4	s
op	87:48	0:0	4	->
water	87:50	0:0	4	samples
water	87:58	0:0	2	;
if	90:4	91:35	2	(s -> fileversion < 3930)
cond	90:8	90:25	3	s -> fileversion < 3930
water	90:8	0:0	4	s
op	90:9	0:0	4	->
water	90:11	0:0	4	fileversion
op	90:23	0:0	4	<
water	90:25	0:0	4	3930
stmts	91:8	91:35	3	
water	91:8	0:0	4	blockstodecode
op	91:23	0:0	4	=
water	91:25	0:0	4	s
op	91:26	0:0	4	->
water	91:28	0:0	4	samples
water	91:35	0:0	4	;
call	94:4	95:78	2	av_fast_malloc
arg	94:19	94:37	3	&s->decoded_buffer
op	94:19	0:0	4	&
water	94:20	0:0	4	s
op	94:21	0:0	4	->
water	94:23	0:0	4	decoded_buffer
arg	94:39	94:55	3	&s->decoded_size
op	94:39	0:0	4	&
water	94:40	0:0	4	s
op	94:41	0:0	4	->
water	94:43	0:0	4	decoded_size
arg	95:19	95:78	3	2*FFALIGN(blockstodecode,8)*sizeof(*s->decoded_buffer)
water	95:19	0:0	4	2
call	95:21	95:48	4	*FFALIGN
arg	95:31	95:45	5	blockstodecode
water	95:31	0:0	6	blockstodecode
arg	95:47	95:48	5	8
water	95:47	0:0	6	8
op	95:50	0:0	4	*
op	95:52	0:0	4	sizeof
water	95:58	0:0	4	(
op	95:59	0:0	4	*
water	95:60	0:0	4	s
op	95:61	0:0	4	->
water	95:63	0:0	4	decoded_buffer
water	95:77	0:0	4	)
water	95:79	0:0	2	;
if	96:4	97:30	2	(! s -> decoded_buffer)
cond	96:8	96:12	3	! s -> decoded_buffer
op	96:8	0:0	4	!
water	96:9	0:0	4	s
op	96:10	0:0	4	->
water	96:12	0:0	4	decoded_buffer
stmts	97:8	97:30	3	
return	97:8	97:30	4	AVERROR(ENOMEM)
call	97:15	97:29	5	AVERROR
arg	97:23	97:29	6	ENOMEM
water	97:23	0:0	7	ENOMEM
call	98:4	98:48	2	memset
arg	98:11	98:28	3	s->decoded_buffer
water	98:11	0:0	4	s
op	98:12	0:0	4	->
water	98:14	0:0	4	decoded_buffer
arg	98:30	98:31	3	0
water	98:30	0:0	4	0
arg	98:33	98:48	3	s->decoded_size
water	98:33	0:0	4	s
op	98:34	0:0	4	->
water	98:36	0:0	4	decoded_size
water	98:49	0:0	2	;
water	99:4	0:0	2	s
op	99:5	0:0	2	->
water	99:7	0:0	2	decoded
op	99:14	0:0	2	[
water	99:15	0:0	2	0
op	99:16	0:0	2	]
op	99:18	0:0	2	=
water	99:20	0:0	2	s
op	99:21	0:0	2	->
water	99:23	0:0	2	decoded_buffer
water	99:37	0:0	2	;
water	100:4	0:0	2	s
op	100:5	0:0	2	->
water	100:7	0:0	2	decoded
op	100:14	0:0	2	[
water	100:15	0:0	2	1
op	100:16	0:0	2	]
op	100:18	0:0	2	=
water	100:20	0:0	2	s
op	100:21	0:0	2	->
water	100:23	0:0	2	decoded_buffer
op	100:38	0:0	2	+
call	100:40	100:65	2	FFALIGN
arg	100:48	100:62	3	blockstodecode
water	100:48	0:0	4	blockstodecode
arg	100:64	100:65	3	8
water	100:64	0:0	4	8
water	100:66	0:0	2	;
water	103:4	0:0	2	frame
op	103:9	0:0	2	->
water	103:11	0:0	2	nb_samples
op	103:22	0:0	2	=
water	103:24	0:0	2	blockstodecode
water	103:38	0:0	2	;
if	104:4	105:18	2	(( ret =ff_get_buffer (avctx ,frame ,0 ) ) < 0)
cond	104:8	104:49	3	( ret =ff_get_buffer (avctx ,frame ,0 ) ) < 0
water	104:8	0:0	4	(
water	104:9	0:0	4	ret
op	104:13	0:0	4	=
call	104:15	104:44	4	ff_get_buffer
arg	104:29	104:34	5	avctx
water	104:29	0:0	6	avctx
arg	104:36	104:41	5	frame
water	104:36	0:0	6	frame
arg	104:43	104:44	5	0
water	104:43	0:0	6	0
water	104:45	0:0	4	)
op	104:47	0:0	4	<
water	104:49	0:0	4	0
stmts	105:8	105:18	3	
return	105:8	105:18	4	ret
water	105:15	0:0	5	ret
water	107:4	0:0	2	s
op	107:5	0:0	2	->
water	107:7	0:0	2	error
op	107:12	0:0	2	=
water	107:13	0:0	2	0
water	107:14	0:0	2	;
if	109:4	110:42	2	(( s -> channels == 1 ) || ( s -> frameflags & APE_FRAMECODE_PSEUDO_STEREO ))
cond	109:8	109:74	3	( s -> channels == 1 ) || ( s -> frameflags & APE_FRAMECODE_PSEUDO_STEREO )
water	109:8	0:0	4	(
water	109:9	0:0	4	s
op	109:10	0:0	4	->
water	109:12	0:0	4	channels
op	109:21	0:0	4	==
water	109:24	0:0	4	1
water	109:25	0:0	4	)
op	109:27	0:0	4	||
water	109:30	0:0	4	(
water	109:31	0:0	4	s
op	109:32	0:0	4	->
water	109:34	0:0	4	frameflags
op	109:45	0:0	4	&
water	109:47	0:0	4	APE_FRAMECODE_PSEUDO_STEREO
water	109:74	0:0	4	)
stmts	110:8	110:42	3	
call	110:8	110:41	4	ape_unpack_mono
arg	110:24	110:25	5	s
water	110:24	0:0	6	s
arg	110:27	110:41	5	blockstodecode
water	110:27	0:0	6	blockstodecode
water	110:42	0:0	4	;
else	111:4	112:44	2
stmts	112:8	112:44	3	
call	112:8	112:43	4	ape_unpack_stereo
arg	112:26	112:27	5	s
water	112:26	0:0	6	s
arg	112:29	112:43	5	blockstodecode
water	112:29	0:0	6	blockstodecode
water	112:44	0:0	4	;
call	113:4	113:11	2	emms_c
water	113:12	0:0	2	;
if	115:4	119:4	2	(s -> error)
cond	115:8	115:11	3	s -> error
water	115:8	0:0	4	s
op	115:9	0:0	4	->
water	115:11	0:0	4	error
stmts	115:18	119:4	3	
water	115:18	0:0	4	{
water	116:8	0:0	4	s
op	116:9	0:0	4	->
water	116:11	0:0	4	samples
op	116:18	0:0	4	=
water	116:19	0:0	4	0
water	116:20	0:0	4	;
call	117:8	117:60	4	av_log
arg	117:15	117:20	5	avctx
water	117:15	0:0	6	avctx
arg	117:22	117:34	5	AV_LOG_ERROR
water	117:22	0:0	6	AV_LOG_ERROR
arg	117:36	117:60	5	"Error decoding frame\n"
water	117:36	0:0	6	"Error decoding frame\n"
water	117:61	0:0	4	;
return	118:8	118:34	4	AVERROR_INVALIDDATA
water	118:15	0:0	5	AVERROR_INVALIDDATA
water	119:4	0:0	4	}
switch	121:4	143:4	2	(s -> bps)
cond	121:12	121:15	3	s -> bps
water	121:12	0:0	4	s
op	121:13	0:0	4	->
water	121:15	0:0	4	bps
stmts	121:20	143:4	3	
water	121:20	0:0	4	{
label	122:4	122:10	4	case 8 :
for	123:8	127:8	4	(ch = 0 ;ch < s -> channels;ch ++)
forinit	123:13	123:19	5	ch = 0 ;
water	123:13	0:0	6	ch
op	123:16	0:0	6	=
water	123:18	0:0	6	0
water	123:19	0:0	6	;
cond	123:21	123:29	5	ch < s -> channels
water	123:21	0:0	6	ch
op	123:24	0:0	6	<
water	123:26	0:0	6	s
op	123:27	0:0	6	->
water	123:29	0:0	6	channels
forexpr	123:39	123:41	5	ch ++
water	123:39	0:0	6	ch
op	123:41	0:0	6	++
stmts	123:45	127:8	5	
water	123:45	0:0	6	{
water	124:12	0:0	6	sample8
op	124:20	0:0	6	=
water	124:22	0:0	6	(
water	124:23	0:0	6	uint8_t
op	124:31	0:0	6	*
water	124:32	0:0	6	)
water	124:33	0:0	6	frame
op	124:38	0:0	6	->
water	124:40	0:0	6	data
op	124:44	0:0	6	[
water	124:45	0:0	6	ch
op	124:47	0:0	6	]
water	124:48	0:0	6	;
for	125:12	126:62	6	(i = 0 ;i < blockstodecode;i ++)
forinit	125:17	125:22	7	i = 0 ;
water	125:17	0:0	8	i
op	125:19	0:0	8	=
water	125:21	0:0	8	0
water	125:22	0:0	8	;
cond	125:24	125:28	7	i < blockstodecode
water	125:24	0:0	8	i
op	125:26	0:0	8	<
water	125:28	0:0	8	blockstodecode
forexpr	125:44	125:45	7	i ++
water	125:44	0:0	8	i
op	125:45	0:0	8	++
stmts	126:16	126:62	7	
op	126:16	0:0	8	*
water	126:17	0:0	8	sample8
op	126:24	0:0	8	++
op	126:27	0:0	8	=
water	126:29	0:0	8	(
water	126:30	0:0	8	s
op	126:31	0:0	8	->
water	126:33	0:0	8	decoded
op	126:40	0:0	8	[
water	126:41	0:0	8	ch
op	126:43	0:0	8	]
op	126:44	0:0	8	[
water	126:45	0:0	8	i
op	126:46	0:0	8	]
op	126:48	0:0	8	+
water	126:50	0:0	8	0
water	126:51	0:0	8	x80
water	126:54	0:0	8	)
op	126:56	0:0	8	&
water	126:58	0:0	8	0
water	126:59	0:0	8	xff
water	126:62	0:0	8	;
water	127:8	0:0	6	}
break	128:8	128:13	4	
label	129:4	129:11	4	case 16 :
for	130:8	134:8	4	(ch = 0 ;ch < s -> channels;ch ++)
forinit	130:13	130:19	5	ch = 0 ;
water	130:13	0:0	6	ch
op	130:16	0:0	6	=
water	130:18	0:0	6	0
water	130:19	0:0	6	;
cond	130:21	130:29	5	ch < s -> channels
water	130:21	0:0	6	ch
op	130:24	0:0	6	<
water	130:26	0:0	6	s
op	130:27	0:0	6	->
water	130:29	0:0	6	channels
forexpr	130:39	130:41	5	ch ++
water	130:39	0:0	6	ch
op	130:41	0:0	6	++
stmts	130:45	134:8	5	
water	130:45	0:0	6	{
water	131:12	0:0	6	sample16
op	131:21	0:0	6	=
water	131:23	0:0	6	(
water	131:24	0:0	6	int16_t
op	131:32	0:0	6	*
water	131:33	0:0	6	)
water	131:34	0:0	6	frame
op	131:39	0:0	6	->
water	131:41	0:0	6	data
op	131:45	0:0	6	[
water	131:46	0:0	6	ch
op	131:48	0:0	6	]
water	131:49	0:0	6	;
for	132:12	133:47	6	(i = 0 ;i < blockstodecode;i ++)
forinit	132:17	132:22	7	i = 0 ;
water	132:17	0:0	8	i
op	132:19	0:0	8	=
water	132:21	0:0	8	0
water	132:22	0:0	8	;
cond	132:24	132:28	7	i < blockstodecode
water	132:24	0:0	8	i
op	132:26	0:0	8	<
water	132:28	0:0	8	blockstodecode
forexpr	132:44	132:45	7	i ++
water	132:44	0:0	8	i
op	132:45	0:0	8	++
stmts	133:16	133:47	7	
op	133:16	0:0	8	*
water	133:17	0:0	8	sample16
op	133:25	0:0	8	++
op	133:28	0:0	8	=
water	133:30	0:0	8	s
op	133:31	0:0	8	->
water	133:33	0:0	8	decoded
op	133:40	0:0	8	[
water	133:41	0:0	8	ch
op	133:43	0:0	8	]
op	133:44	0:0	8	[
water	133:45	0:0	8	i
op	133:46	0:0	8	]
water	133:47	0:0	8	;
water	134:8	0:0	6	}
break	135:8	135:13	4	
label	136:4	136:11	4	case 24 :
for	137:8	141:8	4	(ch = 0 ;ch < s -> channels;ch ++)
forinit	137:13	137:19	5	ch = 0 ;
water	137:13	0:0	6	ch
op	137:16	0:0	6	=
water	137:18	0:0	6	0
water	137:19	0:0	6	;
cond	137:21	137:29	5	ch < s -> channels
water	137:21	0:0	6	ch
op	137:24	0:0	6	<
water	137:26	0:0	6	s
op	137:27	0:0	6	->
water	137:29	0:0	6	channels
forexpr	137:39	137:41	5	ch ++
water	137:39	0:0	6	ch
op	137:41	0:0	6	++
stmts	137:45	141:8	5	
water	137:45	0:0	6	{
water	138:12	0:0	6	sample24
op	138:21	0:0	6	=
water	138:23	0:0	6	(
water	138:24	0:0	6	int32_t
op	138:32	0:0	6	*
water	138:33	0:0	6	)
water	138:34	0:0	6	frame
op	138:39	0:0	6	->
water	138:41	0:0	6	data
op	138:45	0:0	6	[
water	138:46	0:0	6	ch
op	138:48	0:0	6	]
water	138:49	0:0	6	;
for	139:12	140:52	6	(i = 0 ;i < blockstodecode;i ++)
forinit	139:17	139:22	7	i = 0 ;
water	139:17	0:0	8	i
op	139:19	0:0	8	=
water	139:21	0:0	8	0
water	139:22	0:0	8	;
cond	139:24	139:28	7	i < blockstodecode
water	139:24	0:0	8	i
op	139:26	0:0	8	<
water	139:28	0:0	8	blockstodecode
forexpr	139:44	139:45	7	i ++
water	139:44	0:0	8	i
op	139:45	0:0	8	++
stmts	140:16	140:52	7	
op	140:16	0:0	8	*
water	140:17	0:0	8	sample24
op	140:25	0:0	8	++
op	140:28	0:0	8	=
water	140:30	0:0	8	s
op	140:31	0:0	8	->
water	140:33	0:0	8	decoded
op	140:40	0:0	8	[
water	140:41	0:0	8	ch
op	140:43	0:0	8	]
op	140:44	0:0	8	[
water	140:45	0:0	8	i
op	140:46	0:0	8	]
op	140:48	0:0	8	<<
water	140:51	0:0	8	8
water	140:52	0:0	8	;
water	141:8	0:0	6	}
break	142:8	142:13	4	
water	143:4	0:0	4	}
water	145:4	0:0	2	s
op	145:5	0:0	2	->
water	145:7	0:0	2	samples
op	145:15	0:0	2	-=
water	145:18	0:0	2	blockstodecode
water	145:32	0:0	2	;
op	147:4	0:0	2	*
water	147:5	0:0	2	got_frame_ptr
op	147:19	0:0	2	=
water	147:21	0:0	2	1
water	147:22	0:0	2	;
return	149:4	149:40	2	!s->samples?avpkt->size:0
op	149:11	0:0	3	!
water	149:12	0:0	3	s
op	149:13	0:0	3	->
water	149:15	0:0	3	samples
water	149:23	0:0	3	?
water	149:25	0:0	3	avpkt
op	149:30	0:0	3	->
water	149:32	0:0	3	size
water	149:37	0:0	3	:
water	149:39	0:0	3	0
