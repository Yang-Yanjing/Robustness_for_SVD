func	2:0	106:0	0	static int	read_header
params	2:22	0:0	1	
param	2:23	2:40	2	ShortenContext *	s
stmnts	0:0	105:12	1	
decl	4:4	4:14	2	int	i
water	4:9	0:0	2	,
decl	4:4	4:14	2	int	ret
decl	5:4	5:19	2	int	maxnlpc
op	5:16	0:0	2	=
water	5:18	0:0	2	0
if	7:4	10:4	2	(get_bits_long (& s -> gb ,32 ) !=AV_RB32 ("ajkg" ))
cond	7:8	7:51	3	get_bits_long (& s -> gb ,32 ) !=AV_RB32 ("ajkg" )
call	7:8	7:32	4	get_bits_long
arg	7:22	7:28	5	&s->gb
op	7:22	0:0	6	&
water	7:23	0:0	6	s
op	7:24	0:0	6	->
water	7:26	0:0	6	gb
arg	7:30	7:32	5	32
water	7:30	0:0	6	32
op	7:34	0:0	4	!=
call	7:37	7:51	4	AV_RB32
arg	7:45	7:51	5	"ajkg"
water	7:45	0:0	6	"ajkg"
stmts	7:54	10:4	3	
water	7:54	0:0	4	{
call	8:8	8:71	4	av_log
arg	8:15	8:23	5	s->avctx
water	8:15	0:0	6	s
op	8:16	0:0	6	->
water	8:18	0:0	6	avctx
arg	8:25	8:37	5	AV_LOG_ERROR
water	8:25	0:0	6	AV_LOG_ERROR
arg	8:39	8:71	5	"missing shorten magic 'ajkg'\n"
water	8:39	0:0	6	"missing shorten magic 'ajkg'\n"
water	8:72	0:0	4	;
return	9:8	9:34	4	AVERROR_INVALIDDATA
water	9:15	0:0	5	AVERROR_INVALIDDATA
water	10:4	0:0	4	}
water	12:4	0:0	2	s
op	12:5	0:0	2	->
water	12:7	0:0	2	lpcqoffset
op	12:22	0:0	2	=
water	12:24	0:0	2	0
water	12:25	0:0	2	;
water	13:4	0:0	2	s
op	13:5	0:0	2	->
water	13:7	0:0	2	blocksize
op	13:22	0:0	2	=
water	13:24	0:0	2	DEFAULT_BLOCK_SIZE
water	13:42	0:0	2	;
water	14:4	0:0	2	s
op	14:5	0:0	2	->
water	14:7	0:0	2	nmean
op	14:22	0:0	2	=
op	14:24	0:0	2	-
water	14:25	0:0	2	1
water	14:26	0:0	2	;
water	15:4	0:0	2	s
op	15:5	0:0	2	->
water	15:7	0:0	2	version
op	15:22	0:0	2	=
call	15:24	15:42	2	get_bits
arg	15:33	15:39	3	&s->gb
op	15:33	0:0	4	&
water	15:34	0:0	4	s
op	15:35	0:0	4	->
water	15:37	0:0	4	gb
arg	15:41	15:42	3	8
water	15:41	0:0	4	8
water	15:43	0:0	2	;
water	16:4	0:0	2	s
op	16:5	0:0	2	->
water	16:7	0:0	2	internal_ftype
op	16:22	0:0	2	=
call	16:24	16:44	2	get_uint
arg	16:33	16:34	3	s
water	16:33	0:0	4	s
arg	16:36	16:44	3	TYPESIZE
water	16:36	0:0	4	TYPESIZE
water	16:45	0:0	2	;
water	18:4	0:0	2	s
op	18:5	0:0	2	->
water	18:7	0:0	2	channels
op	18:16	0:0	2	=
call	18:18	18:38	2	get_uint
arg	18:27	18:28	3	s
water	18:27	0:0	4	s
arg	18:30	18:38	3	CHANSIZE
water	18:30	0:0	4	CHANSIZE
water	18:39	0:0	2	;
if	19:4	22:4	2	(! s -> channels)
cond	19:8	19:12	3	! s -> channels
op	19:8	0:0	4	!
water	19:9	0:0	4	s
op	19:10	0:0	4	->
water	19:12	0:0	4	channels
stmts	19:22	22:4	3	
water	19:22	0:0	4	{
call	20:8	20:63	4	av_log
arg	20:15	20:23	5	s->avctx
water	20:15	0:0	6	s
op	20:16	0:0	6	->
water	20:18	0:0	6	avctx
arg	20:25	20:37	5	AV_LOG_ERROR
water	20:25	0:0	6	AV_LOG_ERROR
arg	20:39	20:63	5	"No channels reported\n"
water	20:39	0:0	6	"No channels reported\n"
water	20:64	0:0	4	;
return	21:8	21:34	4	AVERROR_INVALIDDATA
water	21:15	0:0	5	AVERROR_INVALIDDATA
water	22:4	0:0	4	}
if	23:4	27:4	2	(s -> channels > MAX_CHANNELS)
cond	23:8	23:22	3	s -> channels > MAX_CHANNELS
water	23:8	0:0	4	s
op	23:9	0:0	4	->
water	23:11	0:0	4	channels
op	23:20	0:0	4	>
water	23:22	0:0	4	MAX_CHANNELS
stmts	23:36	27:4	3	
water	23:36	0:0	4	{
call	24:8	24:77	4	av_log
arg	24:15	24:23	5	s->avctx
water	24:15	0:0	6	s
op	24:16	0:0	6	->
water	24:18	0:0	6	avctx
arg	24:25	24:37	5	AV_LOG_ERROR
water	24:25	0:0	6	AV_LOG_ERROR
arg	24:39	24:64	5	"too many channels: %d\n"
water	24:39	0:0	6	"too many channels: %d\n"
arg	24:66	24:77	5	s->channels
water	24:66	0:0	6	s
op	24:67	0:0	6	->
water	24:69	0:0	6	channels
water	24:78	0:0	4	;
water	25:8	0:0	4	s
op	25:9	0:0	4	->
water	25:11	0:0	4	channels
op	25:20	0:0	4	=
water	25:22	0:0	4	0
water	25:23	0:0	4	;
return	26:8	26:34	4	AVERROR_INVALIDDATA
water	26:15	0:0	5	AVERROR_INVALIDDATA
water	27:4	0:0	4	}
water	28:4	0:0	2	s
op	28:5	0:0	2	->
water	28:7	0:0	2	avctx
op	28:12	0:0	2	->
water	28:14	0:0	2	channels
op	28:23	0:0	2	=
water	28:25	0:0	2	s
op	28:26	0:0	2	->
water	28:28	0:0	2	channels
water	28:36	0:0	2	;
if	31:4	55:4	2	(s -> version > 0)
cond	31:8	31:21	3	s -> version > 0
water	31:8	0:0	4	s
op	31:9	0:0	4	->
water	31:11	0:0	4	version
op	31:19	0:0	4	>
water	31:21	0:0	4	0
stmts	31:24	55:4	3	
water	31:24	0:0	4	{
decl	32:8	32:22	4	int	skip_bytes
water	33:8	0:0	4	unsigned
water	33:17	0:0	4	blocksize
water	33:26	0:0	4	;
water	35:8	0:0	4	blocksize
op	35:18	0:0	4	=
call	35:20	35:59	4	get_uint
arg	35:29	35:30	5	s
water	35:29	0:0	6	s
arg	35:32	35:59	5	av_log2(DEFAULT_BLOCK_SIZE)
call	35:32	35:58	6	av_log2
arg	35:40	35:58	7	DEFAULT_BLOCK_SIZE
water	35:40	0:0	8	DEFAULT_BLOCK_SIZE
water	35:60	0:0	4	;
if	36:8	41:8	4	(! blocksize || blocksize > MAX_BLOCKSIZE)
cond	36:12	36:38	5	! blocksize || blocksize > MAX_BLOCKSIZE
op	36:12	0:0	6	!
water	36:13	0:0	6	blocksize
op	36:23	0:0	6	||
water	36:26	0:0	6	blocksize
op	36:36	0:0	6	>
water	36:38	0:0	6	MAX_BLOCKSIZE
stmts	36:53	41:8	5	
water	36:53	0:0	6	{
call	37:12	39:28	6	av_log
arg	37:19	37:27	7	s->avctx
water	37:19	0:0	8	s
op	37:20	0:0	8	->
water	37:22	0:0	8	avctx
arg	37:29	37:41	7	AV_LOG_ERROR
water	37:29	0:0	8	AV_LOG_ERROR
arg	38:19	38:60	7	"invalid or unsupported block size: %d\n"
water	38:19	0:0	8	"invalid or unsupported block size: %d\n"
arg	39:19	39:28	7	blocksize
water	39:19	0:0	8	blocksize
water	39:29	0:0	6	;
return	40:12	40:34	6	AVERROR(EINVAL)
call	40:19	40:33	7	AVERROR
arg	40:27	40:33	8	EINVAL
water	40:27	0:0	9	EINVAL
water	41:8	0:0	6	}
water	42:8	0:0	4	s
op	42:9	0:0	4	->
water	42:11	0:0	4	blocksize
op	42:21	0:0	4	=
water	42:23	0:0	4	blocksize
water	42:32	0:0	4	;
water	44:8	0:0	4	maxnlpc
op	44:17	0:0	4	=
call	44:19	44:39	4	get_uint
arg	44:28	44:29	5	s
water	44:28	0:0	6	s
arg	44:31	44:39	5	LPCQSIZE
water	44:31	0:0	6	LPCQSIZE
water	44:40	0:0	4	;
water	45:8	0:0	4	s
op	45:9	0:0	4	->
water	45:11	0:0	4	nmean
op	45:17	0:0	4	=
call	45:19	45:32	4	get_uint
arg	45:28	45:29	5	s
water	45:28	0:0	6	s
arg	45:31	45:32	5	0
water	45:31	0:0	6	0
water	45:33	0:0	4	;
water	47:8	0:0	4	skip_bytes
op	47:19	0:0	4	=
call	47:21	47:42	4	get_uint
arg	47:30	47:31	5	s
water	47:30	0:0	6	s
arg	47:33	47:42	5	NSKIPSIZE
water	47:33	0:0	6	NSKIPSIZE
water	47:43	0:0	4	;
if	48:8	51:8	4	(( unsigned ) skip_bytes >get_bits_left (& s -> gb ) / 8)
cond	48:12	48:57	5	( unsigned ) skip_bytes >get_bits_left (& s -> gb ) / 8
water	48:12	0:0	6	(
water	48:13	0:0	6	unsigned
water	48:21	0:0	6	)
water	48:22	0:0	6	skip_bytes
op	48:33	0:0	6	>
call	48:35	48:55	6	get_bits_left
arg	48:49	48:55	7	&s->gb
op	48:49	0:0	8	&
water	48:50	0:0	8	s
op	48:51	0:0	8	->
water	48:53	0:0	8	gb
op	48:56	0:0	6	/
water	48:57	0:0	6	8
stmts	48:60	51:8	5	
water	48:60	0:0	6	{
call	49:12	49:81	6	av_log
arg	49:19	49:27	7	s->avctx
water	49:19	0:0	8	s
op	49:20	0:0	8	->
water	49:22	0:0	8	avctx
arg	49:29	49:41	7	AV_LOG_ERROR
water	49:29	0:0	8	AV_LOG_ERROR
arg	49:43	49:69	7	"invalid skip_bytes: %d\n"
water	49:43	0:0	8	"invalid skip_bytes: %d\n"
arg	49:71	49:81	7	skip_bytes
water	49:71	0:0	8	skip_bytes
water	49:82	0:0	6	;
return	50:12	50:38	6	AVERROR_INVALIDDATA
water	50:19	0:0	7	AVERROR_INVALIDDATA
water	51:8	0:0	6	}
for	53:8	54:32	4	(i = 0 ;i < skip_bytes;i ++)
forinit	53:13	53:18	5	i = 0 ;
water	53:13	0:0	6	i
op	53:15	0:0	6	=
water	53:17	0:0	6	0
water	53:18	0:0	6	;
cond	53:20	53:24	5	i < skip_bytes
water	53:20	0:0	6	i
op	53:22	0:0	6	<
water	53:24	0:0	6	skip_bytes
forexpr	53:36	53:37	5	i ++
water	53:36	0:0	6	i
op	53:37	0:0	6	++
stmts	54:12	54:32	5	
call	54:12	54:31	6	skip_bits
arg	54:22	54:28	7	&s->gb
op	54:22	0:0	8	&
water	54:23	0:0	8	s
op	54:24	0:0	8	->
water	54:26	0:0	8	gb
arg	54:30	54:31	7	8
water	54:30	0:0	8	8
water	54:32	0:0	6	;
water	55:4	0:0	4	}
water	56:4	0:0	2	s
op	56:5	0:0	2	->
water	56:7	0:0	2	nwrap
op	56:13	0:0	2	=
call	56:15	56:35	2	FFMAX
arg	56:21	56:26	3	NWRAP
water	56:21	0:0	4	NWRAP
arg	56:28	56:35	3	maxnlpc
water	56:28	0:0	4	maxnlpc
water	56:36	0:0	2	;
if	58:4	59:18	2	(( ret =allocate_buffers (s ) ) < 0)
cond	58:8	58:38	3	( ret =allocate_buffers (s ) ) < 0
water	58:8	0:0	4	(
water	58:9	0:0	4	ret
op	58:13	0:0	4	=
call	58:15	58:33	4	allocate_buffers
arg	58:32	58:33	5	s
water	58:32	0:0	6	s
water	58:34	0:0	4	)
op	58:36	0:0	4	<
water	58:38	0:0	4	0
stmts	59:8	59:18	3	
return	59:8	59:18	4	ret
water	59:15	0:0	5	ret
if	61:4	62:18	2	(( ret =init_offset (s ) ) < 0)
cond	61:8	61:33	3	( ret =init_offset (s ) ) < 0
water	61:8	0:0	4	(
water	61:9	0:0	4	ret
op	61:13	0:0	4	=
call	61:15	61:28	4	init_offset
arg	61:27	61:28	5	s
water	61:27	0:0	6	s
water	61:29	0:0	4	)
op	61:31	0:0	4	<
water	61:33	0:0	4	0
stmts	62:8	62:18	3	
return	62:8	62:18	4	ret
water	62:15	0:0	5	ret
if	64:4	65:36	2	(s -> version > 1)
cond	64:8	64:21	3	s -> version > 1
water	64:8	0:0	4	s
op	64:9	0:0	4	->
water	64:11	0:0	4	version
op	64:19	0:0	4	>
water	64:21	0:0	4	1
stmts	65:8	65:36	3	
water	65:8	0:0	4	s
op	65:9	0:0	4	->
water	65:11	0:0	4	lpcqoffset
op	65:22	0:0	4	=
water	65:24	0:0	4	V2LPCQOFFSET
water	65:36	0:0	4	;
if	67:4	68:16	2	(s -> avctx -> extradata_size > 0)
cond	67:8	67:35	3	s -> avctx -> extradata_size > 0
water	67:8	0:0	4	s
op	67:9	0:0	4	->
water	67:11	0:0	4	avctx
op	67:16	0:0	4	->
water	67:18	0:0	4	extradata_size
op	67:33	0:0	4	>
water	67:35	0:0	4	0
stmts	68:8	68:16	3	
goto	68:8	68:16	4	end
water	68:13	0:0	5	end
if	70:4	74:4	2	(get_ur_golomb_shorten (& s -> gb ,FNSIZE ) != FN_VERBATIM)
cond	70:8	70:49	3	get_ur_golomb_shorten (& s -> gb ,FNSIZE ) != FN_VERBATIM
call	70:8	70:44	4	get_ur_golomb_shorten
arg	70:30	70:36	5	&s->gb
op	70:30	0:0	6	&
water	70:31	0:0	6	s
op	70:32	0:0	6	->
water	70:34	0:0	6	gb
arg	70:38	70:44	5	FNSIZE
water	70:38	0:0	6	FNSIZE
op	70:46	0:0	4	!=
water	70:49	0:0	4	FN_VERBATIM
stmts	70:62	74:4	3	
water	70:62	0:0	4	{
call	71:8	72:66	4	av_log
arg	71:15	71:23	5	s->avctx
water	71:15	0:0	6	s
op	71:16	0:0	6	->
water	71:18	0:0	6	avctx
arg	71:25	71:37	5	AV_LOG_ERROR
water	71:25	0:0	6	AV_LOG_ERROR
arg	72:15	72:66	5	"missing verbatim section at beginning of stream\n"
water	72:15	0:0	6	"missing verbatim section at beginning of stream\n"
water	72:67	0:0	4	;
return	73:8	73:34	4	AVERROR_INVALIDDATA
water	73:15	0:0	5	AVERROR_INVALIDDATA
water	74:4	0:0	4	}
water	76:4	0:0	2	s
op	76:5	0:0	2	->
water	76:7	0:0	2	header_size
op	76:19	0:0	2	=
call	76:21	76:71	2	get_ur_golomb_shorten
arg	76:43	76:49	3	&s->gb
op	76:43	0:0	4	&
water	76:44	0:0	4	s
op	76:45	0:0	4	->
water	76:47	0:0	4	gb
arg	76:51	76:71	3	VERBATIM_CKSIZE_SIZE
water	76:51	0:0	4	VERBATIM_CKSIZE_SIZE
water	76:72	0:0	2	;
if	77:4	82:4	2	(s -> header_size >= OUT_BUFFER_SIZE || s -> header_size < CANONICAL_HEADER_SIZE)
cond	77:8	78:25	3	s -> header_size >= OUT_BUFFER_SIZE || s -> header_size < CANONICAL_HEADER_SIZE
water	77:8	0:0	4	s
op	77:9	0:0	4	->
water	77:11	0:0	4	header_size
op	77:23	0:0	4	>=
water	77:26	0:0	4	OUT_BUFFER_SIZE
op	77:42	0:0	4	||
water	78:8	0:0	4	s
op	78:9	0:0	4	->
water	78:11	0:0	4	header_size
op	78:23	0:0	4	<
water	78:25	0:0	4	CANONICAL_HEADER_SIZE
stmts	78:48	82:4	3	
water	78:48	0:0	4	{
call	79:8	80:29	4	av_log
arg	79:15	79:23	5	s->avctx
water	79:15	0:0	6	s
op	79:16	0:0	6	->
water	79:18	0:0	6	avctx
arg	79:25	79:37	5	AV_LOG_ERROR
water	79:25	0:0	6	AV_LOG_ERROR
arg	79:39	79:67	5	"header is wrong size: %d\n"
water	79:39	0:0	6	"header is wrong size: %d\n"
arg	80:15	80:29	5	s->header_size
water	80:15	0:0	6	s
op	80:16	0:0	6	->
water	80:18	0:0	6	header_size
water	80:30	0:0	4	;
return	81:8	81:34	4	AVERROR_INVALIDDATA
water	81:15	0:0	5	AVERROR_INVALIDDATA
water	82:4	0:0	4	}
for	84:4	85:78	2	(i = 0 ;i < s -> header_size;i ++)
forinit	84:9	84:14	3	i = 0 ;
water	84:9	0:0	4	i
op	84:11	0:0	4	=
water	84:13	0:0	4	0
water	84:14	0:0	4	;
cond	84:16	84:23	3	i < s -> header_size
water	84:16	0:0	4	i
op	84:18	0:0	4	<
water	84:20	0:0	4	s
op	84:21	0:0	4	->
water	84:23	0:0	4	header_size
forexpr	84:36	84:37	3	i ++
water	84:36	0:0	4	i
op	84:37	0:0	4	++
stmts	85:8	85:78	3	
water	85:8	0:0	4	s
op	85:9	0:0	4	->
water	85:11	0:0	4	header
op	85:17	0:0	4	[
water	85:18	0:0	4	i
op	85:19	0:0	4	]
op	85:21	0:0	4	=
water	85:23	0:0	4	(
water	85:24	0:0	4	char
water	85:28	0:0	4	)
call	85:29	85:77	4	get_ur_golomb_shorten
arg	85:51	85:57	5	&s->gb
op	85:51	0:0	6	&
water	85:52	0:0	6	s
op	85:53	0:0	6	->
water	85:55	0:0	6	gb
arg	85:59	85:77	5	VERBATIM_BYTE_SIZE
water	85:59	0:0	6	VERBATIM_BYTE_SIZE
water	85:78	0:0	4	;
if	87:4	90:4	2	(AV_RL32 (s -> header ) ==MKTAG ('R' ,'I' ,'F' ,'F' ))
cond	87:8	87:51	3	AV_RL32 (s -> header ) ==MKTAG ('R' ,'I' ,'F' ,'F' )
call	87:8	87:25	4	AV_RL32
arg	87:16	87:25	5	s->header
water	87:16	0:0	6	s
op	87:17	0:0	6	->
water	87:19	0:0	6	header
op	87:27	0:0	4	==
call	87:30	87:51	4	MKTAG
arg	87:36	87:39	5	'R'
water	87:36	0:0	6	'R'
arg	87:40	87:43	5	'I'
water	87:40	0:0	6	'I'
arg	87:44	87:47	5	'F'
water	87:44	0:0	6	'F'
arg	87:48	87:51	5	'F'
water	87:48	0:0	6	'F'
stmts	87:54	90:4	3	
water	87:54	0:0	4	{
if	88:8	89:22	4	(( ret =decode_wave_header (s -> avctx ,s -> header ,s -> header_size ) ) < 0)
cond	88:12	88:78	5	( ret =decode_wave_header (s -> avctx ,s -> header ,s -> header_size ) ) < 0
water	88:12	0:0	6	(
water	88:13	0:0	6	ret
op	88:17	0:0	6	=
call	88:19	88:73	6	decode_wave_header
arg	88:38	88:46	7	s->avctx
water	88:38	0:0	8	s
op	88:39	0:0	8	->
water	88:41	0:0	8	avctx
arg	88:48	88:57	7	s->header
water	88:48	0:0	8	s
op	88:49	0:0	8	->
water	88:51	0:0	8	header
arg	88:59	88:73	7	s->header_size
water	88:59	0:0	8	s
op	88:60	0:0	8	->
water	88:62	0:0	8	header_size
water	88:74	0:0	6	)
op	88:76	0:0	6	<
water	88:78	0:0	6	0
stmts	89:12	89:22	5	
return	89:12	89:22	6	ret
water	89:19	0:0	7	ret
water	90:4	0:0	4	}
else	90:6	93:4	2
stmts	90:11	93:4	3	
if	90:11	93:4	4	(AV_RL32 (s -> header ) ==MKTAG ('F' ,'O' ,'R' ,'M' ))
cond	90:15	90:58	5	AV_RL32 (s -> header ) ==MKTAG ('F' ,'O' ,'R' ,'M' )
call	90:15	90:32	6	AV_RL32
arg	90:23	90:32	7	s->header
water	90:23	0:0	8	s
op	90:24	0:0	8	->
water	90:26	0:0	8	header
op	90:34	0:0	6	==
call	90:37	90:58	6	MKTAG
arg	90:43	90:46	7	'F'
water	90:43	0:0	8	'F'
arg	90:47	90:50	7	'O'
water	90:47	0:0	8	'O'
arg	90:51	90:54	7	'R'
water	90:51	0:0	8	'R'
arg	90:55	90:58	7	'M'
water	90:55	0:0	8	'M'
stmts	90:61	93:4	5	
water	90:61	0:0	6	{
if	91:8	92:22	6	(( ret =decode_aiff_header (s -> avctx ,s -> header ,s -> header_size ) ) < 0)
cond	91:12	91:78	7	( ret =decode_aiff_header (s -> avctx ,s -> header ,s -> header_size ) ) < 0
water	91:12	0:0	8	(
water	91:13	0:0	8	ret
op	91:17	0:0	8	=
call	91:19	91:73	8	decode_aiff_header
arg	91:38	91:46	9	s->avctx
water	91:38	0:0	10	s
op	91:39	0:0	10	->
water	91:41	0:0	10	avctx
arg	91:48	91:57	9	s->header
water	91:48	0:0	10	s
op	91:49	0:0	10	->
water	91:51	0:0	10	header
arg	91:59	91:73	9	s->header_size
water	91:59	0:0	10	s
op	91:60	0:0	10	->
water	91:62	0:0	10	header_size
water	91:74	0:0	8	)
op	91:76	0:0	8	<
water	91:78	0:0	8	0
stmts	92:12	92:22	7	
return	92:12	92:22	8	ret
water	92:19	0:0	9	ret
water	93:4	0:0	6	}
else	93:6	97:4	2
stmts	93:11	97:4	3	
water	93:11	0:0	4	{
call	94:8	95:64	4	avpriv_report_missing_feature
arg	94:38	94:46	5	s->avctx
water	94:38	0:0	6	s
op	94:39	0:0	6	->
water	94:41	0:0	6	avctx
arg	94:48	95:44	5	"unsupported bit packing %"PRIX32
water	94:48	0:0	6	"unsupported bit packing %"
water	95:38	0:0	6	PRIX32
arg	95:46	95:64	5	AV_RL32(s->header)
call	95:46	95:63	6	AV_RL32
arg	95:54	95:63	7	s->header
water	95:54	0:0	8	s
op	95:55	0:0	8	->
water	95:57	0:0	8	header
water	95:65	0:0	4	;
return	96:8	96:35	4	AVERROR_PATCHWELCOME
water	96:15	0:0	5	AVERROR_PATCHWELCOME
water	97:4	0:0	4	}
label	99:0	99:3	2	end :
water	100:4	0:0	2	s
op	100:5	0:0	2	->
water	100:7	0:0	2	cur_chan
op	100:16	0:0	2	=
water	100:18	0:0	2	0
water	100:19	0:0	2	;
water	101:4	0:0	2	s
op	101:5	0:0	2	->
water	101:7	0:0	2	bitshift
op	101:16	0:0	2	=
water	101:18	0:0	2	0
water	101:19	0:0	2	;
water	103:4	0:0	2	s
op	103:5	0:0	2	->
water	103:7	0:0	2	got_header
op	103:18	0:0	2	=
water	103:20	0:0	2	1
water	103:21	0:0	2	;
return	105:4	105:12	2	0
water	105:11	0:0	3	0
