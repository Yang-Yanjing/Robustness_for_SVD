func	2:0	195:0	0	static int	read_header
params	2:22	0:0	1	
param	2:23	2:37	2	FFV1Context *	f
stmnts	0:0	194:12	1	
decl	4:4	4:31	2	uint8_t	state[CONTEXT_SIZE]
decl	5:4	5:32	2	int	i
water	5:9	0:0	2	,
decl	5:4	5:32	2	int	j
water	5:12	0:0	2	,
decl	5:4	5:32	2	int	context_count
op	5:28	0:0	2	=
op	5:30	0:0	2	-
water	5:31	0:0	2	1
water	6:4	0:0	2	RangeCoder
op	6:15	0:0	2	*
water	6:16	0:0	2	const
water	6:22	0:0	2	c
op	6:24	0:0	2	=
op	6:26	0:0	2	&
water	6:27	0:0	2	f
op	6:28	0:0	2	->
water	6:30	0:0	2	slice_context
op	6:43	0:0	2	[
water	6:44	0:0	2	0
op	6:45	0:0	2	]
op	6:46	0:0	2	->
water	6:48	0:0	2	c
water	6:49	0:0	2	;
call	8:4	8:36	2	memset
arg	8:11	8:16	3	state
water	8:11	0:0	4	state
arg	8:18	8:21	3	128
water	8:18	0:0	4	128
arg	8:23	8:36	3	sizeof(state)
op	8:23	0:0	4	sizeof
water	8:29	0:0	4	(
water	8:30	0:0	4	state
water	8:35	0:0	4	)
water	8:37	0:0	2	;
if	10:4	33:4	2	(f -> version < 2)
cond	10:8	10:21	3	f -> version < 2
water	10:8	0:0	4	f
op	10:9	0:0	4	->
water	10:11	0:0	4	version
op	10:19	0:0	4	<
water	10:21	0:0	4	2
stmts	10:24	33:4	3	
water	10:24	0:0	4	{
water	11:8	0:0	4	unsigned
water	11:17	0:0	4	v
op	11:18	0:0	4	=
call	11:20	11:42	4	get_symbol
arg	11:31	11:32	5	c
water	11:31	0:0	6	c
arg	11:34	11:39	5	state
water	11:34	0:0	6	state
arg	11:41	11:42	5	0
water	11:41	0:0	6	0
water	11:43	0:0	4	;
if	12:8	15:8	4	(v >= 2)
cond	12:12	12:17	5	v >= 2
water	12:12	0:0	6	v
op	12:14	0:0	6	>=
water	12:17	0:0	6	2
stmts	12:20	15:8	5	
water	12:20	0:0	6	{
call	13:12	13:84	6	av_log
arg	13:19	13:27	7	f->avctx
water	13:19	0:0	8	f
op	13:20	0:0	8	->
water	13:22	0:0	8	avctx
arg	13:29	13:41	7	AV_LOG_ERROR
water	13:29	0:0	8	AV_LOG_ERROR
arg	13:43	13:81	7	"invalid version %d in ver01 header\n"
water	13:43	0:0	8	"invalid version %d in ver01 header\n"
arg	13:83	13:84	7	v
water	13:83	0:0	8	v
water	13:85	0:0	6	;
return	14:12	14:38	6	AVERROR_INVALIDDATA
water	14:19	0:0	7	AVERROR_INVALIDDATA
water	15:8	0:0	6	}
water	16:8	0:0	4	f
op	16:9	0:0	4	->
water	16:11	0:0	4	version
op	16:19	0:0	4	=
water	16:21	0:0	4	v
water	16:22	0:0	4	;
water	17:8	0:0	4	f
op	17:9	0:0	4	->
water	17:11	0:0	4	ac
op	17:19	0:0	4	=
water	17:21	0:0	4	f
op	17:22	0:0	4	->
water	17:24	0:0	4	avctx
op	17:29	0:0	4	->
water	17:31	0:0	4	coder_type
op	17:42	0:0	4	=
call	17:44	17:66	4	get_symbol
arg	17:55	17:56	5	c
water	17:55	0:0	6	c
arg	17:58	17:63	5	state
water	17:58	0:0	6	state
arg	17:65	17:66	5	0
water	17:65	0:0	6	0
water	17:67	0:0	4	;
if	18:8	21:8	4	(f -> ac > 1)
cond	18:12	18:20	5	f -> ac > 1
water	18:12	0:0	6	f
op	18:13	0:0	6	->
water	18:15	0:0	6	ac
op	18:18	0:0	6	>
water	18:20	0:0	6	1
stmts	18:23	21:8	5	
water	18:23	0:0	6	{
for	19:12	20:82	6	(i = 1 ;i < 256;i ++)
forinit	19:17	19:22	7	i = 1 ;
water	19:17	0:0	8	i
op	19:19	0:0	8	=
water	19:21	0:0	8	1
water	19:22	0:0	8	;
cond	19:24	19:28	7	i < 256
water	19:24	0:0	8	i
op	19:26	0:0	8	<
water	19:28	0:0	8	256
forexpr	19:33	19:34	7	i ++
water	19:33	0:0	8	i
op	19:34	0:0	8	++
stmts	20:16	20:82	7	
water	20:16	0:0	8	f
op	20:17	0:0	8	->
water	20:19	0:0	8	state_transition
op	20:35	0:0	8	[
water	20:36	0:0	8	i
op	20:37	0:0	8	]
op	20:39	0:0	8	=
call	20:41	20:63	8	get_symbol
arg	20:52	20:53	9	c
water	20:52	0:0	10	c
arg	20:55	20:60	9	state
water	20:55	0:0	10	state
arg	20:62	20:63	9	1
water	20:62	0:0	10	1
op	20:65	0:0	8	+
water	20:67	0:0	8	c
op	20:68	0:0	8	->
water	20:70	0:0	8	one_state
op	20:79	0:0	8	[
water	20:80	0:0	8	i
op	20:81	0:0	8	]
water	20:82	0:0	8	;
water	21:8	0:0	6	}
water	23:8	0:0	4	f
op	23:9	0:0	4	->
water	23:11	0:0	4	colorspace
op	23:22	0:0	4	=
call	23:24	23:46	4	get_symbol
arg	23:35	23:36	5	c
water	23:35	0:0	6	c
arg	23:38	23:43	5	state
water	23:38	0:0	6	state
arg	23:45	23:46	5	0
water	23:45	0:0	6	0
water	23:47	0:0	4	;
if	25:8	26:67	4	(f -> version > 0)
cond	25:12	25:25	5	f -> version > 0
water	25:12	0:0	6	f
op	25:13	0:0	6	->
water	25:15	0:0	6	version
op	25:23	0:0	6	>
water	25:25	0:0	6	0
stmts	26:12	26:67	5	
water	26:12	0:0	6	f
op	26:13	0:0	6	->
water	26:15	0:0	6	avctx
op	26:20	0:0	6	->
water	26:22	0:0	6	bits_per_raw_sample
op	26:42	0:0	6	=
call	26:44	26:66	6	get_symbol
arg	26:55	26:56	7	c
water	26:55	0:0	8	c
arg	26:58	26:63	7	state
water	26:58	0:0	8	state
arg	26:65	26:66	7	0
water	26:65	0:0	8	0
water	26:67	0:0	6	;
water	28:8	0:0	4	f
op	28:9	0:0	4	->
water	28:11	0:0	4	chroma_planes
op	28:26	0:0	4	=
call	28:28	28:44	4	get_rac
arg	28:36	28:37	5	c
water	28:36	0:0	6	c
arg	28:39	28:44	5	state
water	28:39	0:0	6	state
water	28:45	0:0	4	;
water	29:8	0:0	4	f
op	29:9	0:0	4	->
water	29:11	0:0	4	chroma_h_shift
op	29:26	0:0	4	=
call	29:28	29:50	4	get_symbol
arg	29:39	29:40	5	c
water	29:39	0:0	6	c
arg	29:42	29:47	5	state
water	29:42	0:0	6	state
arg	29:49	29:50	5	0
water	29:49	0:0	6	0
water	29:51	0:0	4	;
water	30:8	0:0	4	f
op	30:9	0:0	4	->
water	30:11	0:0	4	chroma_v_shift
op	30:26	0:0	4	=
call	30:28	30:50	4	get_symbol
arg	30:39	30:40	5	c
water	30:39	0:0	6	c
arg	30:42	30:47	5	state
water	30:42	0:0	6	state
arg	30:49	30:50	5	0
water	30:49	0:0	6	0
water	30:51	0:0	4	;
water	31:8	0:0	4	f
op	31:9	0:0	4	->
water	31:11	0:0	4	transparency
op	31:26	0:0	4	=
call	31:28	31:44	4	get_rac
arg	31:36	31:37	5	c
water	31:36	0:0	6	c
arg	31:39	31:44	5	state
water	31:39	0:0	6	state
water	31:45	0:0	4	;
water	32:8	0:0	4	f
op	32:9	0:0	4	->
water	32:11	0:0	4	plane_count
op	32:26	0:0	4	=
water	32:28	0:0	4	2
op	32:30	0:0	4	+
water	32:32	0:0	4	f
op	32:33	0:0	4	->
water	32:35	0:0	4	transparency
water	32:47	0:0	4	;
water	33:4	0:0	4	}
if	35:4	92:4	2	(f -> colorspace == 0)
cond	35:8	35:25	3	f -> colorspace == 0
water	35:8	0:0	4	f
op	35:9	0:0	4	->
water	35:11	0:0	4	colorspace
op	35:22	0:0	4	==
water	35:25	0:0	4	0
stmts	35:28	92:4	3	
water	35:28	0:0	4	{
if	36:8	41:8	4	(! f -> transparency && ! f -> chroma_planes)
cond	36:12	36:36	5	! f -> transparency && ! f -> chroma_planes
op	36:12	0:0	6	!
water	36:13	0:0	6	f
op	36:14	0:0	6	->
water	36:16	0:0	6	transparency
op	36:29	0:0	6	&&
op	36:32	0:0	6	!
water	36:33	0:0	6	f
op	36:34	0:0	6	->
water	36:36	0:0	6	chroma_planes
stmts	36:51	41:8	5	
water	36:51	0:0	6	{
if	37:12	38:52	6	(f -> avctx -> bits_per_raw_sample <= 8)
cond	37:16	37:49	7	f -> avctx -> bits_per_raw_sample <= 8
water	37:16	0:0	8	f
op	37:17	0:0	8	->
water	37:19	0:0	8	avctx
op	37:24	0:0	8	->
water	37:26	0:0	8	bits_per_raw_sample
op	37:46	0:0	8	<=
water	37:49	0:0	8	8
stmts	38:16	38:52	7	
water	38:16	0:0	8	f
op	38:17	0:0	8	->
water	38:19	0:0	8	avctx
op	38:24	0:0	8	->
water	38:26	0:0	8	pix_fmt
op	38:34	0:0	8	=
water	38:36	0:0	8	AV_PIX_FMT_GRAY8
water	38:52	0:0	8	;
else	39:12	40:53	6
stmts	40:16	40:53	7	
water	40:16	0:0	8	f
op	40:17	0:0	8	->
water	40:19	0:0	8	avctx
op	40:24	0:0	8	->
water	40:26	0:0	8	pix_fmt
op	40:34	0:0	8	=
water	40:36	0:0	8	AV_PIX_FMT_GRAY16
water	40:53	0:0	8	;
water	41:8	0:0	6	}
else	41:10	53:8	4
stmts	41:15	53:8	5	
if	41:15	53:8	6	(f -> avctx -> bits_per_raw_sample <= 8 && ! f -> transparency)
cond	41:19	41:59	7	f -> avctx -> bits_per_raw_sample <= 8 && ! f -> transparency
water	41:19	0:0	8	f
op	41:20	0:0	8	->
water	41:22	0:0	8	avctx
op	41:27	0:0	8	->
water	41:29	0:0	8	bits_per_raw_sample
op	41:48	0:0	8	<=
water	41:50	0:0	8	8
op	41:52	0:0	8	&&
op	41:55	0:0	8	!
water	41:56	0:0	8	f
op	41:57	0:0	8	->
water	41:59	0:0	8	transparency
stmts	41:73	53:8	7	
water	41:73	0:0	8	{
switch	42:12	52:12	8	(16 * f -> chroma_h_shift + f -> chroma_v_shift)
cond	42:19	42:47	9	16 * f -> chroma_h_shift + f -> chroma_v_shift
water	42:19	0:0	10	16
op	42:22	0:0	10	*
water	42:24	0:0	10	f
op	42:25	0:0	10	->
water	42:27	0:0	10	chroma_h_shift
op	42:42	0:0	10	+
water	42:44	0:0	10	f
op	42:45	0:0	10	->
water	42:47	0:0	10	chroma_v_shift
stmts	42:63	52:12	9	
water	42:63	0:0	10	{
label	43:12	43:21	10	case 0 x00 :
water	43:23	0:0	10	f
op	43:24	0:0	10	->
water	43:26	0:0	10	avctx
op	43:31	0:0	10	->
water	43:33	0:0	10	pix_fmt
op	43:41	0:0	10	=
water	43:43	0:0	10	AV_PIX_FMT_YUV444P
water	43:61	0:0	10	;
break	43:63	43:68	10	
label	44:12	44:21	10	case 0 x01 :
water	44:23	0:0	10	f
op	44:24	0:0	10	->
water	44:26	0:0	10	avctx
op	44:31	0:0	10	->
water	44:33	0:0	10	pix_fmt
op	44:41	0:0	10	=
water	44:43	0:0	10	AV_PIX_FMT_YUV440P
water	44:61	0:0	10	;
break	44:63	44:68	10	
label	45:12	45:21	10	case 0 x10 :
water	45:23	0:0	10	f
op	45:24	0:0	10	->
water	45:26	0:0	10	avctx
op	45:31	0:0	10	->
water	45:33	0:0	10	pix_fmt
op	45:41	0:0	10	=
water	45:43	0:0	10	AV_PIX_FMT_YUV422P
water	45:61	0:0	10	;
break	45:63	45:68	10	
label	46:12	46:21	10	case 0 x11 :
water	46:23	0:0	10	f
op	46:24	0:0	10	->
water	46:26	0:0	10	avctx
op	46:31	0:0	10	->
water	46:33	0:0	10	pix_fmt
op	46:41	0:0	10	=
water	46:43	0:0	10	AV_PIX_FMT_YUV420P
water	46:61	0:0	10	;
break	46:63	46:68	10	
label	47:12	47:21	10	case 0 x20 :
water	47:23	0:0	10	f
op	47:24	0:0	10	->
water	47:26	0:0	10	avctx
op	47:31	0:0	10	->
water	47:33	0:0	10	pix_fmt
op	47:41	0:0	10	=
water	47:43	0:0	10	AV_PIX_FMT_YUV411P
water	47:61	0:0	10	;
break	47:63	47:68	10	
label	48:12	48:21	10	case 0 x22 :
water	48:23	0:0	10	f
op	48:24	0:0	10	->
water	48:26	0:0	10	avctx
op	48:31	0:0	10	->
water	48:33	0:0	10	pix_fmt
op	48:41	0:0	10	=
water	48:43	0:0	10	AV_PIX_FMT_YUV410P
water	48:61	0:0	10	;
break	48:63	48:68	10	
label	49:12	49:19	10	default :
call	50:16	50:71	10	av_log
arg	50:23	50:31	11	f->avctx
water	50:23	0:0	12	f
op	50:24	0:0	12	->
water	50:26	0:0	12	avctx
arg	50:33	50:45	11	AV_LOG_ERROR
water	50:33	0:0	12	AV_LOG_ERROR
arg	50:47	50:71	11	"format not supported\n"
water	50:47	0:0	12	"format not supported\n"
water	50:72	0:0	10	;
return	51:16	51:38	10	AVERROR(ENOSYS)
call	51:23	51:37	11	AVERROR
arg	51:31	51:37	12	ENOSYS
water	51:31	0:0	13	ENOSYS
water	52:12	0:0	10	}
water	53:8	0:0	8	}
else	53:10	62:8	4
stmts	53:15	62:8	5	
if	53:15	62:8	6	(f -> avctx -> bits_per_raw_sample <= 8 && f -> transparency)
cond	53:19	53:60	7	f -> avctx -> bits_per_raw_sample <= 8 && f -> transparency
water	53:19	0:0	8	f
op	53:20	0:0	8	->
water	53:22	0:0	8	avctx
op	53:27	0:0	8	->
water	53:29	0:0	8	bits_per_raw_sample
op	53:49	0:0	8	<=
water	53:52	0:0	8	8
op	53:54	0:0	8	&&
water	53:57	0:0	8	f
op	53:58	0:0	8	->
water	53:60	0:0	8	transparency
stmts	53:74	62:8	7	
water	53:74	0:0	8	{
switch	54:12	61:12	8	(16 * f -> chroma_h_shift + f -> chroma_v_shift)
cond	54:19	54:45	9	16 * f -> chroma_h_shift + f -> chroma_v_shift
water	54:19	0:0	10	16
op	54:21	0:0	10	*
water	54:22	0:0	10	f
op	54:23	0:0	10	->
water	54:25	0:0	10	chroma_h_shift
op	54:40	0:0	10	+
water	54:42	0:0	10	f
op	54:43	0:0	10	->
water	54:45	0:0	10	chroma_v_shift
stmts	54:61	61:12	9	
water	54:61	0:0	10	{
label	55:12	55:21	10	case 0 x00 :
water	55:23	0:0	10	f
op	55:24	0:0	10	->
water	55:26	0:0	10	avctx
op	55:31	0:0	10	->
water	55:33	0:0	10	pix_fmt
op	55:41	0:0	10	=
water	55:43	0:0	10	AV_PIX_FMT_YUVA444P
water	55:62	0:0	10	;
break	55:64	55:69	10	
label	56:12	56:21	10	case 0 x10 :
water	56:23	0:0	10	f
op	56:24	0:0	10	->
water	56:26	0:0	10	avctx
op	56:31	0:0	10	->
water	56:33	0:0	10	pix_fmt
op	56:41	0:0	10	=
water	56:43	0:0	10	AV_PIX_FMT_YUVA422P
water	56:62	0:0	10	;
break	56:64	56:69	10	
label	57:12	57:21	10	case 0 x11 :
water	57:23	0:0	10	f
op	57:24	0:0	10	->
water	57:26	0:0	10	avctx
op	57:31	0:0	10	->
water	57:33	0:0	10	pix_fmt
op	57:41	0:0	10	=
water	57:43	0:0	10	AV_PIX_FMT_YUVA420P
water	57:62	0:0	10	;
break	57:64	57:69	10	
label	58:12	58:19	10	default :
call	59:16	59:71	10	av_log
arg	59:23	59:31	11	f->avctx
water	59:23	0:0	12	f
op	59:24	0:0	12	->
water	59:26	0:0	12	avctx
arg	59:33	59:45	11	AV_LOG_ERROR
water	59:33	0:0	12	AV_LOG_ERROR
arg	59:47	59:71	11	"format not supported\n"
water	59:47	0:0	12	"format not supported\n"
water	59:72	0:0	10	;
return	60:16	60:38	10	AVERROR(ENOSYS)
call	60:23	60:37	11	AVERROR
arg	60:31	60:37	12	ENOSYS
water	60:31	0:0	13	ENOSYS
water	61:12	0:0	10	}
water	62:8	0:0	8	}
else	62:10	72:8	4
stmts	62:15	72:8	5	
if	62:15	72:8	6	(f -> avctx -> bits_per_raw_sample == 9)
cond	62:19	62:52	7	f -> avctx -> bits_per_raw_sample == 9
water	62:19	0:0	8	f
op	62:20	0:0	8	->
water	62:22	0:0	8	avctx
op	62:27	0:0	8	->
water	62:29	0:0	8	bits_per_raw_sample
op	62:49	0:0	8	==
water	62:52	0:0	8	9
stmts	62:55	72:8	7	
water	62:55	0:0	8	{
water	63:12	0:0	8	f
op	63:13	0:0	8	->
water	63:15	0:0	8	packed_at_lsb
op	63:29	0:0	8	=
water	63:31	0:0	8	1
water	63:32	0:0	8	;
switch	64:12	71:12	8	(16 * f -> chroma_h_shift + f -> chroma_v_shift)
cond	64:19	64:47	9	16 * f -> chroma_h_shift + f -> chroma_v_shift
water	64:19	0:0	10	16
op	64:22	0:0	10	*
water	64:24	0:0	10	f
op	64:25	0:0	10	->
water	64:27	0:0	10	chroma_h_shift
op	64:42	0:0	10	+
water	64:44	0:0	10	f
op	64:45	0:0	10	->
water	64:47	0:0	10	chroma_v_shift
stmts	64:63	71:12	9	
water	64:63	0:0	10	{
label	65:12	65:21	10	case 0 x00 :
water	65:23	0:0	10	f
op	65:24	0:0	10	->
water	65:26	0:0	10	avctx
op	65:31	0:0	10	->
water	65:33	0:0	10	pix_fmt
op	65:41	0:0	10	=
water	65:43	0:0	10	AV_PIX_FMT_YUV444P9
water	65:62	0:0	10	;
break	65:64	65:69	10	
label	66:12	66:21	10	case 0 x10 :
water	66:23	0:0	10	f
op	66:24	0:0	10	->
water	66:26	0:0	10	avctx
op	66:31	0:0	10	->
water	66:33	0:0	10	pix_fmt
op	66:41	0:0	10	=
water	66:43	0:0	10	AV_PIX_FMT_YUV422P9
water	66:62	0:0	10	;
break	66:64	66:69	10	
label	67:12	67:21	10	case 0 x11 :
water	67:23	0:0	10	f
op	67:24	0:0	10	->
water	67:26	0:0	10	avctx
op	67:31	0:0	10	->
water	67:33	0:0	10	pix_fmt
op	67:41	0:0	10	=
water	67:43	0:0	10	AV_PIX_FMT_YUV420P9
water	67:62	0:0	10	;
break	67:64	67:69	10	
label	68:12	68:19	10	default :
call	69:16	69:71	10	av_log
arg	69:23	69:31	11	f->avctx
water	69:23	0:0	12	f
op	69:24	0:0	12	->
water	69:26	0:0	12	avctx
arg	69:33	69:45	11	AV_LOG_ERROR
water	69:33	0:0	12	AV_LOG_ERROR
arg	69:47	69:71	11	"format not supported\n"
water	69:47	0:0	12	"format not supported\n"
water	69:72	0:0	10	;
return	70:16	70:38	10	AVERROR(ENOSYS)
call	70:23	70:37	11	AVERROR
arg	70:31	70:37	12	ENOSYS
water	70:31	0:0	13	ENOSYS
water	71:12	0:0	10	}
water	72:8	0:0	8	}
else	72:10	82:8	4
stmts	72:15	82:8	5	
if	72:15	82:8	6	(f -> avctx -> bits_per_raw_sample == 10)
cond	72:19	72:52	7	f -> avctx -> bits_per_raw_sample == 10
water	72:19	0:0	8	f
op	72:20	0:0	8	->
water	72:22	0:0	8	avctx
op	72:27	0:0	8	->
water	72:29	0:0	8	bits_per_raw_sample
op	72:49	0:0	8	==
water	72:52	0:0	8	10
stmts	72:56	82:8	7	
water	72:56	0:0	8	{
water	73:12	0:0	8	f
op	73:13	0:0	8	->
water	73:15	0:0	8	packed_at_lsb
op	73:29	0:0	8	=
water	73:31	0:0	8	1
water	73:32	0:0	8	;
switch	74:12	81:12	8	(16 * f -> chroma_h_shift + f -> chroma_v_shift)
cond	74:19	74:47	9	16 * f -> chroma_h_shift + f -> chroma_v_shift
water	74:19	0:0	10	16
op	74:22	0:0	10	*
water	74:24	0:0	10	f
op	74:25	0:0	10	->
water	74:27	0:0	10	chroma_h_shift
op	74:42	0:0	10	+
water	74:44	0:0	10	f
op	74:45	0:0	10	->
water	74:47	0:0	10	chroma_v_shift
stmts	74:63	81:12	9	
water	74:63	0:0	10	{
label	75:12	75:21	10	case 0 x00 :
water	75:23	0:0	10	f
op	75:24	0:0	10	->
water	75:26	0:0	10	avctx
op	75:31	0:0	10	->
water	75:33	0:0	10	pix_fmt
op	75:41	0:0	10	=
water	75:43	0:0	10	AV_PIX_FMT_YUV444P10
water	75:63	0:0	10	;
break	75:65	75:70	10	
label	76:12	76:21	10	case 0 x10 :
water	76:23	0:0	10	f
op	76:24	0:0	10	->
water	76:26	0:0	10	avctx
op	76:31	0:0	10	->
water	76:33	0:0	10	pix_fmt
op	76:41	0:0	10	=
water	76:43	0:0	10	AV_PIX_FMT_YUV422P10
water	76:63	0:0	10	;
break	76:65	76:70	10	
label	77:12	77:21	10	case 0 x11 :
water	77:23	0:0	10	f
op	77:24	0:0	10	->
water	77:26	0:0	10	avctx
op	77:31	0:0	10	->
water	77:33	0:0	10	pix_fmt
op	77:41	0:0	10	=
water	77:43	0:0	10	AV_PIX_FMT_YUV420P10
water	77:63	0:0	10	;
break	77:65	77:70	10	
label	78:12	78:19	10	default :
call	79:16	79:71	10	av_log
arg	79:23	79:31	11	f->avctx
water	79:23	0:0	12	f
op	79:24	0:0	12	->
water	79:26	0:0	12	avctx
arg	79:33	79:45	11	AV_LOG_ERROR
water	79:33	0:0	12	AV_LOG_ERROR
arg	79:47	79:71	11	"format not supported\n"
water	79:47	0:0	12	"format not supported\n"
water	79:72	0:0	10	;
return	80:16	80:38	10	AVERROR(ENOSYS)
call	80:23	80:37	11	AVERROR
arg	80:31	80:37	12	ENOSYS
water	80:31	0:0	13	ENOSYS
water	81:12	0:0	10	}
water	82:8	0:0	8	}
else	82:10	91:8	4
stmts	82:15	91:8	5	
water	82:15	0:0	6	{
switch	83:12	90:12	6	(16 * f -> chroma_h_shift + f -> chroma_v_shift)
cond	83:19	83:47	7	16 * f -> chroma_h_shift + f -> chroma_v_shift
water	83:19	0:0	8	16
op	83:22	0:0	8	*
water	83:24	0:0	8	f
op	83:25	0:0	8	->
water	83:27	0:0	8	chroma_h_shift
op	83:42	0:0	8	+
water	83:44	0:0	8	f
op	83:45	0:0	8	->
water	83:47	0:0	8	chroma_v_shift
stmts	83:63	90:12	7	
water	83:63	0:0	8	{
label	84:12	84:21	8	case 0 x00 :
water	84:23	0:0	8	f
op	84:24	0:0	8	->
water	84:26	0:0	8	avctx
op	84:31	0:0	8	->
water	84:33	0:0	8	pix_fmt
op	84:41	0:0	8	=
water	84:43	0:0	8	AV_PIX_FMT_YUV444P16
water	84:63	0:0	8	;
break	84:65	84:70	8	
label	85:12	85:21	8	case 0 x10 :
water	85:23	0:0	8	f
op	85:24	0:0	8	->
water	85:26	0:0	8	avctx
op	85:31	0:0	8	->
water	85:33	0:0	8	pix_fmt
op	85:41	0:0	8	=
water	85:43	0:0	8	AV_PIX_FMT_YUV422P16
water	85:63	0:0	8	;
break	85:65	85:70	8	
label	86:12	86:21	8	case 0 x11 :
water	86:23	0:0	8	f
op	86:24	0:0	8	->
water	86:26	0:0	8	avctx
op	86:31	0:0	8	->
water	86:33	0:0	8	pix_fmt
op	86:41	0:0	8	=
water	86:43	0:0	8	AV_PIX_FMT_YUV420P16
water	86:63	0:0	8	;
break	86:65	86:70	8	
label	87:12	87:19	8	default :
call	88:16	88:71	8	av_log
arg	88:23	88:31	9	f->avctx
water	88:23	0:0	10	f
op	88:24	0:0	10	->
water	88:26	0:0	10	avctx
arg	88:33	88:45	9	AV_LOG_ERROR
water	88:33	0:0	10	AV_LOG_ERROR
arg	88:47	88:71	9	"format not supported\n"
water	88:47	0:0	10	"format not supported\n"
water	88:72	0:0	8	;
return	89:16	89:38	8	AVERROR(ENOSYS)
call	89:23	89:37	9	AVERROR
arg	89:31	89:37	10	ENOSYS
water	89:31	0:0	11	ENOSYS
water	90:12	0:0	8	}
water	91:8	0:0	6	}
water	92:4	0:0	4	}
else	92:6	109:4	2
stmts	92:11	109:4	3	
if	92:11	109:4	4	(f -> colorspace == 1)
cond	92:15	92:32	5	f -> colorspace == 1
water	92:15	0:0	6	f
op	92:16	0:0	6	->
water	92:18	0:0	6	colorspace
op	92:29	0:0	6	==
water	92:32	0:0	6	1
stmts	92:35	109:4	5	
water	92:35	0:0	6	{
if	93:8	97:8	6	(f -> chroma_h_shift || f -> chroma_v_shift)
cond	93:12	93:36	7	f -> chroma_h_shift || f -> chroma_v_shift
water	93:12	0:0	8	f
op	93:13	0:0	8	->
water	93:15	0:0	8	chroma_h_shift
op	93:30	0:0	8	||
water	93:33	0:0	8	f
op	93:34	0:0	8	->
water	93:36	0:0	8	chroma_v_shift
stmts	93:52	97:8	7	
water	93:52	0:0	8	{
call	94:12	95:74	8	av_log
arg	94:19	94:27	9	f->avctx
water	94:19	0:0	10	f
op	94:20	0:0	10	->
water	94:22	0:0	10	avctx
arg	94:29	94:41	9	AV_LOG_ERROR
water	94:29	0:0	10	AV_LOG_ERROR
arg	95:19	95:74	9	"chroma subsampling not supported in this colorspace\n"
water	95:19	0:0	10	"chroma subsampling not supported in this colorspace\n"
water	95:75	0:0	8	;
return	96:12	96:34	8	AVERROR(ENOSYS)
call	96:19	96:33	9	AVERROR
arg	96:27	96:33	10	ENOSYS
water	96:27	0:0	11	ENOSYS
water	97:8	0:0	8	}
if	98:8	99:48	6	(f -> avctx -> bits_per_raw_sample == 9)
cond	98:17	98:51	7	f -> avctx -> bits_per_raw_sample == 9
water	98:17	0:0	8	f
op	98:18	0:0	8	->
water	98:20	0:0	8	avctx
op	98:25	0:0	8	->
water	98:27	0:0	8	bits_per_raw_sample
op	98:47	0:0	8	==
water	98:51	0:0	8	9
stmts	99:12	99:48	7	
water	99:12	0:0	8	f
op	99:13	0:0	8	->
water	99:15	0:0	8	avctx
op	99:20	0:0	8	->
water	99:22	0:0	8	pix_fmt
op	99:30	0:0	8	=
water	99:32	0:0	8	AV_PIX_FMT_GBRP9
water	99:48	0:0	8	;
else	100:8	101:49	6
stmts	100:13	101:49	7	
if	100:13	101:49	8	(f -> avctx -> bits_per_raw_sample == 10)
cond	100:17	100:50	9	f -> avctx -> bits_per_raw_sample == 10
water	100:17	0:0	10	f
op	100:18	0:0	10	->
water	100:20	0:0	10	avctx
op	100:25	0:0	10	->
water	100:27	0:0	10	bits_per_raw_sample
op	100:47	0:0	10	==
water	100:50	0:0	10	10
stmts	101:12	101:49	9	
water	101:12	0:0	10	f
op	101:13	0:0	10	->
water	101:15	0:0	10	avctx
op	101:20	0:0	10	->
water	101:22	0:0	10	pix_fmt
op	101:30	0:0	10	=
water	101:32	0:0	10	AV_PIX_FMT_GBRP10
water	101:49	0:0	10	;
else	102:8	103:49	6
stmts	102:13	103:49	7	
if	102:13	103:49	8	(f -> avctx -> bits_per_raw_sample == 12)
cond	102:17	102:50	9	f -> avctx -> bits_per_raw_sample == 12
water	102:17	0:0	10	f
op	102:18	0:0	10	->
water	102:20	0:0	10	avctx
op	102:25	0:0	10	->
water	102:27	0:0	10	bits_per_raw_sample
op	102:47	0:0	10	==
water	102:50	0:0	10	12
stmts	103:12	103:49	9	
water	103:12	0:0	10	f
op	103:13	0:0	10	->
water	103:15	0:0	10	avctx
op	103:20	0:0	10	->
water	103:22	0:0	10	pix_fmt
op	103:30	0:0	10	=
water	103:32	0:0	10	AV_PIX_FMT_GBRP12
water	103:49	0:0	10	;
else	104:8	105:49	6
stmts	104:13	105:49	7	
if	104:13	105:49	8	(f -> avctx -> bits_per_raw_sample == 14)
cond	104:17	104:50	9	f -> avctx -> bits_per_raw_sample == 14
water	104:17	0:0	10	f
op	104:18	0:0	10	->
water	104:20	0:0	10	avctx
op	104:25	0:0	10	->
water	104:27	0:0	10	bits_per_raw_sample
op	104:47	0:0	10	==
water	104:50	0:0	10	14
stmts	105:12	105:49	9	
water	105:12	0:0	10	f
op	105:13	0:0	10	->
water	105:15	0:0	10	avctx
op	105:20	0:0	10	->
water	105:22	0:0	10	pix_fmt
op	105:30	0:0	10	=
water	105:32	0:0	10	AV_PIX_FMT_GBRP14
water	105:49	0:0	10	;
else	106:8	107:65	6
stmts	107:8	107:65	7	
if	107:8	107:65	8	(f -> transparency)
cond	107:12	107:15	9	f -> transparency
water	107:12	0:0	10	f
op	107:13	0:0	10	->
water	107:15	0:0	10	transparency
stmts	107:29	107:65	9	
water	107:29	0:0	10	f
op	107:30	0:0	10	->
water	107:32	0:0	10	avctx
op	107:37	0:0	10	->
water	107:39	0:0	10	pix_fmt
op	107:47	0:0	10	=
water	107:49	0:0	10	AV_PIX_FMT_RGB32
water	107:65	0:0	10	;
else	108:8	108:66	6
stmts	108:29	108:66	7	
water	108:29	0:0	8	f
op	108:30	0:0	8	->
water	108:32	0:0	8	avctx
op	108:37	0:0	8	->
water	108:39	0:0	8	pix_fmt
op	108:47	0:0	8	=
water	108:49	0:0	8	AV_PIX_FMT_0RGB32
water	108:66	0:0	8	;
water	109:4	0:0	6	}
else	109:6	112:4	2
stmts	109:11	112:4	3	
water	109:11	0:0	4	{
call	110:8	110:67	4	av_log
arg	110:15	110:23	5	f->avctx
water	110:15	0:0	6	f
op	110:16	0:0	6	->
water	110:18	0:0	6	avctx
arg	110:25	110:37	5	AV_LOG_ERROR
water	110:25	0:0	6	AV_LOG_ERROR
arg	110:39	110:67	5	"colorspace not supported\n"
water	110:39	0:0	6	"colorspace not supported\n"
water	110:68	0:0	4	;
return	111:8	111:30	4	AVERROR(ENOSYS)
call	111:15	111:29	5	AVERROR
arg	111:23	111:29	6	ENOSYS
water	111:23	0:0	7	ENOSYS
water	112:4	0:0	4	}
call	114:4	115:67	2	av_dlog
arg	114:12	114:20	3	f->avctx
water	114:12	0:0	4	f
op	114:13	0:0	4	->
water	114:15	0:0	4	avctx
arg	114:22	114:34	3	"%d %d %d\n"
water	114:22	0:0	4	"%d %d %d\n"
arg	115:12	115:29	3	f->chroma_h_shift
water	115:12	0:0	4	f
op	115:13	0:0	4	->
water	115:15	0:0	4	chroma_h_shift
arg	115:31	115:48	3	f->chroma_v_shift
water	115:31	0:0	4	f
op	115:32	0:0	4	->
water	115:34	0:0	4	chroma_v_shift
arg	115:50	115:67	3	f->avctx->pix_fmt
water	115:50	0:0	4	f
op	115:51	0:0	4	->
water	115:53	0:0	4	avctx
op	115:58	0:0	4	->
water	115:60	0:0	4	pix_fmt
water	115:68	0:0	2	;
if	116:4	122:4	2	(f -> version < 2)
cond	116:8	116:21	3	f -> version < 2
water	116:8	0:0	4	f
op	116:9	0:0	4	->
water	116:11	0:0	4	version
op	116:19	0:0	4	<
water	116:21	0:0	4	2
stmts	116:24	122:4	3	
water	116:24	0:0	4	{
water	117:8	0:0	4	context_count
op	117:22	0:0	4	=
call	117:24	117:59	4	read_quant_tables
arg	117:42	117:43	5	c
water	117:42	0:0	6	c
arg	117:45	117:59	5	f->quant_table
water	117:45	0:0	6	f
op	117:46	0:0	6	->
water	117:48	0:0	6	quant_table
water	117:60	0:0	4	;
if	118:8	121:8	4	(context_count < 0)
cond	118:12	118:28	5	context_count < 0
water	118:12	0:0	6	context_count
op	118:26	0:0	6	<
water	118:28	0:0	6	0
stmts	118:31	121:8	5	
water	118:31	0:0	6	{
call	119:12	119:69	6	av_log
arg	119:19	119:27	7	f->avctx
water	119:19	0:0	8	f
op	119:20	0:0	8	->
water	119:22	0:0	8	avctx
arg	119:29	119:41	7	AV_LOG_ERROR
water	119:29	0:0	8	AV_LOG_ERROR
arg	119:43	119:69	7	"read_quant_table error\n"
water	119:43	0:0	8	"read_quant_table error\n"
water	119:70	0:0	6	;
return	120:12	120:38	6	AVERROR_INVALIDDATA
water	120:19	0:0	7	AVERROR_INVALIDDATA
water	121:8	0:0	6	}
water	122:4	0:0	4	}
else	122:6	124:4	2
stmts	122:11	124:4	3	
if	122:11	124:4	4	(f -> version < 3)
cond	122:15	122:28	5	f -> version < 3
water	122:15	0:0	6	f
op	122:16	0:0	6	->
water	122:18	0:0	6	version
op	122:26	0:0	6	<
water	122:28	0:0	6	3
stmts	122:31	124:4	5	
water	122:31	0:0	6	{
water	123:8	0:0	6	f
op	123:9	0:0	6	->
water	123:11	0:0	6	slice_count
op	123:23	0:0	6	=
call	123:25	123:47	6	get_symbol
arg	123:36	123:37	7	c
water	123:36	0:0	8	c
arg	123:39	123:44	7	state
water	123:39	0:0	8	state
arg	123:46	123:47	7	0
water	123:46	0:0	8	0
water	123:48	0:0	6	;
water	124:4	0:0	6	}
else	124:6	135:4	2
stmts	124:11	135:4	3	
water	124:11	0:0	4	{
decl	125:8	125:44	4	const uint8_t	*p
op	125:25	0:0	4	=
water	125:27	0:0	4	c
op	125:28	0:0	4	->
water	125:30	0:0	4	bytestream_end
for	126:8	134:8	4	(f -> slice_count = 0 ;f -> slice_count < MAX_SLICES && 3 < p - c -> bytestream_start;f -> slice_count ++)
forinit	126:13	126:31	5	f -> slice_count = 0 ;
water	126:13	0:0	6	f
op	126:14	0:0	6	->
water	126:16	0:0	6	slice_count
op	126:28	0:0	6	=
water	126:30	0:0	6	0
water	126:31	0:0	6	;
cond	127:13	127:55	5	f -> slice_count < MAX_SLICES && 3 < p - c -> bytestream_start
water	127:13	0:0	6	f
op	127:14	0:0	6	->
water	127:16	0:0	6	slice_count
op	127:28	0:0	6	<
water	127:30	0:0	6	MAX_SLICES
op	127:41	0:0	6	&&
water	127:44	0:0	6	3
op	127:46	0:0	6	<
water	127:48	0:0	6	p
op	127:50	0:0	6	-
water	127:52	0:0	6	c
op	127:53	0:0	6	->
water	127:55	0:0	6	bytestream_start
forexpr	128:13	128:27	5	f -> slice_count ++
water	128:13	0:0	6	f
op	128:14	0:0	6	->
water	128:16	0:0	6	slice_count
op	128:27	0:0	6	++
stmts	128:31	134:8	5	
water	128:31	0:0	6	{
decl	129:12	129:39	6	int	trailer
op	129:24	0:0	6	=
water	129:26	0:0	6	3
op	129:28	0:0	6	+
water	129:30	0:0	6	5
op	129:31	0:0	6	*
op	129:32	0:0	6	!
op	129:33	0:0	6	!
water	129:34	0:0	6	f
op	129:35	0:0	6	->
water	129:37	0:0	6	ec
decl	130:12	130:41	6	int	size
op	130:21	0:0	6	=
call	130:23	130:40	7	AV_RB24
arg	130:31	130:40	8	p-trailer
water	130:31	0:0	9	p
op	130:32	0:0	9	-
water	130:33	0:0	9	trailer
if	131:12	132:21	6	(size + trailer > p - c -> bytestream_start)
cond	131:16	131:40	7	size + trailer > p - c -> bytestream_start
water	131:16	0:0	8	size
op	131:21	0:0	8	+
water	131:23	0:0	8	trailer
op	131:31	0:0	8	>
water	131:33	0:0	8	p
op	131:35	0:0	8	-
water	131:37	0:0	8	c
op	131:38	0:0	8	->
water	131:40	0:0	8	bytestream_start
stmts	132:16	132:21	7	
break	132:16	132:21	8	
water	133:12	0:0	6	p
op	133:14	0:0	6	-=
water	133:17	0:0	6	size
op	133:22	0:0	6	+
water	133:24	0:0	6	trailer
water	133:31	0:0	6	;
water	134:8	0:0	6	}
water	135:4	0:0	4	}
if	136:4	139:4	2	(f -> slice_count > ( unsigned ) MAX_SLICES || f -> slice_count <= 0)
cond	136:8	136:67	3	f -> slice_count > ( unsigned ) MAX_SLICES || f -> slice_count <= 0
water	136:8	0:0	4	f
op	136:9	0:0	4	->
water	136:11	0:0	4	slice_count
op	136:23	0:0	4	>
water	136:25	0:0	4	(
water	136:26	0:0	4	unsigned
water	136:34	0:0	4	)
water	136:35	0:0	4	MAX_SLICES
op	136:46	0:0	4	||
water	136:49	0:0	4	f
op	136:50	0:0	4	->
water	136:52	0:0	4	slice_count
op	136:64	0:0	4	<=
water	136:67	0:0	4	0
stmts	136:70	139:4	3	
water	136:70	0:0	4	{
call	137:8	137:84	4	av_log
arg	137:15	137:23	5	f->avctx
water	137:15	0:0	6	f
op	137:16	0:0	6	->
water	137:18	0:0	6	avctx
arg	137:25	137:37	5	AV_LOG_ERROR
water	137:25	0:0	6	AV_LOG_ERROR
arg	137:39	137:68	5	"slice count %d is invalid\n"
water	137:39	0:0	6	"slice count %d is invalid\n"
arg	137:70	137:84	5	f->slice_count
water	137:70	0:0	6	f
op	137:71	0:0	6	->
water	137:73	0:0	6	slice_count
water	137:85	0:0	4	;
return	138:8	138:34	4	AVERROR_INVALIDDATA
water	138:15	0:0	5	AVERROR_INVALIDDATA
water	139:4	0:0	4	}
for	141:4	193:4	2	(j = 0 ;j < f -> slice_count;j ++)
forinit	141:9	141:14	3	j = 0 ;
water	141:9	0:0	4	j
op	141:11	0:0	4	=
water	141:13	0:0	4	0
water	141:14	0:0	4	;
cond	141:16	141:23	3	j < f -> slice_count
water	141:16	0:0	4	j
op	141:18	0:0	4	<
water	141:20	0:0	4	f
op	141:21	0:0	4	->
water	141:23	0:0	4	slice_count
forexpr	141:36	141:37	3	j ++
water	141:36	0:0	4	j
op	141:37	0:0	4	++
stmts	141:41	193:4	3	
water	141:41	0:0	4	{
decl	142:8	142:45	4	FFV1Context	*fs
op	142:24	0:0	4	=
water	142:26	0:0	4	f
op	142:27	0:0	4	->
water	142:29	0:0	4	slice_context
op	142:42	0:0	4	[
water	142:43	0:0	4	j
op	142:44	0:0	4	]
water	143:8	0:0	4	fs
op	143:10	0:0	4	->
water	143:12	0:0	4	ac
op	143:26	0:0	4	=
water	143:28	0:0	4	f
op	143:29	0:0	4	->
water	143:31	0:0	4	ac
water	143:33	0:0	4	;
water	144:8	0:0	4	fs
op	144:10	0:0	4	->
water	144:12	0:0	4	packed_at_lsb
op	144:26	0:0	4	=
water	144:28	0:0	4	f
op	144:29	0:0	4	->
water	144:31	0:0	4	packed_at_lsb
water	144:44	0:0	4	;
water	146:8	0:0	4	fs
op	146:10	0:0	4	->
water	146:12	0:0	4	slice_damaged
op	146:26	0:0	4	=
water	146:28	0:0	4	0
water	146:29	0:0	4	;
if	148:8	164:8	4	(f -> version == 2)
cond	148:12	148:26	5	f -> version == 2
water	148:12	0:0	6	f
op	148:13	0:0	6	->
water	148:15	0:0	6	version
op	148:23	0:0	6	==
water	148:26	0:0	6	2
stmts	148:29	164:8	5	
water	148:29	0:0	6	{
water	149:12	0:0	6	fs
op	149:14	0:0	6	->
water	149:16	0:0	6	slice_x
op	149:29	0:0	6	=
call	149:32	149:54	6	get_symbol
arg	149:43	149:44	7	c
water	149:43	0:0	8	c
arg	149:46	149:51	7	state
water	149:46	0:0	8	state
arg	149:53	149:54	7	0
water	149:53	0:0	8	0
op	149:61	0:0	6	*
water	149:63	0:0	6	f
op	149:64	0:0	6	->
water	149:66	0:0	6	width
water	149:72	0:0	6	;
water	150:12	0:0	6	fs
op	150:14	0:0	6	->
water	150:16	0:0	6	slice_y
op	150:29	0:0	6	=
call	150:32	150:54	6	get_symbol
arg	150:43	150:44	7	c
water	150:43	0:0	8	c
arg	150:46	150:51	7	state
water	150:46	0:0	8	state
arg	150:53	150:54	7	0
water	150:53	0:0	8	0
op	150:61	0:0	6	*
water	150:63	0:0	6	f
op	150:64	0:0	6	->
water	150:66	0:0	6	height
water	150:72	0:0	6	;
water	151:12	0:0	6	fs
op	151:14	0:0	6	->
water	151:16	0:0	6	slice_width
op	151:29	0:0	6	=
water	151:31	0:0	6	(
call	151:32	151:54	6	get_symbol
arg	151:43	151:44	7	c
water	151:43	0:0	8	c
arg	151:46	151:51	7	state
water	151:46	0:0	8	state
arg	151:53	151:54	7	0
water	151:53	0:0	8	0
op	151:56	0:0	6	+
water	151:58	0:0	6	1
water	151:59	0:0	6	)
op	151:61	0:0	6	*
water	151:63	0:0	6	f
op	151:64	0:0	6	->
water	151:66	0:0	6	width
op	151:73	0:0	6	+
water	151:75	0:0	6	fs
op	151:77	0:0	6	->
water	151:79	0:0	6	slice_x
water	151:86	0:0	6	;
water	152:12	0:0	6	fs
op	152:14	0:0	6	->
water	152:16	0:0	6	slice_height
op	152:29	0:0	6	=
water	152:31	0:0	6	(
call	152:32	152:54	6	get_symbol
arg	152:43	152:44	7	c
water	152:43	0:0	8	c
arg	152:46	152:51	7	state
water	152:46	0:0	8	state
arg	152:53	152:54	7	0
water	152:53	0:0	8	0
op	152:56	0:0	6	+
water	152:58	0:0	6	1
water	152:59	0:0	6	)
op	152:61	0:0	6	*
water	152:63	0:0	6	f
op	152:64	0:0	6	->
water	152:66	0:0	6	height
op	152:73	0:0	6	+
water	152:75	0:0	6	fs
op	152:77	0:0	6	->
water	152:79	0:0	6	slice_y
water	152:86	0:0	6	;
water	154:12	0:0	6	fs
op	154:14	0:0	6	->
water	154:16	0:0	6	slice_x
op	154:28	0:0	6	/=
water	154:31	0:0	6	f
op	154:32	0:0	6	->
water	154:34	0:0	6	num_h_slices
water	154:46	0:0	6	;
water	155:12	0:0	6	fs
op	155:14	0:0	6	->
water	155:16	0:0	6	slice_y
op	155:28	0:0	6	/=
water	155:31	0:0	6	f
op	155:32	0:0	6	->
water	155:34	0:0	6	num_v_slices
water	155:46	0:0	6	;
water	156:12	0:0	6	fs
op	156:14	0:0	6	->
water	156:16	0:0	6	slice_width
op	156:29	0:0	6	=
water	156:31	0:0	6	fs
op	156:33	0:0	6	->
water	156:35	0:0	6	slice_width
op	156:48	0:0	6	/
water	156:50	0:0	6	f
op	156:51	0:0	6	->
water	156:53	0:0	6	num_h_slices
op	156:66	0:0	6	-
water	156:68	0:0	6	fs
op	156:70	0:0	6	->
water	156:72	0:0	6	slice_x
water	156:79	0:0	6	;
water	157:12	0:0	6	fs
op	157:14	0:0	6	->
water	157:16	0:0	6	slice_height
op	157:29	0:0	6	=
water	157:31	0:0	6	fs
op	157:33	0:0	6	->
water	157:35	0:0	6	slice_height
op	157:48	0:0	6	/
water	157:50	0:0	6	f
op	157:51	0:0	6	->
water	157:53	0:0	6	num_v_slices
op	157:66	0:0	6	-
water	157:68	0:0	6	fs
op	157:70	0:0	6	->
water	157:72	0:0	6	slice_y
water	157:79	0:0	6	;
if	158:12	160:42	6	(( unsigned ) fs -> slice_width > f -> width || ( unsigned ) fs -> slice_height > f -> height)
cond	158:16	159:48	7	( unsigned ) fs -> slice_width > f -> width || ( unsigned ) fs -> slice_height > f -> height
water	158:16	0:0	8	(
water	158:17	0:0	8	unsigned
water	158:25	0:0	8	)
water	158:26	0:0	8	fs
op	158:28	0:0	8	->
water	158:30	0:0	8	slice_width
op	158:43	0:0	8	>
water	158:45	0:0	8	f
op	158:46	0:0	8	->
water	158:48	0:0	8	width
op	158:54	0:0	8	||
water	159:16	0:0	8	(
water	159:17	0:0	8	unsigned
water	159:25	0:0	8	)
water	159:26	0:0	8	fs
op	159:28	0:0	8	->
water	159:30	0:0	8	slice_height
op	159:43	0:0	8	>
water	159:45	0:0	8	f
op	159:46	0:0	8	->
water	159:48	0:0	8	height
stmts	160:16	160:42	7	
return	160:16	160:42	8	AVERROR_INVALIDDATA
water	160:23	0:0	9	AVERROR_INVALIDDATA
if	161:12	163:42	6	(( unsigned ) fs -> slice_x + ( uint64_t ) fs -> slice_width > f -> width || ( unsigned ) fs -> slice_y + ( uint64_t ) fs -> slice_height > f -> height)
cond	161:19	162:75	7	( unsigned ) fs -> slice_x + ( uint64_t ) fs -> slice_width > f -> width || ( unsigned ) fs -> slice_y + ( uint64_t ) fs -> slice_height > f -> height
water	161:19	0:0	8	(
water	161:20	0:0	8	unsigned
water	161:28	0:0	8	)
water	161:29	0:0	8	fs
op	161:31	0:0	8	->
water	161:33	0:0	8	slice_x
op	161:41	0:0	8	+
water	161:43	0:0	8	(
water	161:44	0:0	8	uint64_t
water	161:52	0:0	8	)
water	161:53	0:0	8	fs
op	161:55	0:0	8	->
water	161:57	0:0	8	slice_width
op	161:70	0:0	8	>
water	161:72	0:0	8	f
op	161:73	0:0	8	->
water	161:75	0:0	8	width
op	162:16	0:0	8	||
water	162:19	0:0	8	(
water	162:20	0:0	8	unsigned
water	162:28	0:0	8	)
water	162:29	0:0	8	fs
op	162:31	0:0	8	->
water	162:33	0:0	8	slice_y
op	162:41	0:0	8	+
water	162:43	0:0	8	(
water	162:44	0:0	8	uint64_t
water	162:52	0:0	8	)
water	162:53	0:0	8	fs
op	162:55	0:0	8	->
water	162:57	0:0	8	slice_height
op	162:70	0:0	8	>
water	162:72	0:0	8	f
op	162:73	0:0	8	->
water	162:75	0:0	8	height
stmts	163:16	163:42	7	
return	163:16	163:42	8	AVERROR_INVALIDDATA
water	163:23	0:0	9	AVERROR_INVALIDDATA
water	164:8	0:0	6	}
for	166:8	192:8	4	(i = 0 ;i < f -> plane_count;i ++)
forinit	166:13	166:18	5	i = 0 ;
water	166:13	0:0	6	i
op	166:15	0:0	6	=
water	166:17	0:0	6	0
water	166:18	0:0	6	;
cond	166:20	166:27	5	i < f -> plane_count
water	166:20	0:0	6	i
op	166:22	0:0	6	<
water	166:24	0:0	6	f
op	166:25	0:0	6	->
water	166:27	0:0	6	plane_count
forexpr	166:40	166:41	5	i ++
water	166:40	0:0	6	i
op	166:41	0:0	6	++
stmts	166:45	192:8	5	
water	166:45	0:0	6	{
water	167:12	0:0	6	PlaneContext
op	167:25	0:0	6	*
water	167:26	0:0	6	const
water	167:32	0:0	6	p
op	167:34	0:0	6	=
op	167:36	0:0	6	&
water	167:37	0:0	6	fs
op	167:39	0:0	6	->
water	167:41	0:0	6	plane
op	167:46	0:0	6	[
water	167:47	0:0	6	i
op	167:48	0:0	6	]
water	167:49	0:0	6	;
if	169:12	180:12	6	(f -> version == 2)
cond	169:16	169:30	7	f -> version == 2
water	169:16	0:0	8	f
op	169:17	0:0	8	->
water	169:19	0:0	8	version
op	169:27	0:0	8	==
water	169:30	0:0	8	2
stmts	169:33	180:12	7	
water	169:33	0:0	8	{
decl	170:16	170:49	8	int	idx
op	170:24	0:0	8	=
call	170:26	170:48	9	get_symbol
arg	170:37	170:38	10	c
water	170:37	0:0	11	c
arg	170:40	170:45	10	state
water	170:40	0:0	11	state
arg	170:47	170:48	10	0
water	170:47	0:0	11	0
if	171:16	175:16	8	(idx > ( unsigned ) f -> quant_table_count)
cond	171:20	171:39	9	idx > ( unsigned ) f -> quant_table_count
water	171:20	0:0	10	idx
op	171:24	0:0	10	>
water	171:26	0:0	10	(
water	171:27	0:0	10	unsigned
water	171:35	0:0	10	)
water	171:36	0:0	10	f
op	171:37	0:0	10	->
water	171:39	0:0	10	quant_table_count
stmts	171:58	175:16	9	
water	171:58	0:0	10	{
call	172:20	173:61	10	av_log
arg	172:27	172:35	11	f->avctx
water	172:27	0:0	12	f
op	172:28	0:0	12	->
water	172:30	0:0	12	avctx
arg	172:37	172:49	11	AV_LOG_ERROR
water	172:37	0:0	12	AV_LOG_ERROR
arg	173:27	173:61	11	"quant_table_index out of range\n"
water	173:27	0:0	12	"quant_table_index out of range\n"
water	173:62	0:0	10	;
return	174:20	174:46	10	AVERROR_INVALIDDATA
water	174:27	0:0	11	AVERROR_INVALIDDATA
water	175:16	0:0	10	}
water	176:16	0:0	8	p
op	176:17	0:0	8	->
water	176:19	0:0	8	quant_table_index
op	176:37	0:0	8	=
water	176:39	0:0	8	idx
water	176:42	0:0	8	;
call	177:16	178:45	8	memcpy
arg	177:23	177:37	9	p->quant_table
water	177:23	0:0	10	p
op	177:24	0:0	10	->
water	177:26	0:0	10	quant_table
arg	177:39	177:59	9	f->quant_tables[idx]
water	177:39	0:0	10	f
op	177:40	0:0	10	->
water	177:42	0:0	10	quant_tables
op	177:54	0:0	10	[
water	177:55	0:0	10	idx
op	177:58	0:0	10	]
arg	178:23	178:45	9	sizeof(p->quant_table)
op	178:23	0:0	10	sizeof
water	178:29	0:0	10	(
water	178:30	0:0	10	p
op	178:31	0:0	10	->
water	178:33	0:0	10	quant_table
water	178:44	0:0	10	)
water	178:46	0:0	8	;
water	179:16	0:0	8	context_count
op	179:30	0:0	8	=
water	179:32	0:0	8	f
op	179:33	0:0	8	->
water	179:35	0:0	8	context_count
op	179:48	0:0	8	[
water	179:49	0:0	8	idx
op	179:52	0:0	8	]
water	179:53	0:0	8	;
water	180:12	0:0	8	}
else	180:14	182:12	6
stmts	180:19	182:12	7	
water	180:19	0:0	8	{
call	181:16	181:77	8	memcpy
arg	181:23	181:37	9	p->quant_table
water	181:23	0:0	10	p
op	181:24	0:0	10	->
water	181:26	0:0	10	quant_table
arg	181:39	181:53	9	f->quant_table
water	181:39	0:0	10	f
op	181:40	0:0	10	->
water	181:42	0:0	10	quant_table
arg	181:55	181:77	9	sizeof(p->quant_table)
op	181:55	0:0	10	sizeof
water	181:61	0:0	10	(
water	181:62	0:0	10	p
op	181:63	0:0	10	->
water	181:65	0:0	10	quant_table
water	181:76	0:0	10	)
water	181:78	0:0	8	;
water	182:12	0:0	8	}
if	184:12	191:12	6	(f -> version <= 2)
cond	184:16	184:30	7	f -> version <= 2
water	184:16	0:0	8	f
op	184:17	0:0	8	->
water	184:19	0:0	8	version
op	184:27	0:0	8	<=
water	184:30	0:0	8	2
stmts	184:33	191:12	7	
water	184:33	0:0	8	{
call	185:16	185:45	8	av_assert0
arg	185:27	185:45	9	context_count>=0
water	185:27	0:0	10	context_count
op	185:41	0:0	10	>=
water	185:44	0:0	10	0
water	185:46	0:0	8	;
if	186:16	189:16	8	(p -> context_count < context_count)
cond	186:20	186:39	9	p -> context_count < context_count
water	186:20	0:0	10	p
op	186:21	0:0	10	->
water	186:23	0:0	10	context_count
op	186:37	0:0	10	<
water	186:39	0:0	10	context_count
stmts	186:54	189:16	9	
water	186:54	0:0	10	{
call	187:20	187:38	10	av_freep
arg	187:29	187:38	11	&p->state
op	187:29	0:0	12	&
water	187:30	0:0	12	p
op	187:31	0:0	12	->
water	187:33	0:0	12	state
water	187:39	0:0	10	;
call	188:20	188:42	10	av_freep
arg	188:29	188:42	11	&p->vlc_state
op	188:29	0:0	12	&
water	188:30	0:0	12	p
op	188:31	0:0	12	->
water	188:33	0:0	12	vlc_state
water	188:43	0:0	10	;
water	189:16	0:0	10	}
water	190:16	0:0	8	p
op	190:17	0:0	8	->
water	190:19	0:0	8	context_count
op	190:33	0:0	8	=
water	190:35	0:0	8	context_count
water	190:48	0:0	8	;
water	191:12	0:0	8	}
water	192:8	0:0	6	}
water	193:4	0:0	4	}
return	194:4	194:12	2	0
water	194:11	0:0	3	0
