func	2:0	73:0	0	int	av_probe_input_buffer
params	2:25	0:0	1	
param	2:26	2:41	2	AVIOContext *	pb
param	2:43	2:62	2	AVInputFormat * *	fmt
param	3:26	3:46	2	const char *	filename
param	3:48	3:60	2	void *	logctx
param	4:26	4:45	2	unsigned int	offset
param	4:47	4:74	2	unsigned int	max_probe_size
stmnts	0:0	72:14	1	
decl	6:4	6:64	2	AVProbeData	pd
op	6:19	0:0	2	=
water	6:21	0:0	2	{
water	6:23	0:0	2	filename
water	6:32	0:0	2	?
water	6:34	0:0	2	filename
water	6:43	0:0	2	:
water	6:45	0:0	2	""
water	6:47	0:0	2	,
water	6:49	0:0	2	NULL
water	6:53	0:0	2	,
op	6:55	0:0	2	-
water	6:56	0:0	2	offset
water	6:63	0:0	2	}
decl	7:4	7:29	2	unsigned char	*buf
op	7:23	0:0	2	=
water	7:25	0:0	2	NULL
decl	8:4	8:43	2	int	ret
op	8:12	0:0	2	=
water	8:14	0:0	2	0
water	8:15	0:0	2	,
decl	8:4	8:43	2	int	probe_size
water	8:27	0:0	2	,
decl	8:4	8:43	2	int	buf_offset
op	8:40	0:0	2	=
water	8:42	0:0	2	0
if	10:4	12:4	2	(! max_probe_size)
cond	10:8	10:9	3	! max_probe_size
op	10:8	0:0	4	!
water	10:9	0:0	4	max_probe_size
stmts	10:25	12:4	3	
water	10:25	0:0	4	{
water	11:8	0:0	4	max_probe_size
op	11:23	0:0	4	=
water	11:25	0:0	4	PROBE_BUF_MAX
water	11:38	0:0	4	;
water	12:4	0:0	4	}
else	12:6	14:4	2
stmts	12:11	14:4	3	
if	12:11	14:4	4	(max_probe_size > PROBE_BUF_MAX)
cond	12:15	12:32	5	max_probe_size > PROBE_BUF_MAX
water	12:15	0:0	6	max_probe_size
op	12:30	0:0	6	>
water	12:32	0:0	6	PROBE_BUF_MAX
stmts	12:47	14:4	5	
water	12:47	0:0	6	{
water	13:8	0:0	6	max_probe_size
op	13:23	0:0	6	=
water	13:25	0:0	6	PROBE_BUF_MAX
water	13:38	0:0	6	;
water	14:4	0:0	6	}
else	14:6	16:4	2
stmts	14:11	16:4	3	
if	14:11	16:4	4	(max_probe_size < PROBE_BUF_MIN)
cond	14:15	14:32	5	max_probe_size < PROBE_BUF_MIN
water	14:15	0:0	6	max_probe_size
op	14:30	0:0	6	<
water	14:32	0:0	6	PROBE_BUF_MIN
stmts	14:47	16:4	5	
water	14:47	0:0	6	{
return	15:8	15:30	6	AVERROR(EINVAL)
call	15:15	15:29	7	AVERROR
arg	15:23	15:29	8	EINVAL
water	15:23	0:0	9	EINVAL
water	16:4	0:0	6	}
if	18:4	20:4	2	(offset >= max_probe_size)
cond	18:8	18:18	3	offset >= max_probe_size
water	18:8	0:0	4	offset
op	18:15	0:0	4	>=
water	18:18	0:0	4	max_probe_size
stmts	18:34	20:4	3	
water	18:34	0:0	4	{
return	19:8	19:30	4	AVERROR(EINVAL)
call	19:15	19:29	5	AVERROR
arg	19:23	19:29	6	EINVAL
water	19:23	0:0	7	EINVAL
water	20:4	0:0	4	}
for	22:4	61:4	2	(probe_size = PROBE_BUF_MIN ;probe_size <= max_probe_size && ! * fmt;probe_size =FFMIN (probe_size << 1 ,FFMAX (max_probe_size ,probe_size + 1 ) ))
forinit	22:8	22:33	3	probe_size = PROBE_BUF_MIN ;
water	22:8	0:0	4	probe_size
op	22:18	0:0	4	=
water	22:20	0:0	4	PROBE_BUF_MIN
water	22:33	0:0	4	;
cond	22:35	22:67	3	probe_size <= max_probe_size && ! * fmt
water	22:35	0:0	4	probe_size
op	22:45	0:0	4	<=
water	22:47	0:0	4	max_probe_size
op	22:62	0:0	4	&&
op	22:65	0:0	4	!
op	22:66	0:0	4	*
water	22:67	0:0	4	fmt
forexpr	23:8	23:77	3	probe_size =FFMIN (probe_size << 1 ,FFMAX (max_probe_size ,probe_size + 1 ) )
water	23:8	0:0	4	probe_size
op	23:19	0:0	4	=
call	23:21	23:77	4	FFMIN
arg	23:27	23:40	5	probe_size<<1
water	23:27	0:0	6	probe_size
op	23:37	0:0	6	<<
water	23:39	0:0	6	1
arg	23:42	23:77	5	FFMAX(max_probe_size,probe_size+1)
call	23:42	23:76	6	FFMAX
arg	23:48	23:62	7	max_probe_size
water	23:48	0:0	8	max_probe_size
arg	23:64	23:76	7	probe_size+1
water	23:64	0:0	8	probe_size
op	23:74	0:0	8	+
water	23:75	0:0	8	1
stmts	23:80	61:4	3	
water	23:80	0:0	4	{
decl	24:8	24:73	4	int	score
op	24:18	0:0	4	=
water	24:20	0:0	4	probe_size
op	24:31	0:0	4	<
water	24:33	0:0	4	max_probe_size
water	24:48	0:0	4	?
water	24:50	0:0	4	AVPROBE_SCORE_MAX
op	24:67	0:0	4	/
water	24:68	0:0	4	4
water	24:70	0:0	4	:
water	24:72	0:0	4	0
decl	25:8	25:74	4	int	buf_offset
op	25:23	0:0	4	=
water	25:25	0:0	4	(
water	25:26	0:0	4	probe_size
op	25:37	0:0	4	==
water	25:40	0:0	4	PROBE_BUF_MIN
water	25:53	0:0	4	)
water	25:55	0:0	4	?
water	25:57	0:0	4	0
water	25:59	0:0	4	:
water	25:61	0:0	4	probe_size
op	25:71	0:0	4	>>
water	25:73	0:0	4	1
decl	26:8	26:20	4	void	*buftmp
if	28:8	30:8	4	(probe_size < offset)
cond	28:12	28:25	5	probe_size < offset
water	28:12	0:0	6	probe_size
op	28:23	0:0	6	<
water	28:25	0:0	6	offset
stmts	28:33	30:8	5	
water	28:33	0:0	6	{
continue	29:12	29:20	6	
water	30:8	0:0	6	}
water	33:8	0:0	4	buftmp
op	33:15	0:0	4	=
call	33:17	33:66	4	av_realloc
arg	33:28	33:31	5	buf
water	33:28	0:0	6	buf
arg	33:33	33:66	5	probe_size+AVPROBE_PADDING_SIZE
water	33:33	0:0	6	probe_size
op	33:44	0:0	6	+
water	33:46	0:0	6	AVPROBE_PADDING_SIZE
water	33:67	0:0	4	;
if	34:8	37:8	4	(! buftmp)
cond	34:11	34:12	5	! buftmp
op	34:11	0:0	6	!
water	34:12	0:0	6	buftmp
stmts	34:19	37:8	5	
water	34:19	0:0	6	{
call	35:12	35:23	6	av_free
arg	35:20	35:23	7	buf
water	35:20	0:0	8	buf
water	35:24	0:0	6	;
return	36:12	36:34	6	AVERROR(ENOMEM)
call	36:19	36:33	7	AVERROR
arg	36:27	36:33	8	ENOMEM
water	36:27	0:0	9	ENOMEM
water	37:8	0:0	6	}
water	38:8	0:0	4	buf
op	38:11	0:0	4	=
water	38:12	0:0	4	buftmp
water	38:18	0:0	4	;
if	39:8	47:8	4	(( ret =avio_read (pb ,buf + buf_offset ,probe_size - buf_offset ) ) < 0)
cond	39:12	39:79	5	( ret =avio_read (pb ,buf + buf_offset ,probe_size - buf_offset ) ) < 0
water	39:12	0:0	6	(
water	39:13	0:0	6	ret
op	39:17	0:0	6	=
call	39:19	39:74	6	avio_read
arg	39:29	39:31	7	pb
water	39:29	0:0	8	pb
arg	39:33	39:49	7	buf+buf_offset
water	39:33	0:0	8	buf
op	39:37	0:0	8	+
water	39:39	0:0	8	buf_offset
arg	39:51	39:74	7	probe_size-buf_offset
water	39:51	0:0	8	probe_size
op	39:62	0:0	8	-
water	39:64	0:0	8	buf_offset
water	39:75	0:0	6	)
op	39:77	0:0	6	<
water	39:79	0:0	6	0
stmts	39:82	47:8	5	
water	39:82	0:0	6	{
if	41:12	44:12	6	(ret != AVERROR_EOF)
cond	41:16	41:23	7	ret != AVERROR_EOF
water	41:16	0:0	8	ret
op	41:20	0:0	8	!=
water	41:23	0:0	8	AVERROR_EOF
stmts	41:36	44:12	7	
water	41:36	0:0	8	{
call	42:16	42:27	8	av_free
arg	42:24	42:27	9	buf
water	42:24	0:0	10	buf
water	42:28	0:0	8	;
return	43:16	43:26	8	ret
water	43:23	0:0	9	ret
water	44:12	0:0	8	}
water	45:12	0:0	6	score
op	45:18	0:0	6	=
water	45:20	0:0	6	0
water	45:21	0:0	6	;
water	46:12	0:0	6	ret
op	46:16	0:0	6	=
water	46:18	0:0	6	0
water	46:19	0:0	6	;
water	47:8	0:0	6	}
water	48:8	0:0	4	pd
op	48:10	0:0	4	.
water	48:11	0:0	4	buf_size
op	48:20	0:0	4	=
water	48:22	0:0	4	buf_offset
op	48:33	0:0	4	+=
water	48:36	0:0	4	ret
water	48:39	0:0	4	;
water	49:8	0:0	4	pd
op	49:10	0:0	4	.
water	49:11	0:0	4	buf
op	49:15	0:0	4	=
op	49:17	0:0	4	&
water	49:18	0:0	4	buf
op	49:21	0:0	4	[
water	49:22	0:0	4	offset
op	49:28	0:0	4	]
water	49:29	0:0	4	;
call	51:8	51:60	4	memset
arg	51:15	51:35	5	pd.buf+pd.buf_size
water	51:15	0:0	6	pd
op	51:17	0:0	6	.
water	51:18	0:0	6	buf
op	51:22	0:0	6	+
water	51:24	0:0	6	pd
op	51:26	0:0	6	.
water	51:27	0:0	6	buf_size
arg	51:37	51:38	5	0
water	51:37	0:0	6	0
arg	51:40	51:60	5	AVPROBE_PADDING_SIZE
water	51:40	0:0	6	AVPROBE_PADDING_SIZE
water	51:61	0:0	4	;
op	54:8	0:0	4	*
water	54:9	0:0	4	fmt
op	54:13	0:0	4	=
call	54:15	54:52	4	av_probe_input_format2
arg	54:38	54:41	5	&pd
op	54:38	0:0	6	&
water	54:39	0:0	6	pd
arg	54:43	54:44	5	1
water	54:43	0:0	6	1
arg	54:46	54:52	5	&score
op	54:46	0:0	6	&
water	54:47	0:0	6	score
water	54:53	0:0	4	;
if	55:8	60:8	4	(* fmt)
cond	55:11	55:12	5	* fmt
op	55:11	0:0	6	*
water	55:12	0:0	6	fmt
stmts	55:16	60:8	5	
water	55:16	0:0	6	{
if	56:12	58:12	6	(score <= AVPROBE_SCORE_MAX / 4)
cond	56:15	56:42	7	score <= AVPROBE_SCORE_MAX / 4
water	56:15	0:0	8	score
op	56:21	0:0	8	<=
water	56:24	0:0	8	AVPROBE_SCORE_MAX
op	56:41	0:0	8	/
water	56:42	0:0	8	4
stmts	56:44	58:12	7	
water	56:44	0:0	8	{
call	57:16	57:140	8	av_log
arg	57:23	57:29	9	logctx
water	57:23	0:0	10	logctx
arg	57:31	57:45	9	AV_LOG_WARNING
water	57:31	0:0	10	AV_LOG_WARNING
arg	57:47	57:119	9	"Format %s detected only with low score of %d, misdetection possible!\n"
water	57:47	0:0	10	"Format %s detected only with low score of %d, misdetection possible!\n"
arg	57:121	57:133	9	(*fmt)->name
water	57:121	0:0	10	(
op	57:122	0:0	10	*
water	57:123	0:0	10	fmt
water	57:126	0:0	10	)
op	57:127	0:0	10	->
water	57:129	0:0	10	name
arg	57:135	57:140	9	score
water	57:135	0:0	10	score
water	57:141	0:0	8	;
water	58:12	0:0	8	}
else	58:13	59:125	6
stmts	59:16	59:125	7	
call	59:16	59:124	8	av_log
arg	59:23	59:29	9	logctx
water	59:23	0:0	10	logctx
arg	59:31	59:43	9	AV_LOG_DEBUG
water	59:31	0:0	10	AV_LOG_DEBUG
arg	59:45	59:91	9	"Format %s probed with size=%d and score=%d\n"
water	59:45	0:0	10	"Format %s probed with size=%d and score=%d\n"
arg	59:93	59:105	9	(*fmt)->name
water	59:93	0:0	10	(
op	59:94	0:0	10	*
water	59:95	0:0	10	fmt
water	59:98	0:0	10	)
op	59:99	0:0	10	->
water	59:101	0:0	10	name
arg	59:107	59:117	9	probe_size
water	59:107	0:0	10	probe_size
arg	59:119	59:124	9	score
water	59:119	0:0	10	score
water	59:125	0:0	8	;
water	60:8	0:0	6	}
water	61:4	0:0	4	}
if	63:4	66:4	2	(! * fmt)
cond	63:8	63:10	3	! * fmt
op	63:8	0:0	4	!
op	63:9	0:0	4	*
water	63:10	0:0	4	fmt
stmts	63:15	66:4	3	
water	63:15	0:0	4	{
call	64:8	64:19	4	av_free
arg	64:16	64:19	5	buf
water	64:16	0:0	6	buf
water	64:20	0:0	4	;
return	65:8	65:34	4	AVERROR_INVALIDDATA
water	65:15	0:0	5	AVERROR_INVALIDDATA
water	66:4	0:0	4	}
if	69:4	70:20	2	(( ret =ffio_rewind_with_probe_data (pb ,buf ,pd . buf_size ) ) < 0)
cond	69:8	69:68	3	( ret =ffio_rewind_with_probe_data (pb ,buf ,pd . buf_size ) ) < 0
water	69:8	0:0	4	(
water	69:9	0:0	4	ret
op	69:13	0:0	4	=
call	69:15	69:63	4	ffio_rewind_with_probe_data
arg	69:43	69:45	5	pb
water	69:43	0:0	6	pb
arg	69:47	69:50	5	buf
water	69:47	0:0	6	buf
arg	69:52	69:63	5	pd.buf_size
water	69:52	0:0	6	pd
op	69:54	0:0	6	.
water	69:55	0:0	6	buf_size
water	69:64	0:0	4	)
op	69:66	0:0	4	<
water	69:68	0:0	4	0
stmts	70:8	70:20	3	
call	70:8	70:19	4	av_free
arg	70:16	70:19	5	buf
water	70:16	0:0	6	buf
water	70:20	0:0	4	;
return	72:4	72:14	2	ret
water	72:11	0:0	3	ret
