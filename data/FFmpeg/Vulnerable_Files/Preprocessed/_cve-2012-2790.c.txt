func	4:0	246:0	0	static int	read_var_block_data
params	4:30	0:0	1	
param	4:31	4:49	2	ALSDecContext *	ctx
param	4:51	4:67	2	ALSBlockData *	bd
stmnts	0:0	245:12	1	
decl	6:4	6:42	2	ALSSpecificConfig	*sconf
op	6:29	0:0	2	=
op	6:31	0:0	2	&
water	6:32	0:0	2	ctx
op	6:35	0:0	2	->
water	6:37	0:0	2	sconf
decl	7:4	7:41	2	AVCodecContext	*avctx
op	7:29	0:0	2	=
water	7:31	0:0	2	ctx
op	7:34	0:0	2	->
water	7:36	0:0	2	avctx
decl	8:4	8:39	2	GetBitContext	*gb
op	8:29	0:0	2	=
op	8:31	0:0	2	&
water	8:32	0:0	2	ctx
op	8:35	0:0	2	->
water	8:37	0:0	2	gb
decl	9:4	9:18	2	unsigned int	k
decl	10:4	10:21	2	unsigned int	s[8]
decl	11:4	11:22	2	unsigned int	sx[8]
decl	12:4	12:55	2	unsigned int	sub_blocks
water	12:27	0:0	2	,
decl	12:4	12:55	2	unsigned int	log2_sub_blocks
water	12:44	0:0	2	,
decl	12:4	12:55	2	unsigned int	sb_length
decl	13:4	13:31	2	unsigned int	start
op	13:28	0:0	2	=
water	13:30	0:0	2	0
decl	14:4	14:26	2	unsigned int	opt_order
decl	15:4	15:19	2	int	sb
decl	16:4	16:43	2	int32_t	*quant_cof
op	16:28	0:0	2	=
water	16:30	0:0	2	bd
op	16:32	0:0	2	->
water	16:34	0:0	2	quant_cof
decl	17:4	17:29	2	int32_t	*current_res
op	21:4	0:0	2	*
water	21:5	0:0	2	bd
op	21:7	0:0	2	->
water	21:9	0:0	2	const_block
op	21:21	0:0	2	=
water	21:23	0:0	2	0
water	21:24	0:0	2	;
op	23:4	0:0	2	*
water	23:5	0:0	2	bd
op	23:7	0:0	2	->
water	23:9	0:0	2	opt_order
op	23:20	0:0	2	=
water	23:22	0:0	2	1
water	23:23	0:0	2	;
water	24:4	0:0	2	bd
op	24:6	0:0	2	->
water	24:8	0:0	2	js_blocks
op	24:20	0:0	2	=
call	24:22	24:34	2	get_bits1
arg	24:32	24:34	3	gb
water	24:32	0:0	4	gb
water	24:35	0:0	2	;
water	26:4	0:0	2	opt_order
op	26:20	0:0	2	=
op	26:22	0:0	2	*
water	26:23	0:0	2	bd
op	26:25	0:0	2	->
water	26:27	0:0	2	opt_order
water	26:36	0:0	2	;
if	29:4	31:4	2	(! sconf -> bgmc && ! sconf -> sb_part)
cond	29:8	29:32	3	! sconf -> bgmc && ! sconf -> sb_part
op	29:8	0:0	4	!
water	29:9	0:0	4	sconf
op	29:14	0:0	4	->
water	29:16	0:0	4	bgmc
op	29:21	0:0	4	&&
op	29:24	0:0	4	!
water	29:25	0:0	4	sconf
op	29:30	0:0	4	->
water	29:32	0:0	4	sb_part
stmts	29:41	31:4	3	
water	29:41	0:0	4	{
water	30:8	0:0	4	log2_sub_blocks
op	30:24	0:0	4	=
water	30:26	0:0	4	0
water	30:27	0:0	4	;
water	31:4	0:0	4	}
else	31:6	36:4	2
stmts	31:11	36:4	3	
water	31:11	0:0	4	{
if	32:8	33:45	4	(sconf -> bgmc && sconf -> sb_part)
cond	32:12	32:34	5	sconf -> bgmc && sconf -> sb_part
water	32:12	0:0	6	sconf
op	32:17	0:0	6	->
water	32:19	0:0	6	bgmc
op	32:24	0:0	6	&&
water	32:27	0:0	6	sconf
op	32:32	0:0	6	->
water	32:34	0:0	6	sb_part
stmts	33:12	33:45	5	
water	33:12	0:0	6	log2_sub_blocks
op	33:28	0:0	6	=
call	33:30	33:44	6	get_bits
arg	33:39	33:41	7	gb
water	33:39	0:0	8	gb
arg	33:43	33:44	7	2
water	33:43	0:0	8	2
water	33:45	0:0	6	;
else	34:8	35:47	4
stmts	35:12	35:47	5	
water	35:12	0:0	6	log2_sub_blocks
op	35:28	0:0	6	=
water	35:30	0:0	6	2
call	35:32	35:46	6	*get_bits1
arg	35:44	35:46	7	gb
water	35:44	0:0	8	gb
water	35:47	0:0	6	;
water	36:4	0:0	4	}
water	38:4	0:0	2	sub_blocks
op	38:15	0:0	2	=
water	38:17	0:0	2	1
op	38:19	0:0	2	<<
water	38:22	0:0	2	log2_sub_blocks
water	38:37	0:0	2	;
if	42:4	46:4	2	(bd -> block_length & ( sub_blocks - 1 ))
cond	42:8	42:42	3	bd -> block_length & ( sub_blocks - 1 )
water	42:8	0:0	4	bd
op	42:10	0:0	4	->
water	42:12	0:0	4	block_length
op	42:25	0:0	4	&
water	42:27	0:0	4	(
water	42:28	0:0	4	sub_blocks
op	42:39	0:0	4	-
water	42:41	0:0	4	1
water	42:42	0:0	4	)
stmts	42:45	46:4	3	
water	42:45	0:0	4	{
call	43:8	44:83	4	av_log
arg	43:15	43:20	5	avctx
water	43:15	0:0	6	avctx
arg	43:22	43:36	5	AV_LOG_WARNING
water	43:22	0:0	6	AV_LOG_WARNING
arg	44:15	44:83	5	"Block length is not evenly divisible by the number of subblocks.\n"
water	44:15	0:0	6	"Block length is not evenly divisible by the number of subblocks.\n"
water	44:84	0:0	4	;
return	45:8	45:17	4	-1
op	45:15	0:0	5	-
water	45:16	0:0	5	1
water	46:4	0:0	4	}
water	48:4	0:0	2	sb_length
op	48:14	0:0	2	=
water	48:16	0:0	2	bd
op	48:18	0:0	2	->
water	48:20	0:0	2	block_length
op	48:33	0:0	2	>>
water	48:36	0:0	2	log2_sub_blocks
water	48:51	0:0	2	;
if	50:4	59:4	2	(sconf -> bgmc)
cond	50:8	50:15	3	sconf -> bgmc
water	50:8	0:0	4	sconf
op	50:13	0:0	4	->
water	50:15	0:0	4	bgmc
stmts	50:21	59:4	3	
water	50:21	0:0	4	{
water	51:8	0:0	4	s
op	51:9	0:0	4	[
water	51:10	0:0	4	0
op	51:11	0:0	4	]
op	51:13	0:0	4	=
call	51:15	51:55	4	get_bits
arg	51:24	51:26	5	gb
water	51:24	0:0	6	gb
arg	51:28	51:55	5	8+(sconf->resolution>1)
water	51:28	0:0	6	8
op	51:30	0:0	6	+
water	51:32	0:0	6	(
water	51:33	0:0	6	sconf
op	51:38	0:0	6	->
water	51:40	0:0	6	resolution
op	51:51	0:0	6	>
water	51:53	0:0	6	1
water	51:54	0:0	6	)
water	51:56	0:0	4	;
for	52:8	53:48	4	(k = 1 ;k < sub_blocks;k ++)
forinit	52:13	52:18	5	k = 1 ;
water	52:13	0:0	6	k
op	52:15	0:0	6	=
water	52:17	0:0	6	1
water	52:18	0:0	6	;
cond	52:20	52:24	5	k < sub_blocks
water	52:20	0:0	6	k
op	52:22	0:0	6	<
water	52:24	0:0	6	sub_blocks
forexpr	52:36	52:37	5	k ++
water	52:36	0:0	6	k
op	52:37	0:0	6	++
stmts	53:12	53:48	5	
water	53:12	0:0	6	s
op	53:13	0:0	6	[
water	53:14	0:0	6	k
op	53:15	0:0	6	]
op	53:17	0:0	6	=
water	53:19	0:0	6	s
op	53:20	0:0	6	[
water	53:21	0:0	6	k
op	53:23	0:0	6	-
water	53:25	0:0	6	1
op	53:26	0:0	6	]
op	53:28	0:0	6	+
call	53:30	53:47	6	decode_rice
arg	53:42	53:44	7	gb
water	53:42	0:0	8	gb
arg	53:46	53:47	7	2
water	53:46	0:0	8	2
water	53:48	0:0	6	;
for	55:8	58:8	4	(k = 0 ;k < sub_blocks;k ++)
forinit	55:13	55:18	5	k = 0 ;
water	55:13	0:0	6	k
op	55:15	0:0	6	=
water	55:17	0:0	6	0
water	55:18	0:0	6	;
cond	55:20	55:24	5	k < sub_blocks
water	55:20	0:0	6	k
op	55:22	0:0	6	<
water	55:24	0:0	6	sub_blocks
forexpr	55:36	55:37	5	k ++
water	55:36	0:0	6	k
op	55:37	0:0	6	++
stmts	55:41	58:8	5	
water	55:41	0:0	6	{
water	56:12	0:0	6	sx
op	56:14	0:0	6	[
water	56:15	0:0	6	k
op	56:16	0:0	6	]
op	56:20	0:0	6	=
water	56:22	0:0	6	s
op	56:23	0:0	6	[
water	56:24	0:0	6	k
op	56:25	0:0	6	]
op	56:27	0:0	6	&
water	56:29	0:0	6	0
water	56:30	0:0	6	x0F
water	56:33	0:0	6	;
water	57:12	0:0	6	s
op	57:14	0:0	6	[
water	57:15	0:0	6	k
op	57:16	0:0	6	]
op	57:18	0:0	6	>>=
water	57:22	0:0	6	4
water	57:23	0:0	6	;
water	58:8	0:0	6	}
water	59:4	0:0	4	}
else	59:6	63:4	2
stmts	59:11	63:4	3	
water	59:11	0:0	4	{
water	60:8	0:0	4	s
op	60:9	0:0	4	[
water	60:10	0:0	4	0
op	60:11	0:0	4	]
op	60:13	0:0	4	=
call	60:15	60:55	4	get_bits
arg	60:24	60:26	5	gb
water	60:24	0:0	6	gb
arg	60:28	60:55	5	4+(sconf->resolution>1)
water	60:28	0:0	6	4
op	60:30	0:0	6	+
water	60:32	0:0	6	(
water	60:33	0:0	6	sconf
op	60:38	0:0	6	->
water	60:40	0:0	6	resolution
op	60:51	0:0	6	>
water	60:53	0:0	6	1
water	60:54	0:0	6	)
water	60:56	0:0	4	;
for	61:8	62:48	4	(k = 1 ;k < sub_blocks;k ++)
forinit	61:13	61:18	5	k = 1 ;
water	61:13	0:0	6	k
op	61:15	0:0	6	=
water	61:17	0:0	6	1
water	61:18	0:0	6	;
cond	61:20	61:24	5	k < sub_blocks
water	61:20	0:0	6	k
op	61:22	0:0	6	<
water	61:24	0:0	6	sub_blocks
forexpr	61:36	61:37	5	k ++
water	61:36	0:0	6	k
op	61:37	0:0	6	++
stmts	62:12	62:48	5	
water	62:12	0:0	6	s
op	62:13	0:0	6	[
water	62:14	0:0	6	k
op	62:15	0:0	6	]
op	62:17	0:0	6	=
water	62:19	0:0	6	s
op	62:20	0:0	6	[
water	62:21	0:0	6	k
op	62:23	0:0	6	-
water	62:25	0:0	6	1
op	62:26	0:0	6	]
op	62:28	0:0	6	+
call	62:30	62:47	6	decode_rice
arg	62:42	62:44	7	gb
water	62:42	0:0	8	gb
arg	62:46	62:47	7	0
water	62:46	0:0	8	0
water	62:48	0:0	6	;
water	63:4	0:0	4	}
if	65:4	66:45	2	(get_bits1 (gb ))
cond	65:8	65:20	3	get_bits1 (gb )
call	65:8	65:20	4	get_bits1
arg	65:18	65:20	5	gb
water	65:18	0:0	6	gb
stmts	66:8	66:45	3	
op	66:8	0:0	4	*
water	66:9	0:0	4	bd
op	66:11	0:0	4	->
water	66:13	0:0	4	shift_lsbs
op	66:24	0:0	4	=
call	66:26	66:40	4	get_bits
arg	66:35	66:37	5	gb
water	66:35	0:0	6	gb
arg	66:39	66:40	5	4
water	66:39	0:0	6	4
op	66:42	0:0	4	+
water	66:44	0:0	4	1
water	66:45	0:0	4	;
op	68:4	0:0	2	*
water	68:5	0:0	2	bd
op	68:7	0:0	2	->
water	68:9	0:0	2	store_prev_samples
op	68:28	0:0	2	=
water	68:30	0:0	2	(
water	68:31	0:0	2	bd
op	68:33	0:0	2	->
water	68:35	0:0	2	js_blocks
op	68:45	0:0	2	&&
water	68:48	0:0	2	bd
op	68:50	0:0	2	->
water	68:52	0:0	2	raw_other
water	68:61	0:0	2	)
op	68:63	0:0	2	||
op	68:66	0:0	2	*
water	68:67	0:0	2	bd
op	68:69	0:0	2	->
water	68:71	0:0	2	shift_lsbs
water	68:81	0:0	2	;
if	71:4	128:4	2	(! sconf -> rlslms)
cond	71:8	71:16	3	! sconf -> rlslms
op	71:8	0:0	4	!
water	71:9	0:0	4	sconf
op	71:14	0:0	4	->
water	71:16	0:0	4	rlslms
stmts	71:24	128:4	3	
water	71:24	0:0	4	{
if	72:8	76:8	4	(sconf -> adapt_order)
cond	72:12	72:19	5	sconf -> adapt_order
water	72:12	0:0	6	sconf
op	72:17	0:0	6	->
water	72:19	0:0	6	adapt_order
stmts	72:32	76:8	5	
water	72:32	0:0	6	{
decl	73:12	74:73	6	int	opt_order_length
op	73:33	0:0	6	=
call	73:35	74:72	7	av_ceil_log2
arg	73:48	74:72	8	av_clip((bd->block_length>>3)-1,2,sconf->max_order+1)
call	73:48	74:71	9	av_clip
arg	73:56	73:83	10	(bd->block_length>>3)-1
water	73:56	0:0	11	(
water	73:57	0:0	11	bd
op	73:59	0:0	11	->
water	73:61	0:0	11	block_length
op	73:74	0:0	11	>>
water	73:77	0:0	11	3
water	73:78	0:0	11	)
op	73:80	0:0	11	-
water	73:82	0:0	11	1
arg	74:48	74:49	10	2
water	74:48	0:0	11	2
arg	74:51	74:71	10	sconf->max_order+1
water	74:51	0:0	11	sconf
op	74:56	0:0	11	->
water	74:58	0:0	11	max_order
op	74:68	0:0	11	+
water	74:70	0:0	11	1
op	75:12	0:0	6	*
water	75:13	0:0	6	bd
op	75:15	0:0	6	->
water	75:17	0:0	6	opt_order
op	75:33	0:0	6	=
call	75:35	75:64	6	get_bits
arg	75:44	75:46	7	gb
water	75:44	0:0	8	gb
arg	75:48	75:64	7	opt_order_length
water	75:48	0:0	8	opt_order_length
water	75:65	0:0	6	;
water	76:8	0:0	6	}
else	76:10	78:8	4
stmts	76:15	78:8	5	
water	76:15	0:0	6	{
op	77:12	0:0	6	*
water	77:13	0:0	6	bd
op	77:15	0:0	6	->
water	77:17	0:0	6	opt_order
op	77:27	0:0	6	=
water	77:29	0:0	6	sconf
op	77:34	0:0	6	->
water	77:36	0:0	6	max_order
water	77:45	0:0	6	;
water	78:8	0:0	6	}
water	80:8	0:0	4	opt_order
op	80:18	0:0	4	=
op	80:20	0:0	4	*
water	80:21	0:0	4	bd
op	80:23	0:0	4	->
water	80:25	0:0	4	opt_order
water	80:34	0:0	4	;
if	82:8	127:8	4	(opt_order)
cond	82:12	82:12	5	opt_order
water	82:12	0:0	6	opt_order
stmts	82:23	127:8	5	
water	82:23	0:0	6	{
decl	83:12	83:24	6	int	add_base
if	85:12	98:12	6	(sconf -> coef_table == 3)
cond	85:16	85:37	7	sconf -> coef_table == 3
water	85:16	0:0	8	sconf
op	85:21	0:0	8	->
water	85:23	0:0	8	coef_table
op	85:34	0:0	8	==
water	85:37	0:0	8	3
stmts	85:40	98:12	7	
water	85:40	0:0	8	{
water	86:16	0:0	8	add_base
op	86:25	0:0	8	=
water	86:27	0:0	8	0
water	86:28	0:0	8	x7F
water	86:31	0:0	8	;
water	89:16	0:0	8	quant_cof
op	89:25	0:0	8	[
water	89:26	0:0	8	0
op	89:27	0:0	8	]
op	89:29	0:0	8	=
water	89:31	0:0	8	32
op	89:34	0:0	8	*
water	89:36	0:0	8	parcor_scaled_values
op	89:56	0:0	8	[
call	89:57	89:71	8	get_bits
arg	89:66	89:68	9	gb
water	89:66	0:0	10	gb
arg	89:70	89:71	9	7
water	89:70	0:0	10	7
op	89:72	0:0	8	]
water	89:73	0:0	8	;
if	92:16	93:78	8	(opt_order > 1)
cond	92:20	92:32	9	opt_order > 1
water	92:20	0:0	10	opt_order
op	92:30	0:0	10	>
water	92:32	0:0	10	1
stmts	93:20	93:78	9	
water	93:20	0:0	10	quant_cof
op	93:29	0:0	10	[
water	93:30	0:0	10	1
op	93:31	0:0	10	]
op	93:33	0:0	10	=
op	93:35	0:0	10	-
water	93:36	0:0	10	32
op	93:39	0:0	10	*
water	93:41	0:0	10	parcor_scaled_values
op	93:61	0:0	10	[
call	93:62	93:76	10	get_bits
arg	93:71	93:73	11	gb
water	93:71	0:0	12	gb
arg	93:75	93:76	11	7
water	93:75	0:0	12	7
op	93:77	0:0	10	]
water	93:78	0:0	10	;
for	96:16	97:50	8	(k = 2 ;k < opt_order;k ++)
forinit	96:21	96:26	9	k = 2 ;
water	96:21	0:0	10	k
op	96:23	0:0	10	=
water	96:25	0:0	10	2
water	96:26	0:0	10	;
cond	96:28	96:32	9	k < opt_order
water	96:28	0:0	10	k
op	96:30	0:0	10	<
water	96:32	0:0	10	opt_order
forexpr	96:43	96:44	9	k ++
water	96:43	0:0	10	k
op	96:44	0:0	10	++
stmts	97:20	97:50	9	
water	97:20	0:0	10	quant_cof
op	97:29	0:0	10	[
water	97:30	0:0	10	k
op	97:31	0:0	10	]
op	97:33	0:0	10	=
call	97:35	97:49	10	get_bits
arg	97:44	97:46	11	gb
water	97:44	0:0	12	gb
arg	97:48	97:49	11	7
water	97:48	0:0	12	7
water	97:50	0:0	10	;
water	98:12	0:0	8	}
else	98:14	123:12	6
stmts	98:19	123:12	7	
water	98:19	0:0	8	{
decl	99:16	99:25	8	int	k_max
water	100:16	0:0	8	add_base
op	100:25	0:0	8	=
water	100:27	0:0	8	1
water	100:28	0:0	8	;
water	103:16	0:0	8	k_max
op	103:22	0:0	8	=
call	103:24	103:43	8	FFMIN
arg	103:30	103:39	9	opt_order
water	103:30	0:0	10	opt_order
arg	103:41	103:43	9	20
water	103:41	0:0	10	20
water	103:44	0:0	8	;
for	104:16	108:16	8	(k = 0 ;k < k_max;k ++)
forinit	104:21	104:26	9	k = 0 ;
water	104:21	0:0	10	k
op	104:23	0:0	10	=
water	104:25	0:0	10	0
water	104:26	0:0	10	;
cond	104:28	104:32	9	k < k_max
water	104:28	0:0	10	k
op	104:30	0:0	10	<
water	104:32	0:0	10	k_max
forexpr	104:39	104:40	9	k ++
water	104:39	0:0	10	k
op	104:40	0:0	10	++
stmts	104:44	108:16	9	
water	104:44	0:0	10	{
decl	105:20	105:79	10	int	rice_param
op	105:35	0:0	10	=
water	105:37	0:0	10	parcor_rice_table
op	105:54	0:0	10	[
water	105:55	0:0	10	sconf
op	105:60	0:0	10	->
water	105:62	0:0	10	coef_table
op	105:72	0:0	10	]
op	105:73	0:0	10	[
water	105:74	0:0	10	k
op	105:75	0:0	10	]
op	105:76	0:0	10	[
water	105:77	0:0	10	1
op	105:78	0:0	10	]
decl	106:20	106:79	10	int	offset
op	106:35	0:0	10	=
water	106:37	0:0	10	parcor_rice_table
op	106:54	0:0	10	[
water	106:55	0:0	10	sconf
op	106:60	0:0	10	->
water	106:62	0:0	10	coef_table
op	106:72	0:0	10	]
op	106:73	0:0	10	[
water	106:74	0:0	10	k
op	106:75	0:0	10	]
op	106:76	0:0	10	[
water	106:77	0:0	10	0
op	106:78	0:0	10	]
water	107:20	0:0	10	quant_cof
op	107:29	0:0	10	[
water	107:30	0:0	10	k
op	107:31	0:0	10	]
op	107:33	0:0	10	=
call	107:35	107:61	10	decode_rice
arg	107:47	107:49	11	gb
water	107:47	0:0	12	gb
arg	107:51	107:61	11	rice_param
water	107:51	0:0	12	rice_param
op	107:63	0:0	10	+
water	107:65	0:0	10	offset
water	107:71	0:0	10	;
water	108:16	0:0	10	}
water	111:16	0:0	8	k_max
op	111:22	0:0	8	=
call	111:24	111:44	8	FFMIN
arg	111:30	111:39	9	opt_order
water	111:30	0:0	10	opt_order
arg	111:41	111:44	9	127
water	111:41	0:0	10	127
water	111:45	0:0	8	;
for	112:16	113:63	8	(;k < k_max;k ++)
forinit	112:21	112:21	9	;
water	112:21	0:0	10	;
cond	112:23	112:27	9	k < k_max
water	112:23	0:0	10	k
op	112:25	0:0	10	<
water	112:27	0:0	10	k_max
forexpr	112:34	112:35	9	k ++
water	112:34	0:0	10	k
op	112:35	0:0	10	++
stmts	113:20	113:63	9	
water	113:20	0:0	10	quant_cof
op	113:29	0:0	10	[
water	113:30	0:0	10	k
op	113:31	0:0	10	]
op	113:33	0:0	10	=
call	113:35	113:52	10	decode_rice
arg	113:47	113:49	11	gb
water	113:47	0:0	12	gb
arg	113:51	113:52	11	2
water	113:51	0:0	12	2
op	113:54	0:0	10	+
water	113:56	0:0	10	(
water	113:57	0:0	10	k
op	113:59	0:0	10	&
water	113:61	0:0	10	1
water	113:62	0:0	10	)
water	113:63	0:0	10	;
for	116:16	117:53	8	(;k < opt_order;k ++)
forinit	116:21	116:21	9	;
water	116:21	0:0	10	;
cond	116:23	116:27	9	k < opt_order
water	116:23	0:0	10	k
op	116:25	0:0	10	<
water	116:27	0:0	10	opt_order
forexpr	116:38	116:39	9	k ++
water	116:38	0:0	10	k
op	116:39	0:0	10	++
stmts	117:20	117:53	9	
water	117:20	0:0	10	quant_cof
op	117:29	0:0	10	[
water	117:30	0:0	10	k
op	117:31	0:0	10	]
op	117:33	0:0	10	=
call	117:35	117:52	10	decode_rice
arg	117:47	117:49	11	gb
water	117:47	0:0	12	gb
arg	117:51	117:52	11	1
water	117:51	0:0	12	1
water	117:53	0:0	10	;
water	119:16	0:0	8	quant_cof
op	119:25	0:0	8	[
water	119:26	0:0	8	0
op	119:27	0:0	8	]
op	119:29	0:0	8	=
water	119:31	0:0	8	32
op	119:34	0:0	8	*
water	119:36	0:0	8	parcor_scaled_values
op	119:56	0:0	8	[
water	119:57	0:0	8	quant_cof
op	119:66	0:0	8	[
water	119:67	0:0	8	0
op	119:68	0:0	8	]
op	119:70	0:0	8	+
water	119:72	0:0	8	64
op	119:74	0:0	8	]
water	119:75	0:0	8	;
if	121:16	122:80	8	(opt_order > 1)
cond	121:20	121:32	9	opt_order > 1
water	121:20	0:0	10	opt_order
op	121:30	0:0	10	>
water	121:32	0:0	10	1
stmts	122:20	122:80	9	
water	122:20	0:0	10	quant_cof
op	122:29	0:0	10	[
water	122:30	0:0	10	1
op	122:31	0:0	10	]
op	122:33	0:0	10	=
op	122:35	0:0	10	-
water	122:36	0:0	10	32
op	122:39	0:0	10	*
water	122:41	0:0	10	parcor_scaled_values
op	122:61	0:0	10	[
water	122:62	0:0	10	quant_cof
op	122:71	0:0	10	[
water	122:72	0:0	10	1
op	122:73	0:0	10	]
op	122:75	0:0	10	+
water	122:77	0:0	10	64
op	122:79	0:0	10	]
water	122:80	0:0	10	;
water	123:12	0:0	8	}
for	125:12	126:70	6	(k = 2 ;k < opt_order;k ++)
forinit	125:17	125:22	7	k = 2 ;
water	125:17	0:0	8	k
op	125:19	0:0	8	=
water	125:21	0:0	8	2
water	125:22	0:0	8	;
cond	125:24	125:28	7	k < opt_order
water	125:24	0:0	8	k
op	125:26	0:0	8	<
water	125:28	0:0	8	opt_order
forexpr	125:39	125:40	7	k ++
water	125:39	0:0	8	k
op	125:40	0:0	8	++
stmts	126:16	126:70	7	
water	126:16	0:0	8	quant_cof
op	126:25	0:0	8	[
water	126:26	0:0	8	k
op	126:27	0:0	8	]
op	126:29	0:0	8	=
water	126:31	0:0	8	(
water	126:32	0:0	8	quant_cof
op	126:41	0:0	8	[
water	126:42	0:0	8	k
op	126:43	0:0	8	]
op	126:45	0:0	8	<<
water	126:48	0:0	8	14
water	126:50	0:0	8	)
op	126:52	0:0	8	+
water	126:54	0:0	8	(
water	126:55	0:0	8	add_base
op	126:64	0:0	8	<<
water	126:67	0:0	8	13
water	126:69	0:0	8	)
water	126:70	0:0	8	;
water	127:8	0:0	6	}
water	128:4	0:0	4	}
if	131:4	150:4	2	(sconf -> long_term_prediction)
cond	131:8	131:15	3	sconf -> long_term_prediction
water	131:8	0:0	4	sconf
op	131:13	0:0	4	->
water	131:15	0:0	4	long_term_prediction
stmts	131:37	150:4	3	
water	131:37	0:0	4	{
op	132:8	0:0	4	*
water	132:9	0:0	4	bd
op	132:11	0:0	4	->
water	132:13	0:0	4	use_ltp
op	132:21	0:0	4	=
call	132:23	132:35	4	get_bits1
arg	132:33	132:35	5	gb
water	132:33	0:0	6	gb
water	132:36	0:0	4	;
if	134:8	149:8	4	(* bd -> use_ltp)
cond	134:12	134:17	5	* bd -> use_ltp
op	134:12	0:0	6	*
water	134:13	0:0	6	bd
op	134:15	0:0	6	->
water	134:17	0:0	6	use_ltp
stmts	134:26	149:8	5	
water	134:26	0:0	6	{
decl	135:12	135:20	6	int	r
water	135:17	0:0	6	,
decl	135:12	135:20	6	int	c
water	137:12	0:0	6	bd
op	137:14	0:0	6	->
water	137:16	0:0	6	ltp_gain
op	137:24	0:0	6	[
water	137:25	0:0	6	0
op	137:26	0:0	6	]
op	137:30	0:0	6	=
call	137:32	137:49	6	decode_rice
arg	137:44	137:46	7	gb
water	137:44	0:0	8	gb
arg	137:48	137:49	7	1
water	137:48	0:0	8	1
op	137:51	0:0	6	<<
water	137:54	0:0	6	3
water	137:55	0:0	6	;
water	138:12	0:0	6	bd
op	138:14	0:0	6	->
water	138:16	0:0	6	ltp_gain
op	138:24	0:0	6	[
water	138:25	0:0	6	1
op	138:26	0:0	6	]
op	138:30	0:0	6	=
call	138:32	138:49	6	decode_rice
arg	138:44	138:46	7	gb
water	138:44	0:0	8	gb
arg	138:48	138:49	7	2
water	138:48	0:0	8	2
op	138:51	0:0	6	<<
water	138:54	0:0	6	3
water	138:55	0:0	6	;
water	140:12	0:0	6	r
op	140:30	0:0	6	=
call	140:32	140:50	6	get_unary
arg	140:42	140:44	7	gb
water	140:42	0:0	8	gb
arg	140:46	140:47	7	0
water	140:46	0:0	8	0
arg	140:49	140:50	7	4
water	140:49	0:0	8	4
water	140:51	0:0	6	;
water	141:12	0:0	6	c
op	141:30	0:0	6	=
call	141:32	141:46	6	get_bits
arg	141:41	141:43	7	gb
water	141:41	0:0	8	gb
arg	141:45	141:46	7	2
water	141:45	0:0	8	2
water	141:47	0:0	6	;
water	142:12	0:0	6	bd
op	142:14	0:0	6	->
water	142:16	0:0	6	ltp_gain
op	142:24	0:0	6	[
water	142:25	0:0	6	2
op	142:26	0:0	6	]
op	142:30	0:0	6	=
water	142:32	0:0	6	ltp_gain_values
op	142:47	0:0	6	[
water	142:48	0:0	6	r
op	142:49	0:0	6	]
op	142:50	0:0	6	[
water	142:51	0:0	6	c
op	142:52	0:0	6	]
water	142:53	0:0	6	;
water	144:12	0:0	6	bd
op	144:14	0:0	6	->
water	144:16	0:0	6	ltp_gain
op	144:24	0:0	6	[
water	144:25	0:0	6	3
op	144:26	0:0	6	]
op	144:30	0:0	6	=
call	144:32	144:49	6	decode_rice
arg	144:44	144:46	7	gb
water	144:44	0:0	8	gb
arg	144:48	144:49	7	2
water	144:48	0:0	8	2
op	144:51	0:0	6	<<
water	144:54	0:0	6	3
water	144:55	0:0	6	;
water	145:12	0:0	6	bd
op	145:14	0:0	6	->
water	145:16	0:0	6	ltp_gain
op	145:24	0:0	6	[
water	145:25	0:0	6	4
op	145:26	0:0	6	]
op	145:30	0:0	6	=
call	145:32	145:49	6	decode_rice
arg	145:44	145:46	7	gb
water	145:44	0:0	8	gb
arg	145:48	145:49	7	1
water	145:48	0:0	8	1
op	145:51	0:0	6	<<
water	145:54	0:0	6	3
water	145:55	0:0	6	;
op	147:12	0:0	6	*
water	147:13	0:0	6	bd
op	147:15	0:0	6	->
water	147:17	0:0	6	ltp_lag
op	147:30	0:0	6	=
call	147:32	147:64	6	get_bits
arg	147:41	147:43	7	gb
water	147:41	0:0	8	gb
arg	147:45	147:64	7	ctx->ltp_lag_length
water	147:45	0:0	8	ctx
op	147:48	0:0	8	->
water	147:50	0:0	8	ltp_lag_length
water	147:65	0:0	6	;
op	148:12	0:0	6	*
water	148:13	0:0	6	bd
op	148:15	0:0	6	->
water	148:17	0:0	6	ltp_lag
op	148:29	0:0	6	+=
call	148:32	148:54	6	FFMAX
arg	148:38	148:39	7	4
water	148:38	0:0	8	4
arg	148:41	148:54	7	opt_order+1
water	148:41	0:0	8	opt_order
op	148:51	0:0	8	+
water	148:53	0:0	8	1
water	148:55	0:0	6	;
water	149:8	0:0	6	}
water	150:4	0:0	4	}
if	153:4	162:4	2	(bd -> ra_block)
cond	153:8	153:12	3	bd -> ra_block
water	153:8	0:0	4	bd
op	153:10	0:0	4	->
water	153:12	0:0	4	ra_block
stmts	153:22	162:4	3	
water	153:22	0:0	4	{
if	154:8	155:80	4	(opt_order)
cond	154:12	154:12	5	opt_order
water	154:12	0:0	6	opt_order
stmts	155:12	155:80	5	
water	155:12	0:0	6	bd
op	155:14	0:0	6	->
water	155:16	0:0	6	raw_samples
op	155:27	0:0	6	[
water	155:28	0:0	6	0
op	155:29	0:0	6	]
op	155:31	0:0	6	=
call	155:33	155:79	6	decode_rice
arg	155:45	155:47	7	gb
water	155:45	0:0	8	gb
arg	155:49	155:79	7	avctx->bits_per_raw_sample-4
water	155:49	0:0	8	avctx
op	155:54	0:0	8	->
water	155:56	0:0	8	bits_per_raw_sample
op	155:76	0:0	8	-
water	155:78	0:0	8	4
water	155:80	0:0	6	;
if	156:8	157:77	4	(opt_order > 1)
cond	156:12	156:24	5	opt_order > 1
water	156:12	0:0	6	opt_order
op	156:22	0:0	6	>
water	156:24	0:0	6	1
stmts	157:12	157:77	5	
water	157:12	0:0	6	bd
op	157:14	0:0	6	->
water	157:16	0:0	6	raw_samples
op	157:27	0:0	6	[
water	157:28	0:0	6	1
op	157:29	0:0	6	]
op	157:31	0:0	6	=
call	157:33	157:76	6	decode_rice
arg	157:45	157:47	7	gb
water	157:45	0:0	8	gb
arg	157:49	157:76	7	FFMIN(s[0]+3,ctx->s_max)
call	157:49	157:75	8	FFMIN
arg	157:55	157:63	9	s[0]+3
water	157:55	0:0	10	s
op	157:56	0:0	10	[
water	157:57	0:0	10	0
op	157:58	0:0	10	]
op	157:60	0:0	10	+
water	157:62	0:0	10	3
arg	157:65	157:75	9	ctx->s_max
water	157:65	0:0	10	ctx
op	157:68	0:0	10	->
water	157:70	0:0	10	s_max
water	157:77	0:0	6	;
if	158:8	159:77	4	(opt_order > 2)
cond	158:12	158:24	5	opt_order > 2
water	158:12	0:0	6	opt_order
op	158:22	0:0	6	>
water	158:24	0:0	6	2
stmts	159:12	159:77	5	
water	159:12	0:0	6	bd
op	159:14	0:0	6	->
water	159:16	0:0	6	raw_samples
op	159:27	0:0	6	[
water	159:28	0:0	6	2
op	159:29	0:0	6	]
op	159:31	0:0	6	=
call	159:33	159:76	6	decode_rice
arg	159:45	159:47	7	gb
water	159:45	0:0	8	gb
arg	159:49	159:76	7	FFMIN(s[0]+1,ctx->s_max)
call	159:49	159:75	8	FFMIN
arg	159:55	159:63	9	s[0]+1
water	159:55	0:0	10	s
op	159:56	0:0	10	[
water	159:57	0:0	10	0
op	159:58	0:0	10	]
op	159:60	0:0	10	+
water	159:62	0:0	10	1
arg	159:65	159:75	9	ctx->s_max
water	159:65	0:0	10	ctx
op	159:68	0:0	10	->
water	159:70	0:0	10	s_max
water	159:77	0:0	6	;
water	161:8	0:0	4	start
op	161:14	0:0	4	=
call	161:16	161:34	4	FFMIN
arg	161:22	161:31	5	opt_order
water	161:22	0:0	6	opt_order
arg	161:33	161:34	5	3
water	161:33	0:0	6	3
water	161:35	0:0	4	;
water	162:4	0:0	4	}
if	165:4	234:4	2	(sconf -> bgmc)
cond	165:8	165:15	3	sconf -> bgmc
water	165:8	0:0	4	sconf
op	165:13	0:0	4	->
water	165:15	0:0	4	bgmc
stmts	165:21	234:4	3	
water	165:21	0:0	4	{
decl	166:8	166:29	4	int	delta[8]
decl	167:8	167:29	4	unsigned int	k[8]
decl	168:8	168:81	4	unsigned int	b
op	168:23	0:0	4	=
call	168:25	168:80	5	av_clip
arg	168:33	168:74	6	(av_ceil_log2(bd->block_length)-3)>>1
water	168:33	0:0	7	(
call	168:34	168:63	7	av_ceil_log2
arg	168:47	168:63	8	bd->block_length
water	168:47	0:0	9	bd
op	168:49	0:0	9	->
water	168:51	0:0	9	block_length
op	168:65	0:0	7	-
water	168:67	0:0	7	3
water	168:68	0:0	7	)
op	168:70	0:0	7	>>
water	168:73	0:0	7	1
arg	168:76	168:77	6	0
water	168:76	0:0	7	0
arg	168:79	168:80	6	5
water	168:79	0:0	7	5
decl	169:8	169:30	4	unsigned int	i
op	169:23	0:0	4	=
water	169:25	0:0	4	start
decl	172:8	172:25	4	unsigned int	high
decl	173:8	173:24	4	unsigned int	low
decl	174:8	174:26	4	unsigned int	value
call	176:8	176:51	4	ff_bgmc_decode_init
arg	176:28	176:30	5	gb
water	176:28	0:0	6	gb
arg	176:32	176:37	5	&high
op	176:32	0:0	6	&
water	176:33	0:0	6	high
arg	176:39	176:43	5	&low
op	176:39	0:0	6	&
water	176:40	0:0	6	low
arg	176:45	176:51	5	&value
op	176:45	0:0	6	&
water	176:46	0:0	6	value
water	176:52	0:0	4	;
water	178:8	0:0	4	current_res
op	178:20	0:0	4	=
water	178:22	0:0	4	bd
op	178:24	0:0	4	->
water	178:26	0:0	4	raw_samples
op	178:38	0:0	4	+
water	178:40	0:0	4	start
water	178:45	0:0	4	;
for	180:8	188:8	4	(sb = 0 ;sb < sub_blocks;sb ++ , i = 0)
forinit	180:13	180:19	5	sb = 0 ;
water	180:13	0:0	6	sb
op	180:16	0:0	6	=
water	180:18	0:0	6	0
water	180:19	0:0	6	;
cond	180:21	180:26	5	sb < sub_blocks
water	180:21	0:0	6	sb
op	180:24	0:0	6	<
water	180:26	0:0	6	sub_blocks
forexpr	180:38	180:48	5	sb ++ , i = 0
water	180:38	0:0	6	sb
op	180:40	0:0	6	++
water	180:42	0:0	6	,
water	180:44	0:0	6	i
op	180:46	0:0	6	=
water	180:48	0:0	6	0
stmts	180:51	188:8	5	
water	180:51	0:0	6	{
water	181:12	0:0	6	k
op	181:17	0:0	6	[
water	181:18	0:0	6	sb
op	181:20	0:0	6	]
op	181:22	0:0	6	=
water	181:24	0:0	6	s
op	181:25	0:0	6	[
water	181:26	0:0	6	sb
op	181:28	0:0	6	]
op	181:30	0:0	6	>
water	181:32	0:0	6	b
water	181:34	0:0	6	?
water	181:36	0:0	6	s
op	181:37	0:0	6	[
water	181:38	0:0	6	sb
op	181:40	0:0	6	]
op	181:42	0:0	6	-
water	181:44	0:0	6	b
water	181:46	0:0	6	:
water	181:48	0:0	6	0
water	181:49	0:0	6	;
water	182:12	0:0	6	delta
op	182:17	0:0	6	[
water	182:18	0:0	6	sb
op	182:20	0:0	6	]
op	182:22	0:0	6	=
water	182:24	0:0	6	5
op	182:26	0:0	6	-
water	182:28	0:0	6	s
op	182:29	0:0	6	[
water	182:30	0:0	6	sb
op	182:32	0:0	6	]
op	182:34	0:0	6	+
water	182:36	0:0	6	k
op	182:37	0:0	6	[
water	182:38	0:0	6	sb
op	182:40	0:0	6	]
water	182:41	0:0	6	;
call	184:12	185:99	6	ff_bgmc_decode
arg	184:27	184:29	7	gb
water	184:27	0:0	8	gb
arg	184:31	184:40	7	sb_length
water	184:31	0:0	8	sb_length
arg	184:42	184:53	7	current_res
water	184:42	0:0	8	current_res
arg	185:24	185:33	7	delta[sb]
water	185:24	0:0	8	delta
op	185:29	0:0	8	[
water	185:30	0:0	8	sb
op	185:32	0:0	8	]
arg	185:35	185:41	7	sx[sb]
water	185:35	0:0	8	sx
op	185:37	0:0	8	[
water	185:38	0:0	8	sb
op	185:40	0:0	8	]
arg	185:43	185:48	7	&high
op	185:43	0:0	8	&
water	185:44	0:0	8	high
arg	185:50	185:54	7	&low
op	185:50	0:0	8	&
water	185:51	0:0	8	low
arg	185:56	185:62	7	&value
op	185:56	0:0	8	&
water	185:57	0:0	8	value
arg	185:64	185:77	7	ctx->bgmc_lut
water	185:64	0:0	8	ctx
op	185:67	0:0	8	->
water	185:69	0:0	8	bgmc_lut
arg	185:79	185:99	7	ctx->bgmc_lut_status
water	185:79	0:0	8	ctx
op	185:82	0:0	8	->
water	185:84	0:0	8	bgmc_lut_status
water	185:100	0:0	6	;
water	187:12	0:0	6	current_res
op	187:24	0:0	6	+=
water	187:27	0:0	6	sb_length
water	187:36	0:0	6	;
water	188:8	0:0	6	}
call	190:8	190:29	4	ff_bgmc_decode_end
arg	190:27	190:29	5	gb
water	190:27	0:0	6	gb
water	190:30	0:0	4	;
water	194:8	0:0	4	i
op	194:10	0:0	4	=
water	194:12	0:0	4	start
water	194:17	0:0	4	;
water	195:8	0:0	4	current_res
op	195:20	0:0	4	=
water	195:22	0:0	4	bd
op	195:24	0:0	4	->
water	195:26	0:0	4	raw_samples
op	195:38	0:0	4	+
water	195:40	0:0	4	start
water	195:45	0:0	4	;
for	197:8	233:8	4	(sb = 0 ;sb < sub_blocks;sb ++ , i = 0)
forinit	197:13	197:19	5	sb = 0 ;
water	197:13	0:0	6	sb
op	197:16	0:0	6	=
water	197:18	0:0	6	0
water	197:19	0:0	6	;
cond	197:21	197:26	5	sb < sub_blocks
water	197:21	0:0	6	sb
op	197:24	0:0	6	<
water	197:26	0:0	6	sub_blocks
forexpr	197:38	197:48	5	sb ++ , i = 0
water	197:38	0:0	6	sb
op	197:40	0:0	6	++
water	197:42	0:0	6	,
water	197:44	0:0	6	i
op	197:46	0:0	6	=
water	197:48	0:0	6	0
stmts	197:51	233:8	5	
water	197:51	0:0	6	{
decl	198:12	198:69	6	unsigned int	cur_tail_code
op	198:39	0:0	6	=
water	198:41	0:0	6	tail_code
op	198:50	0:0	6	[
water	198:51	0:0	6	sx
op	198:53	0:0	6	[
water	198:54	0:0	6	sb
op	198:56	0:0	6	]
op	198:57	0:0	6	]
op	198:58	0:0	6	[
water	198:59	0:0	6	delta
op	198:64	0:0	6	[
water	198:65	0:0	6	sb
op	198:67	0:0	6	]
op	198:68	0:0	6	]
decl	199:12	199:46	6	unsigned int	cur_k
op	199:39	0:0	6	=
water	199:41	0:0	6	k
op	199:42	0:0	6	[
water	199:43	0:0	6	sb
op	199:45	0:0	6	]
decl	200:12	200:46	6	unsigned int	cur_s
op	200:39	0:0	6	=
water	200:41	0:0	6	s
op	200:42	0:0	6	[
water	200:43	0:0	6	sb
op	200:45	0:0	6	]
for	202:12	232:12	6	(;i < sb_length;i ++)
forinit	202:17	202:17	7	;
water	202:17	0:0	8	;
cond	202:19	202:23	7	i < sb_length
water	202:19	0:0	8	i
op	202:21	0:0	8	<
water	202:23	0:0	8	sb_length
forexpr	202:34	202:35	7	i ++
water	202:34	0:0	8	i
op	202:35	0:0	8	++
stmts	202:39	232:12	7	
water	202:39	0:0	8	{
decl	203:16	203:42	8	int32_t	res
op	203:28	0:0	8	=
op	203:30	0:0	8	*
water	203:31	0:0	8	current_res
if	205:16	216:16	8	(res == cur_tail_code)
cond	205:20	205:27	9	res == cur_tail_code
water	205:20	0:0	10	res
op	205:24	0:0	10	==
water	205:27	0:0	10	cur_tail_code
stmts	205:42	216:16	9	
water	205:42	0:0	10	{
decl	206:20	207:60	10	unsigned int	max_msb
op	206:41	0:0	10	=
water	206:45	0:0	10	(
water	206:46	0:0	10	2
op	206:48	0:0	10	+
water	206:50	0:0	10	(
water	206:51	0:0	10	sx
op	206:53	0:0	10	[
water	206:54	0:0	10	sb
op	206:56	0:0	10	]
op	206:58	0:0	10	>
water	206:60	0:0	10	2
water	206:61	0:0	10	)
op	206:63	0:0	10	+
water	206:65	0:0	10	(
water	206:66	0:0	10	sx
op	206:68	0:0	10	[
water	206:69	0:0	10	sb
op	206:71	0:0	10	]
op	206:73	0:0	10	>
water	206:75	0:0	10	10
water	206:77	0:0	10	)
water	206:78	0:0	10	)
op	207:42	0:0	10	<<
water	207:45	0:0	10	(
water	207:46	0:0	10	5
op	207:48	0:0	10	-
water	207:50	0:0	10	delta
op	207:55	0:0	10	[
water	207:56	0:0	10	sb
op	207:58	0:0	10	]
water	207:59	0:0	10	)
water	209:20	0:0	10	res
op	209:24	0:0	10	=
call	209:26	209:47	10	decode_rice
arg	209:38	209:40	11	gb
water	209:38	0:0	12	gb
arg	209:42	209:47	11	cur_s
water	209:42	0:0	12	cur_s
water	209:48	0:0	10	;
if	211:20	213:20	10	(res >= 0)
cond	211:24	211:31	11	res >= 0
water	211:24	0:0	12	res
op	211:28	0:0	12	>=
water	211:31	0:0	12	0
stmts	211:34	213:20	11	
water	211:34	0:0	12	{
water	212:24	0:0	12	res
op	212:28	0:0	12	+=
water	212:31	0:0	12	(
water	212:32	0:0	12	max_msb
water	212:43	0:0	12	)
op	212:45	0:0	12	<<
water	212:48	0:0	12	cur_k
water	212:53	0:0	12	;
water	213:20	0:0	12	}
else	213:22	215:20	10
stmts	213:27	215:20	11	
water	213:27	0:0	12	{
water	214:24	0:0	12	res
op	214:28	0:0	12	-=
water	214:31	0:0	12	(
water	214:32	0:0	12	max_msb
op	214:40	0:0	12	-
water	214:42	0:0	12	1
water	214:43	0:0	12	)
op	214:45	0:0	12	<<
water	214:48	0:0	12	cur_k
water	214:53	0:0	12	;
water	215:20	0:0	12	}
water	216:16	0:0	10	}
else	216:18	229:16	8
stmts	216:23	229:16	9	
water	216:23	0:0	10	{
if	217:20	218:29	10	(res > cur_tail_code)
cond	217:24	217:30	11	res > cur_tail_code
water	217:24	0:0	12	res
op	217:28	0:0	12	>
water	217:30	0:0	12	cur_tail_code
stmts	218:24	218:29	11	
water	218:24	0:0	12	res
op	218:27	0:0	12	--
water	218:29	0:0	12	;
if	220:20	221:34	10	(res & 1)
cond	220:24	220:30	11	res & 1
water	220:24	0:0	12	res
op	220:28	0:0	12	&
water	220:30	0:0	12	1
stmts	221:24	221:34	11	
water	221:24	0:0	12	res
op	221:28	0:0	12	=
op	221:30	0:0	12	-
water	221:31	0:0	12	res
water	221:34	0:0	12	;
water	223:20	0:0	10	res
op	223:24	0:0	10	>>=
water	223:28	0:0	10	1
water	223:29	0:0	10	;
if	225:20	228:20	10	(cur_k)
cond	225:24	225:24	11	cur_k
water	225:24	0:0	12	cur_k
stmts	225:31	228:20	11	
water	225:31	0:0	12	{
water	226:24	0:0	12	res
op	226:28	0:0	12	<<=
water	226:32	0:0	12	cur_k
water	226:37	0:0	12	;
water	227:24	0:0	12	res
op	227:29	0:0	12	|=
call	227:32	227:55	12	get_bits_long
arg	227:46	227:48	13	gb
water	227:46	0:0	14	gb
arg	227:50	227:55	13	cur_k
water	227:50	0:0	14	cur_k
water	227:56	0:0	12	;
water	228:20	0:0	12	}
water	229:16	0:0	10	}
op	231:16	0:0	8	*
water	231:17	0:0	8	current_res
op	231:28	0:0	8	++
op	231:31	0:0	8	=
water	231:33	0:0	8	res
water	231:36	0:0	8	;
water	232:12	0:0	8	}
water	233:8	0:0	6	}
water	234:4	0:0	4	}
else	234:6	240:5	2
stmts	234:11	240:5	3	
water	234:11	0:0	4	{
water	235:8	0:0	4	current_res
op	235:20	0:0	4	=
water	235:22	0:0	4	bd
op	235:24	0:0	4	->
water	235:26	0:0	4	raw_samples
op	235:38	0:0	4	+
water	235:40	0:0	4	start
water	235:45	0:0	4	;
for	237:8	239:55	4	(sb = 0 ;sb < sub_blocks;sb ++ , start = 0)
forinit	237:13	237:19	5	sb = 0 ;
water	237:13	0:0	6	sb
op	237:16	0:0	6	=
water	237:18	0:0	6	0
water	237:19	0:0	6	;
cond	237:21	237:26	5	sb < sub_blocks
water	237:21	0:0	6	sb
op	237:24	0:0	6	<
water	237:26	0:0	6	sub_blocks
forexpr	237:38	237:52	5	sb ++ , start = 0
water	237:38	0:0	6	sb
op	237:40	0:0	6	++
water	237:42	0:0	6	,
water	237:44	0:0	6	start
op	237:50	0:0	6	=
water	237:52	0:0	6	0
stmts	238:12	239:55	5	
for	238:12	239:55	6	(;start < sb_length;start ++)
forinit	238:17	238:17	7	;
water	238:17	0:0	8	;
cond	238:19	238:27	7	start < sb_length
water	238:19	0:0	8	start
op	238:25	0:0	8	<
water	238:27	0:0	8	sb_length
forexpr	238:38	238:43	7	start ++
water	238:38	0:0	8	start
op	238:43	0:0	8	++
stmts	239:16	239:55	7	
op	239:16	0:0	8	*
water	239:17	0:0	8	current_res
op	239:28	0:0	8	++
op	239:31	0:0	8	=
call	239:33	239:54	8	decode_rice
arg	239:45	239:47	9	gb
water	239:45	0:0	10	gb
arg	239:49	239:54	9	s[sb]
water	239:49	0:0	10	s
op	239:50	0:0	10	[
water	239:51	0:0	10	sb
op	239:53	0:0	10	]
water	239:55	0:0	8	;
water	240:5	0:0	4	}
if	242:4	243:26	2	(! sconf -> mc_coding || ctx -> js_switch)
cond	242:8	242:34	3	! sconf -> mc_coding || ctx -> js_switch
op	242:8	0:0	4	!
water	242:9	0:0	4	sconf
op	242:14	0:0	4	->
water	242:16	0:0	4	mc_coding
op	242:26	0:0	4	||
water	242:29	0:0	4	ctx
op	242:32	0:0	4	->
water	242:34	0:0	4	js_switch
stmts	243:8	243:26	3	
call	243:8	243:25	4	align_get_bits
arg	243:23	243:25	5	gb
water	243:23	0:0	6	gb
water	243:26	0:0	4	;
return	245:4	245:12	2	0
water	245:11	0:0	3	0
