func	2:0	52:0	0	static int	mjpeg_decode_scan_progressive_ac
params	2:43	0:0	1	
param	2:44	2:65	2	MJpegDecodeContext *	s
param	2:67	2:73	2	int	ss
param	3:44	3:50	2	int	se
param	3:52	3:58	2	int	Ah
param	3:60	3:66	2	int	Al
stmnts	0:0	51:12	1	
decl	5:4	5:18	2	int	mb_x
water	5:12	0:0	2	,
decl	5:4	5:18	2	int	mb_y
decl	6:4	6:18	2	int	EOBRUN
op	6:15	0:0	2	=
water	6:17	0:0	2	0
decl	7:4	7:28	2	int	c
op	7:10	0:0	2	=
water	7:12	0:0	2	s
op	7:13	0:0	2	->
water	7:15	0:0	2	comp_index
op	7:25	0:0	2	[
water	7:26	0:0	2	0
op	7:27	0:0	2	]
decl	8:4	8:38	2	uint8_t	*data
op	8:18	0:0	2	=
water	8:20	0:0	2	s
op	8:21	0:0	2	->
water	8:23	0:0	2	picture
op	8:30	0:0	2	.
water	8:31	0:0	2	data
op	8:35	0:0	2	[
water	8:36	0:0	2	c
op	8:37	0:0	2	]
decl	9:4	9:34	2	int	linesize
op	9:18	0:0	2	=
water	9:20	0:0	2	s
op	9:21	0:0	2	->
water	9:23	0:0	2	linesize
op	9:31	0:0	2	[
water	9:32	0:0	2	c
op	9:33	0:0	2	]
decl	10:4	10:21	2	int	last_scan
op	10:18	0:0	2	=
water	10:20	0:0	2	0
decl	11:4	11:64	2	int16_t	*quant_matrix
op	11:26	0:0	2	=
water	11:28	0:0	2	s
op	11:29	0:0	2	->
water	11:31	0:0	2	quant_matrixes
op	11:45	0:0	2	[
water	11:46	0:0	2	s
op	11:47	0:0	2	->
water	11:49	0:0	2	quant_index
op	11:60	0:0	2	[
water	11:61	0:0	2	c
op	11:62	0:0	2	]
op	11:63	0:0	2	]
if	13:4	16:4	2	(se > 63)
cond	13:8	13:13	3	se > 63
water	13:8	0:0	4	se
op	13:11	0:0	4	>
water	13:13	0:0	4	63
stmts	13:17	16:4	3	
water	13:17	0:0	4	{
call	14:8	14:65	4	av_log
arg	14:15	14:23	5	s->avctx
water	14:15	0:0	6	s
op	14:16	0:0	6	->
water	14:18	0:0	6	avctx
arg	14:25	14:37	5	AV_LOG_ERROR
water	14:25	0:0	6	AV_LOG_ERROR
arg	14:39	14:61	5	"SE %d is too large\n"
water	14:39	0:0	6	"SE %d is too large\n"
arg	14:63	14:65	5	se
water	14:63	0:0	6	se
water	14:66	0:0	4	;
return	15:8	15:34	4	AVERROR_INVALIDDATA
water	15:15	0:0	5	AVERROR_INVALIDDATA
water	16:4	0:0	4	}
if	18:4	21:4	2	(! Al)
cond	18:8	18:9	3	! Al
op	18:8	0:0	4	!
water	18:9	0:0	4	Al
stmts	18:13	21:4	3	
water	18:13	0:0	4	{
water	19:8	0:0	4	s
op	19:9	0:0	4	->
water	19:11	0:0	4	coefs_finished
op	19:25	0:0	4	[
water	19:26	0:0	4	c
op	19:27	0:0	4	]
op	19:29	0:0	4	|=
water	19:32	0:0	4	(
water	19:33	0:0	4	1
water	19:34	0:0	4	LL
op	19:37	0:0	4	<<
water	19:40	0:0	4	(
water	19:41	0:0	4	se
op	19:44	0:0	4	+
water	19:46	0:0	4	1
water	19:47	0:0	4	)
water	19:48	0:0	4	)
op	19:50	0:0	4	-
water	19:52	0:0	4	(
water	19:53	0:0	4	1
water	19:54	0:0	4	LL
op	19:57	0:0	4	<<
water	19:60	0:0	4	ss
water	19:62	0:0	4	)
water	19:63	0:0	4	;
water	20:8	0:0	4	last_scan
op	20:18	0:0	4	=
op	20:20	0:0	4	!
water	20:21	0:0	4	~s
op	20:23	0:0	4	->
water	20:25	0:0	4	coefs_finished
op	20:39	0:0	4	[
water	20:40	0:0	4	c
op	20:41	0:0	4	]
water	20:42	0:0	4	;
water	21:4	0:0	4	}
if	23:4	24:29	2	(s -> interlaced && s -> bottom_field)
cond	23:8	23:28	3	s -> interlaced && s -> bottom_field
water	23:8	0:0	4	s
op	23:9	0:0	4	->
water	23:11	0:0	4	interlaced
op	23:22	0:0	4	&&
water	23:25	0:0	4	s
op	23:26	0:0	4	->
water	23:28	0:0	4	bottom_field
stmts	24:8	24:29	3	
water	24:8	0:0	4	data
op	24:13	0:0	4	+=
water	24:16	0:0	4	linesize
op	24:25	0:0	4	>>
water	24:28	0:0	4	1
water	24:29	0:0	4	;
for	26:4	50:4	2	(mb_y = 0 ;mb_y < s -> mb_height;mb_y ++)
forinit	26:9	26:17	3	mb_y = 0 ;
water	26:9	0:0	4	mb_y
op	26:14	0:0	4	=
water	26:16	0:0	4	0
water	26:17	0:0	4	;
cond	26:19	26:29	3	mb_y < s -> mb_height
water	26:19	0:0	4	mb_y
op	26:24	0:0	4	<
water	26:26	0:0	4	s
op	26:27	0:0	4	->
water	26:29	0:0	4	mb_height
forexpr	26:40	26:44	3	mb_y ++
water	26:40	0:0	4	mb_y
op	26:44	0:0	4	++
stmts	26:48	50:4	3	
water	26:48	0:0	4	{
decl	27:8	27:75	4	uint8_t	*ptr
op	27:25	0:0	4	=
water	27:27	0:0	4	data
op	27:32	0:0	4	+
water	27:34	0:0	4	(
water	27:35	0:0	4	mb_y
op	27:40	0:0	4	*
water	27:42	0:0	4	linesize
op	27:51	0:0	4	*
water	27:53	0:0	4	8
op	27:55	0:0	4	>>
water	27:58	0:0	4	s
op	27:59	0:0	4	->
water	27:61	0:0	4	avctx
op	27:66	0:0	4	->
water	27:68	0:0	4	lowres
water	27:74	0:0	4	)
decl	28:8	28:52	4	int	block_idx
op	28:25	0:0	4	=
water	28:27	0:0	4	mb_y
op	28:32	0:0	4	*
water	28:34	0:0	4	s
op	28:35	0:0	4	->
water	28:37	0:0	4	block_stride
op	28:49	0:0	4	[
water	28:50	0:0	4	c
op	28:51	0:0	4	]
call	29:8	29:23	4	DCTELEM
arg	29:17	29:23	5	*block
op	29:17	0:0	6	*
water	29:18	0:0	6	block
op	29:24	0:0	4	[
water	29:25	0:0	4	64
op	29:27	0:0	4	]
op	29:29	0:0	4	=
op	29:31	0:0	4	&
water	29:32	0:0	4	s
op	29:33	0:0	4	->
water	29:35	0:0	4	blocks
op	29:41	0:0	4	[
water	29:42	0:0	4	c
op	29:43	0:0	4	]
op	29:44	0:0	4	[
water	29:45	0:0	4	block_idx
op	29:54	0:0	4	]
water	29:55	0:0	4	;
decl	30:8	30:57	4	uint8_t	*last_nnz
op	30:29	0:0	4	=
op	30:31	0:0	4	&
water	30:32	0:0	4	s
op	30:33	0:0	4	->
water	30:35	0:0	4	last_nnz
op	30:43	0:0	4	[
water	30:44	0:0	4	c
op	30:45	0:0	4	]
op	30:46	0:0	4	[
water	30:47	0:0	4	block_idx
op	30:56	0:0	4	]
for	31:8	49:8	4	(mb_x = 0 ;mb_x < s -> mb_width;mb_x ++ , block ++ , last_nnz ++)
forinit	31:13	31:21	5	mb_x = 0 ;
water	31:13	0:0	6	mb_x
op	31:18	0:0	6	=
water	31:20	0:0	6	0
water	31:21	0:0	6	;
cond	31:23	31:33	5	mb_x < s -> mb_width
water	31:23	0:0	6	mb_x
op	31:28	0:0	6	<
water	31:30	0:0	6	s
op	31:31	0:0	6	->
water	31:33	0:0	6	mb_width
forexpr	31:43	31:68	5	mb_x ++ , block ++ , last_nnz ++
water	31:43	0:0	6	mb_x
op	31:47	0:0	6	++
water	31:49	0:0	6	,
water	31:51	0:0	6	block
op	31:56	0:0	6	++
water	31:58	0:0	6	,
water	31:60	0:0	6	last_nnz
op	31:68	0:0	6	++
stmts	31:72	49:8	5	
water	31:72	0:0	6	{
decl	32:16	32:23	6	int	ret
if	33:16	35:84	6	(Ah)
cond	33:20	33:20	7	Ah
water	33:20	0:0	8	Ah
stmts	34:20	35:84	7	
water	34:20	0:0	8	ret
op	34:24	0:0	8	=
call	34:26	35:83	8	decode_block_refinement
arg	34:50	34:51	9	s
water	34:50	0:0	10	s
arg	34:53	34:59	9	*block
op	34:53	0:0	10	*
water	34:54	0:0	10	block
arg	34:61	34:69	9	last_nnz
water	34:61	0:0	10	last_nnz
arg	34:71	34:85	9	s->ac_index[0]
water	34:71	0:0	10	s
op	34:72	0:0	10	->
water	34:74	0:0	10	ac_index
op	34:82	0:0	10	[
water	34:83	0:0	10	0
op	34:84	0:0	10	]
arg	35:50	35:62	9	quant_matrix
water	35:50	0:0	10	quant_matrix
arg	35:64	35:66	9	ss
water	35:64	0:0	10	ss
arg	35:68	35:70	9	se
water	35:68	0:0	10	se
arg	35:72	35:74	9	Al
water	35:72	0:0	10	Al
arg	35:76	35:83	9	&EOBRUN
op	35:76	0:0	10	&
water	35:77	0:0	10	EOBRUN
water	35:84	0:0	8	;
else	36:16	38:85	6
stmts	37:20	38:85	7	
water	37:20	0:0	8	ret
op	37:24	0:0	8	=
call	37:26	38:84	8	decode_block_progressive
arg	37:51	37:52	9	s
water	37:51	0:0	10	s
arg	37:54	37:60	9	*block
op	37:54	0:0	10	*
water	37:55	0:0	10	block
arg	37:62	37:70	9	last_nnz
water	37:62	0:0	10	last_nnz
arg	37:72	37:86	9	s->ac_index[0]
water	37:72	0:0	10	s
op	37:73	0:0	10	->
water	37:75	0:0	10	ac_index
op	37:83	0:0	10	[
water	37:84	0:0	10	0
op	37:85	0:0	10	]
arg	38:51	38:63	9	quant_matrix
water	38:51	0:0	10	quant_matrix
arg	38:65	38:67	9	ss
water	38:65	0:0	10	ss
arg	38:69	38:71	9	se
water	38:69	0:0	10	se
arg	38:73	38:75	9	Al
water	38:73	0:0	10	Al
arg	38:77	38:84	9	&EOBRUN
op	38:77	0:0	10	&
water	38:78	0:0	10	EOBRUN
water	38:85	0:0	8	;
if	39:16	43:16	6	(ret < 0)
cond	39:20	39:26	7	ret < 0
water	39:20	0:0	8	ret
op	39:24	0:0	8	<
water	39:26	0:0	8	0
stmts	39:29	43:16	7	
water	39:29	0:0	8	{
call	40:20	41:58	8	av_log
arg	40:27	40:35	9	s->avctx
water	40:27	0:0	10	s
op	40:28	0:0	10	->
water	40:30	0:0	10	avctx
arg	40:37	40:49	9	AV_LOG_ERROR
water	40:37	0:0	10	AV_LOG_ERROR
arg	41:27	41:46	9	"error y=%d x=%d\n"
water	41:27	0:0	10	"error y=%d x=%d\n"
arg	41:48	41:52	9	mb_y
water	41:48	0:0	10	mb_y
arg	41:54	41:58	9	mb_x
water	41:54	0:0	10	mb_x
water	41:59	0:0	8	;
return	42:20	42:46	8	AVERROR_INVALIDDATA
water	42:27	0:0	9	AVERROR_INVALIDDATA
water	43:16	0:0	8	}
if	45:12	48:12	6	(last_scan)
cond	45:16	45:16	7	last_scan
water	45:16	0:0	8	last_scan
stmts	45:27	48:12	7	
water	45:27	0:0	8	{
call	46:20	46:57	8	s->dsp.idct_put
arg	46:36	46:39	9	ptr
water	46:36	0:0	10	ptr
arg	46:41	46:49	9	linesize
water	46:41	0:0	10	linesize
arg	46:51	46:57	9	*block
op	46:51	0:0	10	*
water	46:52	0:0	10	block
water	46:58	0:0	8	;
water	47:20	0:0	8	ptr
op	47:24	0:0	8	+=
water	47:27	0:0	8	8
op	47:29	0:0	8	>>
water	47:32	0:0	8	s
op	47:33	0:0	8	->
water	47:35	0:0	8	avctx
op	47:40	0:0	8	->
water	47:42	0:0	8	lowres
water	47:48	0:0	8	;
water	48:12	0:0	8	}
water	49:8	0:0	6	}
water	50:4	0:0	4	}
return	51:4	51:12	2	0
water	51:11	0:0	3	0
