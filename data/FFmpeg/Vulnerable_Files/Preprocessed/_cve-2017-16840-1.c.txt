func	1:15	174:0	0	int	vc2_encode_init
params	1:34	0:0	1	
param	1:35	1:56	2	AVCodecContext *	avctx
stmnts	0:0	173:26	1	
decl	3:4	3:12	2	Plane	*p
decl	4:4	4:14	2	SubBand	*b
decl	5:4	5:29	2	int	i
water	5:9	0:0	2	,
decl	5:4	5:29	2	int	j
water	5:12	0:0	2	,
decl	5:4	5:29	2	int	level
water	5:19	0:0	2	,
decl	5:4	5:29	2	int	o
water	5:22	0:0	2	,
decl	5:4	5:29	2	int	shift
decl	6:4	6:71	2	const AVPixFmtDescriptor	*fmt
op	6:34	0:0	2	=
call	6:36	6:70	3	av_pix_fmt_desc_get
arg	6:56	6:70	4	avctx->pix_fmt
water	6:56	0:0	5	avctx
op	6:61	0:0	5	->
water	6:63	0:0	5	pix_fmt
decl	7:4	7:40	2	const int	depth
op	7:20	0:0	2	=
water	7:22	0:0	2	fmt
op	7:25	0:0	2	->
water	7:27	0:0	2	comp
op	7:31	0:0	2	[
water	7:32	0:0	2	0
op	7:33	0:0	2	]
op	7:34	0:0	2	.
water	7:35	0:0	2	depth
decl	8:4	8:39	2	VC2EncContext	*s
op	8:21	0:0	2	=
water	8:23	0:0	2	avctx
op	8:28	0:0	2	->
water	8:30	0:0	2	priv_data
water	10:4	0:0	2	s
op	10:5	0:0	2	->
water	10:7	0:0	2	picture_number
op	10:22	0:0	2	=
water	10:24	0:0	2	0
water	10:25	0:0	2	;
water	13:4	0:0	2	s
op	13:5	0:0	2	->
water	13:7	0:0	2	q_ceil
op	13:17	0:0	2	=
water	13:19	0:0	2	DIRAC_MAX_QUANT_INDEX
water	13:40	0:0	2	;
water	15:4	0:0	2	s
op	15:5	0:0	2	->
water	15:7	0:0	2	ver
op	15:10	0:0	2	.
water	15:11	0:0	2	major
op	15:17	0:0	2	=
water	15:19	0:0	2	2
water	15:20	0:0	2	;
water	16:4	0:0	2	s
op	16:5	0:0	2	->
water	16:7	0:0	2	ver
op	16:10	0:0	2	.
water	16:11	0:0	2	minor
op	16:17	0:0	2	=
water	16:19	0:0	2	0
water	16:20	0:0	2	;
water	17:4	0:0	2	s
op	17:5	0:0	2	->
water	17:7	0:0	2	profile
op	17:17	0:0	2	=
water	17:19	0:0	2	3
water	17:20	0:0	2	;
water	18:4	0:0	2	s
op	18:5	0:0	2	->
water	18:7	0:0	2	level
op	18:17	0:0	2	=
water	18:19	0:0	2	3
water	18:20	0:0	2	;
water	20:4	0:0	2	s
op	20:5	0:0	2	->
water	20:7	0:0	2	base_vf
op	20:17	0:0	2	=
op	20:19	0:0	2	-
water	20:20	0:0	2	1
water	20:21	0:0	2	;
water	21:4	0:0	2	s
op	21:5	0:0	2	->
water	21:7	0:0	2	strict_compliance
op	21:25	0:0	2	=
water	21:27	0:0	2	1
water	21:28	0:0	2	;
water	23:4	0:0	2	s
op	23:5	0:0	2	->
water	23:7	0:0	2	q_avg
op	23:13	0:0	2	=
water	23:15	0:0	2	0
water	23:16	0:0	2	;
water	24:4	0:0	2	s
op	24:5	0:0	2	->
water	24:7	0:0	2	slice_max_bytes
op	24:23	0:0	2	=
water	24:25	0:0	2	0
water	24:26	0:0	2	;
water	25:4	0:0	2	s
op	25:5	0:0	2	->
water	25:7	0:0	2	slice_min_bytes
op	25:23	0:0	2	=
water	25:25	0:0	2	0
water	25:26	0:0	2	;
water	28:4	0:0	2	s
op	28:5	0:0	2	->
water	28:7	0:0	2	interlaced
op	28:18	0:0	2	=
op	28:20	0:0	2	!
water	28:21	0:0	2	(
water	28:22	0:0	2	(
water	28:23	0:0	2	avctx
op	28:28	0:0	2	->
water	28:30	0:0	2	field_order
op	28:42	0:0	2	==
water	28:45	0:0	2	AV_FIELD_UNKNOWN
water	28:61	0:0	2	)
op	28:63	0:0	2	||
water	29:22	0:0	2	(
water	29:23	0:0	2	avctx
op	29:28	0:0	2	->
water	29:30	0:0	2	field_order
op	29:42	0:0	2	==
water	29:45	0:0	2	AV_FIELD_PROGRESSIVE
water	29:65	0:0	2	)
water	29:66	0:0	2	)
water	29:67	0:0	2	;
for	31:4	48:4	2	(i = 0 ;i < base_video_fmts_len;i ++)
forinit	31:9	31:14	3	i = 0 ;
water	31:9	0:0	4	i
op	31:11	0:0	4	=
water	31:13	0:0	4	0
water	31:14	0:0	4	;
cond	31:16	31:20	3	i < base_video_fmts_len
water	31:16	0:0	4	i
op	31:18	0:0	4	<
water	31:20	0:0	4	base_video_fmts_len
forexpr	31:41	31:42	3	i ++
water	31:41	0:0	4	i
op	31:42	0:0	4	++
stmts	31:46	48:4	3	
water	31:46	0:0	4	{
decl	32:8	32:59	4	const VC2BaseVideoFormat	*fmt
op	32:38	0:0	4	=
op	32:40	0:0	4	&
water	32:41	0:0	4	base_video_fmts
op	32:56	0:0	4	[
water	32:57	0:0	4	i
op	32:58	0:0	4	]
if	33:8	34:20	4	(avctx -> pix_fmt != fmt -> pix_fmt)
cond	33:12	33:35	5	avctx -> pix_fmt != fmt -> pix_fmt
water	33:12	0:0	6	avctx
op	33:17	0:0	6	->
water	33:19	0:0	6	pix_fmt
op	33:27	0:0	6	!=
water	33:30	0:0	6	fmt
op	33:33	0:0	6	->
water	33:35	0:0	6	pix_fmt
stmts	34:12	34:20	5	
continue	34:12	34:20	6	
if	35:8	36:20	4	(avctx -> time_base . num != fmt -> time_base . num)
cond	35:12	35:51	5	avctx -> time_base . num != fmt -> time_base . num
water	35:12	0:0	6	avctx
op	35:17	0:0	6	->
water	35:19	0:0	6	time_base
op	35:28	0:0	6	.
water	35:29	0:0	6	num
op	35:33	0:0	6	!=
water	35:36	0:0	6	fmt
op	35:39	0:0	6	->
water	35:41	0:0	6	time_base
op	35:50	0:0	6	.
water	35:51	0:0	6	num
stmts	36:12	36:20	5	
continue	36:12	36:20	6	
if	37:8	38:20	4	(avctx -> time_base . den != fmt -> time_base . den)
cond	37:12	37:51	5	avctx -> time_base . den != fmt -> time_base . den
water	37:12	0:0	6	avctx
op	37:17	0:0	6	->
water	37:19	0:0	6	time_base
op	37:28	0:0	6	.
water	37:29	0:0	6	den
op	37:33	0:0	6	!=
water	37:36	0:0	6	fmt
op	37:39	0:0	6	->
water	37:41	0:0	6	time_base
op	37:50	0:0	6	.
water	37:51	0:0	6	den
stmts	38:12	38:20	5	
continue	38:12	38:20	6	
if	39:8	40:20	4	(avctx -> width != fmt -> width)
cond	39:12	39:33	5	avctx -> width != fmt -> width
water	39:12	0:0	6	avctx
op	39:17	0:0	6	->
water	39:19	0:0	6	width
op	39:25	0:0	6	!=
water	39:28	0:0	6	fmt
op	39:31	0:0	6	->
water	39:33	0:0	6	width
stmts	40:12	40:20	5	
continue	40:12	40:20	6	
if	41:8	42:20	4	(avctx -> height != fmt -> height)
cond	41:12	41:34	5	avctx -> height != fmt -> height
water	41:12	0:0	6	avctx
op	41:17	0:0	6	->
water	41:19	0:0	6	height
op	41:26	0:0	6	!=
water	41:29	0:0	6	fmt
op	41:32	0:0	6	->
water	41:34	0:0	6	height
stmts	42:12	42:20	5	
continue	42:12	42:20	6	
if	43:8	44:20	4	(s -> interlaced != fmt -> interlaced)
cond	43:12	43:34	5	s -> interlaced != fmt -> interlaced
water	43:12	0:0	6	s
op	43:13	0:0	6	->
water	43:15	0:0	6	interlaced
op	43:26	0:0	6	!=
water	43:29	0:0	6	fmt
op	43:32	0:0	6	->
water	43:34	0:0	6	interlaced
stmts	44:12	44:20	5	
continue	44:12	44:20	6	
water	45:8	0:0	4	s
op	45:9	0:0	4	->
water	45:11	0:0	4	base_vf
op	45:19	0:0	4	=
water	45:21	0:0	4	i
water	45:22	0:0	4	;
water	46:8	0:0	4	s
op	46:9	0:0	4	->
water	46:11	0:0	4	level
op	46:19	0:0	4	=
water	46:21	0:0	4	base_video_fmts
op	46:36	0:0	4	[
water	46:37	0:0	4	i
op	46:38	0:0	4	]
op	46:39	0:0	4	.
water	46:40	0:0	4	level
water	46:45	0:0	4	;
break	47:8	47:13	4	
water	48:4	0:0	4	}
if	50:4	51:63	2	(s -> interlaced)
cond	50:8	50:11	3	s -> interlaced
water	50:8	0:0	4	s
op	50:9	0:0	4	->
water	50:11	0:0	4	interlaced
stmts	51:8	51:63	3	
call	51:8	51:62	4	av_log
arg	51:15	51:20	5	avctx
water	51:15	0:0	6	avctx
arg	51:22	51:36	5	AV_LOG_WARNING
water	51:22	0:0	6	AV_LOG_WARNING
arg	51:38	51:62	5	"Interlacing enabled!\n"
water	51:38	0:0	6	"Interlacing enabled!\n"
water	51:63	0:0	4	;
if	53:4	57:4	2	(( s -> slice_width & ( s -> slice_width - 1 ) ) || ( s -> slice_height & ( s -> slice_height - 1 ) ))
cond	53:8	54:48	3	( s -> slice_width & ( s -> slice_width - 1 ) ) || ( s -> slice_height & ( s -> slice_height - 1 ) )
water	53:8	0:0	4	(
water	53:9	0:0	4	s
op	53:10	0:0	4	->
water	53:12	0:0	4	slice_width
op	53:25	0:0	4	&
water	53:27	0:0	4	(
water	53:28	0:0	4	s
op	53:29	0:0	4	->
water	53:31	0:0	4	slice_width
op	53:44	0:0	4	-
water	53:46	0:0	4	1
water	53:47	0:0	4	)
water	53:48	0:0	4	)
op	53:50	0:0	4	||
water	54:8	0:0	4	(
water	54:9	0:0	4	s
op	54:10	0:0	4	->
water	54:12	0:0	4	slice_height
op	54:25	0:0	4	&
water	54:27	0:0	4	(
water	54:28	0:0	4	s
op	54:29	0:0	4	->
water	54:31	0:0	4	slice_height
op	54:44	0:0	4	-
water	54:46	0:0	4	1
water	54:47	0:0	4	)
water	54:48	0:0	4	)
stmts	54:51	57:4	3	
water	54:51	0:0	4	{
call	55:8	55:73	4	av_log
arg	55:15	55:20	5	avctx
water	55:15	0:0	6	avctx
arg	55:22	55:34	5	AV_LOG_ERROR
water	55:22	0:0	6	AV_LOG_ERROR
arg	55:36	55:73	5	"Slice size is not a power of two!\n"
water	55:36	0:0	6	"Slice size is not a power of two!\n"
water	55:74	0:0	4	;
return	56:8	56:30	4	AVERROR_UNKNOWN
water	56:15	0:0	5	AVERROR_UNKNOWN
water	57:4	0:0	4	}
if	59:4	63:4	2	(( s -> slice_width > avctx -> width ) || ( s -> slice_height > avctx -> height ))
cond	59:8	60:40	3	( s -> slice_width > avctx -> width ) || ( s -> slice_height > avctx -> height )
water	59:8	0:0	4	(
water	59:9	0:0	4	s
op	59:10	0:0	4	->
water	59:12	0:0	4	slice_width
op	59:24	0:0	4	>
water	59:26	0:0	4	avctx
op	59:31	0:0	4	->
water	59:33	0:0	4	width
water	59:38	0:0	4	)
op	59:40	0:0	4	||
water	60:8	0:0	4	(
water	60:9	0:0	4	s
op	60:10	0:0	4	->
water	60:12	0:0	4	slice_height
op	60:25	0:0	4	>
water	60:27	0:0	4	avctx
op	60:32	0:0	4	->
water	60:34	0:0	4	height
water	60:40	0:0	4	)
stmts	60:43	63:4	3	
water	60:43	0:0	4	{
call	61:8	61:76	4	av_log
arg	61:15	61:20	5	avctx
water	61:15	0:0	6	avctx
arg	61:22	61:34	5	AV_LOG_ERROR
water	61:22	0:0	6	AV_LOG_ERROR
arg	61:36	61:76	5	"Slice size is bigger than the image!\n"
water	61:36	0:0	6	"Slice size is bigger than the image!\n"
water	61:77	0:0	4	;
return	62:8	62:30	4	AVERROR_UNKNOWN
water	62:15	0:0	5	AVERROR_UNKNOWN
water	63:4	0:0	4	}
if	65:4	74:4	2	(s -> base_vf <= 0)
cond	65:8	65:22	3	s -> base_vf <= 0
water	65:8	0:0	4	s
op	65:9	0:0	4	->
water	65:11	0:0	4	base_vf
op	65:19	0:0	4	<=
water	65:22	0:0	4	0
stmts	65:25	74:4	3	
water	65:25	0:0	4	{
if	66:8	69:8	4	(avctx -> strict_std_compliance < FF_COMPLIANCE_STRICT)
cond	66:12	66:43	5	avctx -> strict_std_compliance < FF_COMPLIANCE_STRICT
water	66:12	0:0	6	avctx
op	66:17	0:0	6	->
water	66:19	0:0	6	strict_std_compliance
op	66:41	0:0	6	<
water	66:43	0:0	6	FF_COMPLIANCE_STRICT
stmts	66:65	69:8	5	
water	66:65	0:0	6	{
water	67:12	0:0	6	s
op	67:13	0:0	6	->
water	67:15	0:0	6	strict_compliance
op	67:33	0:0	6	=
water	67:35	0:0	6	s
op	67:36	0:0	6	->
water	67:38	0:0	6	base_vf
op	67:46	0:0	6	=
water	67:48	0:0	6	0
water	67:49	0:0	6	;
call	68:12	68:92	6	av_log
arg	68:19	68:24	7	avctx
water	68:19	0:0	8	avctx
arg	68:26	68:40	7	AV_LOG_WARNING
water	68:26	0:0	8	AV_LOG_WARNING
arg	68:42	68:92	7	"Format does not strictly comply with VC2 specs\n"
water	68:42	0:0	8	"Format does not strictly comply with VC2 specs\n"
water	68:93	0:0	6	;
water	69:8	0:0	6	}
else	69:10	73:8	4
stmts	69:15	73:8	5	
water	69:15	0:0	6	{
call	70:12	71:73	6	av_log
arg	70:19	70:24	7	avctx
water	70:19	0:0	8	avctx
arg	70:26	70:40	7	AV_LOG_WARNING
water	70:26	0:0	8	AV_LOG_WARNING
arg	70:42	71:73	7	"Given format does not strictly comply with ""the specifications, decrease strictness to use it.\n"
water	70:42	0:0	8	"Given format does not strictly comply with "
water	71:19	0:0	8	"the specifications, decrease strictness to use it.\n"
water	71:74	0:0	6	;
return	72:12	72:34	6	AVERROR_UNKNOWN
water	72:19	0:0	7	AVERROR_UNKNOWN
water	73:8	0:0	6	}
water	74:4	0:0	4	}
else	74:6	77:4	2
stmts	74:11	77:4	3	
water	74:11	0:0	4	{
call	75:8	76:59	4	av_log
arg	75:15	75:20	5	avctx
water	75:15	0:0	6	avctx
arg	75:22	75:33	5	AV_LOG_INFO
water	75:22	0:0	6	AV_LOG_INFO
arg	75:35	75:75	5	"Selected base video format = %i (%s)\n"
water	75:35	0:0	6	"Selected base video format = %i (%s)\n"
arg	76:15	76:25	5	s->base_vf
water	76:15	0:0	6	s
op	76:16	0:0	6	->
water	76:18	0:0	6	base_vf
arg	76:27	76:59	5	base_video_fmts[s->base_vf].name
water	76:27	0:0	6	base_video_fmts
op	76:42	0:0	6	[
water	76:43	0:0	6	s
op	76:44	0:0	6	->
water	76:46	0:0	6	base_vf
op	76:53	0:0	6	]
op	76:54	0:0	6	.
water	76:55	0:0	6	name
water	76:60	0:0	4	;
water	77:4	0:0	4	}
call	80:4	80:88	2	avcodec_get_chroma_sub_sample
arg	80:34	80:48	3	avctx->pix_fmt
water	80:34	0:0	4	avctx
op	80:39	0:0	4	->
water	80:41	0:0	4	pix_fmt
arg	80:50	80:68	3	&s->chroma_x_shift
op	80:50	0:0	4	&
water	80:51	0:0	4	s
op	80:52	0:0	4	->
water	80:54	0:0	4	chroma_x_shift
arg	80:70	80:88	3	&s->chroma_y_shift
op	80:70	0:0	4	&
water	80:71	0:0	4	s
op	80:72	0:0	4	->
water	80:74	0:0	4	chroma_y_shift
water	80:89	0:0	2	;
if	83:4	87:4	2	(depth == 8 && avctx -> color_range == AVCOL_RANGE_JPEG)
cond	83:8	83:44	3	depth == 8 && avctx -> color_range == AVCOL_RANGE_JPEG
water	83:8	0:0	4	depth
op	83:14	0:0	4	==
water	83:17	0:0	4	8
op	83:19	0:0	4	&&
water	83:22	0:0	4	avctx
op	83:27	0:0	4	->
water	83:29	0:0	4	color_range
op	83:41	0:0	4	==
water	83:44	0:0	4	AVCOL_RANGE_JPEG
stmts	83:62	87:4	3	
water	83:62	0:0	4	{
water	84:8	0:0	4	s
op	84:9	0:0	4	->
water	84:11	0:0	4	bpp
op	84:15	0:0	4	=
water	84:17	0:0	4	1
water	84:18	0:0	4	;
water	85:8	0:0	4	s
op	85:9	0:0	4	->
water	85:11	0:0	4	bpp_idx
op	85:19	0:0	4	=
water	85:21	0:0	4	1
water	85:22	0:0	4	;
water	86:8	0:0	4	s
op	86:9	0:0	4	->
water	86:11	0:0	4	diff_offset
op	86:23	0:0	4	=
water	86:25	0:0	4	128
water	86:28	0:0	4	;
water	87:4	0:0	4	}
else	87:6	92:4	2
stmts	87:11	92:4	3	
if	87:11	92:4	4	(depth == 8 && ( avctx -> color_range == AVCOL_RANGE_MPEG || avctx -> color_range == AVCOL_RANGE_UNSPECIFIED ))
cond	87:15	88:60	5	depth == 8 && ( avctx -> color_range == AVCOL_RANGE_MPEG || avctx -> color_range == AVCOL_RANGE_UNSPECIFIED )
water	87:15	0:0	6	depth
op	87:21	0:0	6	==
water	87:24	0:0	6	8
op	87:26	0:0	6	&&
water	87:29	0:0	6	(
water	87:30	0:0	6	avctx
op	87:35	0:0	6	->
water	87:37	0:0	6	color_range
op	87:49	0:0	6	==
water	87:52	0:0	6	AVCOL_RANGE_MPEG
op	87:69	0:0	6	||
water	88:15	0:0	6	avctx
op	88:20	0:0	6	->
water	88:22	0:0	6	color_range
op	88:34	0:0	6	==
water	88:37	0:0	6	AVCOL_RANGE_UNSPECIFIED
water	88:60	0:0	6	)
stmts	88:63	92:4	5	
water	88:63	0:0	6	{
water	89:8	0:0	6	s
op	89:9	0:0	6	->
water	89:11	0:0	6	bpp
op	89:15	0:0	6	=
water	89:17	0:0	6	1
water	89:18	0:0	6	;
water	90:8	0:0	6	s
op	90:9	0:0	6	->
water	90:11	0:0	6	bpp_idx
op	90:19	0:0	6	=
water	90:21	0:0	6	2
water	90:22	0:0	6	;
water	91:8	0:0	6	s
op	91:9	0:0	6	->
water	91:11	0:0	6	diff_offset
op	91:23	0:0	6	=
water	91:25	0:0	6	128
water	91:28	0:0	6	;
water	92:4	0:0	6	}
else	92:6	96:4	2
stmts	92:11	96:4	3	
if	92:11	96:4	4	(depth == 10)
cond	92:15	92:24	5	depth == 10
water	92:15	0:0	6	depth
op	92:21	0:0	6	==
water	92:24	0:0	6	10
stmts	92:28	96:4	5	
water	92:28	0:0	6	{
water	93:8	0:0	6	s
op	93:9	0:0	6	->
water	93:11	0:0	6	bpp
op	93:15	0:0	6	=
water	93:17	0:0	6	2
water	93:18	0:0	6	;
water	94:8	0:0	6	s
op	94:9	0:0	6	->
water	94:11	0:0	6	bpp_idx
op	94:19	0:0	6	=
water	94:21	0:0	6	3
water	94:22	0:0	6	;
water	95:8	0:0	6	s
op	95:9	0:0	6	->
water	95:11	0:0	6	diff_offset
op	95:23	0:0	6	=
water	95:25	0:0	6	512
water	95:28	0:0	6	;
water	96:4	0:0	6	}
else	96:6	100:4	2
stmts	96:11	100:4	3	
water	96:11	0:0	4	{
water	97:8	0:0	4	s
op	97:9	0:0	4	->
water	97:11	0:0	4	bpp
op	97:15	0:0	4	=
water	97:17	0:0	4	2
water	97:18	0:0	4	;
water	98:8	0:0	4	s
op	98:9	0:0	4	->
water	98:11	0:0	4	bpp_idx
op	98:19	0:0	4	=
water	98:21	0:0	4	4
water	98:22	0:0	4	;
water	99:8	0:0	4	s
op	99:9	0:0	4	->
water	99:11	0:0	4	diff_offset
op	99:23	0:0	4	=
water	99:25	0:0	4	2048
water	99:29	0:0	4	;
water	100:4	0:0	4	}
for	103:4	134:4	2	(i = 0 ;i < 3;i ++)
forinit	103:9	103:14	3	i = 0 ;
water	103:9	0:0	4	i
op	103:11	0:0	4	=
water	103:13	0:0	4	0
water	103:14	0:0	4	;
cond	103:16	103:20	3	i < 3
water	103:16	0:0	4	i
op	103:18	0:0	4	<
water	103:20	0:0	4	3
forexpr	103:23	103:24	3	i ++
water	103:23	0:0	4	i
op	103:24	0:0	4	++
stmts	103:28	134:4	3	
water	103:28	0:0	4	{
decl	104:8	104:16	4	int	w
water	104:13	0:0	4	,
decl	104:8	104:16	4	int	h
water	105:8	0:0	4	p
op	105:10	0:0	4	=
op	105:12	0:0	4	&
water	105:13	0:0	4	s
op	105:14	0:0	4	->
water	105:16	0:0	4	plane
op	105:21	0:0	4	[
water	105:22	0:0	4	i
op	105:23	0:0	4	]
water	105:24	0:0	4	;
water	106:8	0:0	4	p
op	106:9	0:0	4	->
water	106:11	0:0	4	width
op	106:22	0:0	4	=
water	106:24	0:0	4	avctx
op	106:29	0:0	4	->
water	106:31	0:0	4	width
op	106:38	0:0	4	>>
water	106:41	0:0	4	(
water	106:42	0:0	4	i
water	106:44	0:0	4	?
water	106:46	0:0	4	s
op	106:47	0:0	4	->
water	106:49	0:0	4	chroma_x_shift
water	106:64	0:0	4	:
water	106:66	0:0	4	0
water	106:67	0:0	4	)
water	106:68	0:0	4	;
water	107:8	0:0	4	p
op	107:9	0:0	4	->
water	107:11	0:0	4	height
op	107:22	0:0	4	=
water	107:24	0:0	4	avctx
op	107:29	0:0	4	->
water	107:31	0:0	4	height
op	107:38	0:0	4	>>
water	107:41	0:0	4	(
water	107:42	0:0	4	i
water	107:44	0:0	4	?
water	107:46	0:0	4	s
op	107:47	0:0	4	->
water	107:49	0:0	4	chroma_y_shift
water	107:64	0:0	4	:
water	107:66	0:0	4	0
water	107:67	0:0	4	)
water	107:68	0:0	4	;
if	108:8	109:27	4	(s -> interlaced)
cond	108:12	108:15	5	s -> interlaced
water	108:12	0:0	6	s
op	108:13	0:0	6	->
water	108:15	0:0	6	interlaced
stmts	109:12	109:27	5	
water	109:12	0:0	6	p
op	109:13	0:0	6	->
water	109:15	0:0	6	height
op	109:22	0:0	6	>>=
water	109:26	0:0	6	1
water	109:27	0:0	6	;
water	110:8	0:0	4	p
op	110:9	0:0	4	->
water	110:11	0:0	4	dwt_width
op	110:22	0:0	4	=
water	110:24	0:0	4	w
op	110:26	0:0	4	=
call	110:28	110:70	4	FFALIGN
arg	110:36	110:44	5	p->width
water	110:36	0:0	6	p
op	110:37	0:0	6	->
water	110:39	0:0	6	width
arg	110:47	110:70	5	(1<<s->wavelet_depth)
water	110:47	0:0	6	(
water	110:48	0:0	6	1
op	110:50	0:0	6	<<
water	110:53	0:0	6	s
op	110:54	0:0	6	->
water	110:56	0:0	6	wavelet_depth
water	110:69	0:0	6	)
water	110:71	0:0	4	;
water	111:8	0:0	4	p
op	111:9	0:0	4	->
water	111:11	0:0	4	dwt_height
op	111:22	0:0	4	=
water	111:24	0:0	4	h
op	111:26	0:0	4	=
call	111:28	111:70	4	FFALIGN
arg	111:36	111:45	5	p->height
water	111:36	0:0	6	p
op	111:37	0:0	6	->
water	111:39	0:0	6	height
arg	111:47	111:70	5	(1<<s->wavelet_depth)
water	111:47	0:0	6	(
water	111:48	0:0	6	1
op	111:50	0:0	6	<<
water	111:53	0:0	6	s
op	111:54	0:0	6	->
water	111:56	0:0	6	wavelet_depth
water	111:69	0:0	6	)
water	111:71	0:0	4	;
water	112:8	0:0	4	p
op	112:9	0:0	4	->
water	112:11	0:0	4	coef_stride
op	112:23	0:0	4	=
call	112:25	112:49	4	FFALIGN
arg	112:33	112:45	5	p->dwt_width
water	112:33	0:0	6	p
op	112:34	0:0	6	->
water	112:36	0:0	6	dwt_width
arg	112:47	112:49	5	32
water	112:47	0:0	6	32
water	112:50	0:0	4	;
water	113:8	0:0	4	p
op	113:9	0:0	4	->
water	113:11	0:0	4	coef_buf
op	113:20	0:0	4	=
call	113:22	113:76	4	av_malloc
arg	113:32	113:76	5	p->coef_stride*p->dwt_height*sizeof(dwtcoef)
water	113:32	0:0	6	p
op	113:33	0:0	6	->
water	113:35	0:0	6	coef_stride
op	113:46	0:0	6	*
water	113:47	0:0	6	p
op	113:48	0:0	6	->
water	113:50	0:0	6	dwt_height
op	113:60	0:0	6	*
op	113:61	0:0	6	sizeof
water	113:67	0:0	6	(
water	113:68	0:0	6	dwtcoef
water	113:75	0:0	6	)
water	113:77	0:0	4	;
if	114:8	115:27	4	(! p -> coef_buf)
cond	114:12	114:16	5	! p -> coef_buf
op	114:12	0:0	6	!
water	114:13	0:0	6	p
op	114:14	0:0	6	->
water	114:16	0:0	6	coef_buf
stmts	115:12	115:27	5	
goto	115:12	115:27	6	alloc_fail
water	115:17	0:0	7	alloc_fail
for	116:8	127:8	4	(level = s -> wavelet_depth - 1 ;level >= 0;level --)
forinit	116:13	116:39	5	level = s -> wavelet_depth - 1 ;
water	116:13	0:0	6	level
op	116:19	0:0	6	=
water	116:21	0:0	6	s
op	116:22	0:0	6	->
water	116:24	0:0	6	wavelet_depth
op	116:37	0:0	6	-
water	116:38	0:0	6	1
water	116:39	0:0	6	;
cond	116:41	116:50	5	level >= 0
water	116:41	0:0	6	level
op	116:47	0:0	6	>=
water	116:50	0:0	6	0
forexpr	116:53	116:58	5	level --
water	116:53	0:0	6	level
op	116:58	0:0	6	--
stmts	116:62	127:8	5	
water	116:62	0:0	6	{
water	117:12	0:0	6	w
op	117:14	0:0	6	=
water	117:16	0:0	6	w
op	117:18	0:0	6	>>
water	117:21	0:0	6	1
water	117:22	0:0	6	;
water	118:12	0:0	6	h
op	118:14	0:0	6	=
water	118:16	0:0	6	h
op	118:18	0:0	6	>>
water	118:21	0:0	6	1
water	118:22	0:0	6	;
for	119:12	126:12	6	(o = 0 ;o < 4;o ++)
forinit	119:17	119:22	7	o = 0 ;
water	119:17	0:0	8	o
op	119:19	0:0	8	=
water	119:21	0:0	8	0
water	119:22	0:0	8	;
cond	119:24	119:28	7	o < 4
water	119:24	0:0	8	o
op	119:26	0:0	8	<
water	119:28	0:0	8	4
forexpr	119:31	119:32	7	o ++
water	119:31	0:0	8	o
op	119:32	0:0	8	++
stmts	119:36	126:12	7	
water	119:36	0:0	8	{
water	120:16	0:0	8	b
op	120:18	0:0	8	=
op	120:20	0:0	8	&
water	120:21	0:0	8	p
op	120:22	0:0	8	->
water	120:24	0:0	8	band
op	120:28	0:0	8	[
water	120:29	0:0	8	level
op	120:34	0:0	8	]
op	120:35	0:0	8	[
water	120:36	0:0	8	o
op	120:37	0:0	8	]
water	120:38	0:0	8	;
water	121:16	0:0	8	b
op	121:17	0:0	8	->
water	121:19	0:0	8	width
op	121:26	0:0	8	=
water	121:28	0:0	8	w
water	121:29	0:0	8	;
water	122:16	0:0	8	b
op	122:17	0:0	8	->
water	122:19	0:0	8	height
op	122:26	0:0	8	=
water	122:28	0:0	8	h
water	122:29	0:0	8	;
water	123:16	0:0	8	b
op	123:17	0:0	8	->
water	123:19	0:0	8	stride
op	123:26	0:0	8	=
water	123:28	0:0	8	p
op	123:29	0:0	8	->
water	123:31	0:0	8	coef_stride
water	123:42	0:0	8	;
water	124:16	0:0	8	shift
op	124:22	0:0	8	=
water	124:24	0:0	8	(
water	124:25	0:0	8	o
op	124:27	0:0	8	>
water	124:29	0:0	8	1
water	124:30	0:0	8	)
op	124:31	0:0	8	*
water	124:32	0:0	8	b
op	124:33	0:0	8	->
water	124:35	0:0	8	height
op	124:41	0:0	8	*
water	124:42	0:0	8	b
op	124:43	0:0	8	->
water	124:45	0:0	8	stride
op	124:52	0:0	8	+
water	124:54	0:0	8	(
water	124:55	0:0	8	o
op	124:57	0:0	8	&
water	124:59	0:0	8	1
water	124:60	0:0	8	)
op	124:61	0:0	8	*
water	124:62	0:0	8	b
op	124:63	0:0	8	->
water	124:65	0:0	8	width
water	124:70	0:0	8	;
water	125:16	0:0	8	b
op	125:17	0:0	8	->
water	125:19	0:0	8	buf
op	125:23	0:0	8	=
water	125:25	0:0	8	p
op	125:26	0:0	8	->
water	125:28	0:0	8	coef_buf
op	125:37	0:0	8	+
water	125:39	0:0	8	shift
water	125:44	0:0	8	;
water	126:12	0:0	8	}
water	127:8	0:0	6	}
if	130:8	133:27	4	(ff_vc2enc_init_transforms (& s -> transform_args [ i ] . t ,s -> plane [ i ] . coef_stride ,s -> plane [ i ] . dwt_height ))
cond	130:12	132:60	5	ff_vc2enc_init_transforms (& s -> transform_args [ i ] . t ,s -> plane [ i ] . coef_stride ,s -> plane [ i ] . dwt_height )
call	130:12	132:60	6	ff_vc2enc_init_transforms
arg	130:38	130:61	7	&s->transform_args[i].t
op	130:38	0:0	8	&
water	130:39	0:0	8	s
op	130:40	0:0	8	->
water	130:42	0:0	8	transform_args
op	130:56	0:0	8	[
water	130:57	0:0	8	i
op	130:58	0:0	8	]
op	130:59	0:0	8	.
water	130:60	0:0	8	t
arg	131:38	131:61	7	s->plane[i].coef_stride
water	131:38	0:0	8	s
op	131:39	0:0	8	->
water	131:41	0:0	8	plane
op	131:46	0:0	8	[
water	131:47	0:0	8	i
op	131:48	0:0	8	]
op	131:49	0:0	8	.
water	131:50	0:0	8	coef_stride
arg	132:38	132:60	7	s->plane[i].dwt_height
water	132:38	0:0	8	s
op	132:39	0:0	8	->
water	132:41	0:0	8	plane
op	132:46	0:0	8	[
water	132:47	0:0	8	i
op	132:48	0:0	8	]
op	132:49	0:0	8	.
water	132:50	0:0	8	dwt_height
stmts	133:12	133:27	5	
goto	133:12	133:27	6	alloc_fail
water	133:17	0:0	7	alloc_fail
water	134:4	0:0	4	}
water	137:4	0:0	2	s
op	137:5	0:0	2	->
water	137:7	0:0	2	num_x
op	137:13	0:0	2	=
water	137:15	0:0	2	s
op	137:16	0:0	2	->
water	137:18	0:0	2	plane
op	137:23	0:0	2	[
water	137:24	0:0	2	0
op	137:25	0:0	2	]
op	137:26	0:0	2	.
water	137:27	0:0	2	dwt_width
op	137:36	0:0	2	/
water	137:37	0:0	2	s
op	137:38	0:0	2	->
water	137:40	0:0	2	slice_width
water	137:51	0:0	2	;
water	138:4	0:0	2	s
op	138:5	0:0	2	->
water	138:7	0:0	2	num_y
op	138:13	0:0	2	=
water	138:15	0:0	2	s
op	138:16	0:0	2	->
water	138:18	0:0	2	plane
op	138:23	0:0	2	[
water	138:24	0:0	2	0
op	138:25	0:0	2	]
op	138:26	0:0	2	.
water	138:27	0:0	2	dwt_height
op	138:37	0:0	2	/
water	138:38	0:0	2	s
op	138:39	0:0	2	->
water	138:41	0:0	2	slice_height
water	138:53	0:0	2	;
water	140:4	0:0	2	s
op	140:5	0:0	2	->
water	140:7	0:0	2	slice_args
op	140:18	0:0	2	=
call	140:20	140:66	2	av_calloc
arg	140:30	140:47	3	s->num_x*s->num_y
water	140:30	0:0	4	s
op	140:31	0:0	4	->
water	140:33	0:0	4	num_x
op	140:38	0:0	4	*
water	140:39	0:0	4	s
op	140:40	0:0	4	->
water	140:42	0:0	4	num_y
arg	140:49	140:66	3	sizeof(SliceArgs)
op	140:49	0:0	4	sizeof
water	140:55	0:0	4	(
water	140:56	0:0	4	SliceArgs
water	140:65	0:0	4	)
water	140:67	0:0	2	;
if	141:4	142:23	2	(! s -> slice_args)
cond	141:8	141:12	3	! s -> slice_args
op	141:8	0:0	4	!
water	141:9	0:0	4	s
op	141:10	0:0	4	->
water	141:12	0:0	4	slice_args
stmts	142:8	142:23	3	
goto	142:8	142:23	4	alloc_fail
water	142:13	0:0	5	alloc_fail
water	145:4	0:0	2	s
op	145:5	0:0	2	->
water	145:7	0:0	2	coef_lut_len
op	145:20	0:0	2	=
call	145:22	145:83	2	av_malloc
arg	145:32	145:83	3	COEF_LUT_TAB*(s->q_ceil+1)*sizeof(*s->coef_lut_len)
water	145:32	0:0	4	COEF_LUT_TAB
op	145:44	0:0	4	*
water	145:45	0:0	4	(
water	145:46	0:0	4	s
op	145:47	0:0	4	->
water	145:49	0:0	4	q_ceil
op	145:55	0:0	4	+
water	145:56	0:0	4	1
water	145:57	0:0	4	)
op	145:58	0:0	4	*
op	145:59	0:0	4	sizeof
water	145:65	0:0	4	(
op	145:66	0:0	4	*
water	145:67	0:0	4	s
op	145:68	0:0	4	->
water	145:70	0:0	4	coef_lut_len
water	145:82	0:0	4	)
water	145:84	0:0	2	;
if	146:4	147:23	2	(! s -> coef_lut_len)
cond	146:8	146:12	3	! s -> coef_lut_len
op	146:8	0:0	4	!
water	146:9	0:0	4	s
op	146:10	0:0	4	->
water	146:12	0:0	4	coef_lut_len
stmts	147:8	147:23	3	
goto	147:8	147:23	4	alloc_fail
water	147:13	0:0	5	alloc_fail
water	149:4	0:0	2	s
op	149:5	0:0	2	->
water	149:7	0:0	2	coef_lut_val
op	149:20	0:0	2	=
call	149:22	149:83	2	av_malloc
arg	149:32	149:83	3	COEF_LUT_TAB*(s->q_ceil+1)*sizeof(*s->coef_lut_val)
water	149:32	0:0	4	COEF_LUT_TAB
op	149:44	0:0	4	*
water	149:45	0:0	4	(
water	149:46	0:0	4	s
op	149:47	0:0	4	->
water	149:49	0:0	4	q_ceil
op	149:55	0:0	4	+
water	149:56	0:0	4	1
water	149:57	0:0	4	)
op	149:58	0:0	4	*
op	149:59	0:0	4	sizeof
water	149:65	0:0	4	(
op	149:66	0:0	4	*
water	149:67	0:0	4	s
op	149:68	0:0	4	->
water	149:70	0:0	4	coef_lut_val
water	149:82	0:0	4	)
water	149:84	0:0	2	;
if	150:4	151:23	2	(! s -> coef_lut_val)
cond	150:8	150:12	3	! s -> coef_lut_val
op	150:8	0:0	4	!
water	150:9	0:0	4	s
op	150:10	0:0	4	->
water	150:12	0:0	4	coef_lut_val
stmts	151:8	151:23	3	
goto	151:8	151:23	4	alloc_fail
water	151:13	0:0	5	alloc_fail
for	153:4	166:4	2	(i = 0 ;i < s -> q_ceil;i ++)
forinit	153:9	153:14	3	i = 0 ;
water	153:9	0:0	4	i
op	153:11	0:0	4	=
water	153:13	0:0	4	0
water	153:14	0:0	4	;
cond	153:16	153:23	3	i < s -> q_ceil
water	153:16	0:0	4	i
op	153:18	0:0	4	<
water	153:20	0:0	4	s
op	153:21	0:0	4	->
water	153:23	0:0	4	q_ceil
forexpr	153:31	153:32	3	i ++
water	153:31	0:0	4	i
op	153:32	0:0	4	++
stmts	153:36	166:4	3	
water	153:36	0:0	4	{
decl	154:8	154:60	4	uint8_t	*len_lut
op	154:26	0:0	4	=
op	154:28	0:0	4	&
water	154:29	0:0	4	s
op	154:30	0:0	4	->
water	154:32	0:0	4	coef_lut_len
op	154:44	0:0	4	[
water	154:45	0:0	4	i
op	154:46	0:0	4	*
water	154:47	0:0	4	COEF_LUT_TAB
op	154:59	0:0	4	]
decl	155:8	155:60	4	uint32_t	*val_lut
op	155:26	0:0	4	=
op	155:28	0:0	4	&
water	155:29	0:0	4	s
op	155:30	0:0	4	->
water	155:32	0:0	4	coef_lut_val
op	155:44	0:0	4	[
water	155:45	0:0	4	i
op	155:46	0:0	4	*
water	155:47	0:0	4	COEF_LUT_TAB
op	155:59	0:0	4	]
for	156:8	165:8	4	(j = 0 ;j < COEF_LUT_TAB;j ++)
forinit	156:13	156:18	5	j = 0 ;
water	156:13	0:0	6	j
op	156:15	0:0	6	=
water	156:17	0:0	6	0
water	156:18	0:0	6	;
cond	156:20	156:24	5	j < COEF_LUT_TAB
water	156:20	0:0	6	j
op	156:22	0:0	6	<
water	156:24	0:0	6	COEF_LUT_TAB
forexpr	156:38	156:39	5	j ++
water	156:38	0:0	6	j
op	156:39	0:0	6	++
stmts	156:43	165:8	5	
water	156:43	0:0	6	{
call	157:12	158:52	6	get_vc2_ue_uint
arg	157:28	157:60	7	QUANT(j,ff_dirac_qscale_tab[i])
call	157:28	157:59	8	QUANT
arg	157:34	157:35	9	j
water	157:34	0:0	10	j
arg	157:37	157:59	9	ff_dirac_qscale_tab[i]
water	157:37	0:0	10	ff_dirac_qscale_tab
op	157:56	0:0	10	[
water	157:57	0:0	10	i
op	157:58	0:0	10	]
arg	158:28	158:39	7	&len_lut[j]
op	158:28	0:0	8	&
water	158:29	0:0	8	len_lut
op	158:36	0:0	8	[
water	158:37	0:0	8	j
op	158:38	0:0	8	]
arg	158:41	158:52	7	&val_lut[j]
op	158:41	0:0	8	&
water	158:42	0:0	8	val_lut
op	158:49	0:0	8	[
water	158:50	0:0	8	j
op	158:51	0:0	8	]
water	158:53	0:0	6	;
if	159:12	162:12	6	(len_lut [ j ] != 1)
cond	159:16	159:30	7	len_lut [ j ] != 1
water	159:16	0:0	8	len_lut
op	159:23	0:0	8	[
water	159:24	0:0	8	j
op	159:25	0:0	8	]
op	159:27	0:0	8	!=
water	159:30	0:0	8	1
stmts	159:33	162:12	7	
water	159:33	0:0	8	{
water	160:16	0:0	8	len_lut
op	160:23	0:0	8	[
water	160:24	0:0	8	j
op	160:25	0:0	8	]
op	160:27	0:0	8	+=
water	160:30	0:0	8	1
water	160:31	0:0	8	;
water	161:16	0:0	8	val_lut
op	161:23	0:0	8	[
water	161:24	0:0	8	j
op	161:25	0:0	8	]
op	161:27	0:0	8	<<=
water	161:31	0:0	8	1
water	161:32	0:0	8	;
water	162:12	0:0	8	}
else	162:14	164:12	6
stmts	162:19	164:12	7	
water	162:19	0:0	8	{
water	163:16	0:0	8	val_lut
op	163:23	0:0	8	[
water	163:24	0:0	8	j
op	163:25	0:0	8	]
op	163:27	0:0	8	=
water	163:29	0:0	8	1
water	163:30	0:0	8	;
water	164:12	0:0	8	}
water	165:8	0:0	6	}
water	166:4	0:0	4	}
return	168:4	168:12	2	0
water	168:11	0:0	3	0
label	170:0	170:10	2	alloc_fail :
call	171:4	171:24	2	vc2_encode_end
arg	171:19	171:24	3	avctx
water	171:19	0:0	4	avctx
water	171:25	0:0	2	;
call	172:4	172:62	2	av_log
arg	172:11	172:16	3	avctx
water	172:11	0:0	4	avctx
arg	172:18	172:30	3	AV_LOG_ERROR
water	172:18	0:0	4	AV_LOG_ERROR
arg	172:32	172:62	3	"Unable to allocate memory!\n"
water	172:32	0:0	4	"Unable to allocate memory!\n"
water	172:63	0:0	2	;
return	173:4	173:26	2	AVERROR(ENOMEM)
call	173:11	173:25	3	AVERROR
arg	173:19	173:25	4	ENOMEM
water	173:19	0:0	5	ENOMEM
