func	1:0	110:0	0	static int	mov_read_default
params	1:27	0:0	1	
param	1:28	1:41	2	MOVContext *	c
param	1:43	1:58	2	AVIOContext *	pb
param	1:60	1:72	2	MOVAtom	atom
stmnts	0:0	109:12	1	
decl	3:4	3:26	2	int64_t	total_size
op	3:23	0:0	2	=
water	3:25	0:0	2	0
decl	4:4	4:13	2	MOVAtom	a
decl	5:4	5:9	2	int	i
if	7:4	10:4	2	(c -> atom_depth > 10)
cond	7:8	7:24	3	c -> atom_depth > 10
water	7:8	0:0	4	c
op	7:9	0:0	4	->
water	7:11	0:0	4	atom_depth
op	7:22	0:0	4	>
water	7:24	0:0	4	10
stmts	7:28	10:4	3	
water	7:28	0:0	4	{
call	8:8	8:63	4	av_log
arg	8:15	8:20	5	c->fc
water	8:15	0:0	6	c
op	8:16	0:0	6	->
water	8:18	0:0	6	fc
arg	8:22	8:34	5	AV_LOG_ERROR
water	8:22	0:0	6	AV_LOG_ERROR
arg	8:36	8:63	5	"Atoms too deeply nested\n"
water	8:36	0:0	6	"Atoms too deeply nested\n"
water	8:64	0:0	4	;
return	9:8	9:34	4	AVERROR_INVALIDDATA
water	9:15	0:0	5	AVERROR_INVALIDDATA
water	10:4	0:0	4	}
water	11:4	0:0	2	c
op	11:5	0:0	2	->
water	11:7	0:0	2	atom_depth
op	11:18	0:0	2	++
water	11:20	0:0	2	;
if	13:4	14:29	2	(atom . size < 0)
cond	13:8	13:20	3	atom . size < 0
water	13:8	0:0	4	atom
op	13:12	0:0	4	.
water	13:13	0:0	4	size
op	13:18	0:0	4	<
water	13:20	0:0	4	0
stmts	14:8	14:29	3	
water	14:8	0:0	4	atom
op	14:12	0:0	4	.
water	14:13	0:0	4	size
op	14:18	0:0	4	=
water	14:20	0:0	4	INT64_MAX
water	14:29	0:0	4	;
while	15:4	103:4	2	(total_size + 8 <= atom . size && !avio_feof (pb ))
cond	15:11	15:55	3	total_size + 8 <= atom . size && !avio_feof (pb )
water	15:11	0:0	4	total_size
op	15:22	0:0	4	+
water	15:24	0:0	4	8
op	15:26	0:0	4	<=
water	15:29	0:0	4	atom
op	15:33	0:0	4	.
water	15:34	0:0	4	size
op	15:39	0:0	4	&&
op	15:42	0:0	4	!
call	15:43	15:55	4	avio_feof
arg	15:53	15:55	5	pb
water	15:53	0:0	6	pb
stmts	15:58	103:4	3	
water	15:58	0:0	4	{
call	16:8	16:19	4	int
arg	16:13	16:19	5	*parse
op	16:13	0:0	6	*
water	16:14	0:0	6	parse
water	16:20	0:0	4	(
water	16:21	0:0	4	MOVContext
op	16:31	0:0	4	*
water	16:32	0:0	4	,
water	16:34	0:0	4	AVIOContext
op	16:45	0:0	4	*
water	16:46	0:0	4	,
water	16:48	0:0	4	MOVAtom
water	16:55	0:0	4	)
op	16:57	0:0	4	=
water	16:59	0:0	4	NULL
water	16:63	0:0	4	;
water	17:8	0:0	4	a
op	17:9	0:0	4	.
water	17:10	0:0	4	size
op	17:15	0:0	4	=
water	17:17	0:0	4	atom
op	17:21	0:0	4	.
water	17:22	0:0	4	size
water	17:26	0:0	4	;
water	18:8	0:0	4	a
op	18:9	0:0	4	.
water	18:10	0:0	4	type
op	18:14	0:0	4	=
water	18:15	0:0	4	0
water	18:16	0:0	4	;
if	19:8	51:8	4	(atom . size >= 8)
cond	19:12	19:25	5	atom . size >= 8
water	19:12	0:0	6	atom
op	19:16	0:0	6	.
water	19:17	0:0	6	size
op	19:22	0:0	6	>=
water	19:25	0:0	6	8
stmts	19:28	51:8	5	
water	19:28	0:0	6	{
water	20:12	0:0	6	a
op	20:13	0:0	6	.
water	20:14	0:0	6	size
op	20:19	0:0	6	=
call	20:21	20:33	6	avio_rb32
arg	20:31	20:33	7	pb
water	20:31	0:0	8	pb
water	20:34	0:0	6	;
water	21:12	0:0	6	a
op	21:13	0:0	6	.
water	21:14	0:0	6	type
op	21:19	0:0	6	=
call	21:21	21:33	6	avio_rl32
arg	21:31	21:33	7	pb
water	21:31	0:0	8	pb
water	21:34	0:0	6	;
if	22:12	34:12	6	(a . type ==MKTAG ('f' ,'r' ,'e' ,'e' ) && a . size >= 8 && c -> moov_retry)
cond	22:16	24:19	7	a . type ==MKTAG ('f' ,'r' ,'e' ,'e' ) && a . size >= 8 && c -> moov_retry
water	22:16	0:0	8	a
op	22:17	0:0	8	.
water	22:18	0:0	8	type
op	22:23	0:0	8	==
call	22:26	22:47	8	MKTAG
arg	22:32	22:35	9	'f'
water	22:32	0:0	10	'f'
arg	22:36	22:39	9	'r'
water	22:36	0:0	10	'r'
arg	22:40	22:43	9	'e'
water	22:40	0:0	10	'e'
arg	22:44	22:47	9	'e'
water	22:44	0:0	10	'e'
op	22:49	0:0	8	&&
water	23:16	0:0	8	a
op	23:17	0:0	8	.
water	23:18	0:0	8	size
op	23:23	0:0	8	>=
water	23:26	0:0	8	8
op	23:28	0:0	8	&&
water	24:16	0:0	8	c
op	24:17	0:0	8	->
water	24:19	0:0	8	moov_retry
stmts	24:31	34:12	7	
water	24:31	0:0	8	{
decl	25:16	25:30	8	uint8_t	buf[8]
decl	26:16	26:52	8	uint32_t	*type
op	26:31	0:0	8	=
water	26:33	0:0	8	(
water	26:34	0:0	8	uint32_t
op	26:43	0:0	8	*
water	26:44	0:0	8	)
water	26:45	0:0	8	buf
op	26:49	0:0	8	+
water	26:51	0:0	8	1
call	27:16	27:36	8	avio_read
arg	27:26	27:28	9	pb
water	27:26	0:0	10	pb
arg	27:30	27:33	9	buf
water	27:30	0:0	10	buf
arg	27:35	27:36	9	8
water	27:35	0:0	10	8
water	27:37	0:0	8	;
call	28:16	28:42	8	avio_seek
arg	28:26	28:28	9	pb
water	28:26	0:0	10	pb
arg	28:30	28:32	9	-8
op	28:30	0:0	10	-
water	28:31	0:0	10	8
arg	28:34	28:42	9	SEEK_CUR
water	28:34	0:0	10	SEEK_CUR
water	28:43	0:0	8	;
if	29:16	33:16	8	(* type ==MKTAG ('m' ,'v' ,'h' ,'d' ) || * type ==MKTAG ('c' ,'m' ,'o' ,'v' ))
cond	29:20	30:50	9	* type ==MKTAG ('m' ,'v' ,'h' ,'d' ) || * type ==MKTAG ('c' ,'m' ,'o' ,'v' )
op	29:20	0:0	10	*
water	29:21	0:0	10	type
op	29:26	0:0	10	==
call	29:29	29:50	10	MKTAG
arg	29:35	29:38	11	'm'
water	29:35	0:0	12	'm'
arg	29:39	29:42	11	'v'
water	29:39	0:0	12	'v'
arg	29:43	29:46	11	'h'
water	29:43	0:0	12	'h'
arg	29:47	29:50	11	'd'
water	29:47	0:0	12	'd'
op	29:52	0:0	10	||
op	30:20	0:0	10	*
water	30:21	0:0	10	type
op	30:26	0:0	10	==
call	30:29	30:50	10	MKTAG
arg	30:35	30:38	11	'c'
water	30:35	0:0	12	'c'
arg	30:39	30:42	11	'm'
water	30:39	0:0	12	'm'
arg	30:43	30:46	11	'o'
water	30:43	0:0	12	'o'
arg	30:47	30:50	11	'v'
water	30:47	0:0	12	'v'
stmts	30:53	33:16	9	
water	30:53	0:0	10	{
call	31:20	31:81	10	av_log
arg	31:27	31:32	11	c->fc
water	31:27	0:0	12	c
op	31:28	0:0	12	->
water	31:30	0:0	12	fc
arg	31:34	31:46	11	AV_LOG_ERROR
water	31:34	0:0	12	AV_LOG_ERROR
arg	31:48	31:81	11	"Detected moov in a free atom.\n"
water	31:48	0:0	12	"Detected moov in a free atom.\n"
water	31:82	0:0	10	;
water	32:20	0:0	10	a
op	32:21	0:0	10	.
water	32:22	0:0	10	type
op	32:27	0:0	10	=
call	32:29	32:50	10	MKTAG
arg	32:35	32:38	11	'm'
water	32:35	0:0	12	'm'
arg	32:39	32:42	11	'o'
water	32:39	0:0	12	'o'
arg	32:43	32:46	11	'o'
water	32:43	0:0	12	'o'
arg	32:47	32:50	11	'v'
water	32:47	0:0	12	'v'
water	32:51	0:0	10	;
water	33:16	0:0	10	}
water	34:12	0:0	8	}
if	35:12	45:12	6	(atom . type !=MKTAG ('r' ,'o' ,'o' ,'t' ) && atom . type !=MKTAG ('m' ,'o' ,'o' ,'v' ))
cond	35:16	36:50	7	atom . type !=MKTAG ('r' ,'o' ,'o' ,'t' ) && atom . type !=MKTAG ('m' ,'o' ,'o' ,'v' )
water	35:16	0:0	8	atom
op	35:20	0:0	8	.
water	35:21	0:0	8	type
op	35:26	0:0	8	!=
call	35:29	35:50	8	MKTAG
arg	35:35	35:38	9	'r'
water	35:35	0:0	10	'r'
arg	35:39	35:42	9	'o'
water	35:39	0:0	10	'o'
arg	35:43	35:46	9	'o'
water	35:43	0:0	10	'o'
arg	35:47	35:50	9	't'
water	35:47	0:0	10	't'
op	35:52	0:0	8	&&
water	36:16	0:0	8	atom
op	36:20	0:0	8	.
water	36:21	0:0	8	type
op	36:26	0:0	8	!=
call	36:29	36:50	8	MKTAG
arg	36:35	36:38	9	'm'
water	36:35	0:0	10	'm'
arg	36:39	36:42	9	'o'
water	36:39	0:0	10	'o'
arg	36:43	36:46	9	'o'
water	36:43	0:0	10	'o'
arg	36:47	36:50	9	'v'
water	36:47	0:0	10	'v'
stmts	37:12	45:12	7	
water	37:12	0:0	8	{
if	38:16	44:16	8	(a . type ==MKTAG ('t' ,'r' ,'a' ,'k' ) || a . type ==MKTAG ('m' ,'d' ,'a' ,'t' ))
cond	38:20	38:87	9	a . type ==MKTAG ('t' ,'r' ,'a' ,'k' ) || a . type ==MKTAG ('m' ,'d' ,'a' ,'t' )
water	38:20	0:0	10	a
op	38:21	0:0	10	.
water	38:22	0:0	10	type
op	38:27	0:0	10	==
call	38:30	38:51	10	MKTAG
arg	38:36	38:39	11	't'
water	38:36	0:0	12	't'
arg	38:40	38:43	11	'r'
water	38:40	0:0	12	'r'
arg	38:44	38:47	11	'a'
water	38:44	0:0	12	'a'
arg	38:48	38:51	11	'k'
water	38:48	0:0	12	'k'
op	38:53	0:0	10	||
water	38:56	0:0	10	a
op	38:57	0:0	10	.
water	38:58	0:0	10	type
op	38:63	0:0	10	==
call	38:66	38:87	10	MKTAG
arg	38:72	38:75	11	'm'
water	38:72	0:0	12	'm'
arg	38:76	38:79	11	'd'
water	38:76	0:0	12	'd'
arg	38:80	38:83	11	'a'
water	38:80	0:0	12	'a'
arg	38:84	38:87	11	't'
water	38:84	0:0	12	't'
stmts	39:16	44:16	9	
water	39:16	0:0	10	{
call	40:20	40:91	10	av_log
arg	40:27	40:32	11	c->fc
water	40:27	0:0	12	c
op	40:28	0:0	12	->
water	40:30	0:0	12	fc
arg	40:34	40:46	11	AV_LOG_ERROR
water	40:34	0:0	12	AV_LOG_ERROR
arg	40:48	40:91	11	"Broken file, trak/mdat not at top-level\n"
water	40:48	0:0	12	"Broken file, trak/mdat not at top-level\n"
water	40:92	0:0	10	;
call	41:20	41:36	10	avio_skip
arg	41:30	41:32	11	pb
water	41:30	0:0	12	pb
arg	41:34	41:36	11	-8
op	41:34	0:0	12	-
water	41:35	0:0	12	8
water	41:37	0:0	10	;
water	42:20	0:0	10	c
op	42:21	0:0	10	->
water	42:23	0:0	10	atom_depth
op	42:34	0:0	10	--
water	42:36	0:0	10	;
return	43:20	43:28	10	0
water	43:27	0:0	11	0
water	44:16	0:0	10	}
water	45:12	0:0	8	}
water	46:12	0:0	6	total_size
op	46:23	0:0	6	+=
water	46:26	0:0	6	8
water	46:27	0:0	6	;
if	47:12	50:12	6	(a . size == 1)
cond	47:16	47:26	7	a . size == 1
water	47:16	0:0	8	a
op	47:17	0:0	8	.
water	47:18	0:0	8	size
op	47:23	0:0	8	==
water	47:26	0:0	8	1
stmts	47:29	50:12	7	
water	47:29	0:0	8	{
water	48:16	0:0	8	a
op	48:17	0:0	8	.
water	48:18	0:0	8	size
op	48:23	0:0	8	=
call	48:25	48:37	8	avio_rb64
arg	48:35	48:37	9	pb
water	48:35	0:0	10	pb
op	48:39	0:0	8	-
water	48:41	0:0	8	8
water	48:42	0:0	8	;
water	49:16	0:0	8	total_size
op	49:27	0:0	8	+=
water	49:30	0:0	8	8
water	49:31	0:0	8	;
water	50:12	0:0	8	}
water	51:8	0:0	6	}
call	52:8	53:88	4	av_dlog
arg	52:16	52:21	5	c->fc
water	52:16	0:0	6	c
op	52:17	0:0	6	->
water	52:19	0:0	6	fc
arg	52:23	52:92	5	"type: %08x '%.4s' parent:'%.4s' sz: %"PRId64" %"PRId64" %"PRId64"\n"
water	52:23	0:0	6	"type: %08x '%.4s' parent:'%.4s' sz: %"
water	52:62	0:0	6	PRId64
water	52:68	0:0	6	" %"
water	52:72	0:0	6	PRId64
water	52:78	0:0	6	" %"
water	52:82	0:0	6	PRId64
water	52:88	0:0	6	"\n"
arg	53:16	53:22	5	a.type
water	53:16	0:0	6	a
op	53:17	0:0	6	.
water	53:18	0:0	6	type
arg	53:24	53:38	5	(char*)&a.type
water	53:24	0:0	6	(
water	53:25	0:0	6	char
op	53:29	0:0	6	*
water	53:30	0:0	6	)
op	53:31	0:0	6	&
water	53:32	0:0	6	a
op	53:33	0:0	6	.
water	53:34	0:0	6	type
arg	53:40	53:57	5	(char*)&atom.type
water	53:40	0:0	6	(
water	53:41	0:0	6	char
op	53:45	0:0	6	*
water	53:46	0:0	6	)
op	53:47	0:0	6	&
water	53:48	0:0	6	atom
op	53:52	0:0	6	.
water	53:53	0:0	6	type
arg	53:59	53:65	5	a.size
water	53:59	0:0	6	a
op	53:60	0:0	6	.
water	53:61	0:0	6	size
arg	53:67	53:77	5	total_size
water	53:67	0:0	6	total_size
arg	53:79	53:88	5	atom.size
water	53:79	0:0	6	atom
op	53:83	0:0	6	.
water	53:84	0:0	6	size
water	53:89	0:0	4	;
if	54:8	56:8	4	(a . size == 0)
cond	54:12	54:22	5	a . size == 0
water	54:12	0:0	6	a
op	54:13	0:0	6	.
water	54:14	0:0	6	size
op	54:19	0:0	6	==
water	54:22	0:0	6	0
stmts	54:25	56:8	5	
water	54:25	0:0	6	{
water	55:12	0:0	6	a
op	55:13	0:0	6	.
water	55:14	0:0	6	size
op	55:19	0:0	6	=
water	55:21	0:0	6	atom
op	55:25	0:0	6	.
water	55:26	0:0	6	size
op	55:31	0:0	6	-
water	55:33	0:0	6	total_size
op	55:44	0:0	6	+
water	55:46	0:0	6	8
water	55:47	0:0	6	;
water	56:8	0:0	6	}
water	57:8	0:0	4	a
op	57:9	0:0	4	.
water	57:10	0:0	4	size
op	57:15	0:0	4	-=
water	57:18	0:0	4	8
water	57:19	0:0	4	;
if	58:8	59:17	4	(a . size < 0)
cond	58:12	58:21	5	a . size < 0
water	58:12	0:0	6	a
op	58:13	0:0	6	.
water	58:14	0:0	6	size
op	58:19	0:0	6	<
water	58:21	0:0	6	0
stmts	59:12	59:17	5	
break	59:12	59:17	6	
water	60:8	0:0	4	a
op	60:9	0:0	4	.
water	60:10	0:0	4	size
op	60:15	0:0	4	=
call	60:17	60:53	4	FFMIN
arg	60:23	60:29	5	a.size
water	60:23	0:0	6	a
op	60:24	0:0	6	.
water	60:25	0:0	6	size
arg	60:31	60:53	5	atom.size-total_size
water	60:31	0:0	6	atom
op	60:35	0:0	6	.
water	60:36	0:0	6	size
op	60:41	0:0	6	-
water	60:43	0:0	6	total_size
water	60:54	0:0	4	;
for	62:8	66:12	4	(i = 0 ;mov_default_parse_table [ i ] . type;i ++)
forinit	62:13	62:18	5	i = 0 ;
water	62:13	0:0	6	i
op	62:15	0:0	6	=
water	62:17	0:0	6	0
water	62:18	0:0	6	;
cond	62:20	62:47	5	mov_default_parse_table [ i ] . type
water	62:20	0:0	6	mov_default_parse_table
op	62:43	0:0	6	[
water	62:44	0:0	6	i
op	62:45	0:0	6	]
op	62:46	0:0	6	.
water	62:47	0:0	6	type
forexpr	62:53	62:54	5	i ++
water	62:53	0:0	6	i
op	62:54	0:0	6	++
stmts	63:12	66:12	5	
if	63:12	66:12	6	(mov_default_parse_table [ i ] . type == a . type)
cond	63:16	63:53	7	mov_default_parse_table [ i ] . type == a . type
water	63:16	0:0	8	mov_default_parse_table
op	63:39	0:0	8	[
water	63:40	0:0	8	i
op	63:41	0:0	8	]
op	63:42	0:0	8	.
water	63:43	0:0	8	type
op	63:48	0:0	8	==
water	63:51	0:0	8	a
op	63:52	0:0	8	.
water	63:53	0:0	8	type
stmts	63:59	66:12	7	
water	63:59	0:0	8	{
water	64:16	0:0	8	parse
op	64:22	0:0	8	=
water	64:24	0:0	8	mov_default_parse_table
op	64:47	0:0	8	[
water	64:48	0:0	8	i
op	64:49	0:0	8	]
op	64:50	0:0	8	.
water	64:51	0:0	8	parse
water	64:56	0:0	8	;
break	65:16	65:21	8	
water	66:12	0:0	8	}
if	69:8	71:40	4	(! parse && ( atom . type ==MKTAG ('u' ,'d' ,'t' ,'a' ) || atom . type ==MKTAG ('i' ,'l' ,'s' ,'t' ) ))
cond	69:12	70:58	5	! parse && ( atom . type ==MKTAG ('u' ,'d' ,'t' ,'a' ) || atom . type ==MKTAG ('i' ,'l' ,'s' ,'t' ) )
op	69:12	0:0	6	!
water	69:13	0:0	6	parse
op	69:19	0:0	6	&&
water	69:22	0:0	6	(
water	69:23	0:0	6	atom
op	69:27	0:0	6	.
water	69:28	0:0	6	type
op	69:33	0:0	6	==
call	69:36	69:57	6	MKTAG
arg	69:42	69:45	7	'u'
water	69:42	0:0	8	'u'
arg	69:46	69:49	7	'd'
water	69:46	0:0	8	'd'
arg	69:50	69:53	7	't'
water	69:50	0:0	8	't'
arg	69:54	69:57	7	'a'
water	69:54	0:0	8	'a'
op	69:59	0:0	6	||
water	70:23	0:0	6	atom
op	70:27	0:0	6	.
water	70:28	0:0	6	type
op	70:33	0:0	6	==
call	70:36	70:57	6	MKTAG
arg	70:42	70:45	7	'i'
water	70:42	0:0	8	'i'
arg	70:46	70:49	7	'l'
water	70:46	0:0	8	'l'
arg	70:50	70:53	7	's'
water	70:50	0:0	8	's'
arg	70:54	70:57	7	't'
water	70:54	0:0	8	't'
water	70:58	0:0	6	)
stmts	71:12	71:40	5	
water	71:12	0:0	6	parse
op	71:18	0:0	6	=
water	71:20	0:0	6	mov_read_udta_string
water	71:40	0:0	6	;
if	73:8	75:8	4	(! parse)
cond	73:12	73:13	5	! parse
op	73:12	0:0	6	!
water	73:13	0:0	6	parse
stmts	73:20	75:8	5	
water	73:20	0:0	6	{
call	74:12	74:32	6	avio_skip
arg	74:22	74:24	7	pb
water	74:22	0:0	8	pb
arg	74:26	74:32	7	a.size
water	74:26	0:0	8	a
op	74:27	0:0	8	.
water	74:28	0:0	8	size
water	74:33	0:0	6	;
water	75:8	0:0	6	}
else	75:10	100:8	4
stmts	75:15	100:8	5	
water	75:15	0:0	6	{
decl	76:12	76:45	6	int64_t	start_pos
op	76:30	0:0	6	=
call	76:32	76:44	7	avio_tell
arg	76:42	76:44	8	pb
water	76:42	0:0	9	pb
decl	77:12	77:24	6	int64_t	left
decl	78:12	78:37	6	int	err
op	78:20	0:0	6	=
call	78:22	78:36	7	parse
arg	78:28	78:29	8	c
water	78:28	0:0	9	c
arg	78:31	78:33	8	pb
water	78:31	0:0	9	pb
arg	78:35	78:36	8	a
water	78:35	0:0	9	a
if	79:12	82:12	6	(err < 0)
cond	79:16	79:22	7	err < 0
water	79:16	0:0	8	err
op	79:20	0:0	8	<
water	79:22	0:0	8	0
stmts	79:25	82:12	7	
water	79:25	0:0	8	{
water	80:16	0:0	8	c
op	80:17	0:0	8	->
water	80:19	0:0	8	atom_depth
op	80:30	0:0	8	--
water	80:32	0:0	8	;
return	81:16	81:26	8	err
water	81:23	0:0	9	err
water	82:12	0:0	8	}
if	83:12	90:12	6	(c -> found_moov && c -> found_mdat && ( ( ! pb -> seekable || c -> fc -> flags & AVFMT_FLAG_IGNIDX ) || start_pos + a . size ==avio_size (pb ) ))
cond	83:16	85:52	7	c -> found_moov && c -> found_mdat && ( ( ! pb -> seekable || c -> fc -> flags & AVFMT_FLAG_IGNIDX ) || start_pos + a . size ==avio_size (pb ) )
water	83:16	0:0	8	c
op	83:17	0:0	8	->
water	83:19	0:0	8	found_moov
op	83:30	0:0	8	&&
water	83:33	0:0	8	c
op	83:34	0:0	8	->
water	83:36	0:0	8	found_mdat
op	83:47	0:0	8	&&
water	84:16	0:0	8	(
water	84:17	0:0	8	(
op	84:18	0:0	8	!
water	84:19	0:0	8	pb
op	84:21	0:0	8	->
water	84:23	0:0	8	seekable
op	84:32	0:0	8	||
water	84:35	0:0	8	c
op	84:36	0:0	8	->
water	84:38	0:0	8	fc
op	84:40	0:0	8	->
water	84:42	0:0	8	flags
op	84:48	0:0	8	&
water	84:50	0:0	8	AVFMT_FLAG_IGNIDX
water	84:67	0:0	8	)
op	84:69	0:0	8	||
water	85:17	0:0	8	start_pos
op	85:27	0:0	8	+
water	85:29	0:0	8	a
op	85:30	0:0	8	.
water	85:31	0:0	8	size
op	85:36	0:0	8	==
call	85:39	85:51	8	avio_size
arg	85:49	85:51	9	pb
water	85:49	0:0	10	pb
water	85:52	0:0	8	)
stmts	85:55	90:12	7	
water	85:55	0:0	8	{
if	86:16	87:58	8	(! pb -> seekable || c -> fc -> flags & AVFMT_FLAG_IGNIDX)
cond	86:20	86:52	9	! pb -> seekable || c -> fc -> flags & AVFMT_FLAG_IGNIDX
op	86:20	0:0	10	!
water	86:21	0:0	10	pb
op	86:23	0:0	10	->
water	86:25	0:0	10	seekable
op	86:34	0:0	10	||
water	86:37	0:0	10	c
op	86:38	0:0	10	->
water	86:40	0:0	10	fc
op	86:42	0:0	10	->
water	86:44	0:0	10	flags
op	86:50	0:0	10	&
water	86:52	0:0	10	AVFMT_FLAG_IGNIDX
stmts	87:20	87:58	9	
water	87:20	0:0	10	c
op	87:21	0:0	10	->
water	87:23	0:0	10	next_root_atom
op	87:38	0:0	10	=
water	87:40	0:0	10	start_pos
op	87:50	0:0	10	+
water	87:52	0:0	10	a
op	87:53	0:0	10	.
water	87:54	0:0	10	size
water	87:58	0:0	10	;
water	88:16	0:0	8	c
op	88:17	0:0	8	->
water	88:19	0:0	8	atom_depth
op	88:30	0:0	8	--
water	88:32	0:0	8	;
return	89:16	89:24	8	0
water	89:23	0:0	9	0
water	90:12	0:0	8	}
water	91:12	0:0	6	left
op	91:17	0:0	6	=
water	91:19	0:0	6	a
op	91:20	0:0	6	.
water	91:21	0:0	6	size
op	91:26	0:0	6	-
call	91:28	91:40	6	avio_tell
arg	91:38	91:40	7	pb
water	91:38	0:0	8	pb
op	91:42	0:0	6	+
water	91:44	0:0	6	start_pos
water	91:53	0:0	6	;
if	92:12	93:35	6	(left > 0)
cond	92:16	92:23	7	left > 0
water	92:16	0:0	8	left
op	92:21	0:0	8	>
water	92:23	0:0	8	0
stmts	93:16	93:35	7	
call	93:16	93:34	8	avio_skip
arg	93:26	93:28	9	pb
water	93:26	0:0	10	pb
arg	93:30	93:34	9	left
water	93:30	0:0	10	left
water	93:35	0:0	8	;
else	94:12	99:12	6
stmts	94:17	99:12	7	
if	94:17	99:12	8	(left < 0)
cond	94:21	94:28	9	left < 0
water	94:21	0:0	10	left
op	94:26	0:0	10	<
water	94:28	0:0	10	0
stmts	94:31	99:12	9	
water	94:31	0:0	10	{
call	95:16	97:44	10	av_log
arg	95:23	95:28	11	c->fc
water	95:23	0:0	12	c
op	95:24	0:0	12	->
water	95:26	0:0	12	fc
arg	95:30	95:44	11	AV_LOG_WARNING
water	95:30	0:0	12	AV_LOG_WARNING
arg	96:23	96:73	11	"overread end of atom '%.4s' by %"PRId64" bytes\n"
water	96:23	0:0	12	"overread end of atom '%.4s' by %"
water	96:57	0:0	12	PRId64
water	96:63	0:0	12	" bytes\n"
arg	97:23	97:37	11	(char*)&a.type
water	97:23	0:0	12	(
water	97:24	0:0	12	char
op	97:28	0:0	12	*
water	97:29	0:0	12	)
op	97:30	0:0	12	&
water	97:31	0:0	12	a
op	97:32	0:0	12	.
water	97:33	0:0	12	type
arg	97:39	97:44	11	-left
op	97:39	0:0	12	-
water	97:40	0:0	12	left
water	97:45	0:0	10	;
call	98:16	98:44	10	avio_seek
arg	98:26	98:28	11	pb
water	98:26	0:0	12	pb
arg	98:30	98:34	11	left
water	98:30	0:0	12	left
arg	98:36	98:44	11	SEEK_CUR
water	98:36	0:0	12	SEEK_CUR
water	98:45	0:0	10	;
water	99:12	0:0	10	}
water	100:8	0:0	6	}
water	102:8	0:0	4	total_size
op	102:19	0:0	4	+=
water	102:22	0:0	4	a
op	102:23	0:0	4	.
water	102:24	0:0	4	size
water	102:28	0:0	4	;
water	103:4	0:0	4	}
if	105:4	106:45	2	(total_size < atom . size && atom . size < 0 x7ffff)
cond	105:8	105:47	3	total_size < atom . size && atom . size < 0 x7ffff
water	105:8	0:0	4	total_size
op	105:19	0:0	4	<
water	105:21	0:0	4	atom
op	105:25	0:0	4	.
water	105:26	0:0	4	size
op	105:31	0:0	4	&&
water	105:34	0:0	4	atom
op	105:38	0:0	4	.
water	105:39	0:0	4	size
op	105:44	0:0	4	<
water	105:46	0:0	4	0
water	105:47	0:0	4	x7ffff
stmts	106:8	106:45	3	
call	106:8	106:44	4	avio_skip
arg	106:18	106:20	5	pb
water	106:18	0:0	6	pb
arg	106:22	106:44	5	atom.size-total_size
water	106:22	0:0	6	atom
op	106:26	0:0	6	.
water	106:27	0:0	6	size
op	106:32	0:0	6	-
water	106:34	0:0	6	total_size
water	106:45	0:0	4	;
water	108:4	0:0	2	c
op	108:5	0:0	2	->
water	108:7	0:0	2	atom_depth
op	108:18	0:0	2	--
water	108:20	0:0	2	;
return	109:4	109:12	2	0
water	109:11	0:0	3	0
