func	1:0	41:0	0	static int	get_last_needed_nal
params	1:30	0:0	1	
param	1:31	1:45	2	H264Context *	h
stmnts	0:0	40:22	1	
decl	3:4	3:23	2	int	nals_needed
op	3:20	0:0	2	=
water	3:22	0:0	2	0
decl	4:4	4:23	2	int	first_slice
op	4:20	0:0	2	=
water	4:22	0:0	2	0
decl	5:4	5:14	2	int	i
water	5:9	0:0	2	,
decl	5:4	5:14	2	int	ret
for	7:4	38:4	2	(i = 0 ;i < h -> pkt . nb_nals;i ++)
forinit	7:9	7:14	3	i = 0 ;
water	7:9	0:0	4	i
op	7:11	0:0	4	=
water	7:13	0:0	4	0
water	7:14	0:0	4	;
cond	7:16	7:27	3	i < h -> pkt . nb_nals
water	7:16	0:0	4	i
op	7:18	0:0	4	<
water	7:20	0:0	4	h
op	7:21	0:0	4	->
water	7:23	0:0	4	pkt
op	7:26	0:0	4	.
water	7:27	0:0	4	nb_nals
forexpr	7:36	7:37	3	i ++
water	7:36	0:0	4	i
op	7:37	0:0	4	++
stmts	7:41	38:4	3	
water	7:41	0:0	4	{
decl	8:8	8:39	4	H2645NAL	*nal
op	8:22	0:0	4	=
op	8:24	0:0	4	&
water	8:25	0:0	4	h
op	8:26	0:0	4	->
water	8:28	0:0	4	pkt
op	8:31	0:0	4	.
water	8:32	0:0	4	nals
op	8:36	0:0	4	[
water	8:37	0:0	4	i
op	8:38	0:0	4	]
decl	9:8	9:24	4	GetBitContext	gb
switch	15:8	37:8	4	(nal -> type)
cond	15:16	15:21	5	nal -> type
water	15:16	0:0	6	nal
op	15:19	0:0	6	->
water	15:21	0:0	6	type
stmts	15:27	37:8	5	
water	15:27	0:0	6	{
label	16:8	16:25	6	case H264_NAL_SPS :
label	17:8	17:25	6	case H264_NAL_PPS :
water	18:12	0:0	6	nals_needed
op	18:24	0:0	6	=
water	18:26	0:0	6	i
water	18:27	0:0	6	;
break	19:12	19:17	6	
label	20:8	20:25	6	case H264_NAL_DPA :
label	21:8	21:31	6	case H264_NAL_IDR_SLICE :
label	22:8	22:27	6	case H264_NAL_SLICE :
water	23:12	0:0	6	ret
op	23:16	0:0	6	=
call	23:18	23:66	6	init_get_bits8
arg	23:33	23:36	7	&gb
op	23:33	0:0	8	&
water	23:34	0:0	8	gb
arg	23:38	23:51	7	nal->data+1
water	23:38	0:0	8	nal
op	23:41	0:0	8	->
water	23:43	0:0	8	data
op	23:48	0:0	8	+
water	23:50	0:0	8	1
arg	23:53	23:66	7	nal->size-1
water	23:53	0:0	8	nal
op	23:56	0:0	8	->
water	23:58	0:0	8	size
op	23:63	0:0	8	-
water	23:65	0:0	8	1
water	23:67	0:0	6	;
if	24:12	30:12	6	(ret < 0)
cond	24:16	24:22	7	ret < 0
water	24:16	0:0	8	ret
op	24:20	0:0	8	<
water	24:22	0:0	8	0
stmts	24:25	30:12	7	
water	24:25	0:0	8	{
call	25:16	25:82	8	av_log
arg	25:23	25:31	9	h->avctx
water	25:23	0:0	10	h
op	25:24	0:0	10	->
water	25:26	0:0	10	avctx
arg	25:33	25:45	9	AV_LOG_ERROR
water	25:33	0:0	10	AV_LOG_ERROR
arg	25:47	25:82	9	"Invalid zero-sized VCL NAL unit\n"
water	25:47	0:0	10	"Invalid zero-sized VCL NAL unit\n"
water	25:83	0:0	8	;
if	26:16	27:30	8	(h -> avctx -> err_recognition & AV_EF_EXPLODE)
cond	26:20	26:48	9	h -> avctx -> err_recognition & AV_EF_EXPLODE
water	26:20	0:0	10	h
op	26:21	0:0	10	->
water	26:23	0:0	10	avctx
op	26:28	0:0	10	->
water	26:30	0:0	10	err_recognition
op	26:46	0:0	10	&
water	26:48	0:0	10	AV_EF_EXPLODE
stmts	27:20	27:30	9	
return	27:20	27:30	10	ret
water	27:27	0:0	11	ret
break	29:16	29:21	8	
water	30:12	0:0	8	}
if	31:12	34:31	6	(!get_ue_golomb_long (& gb ) || ! first_slice || first_slice != nal -> type)
cond	31:16	33:36	7	!get_ue_golomb_long (& gb ) || ! first_slice || first_slice != nal -> type
op	31:16	0:0	8	!
call	31:17	31:39	8	get_ue_golomb_long
arg	31:36	31:39	9	&gb
op	31:36	0:0	10	&
water	31:37	0:0	10	gb
op	31:41	0:0	8	||
op	32:16	0:0	8	!
water	32:17	0:0	8	first_slice
op	32:29	0:0	8	||
water	33:16	0:0	8	first_slice
op	33:28	0:0	8	!=
water	33:31	0:0	8	nal
op	33:34	0:0	8	->
water	33:36	0:0	8	type
stmts	34:16	34:31	7	
water	34:16	0:0	8	nals_needed
op	34:28	0:0	8	=
water	34:30	0:0	8	i
water	34:31	0:0	8	;
if	35:12	36:39	6	(! first_slice)
cond	35:16	35:17	7	! first_slice
op	35:16	0:0	8	!
water	35:17	0:0	8	first_slice
stmts	36:16	36:39	7	
water	36:16	0:0	8	first_slice
op	36:28	0:0	8	=
water	36:30	0:0	8	nal
op	36:33	0:0	8	->
water	36:35	0:0	8	type
water	36:39	0:0	8	;
water	37:8	0:0	6	}
water	38:4	0:0	4	}
return	40:4	40:22	2	nals_needed
water	40:11	0:0	3	nals_needed
