func	5:0	70:0	0	static int	decode_frame
params	5:23	0:0	1	
param	5:24	5:45	2	AVCodecContext *	avctx
param	5:47	5:57	2	void *	data
param	5:59	5:73	2	int *	data_size
param	6:24	6:39	2	AVPacket *	avpkt
stmnts	0:0	69:19	1	
decl	8:4	8:43	2	IVI5DecContext	*ctx
op	8:25	0:0	2	=
water	8:27	0:0	2	avctx
op	8:32	0:0	2	->
water	8:34	0:0	2	priv_data
decl	9:4	9:38	2	const uint8_t	*buf
op	9:25	0:0	2	=
water	9:27	0:0	2	avpkt
op	9:32	0:0	2	->
water	9:34	0:0	2	data
decl	10:4	10:42	2	int	buf_size
op	10:29	0:0	2	=
water	10:31	0:0	2	avpkt
op	10:36	0:0	2	->
water	10:38	0:0	2	size
decl	11:4	11:32	2	int	result
water	11:26	0:0	2	,
decl	11:4	11:32	2	int	p
water	11:29	0:0	2	,
decl	11:4	11:32	2	int	b
call	13:4	13:45	2	init_get_bits
arg	13:18	13:26	3	&ctx->gb
op	13:18	0:0	4	&
water	13:19	0:0	4	ctx
op	13:22	0:0	4	->
water	13:24	0:0	4	gb
arg	13:28	13:31	3	buf
water	13:28	0:0	4	buf
arg	13:33	13:45	3	buf_size*8
water	13:33	0:0	4	buf_size
op	13:42	0:0	4	*
water	13:44	0:0	4	8
water	13:46	0:0	2	;
water	14:4	0:0	2	ctx
op	14:7	0:0	2	->
water	14:9	0:0	2	frame_data
op	14:20	0:0	2	=
water	14:22	0:0	2	buf
water	14:25	0:0	2	;
water	15:4	0:0	2	ctx
op	15:7	0:0	2	->
water	15:9	0:0	2	frame_size
op	15:20	0:0	2	=
water	15:22	0:0	2	buf_size
water	15:30	0:0	2	;
water	17:4	0:0	2	result
op	17:11	0:0	2	=
call	17:13	17:38	2	decode_pic_hdr
arg	17:28	17:31	3	ctx
water	17:28	0:0	4	ctx
arg	17:33	17:38	3	avctx
water	17:33	0:0	4	avctx
water	17:39	0:0	2	;
if	18:4	22:4	2	(result)
cond	18:8	18:8	3	result
water	18:8	0:0	4	result
stmts	18:16	22:4	3	
water	18:16	0:0	4	{
call	19:8	20:66	4	av_log
arg	19:15	19:20	5	avctx
water	19:15	0:0	6	avctx
arg	19:22	19:34	5	AV_LOG_ERROR
water	19:22	0:0	6	AV_LOG_ERROR
arg	20:15	20:58	5	"Error while decoding picture header: %d\n"
water	20:15	0:0	6	"Error while decoding picture header: %d\n"
arg	20:60	20:66	5	result
water	20:60	0:0	6	result
water	20:67	0:0	4	;
return	21:8	21:17	4	-1
op	21:15	0:0	5	-
water	21:16	0:0	5	1
water	22:4	0:0	4	}
if	24:4	27:4	2	(ctx -> gop_flags & IVI5_IS_PROTECTED)
cond	24:8	24:25	3	ctx -> gop_flags & IVI5_IS_PROTECTED
water	24:8	0:0	4	ctx
op	24:11	0:0	4	->
water	24:13	0:0	4	gop_flags
op	24:23	0:0	4	&
water	24:25	0:0	4	IVI5_IS_PROTECTED
stmts	24:44	27:4	3	
water	24:44	0:0	4	{
call	25:8	25:64	4	av_log
arg	25:15	25:20	5	avctx
water	25:15	0:0	6	avctx
arg	25:22	25:34	5	AV_LOG_ERROR
water	25:22	0:0	6	AV_LOG_ERROR
arg	25:36	25:64	5	"Password-protected clip!\n"
water	25:36	0:0	6	"Password-protected clip!\n"
water	25:65	0:0	4	;
return	26:8	26:17	4	-1
op	26:15	0:0	5	-
water	26:16	0:0	5	1
water	27:4	0:0	4	}
call	29:4	29:22	2	switch_buffers
arg	29:19	29:22	3	ctx
water	29:19	0:0	4	ctx
water	29:23	0:0	2	;
if	33:4	44:4	2	(ctx -> frame_type != FRAMETYPE_NULL)
cond	33:8	33:27	3	ctx -> frame_type != FRAMETYPE_NULL
water	33:8	0:0	4	ctx
op	33:11	0:0	4	->
water	33:13	0:0	4	frame_type
op	33:24	0:0	4	!=
water	33:27	0:0	4	FRAMETYPE_NULL
stmts	33:43	44:4	3	
water	33:43	0:0	4	{
for	34:8	43:8	4	(p = 0 ;p < 3;p ++)
forinit	34:13	34:18	5	p = 0 ;
water	34:13	0:0	6	p
op	34:15	0:0	6	=
water	34:17	0:0	6	0
water	34:18	0:0	6	;
cond	34:20	34:24	5	p < 3
water	34:20	0:0	6	p
op	34:22	0:0	6	<
water	34:24	0:0	6	3
forexpr	34:27	34:28	5	p ++
water	34:27	0:0	6	p
op	34:28	0:0	6	++
stmts	34:32	43:8	5	
water	34:32	0:0	6	{
for	35:12	42:12	6	(b = 0 ;b < ctx -> planes [ p ] . num_bands;b ++)
forinit	35:17	35:22	7	b = 0 ;
water	35:17	0:0	8	b
op	35:19	0:0	8	=
water	35:21	0:0	8	0
water	35:22	0:0	8	;
cond	35:24	35:43	7	b < ctx -> planes [ p ] . num_bands
water	35:24	0:0	8	b
op	35:26	0:0	8	<
water	35:28	0:0	8	ctx
op	35:31	0:0	8	->
water	35:33	0:0	8	planes
op	35:39	0:0	8	[
water	35:40	0:0	8	p
op	35:41	0:0	8	]
op	35:42	0:0	8	.
water	35:43	0:0	8	num_bands
forexpr	35:54	35:55	7	b ++
water	35:54	0:0	8	b
op	35:55	0:0	8	++
stmts	35:59	42:12	7	
water	35:59	0:0	8	{
water	36:16	0:0	8	result
op	36:23	0:0	8	=
call	36:25	36:76	8	decode_band
arg	36:37	36:40	9	ctx
water	36:37	0:0	10	ctx
arg	36:42	36:43	9	p
water	36:42	0:0	10	p
arg	36:45	36:69	9	&ctx->planes[p].bands[b]
op	36:45	0:0	10	&
water	36:46	0:0	10	ctx
op	36:49	0:0	10	->
water	36:51	0:0	10	planes
op	36:57	0:0	10	[
water	36:58	0:0	10	p
op	36:59	0:0	10	]
op	36:60	0:0	10	.
water	36:61	0:0	10	bands
op	36:66	0:0	10	[
water	36:67	0:0	10	b
op	36:68	0:0	10	]
arg	36:71	36:76	9	avctx
water	36:71	0:0	10	avctx
water	36:77	0:0	8	;
if	37:16	41:16	8	(result)
cond	37:20	37:20	9	result
water	37:20	0:0	10	result
stmts	37:28	41:16	9	
water	37:28	0:0	10	{
call	38:20	39:77	10	av_log
arg	38:27	38:32	11	avctx
water	38:27	0:0	12	avctx
arg	38:34	38:46	11	AV_LOG_ERROR
water	38:34	0:0	12	AV_LOG_ERROR
arg	39:27	39:71	11	"Error while decoding band: %d, plane: %d\n"
water	39:27	0:0	12	"Error while decoding band: %d, plane: %d\n"
arg	39:73	39:74	11	b
water	39:73	0:0	12	b
arg	39:76	39:77	11	p
water	39:76	0:0	12	p
water	39:78	0:0	10	;
return	40:20	40:29	10	-1
op	40:27	0:0	11	-
water	40:28	0:0	11	1
water	41:16	0:0	10	}
water	42:12	0:0	8	}
water	43:8	0:0	6	}
water	44:4	0:0	4	}
if	48:4	49:49	2	(ctx -> frame . data [ 0 ])
cond	48:8	48:25	3	ctx -> frame . data [ 0 ]
water	48:8	0:0	4	ctx
op	48:11	0:0	4	->
water	48:13	0:0	4	frame
op	48:18	0:0	4	.
water	48:19	0:0	4	data
op	48:23	0:0	4	[
water	48:24	0:0	4	0
op	48:25	0:0	4	]
stmts	49:8	49:49	3	
call	49:8	49:48	4	avctx->release_buffer
arg	49:30	49:35	5	avctx
water	49:30	0:0	6	avctx
arg	49:37	49:48	5	&ctx->frame
op	49:37	0:0	6	&
water	49:38	0:0	6	ctx
op	49:41	0:0	6	->
water	49:43	0:0	6	frame
water	49:49	0:0	4	;
water	51:4	0:0	2	ctx
op	51:7	0:0	2	->
water	51:9	0:0	2	frame
op	51:14	0:0	2	.
water	51:15	0:0	2	reference
op	51:25	0:0	2	=
water	51:27	0:0	2	0
water	51:28	0:0	2	;
if	52:4	55:4	2	(avctx -> get_buffer (avctx ,& ctx -> frame ) < 0)
cond	52:8	52:48	3	avctx -> get_buffer (avctx ,& ctx -> frame ) < 0
call	52:8	52:44	4	avctx->get_buffer
arg	52:26	52:31	5	avctx
water	52:26	0:0	6	avctx
arg	52:33	52:44	5	&ctx->frame
op	52:33	0:0	6	&
water	52:34	0:0	6	ctx
op	52:37	0:0	6	->
water	52:39	0:0	6	frame
op	52:46	0:0	4	<
water	52:48	0:0	4	0
stmts	52:51	55:4	3	
water	52:51	0:0	4	{
call	53:8	53:59	4	av_log
arg	53:15	53:20	5	avctx
water	53:15	0:0	6	avctx
arg	53:22	53:34	5	AV_LOG_ERROR
water	53:22	0:0	6	AV_LOG_ERROR
arg	53:36	53:59	5	"get_buffer() failed\n"
water	53:36	0:0	6	"get_buffer() failed\n"
water	53:60	0:0	4	;
return	54:8	54:17	4	-1
op	54:15	0:0	5	-
water	54:16	0:0	5	1
water	55:4	0:0	4	}
if	57:4	59:4	2	(ctx -> is_scalable)
cond	57:8	57:13	3	ctx -> is_scalable
water	57:8	0:0	4	ctx
op	57:11	0:0	4	->
water	57:13	0:0	4	is_scalable
stmts	57:26	59:4	3	
water	57:26	0:0	4	{
call	58:8	58:90	4	ff_ivi_recompose53
arg	58:28	58:43	5	&ctx->planes[0]
op	58:28	0:0	6	&
water	58:29	0:0	6	ctx
op	58:32	0:0	6	->
water	58:34	0:0	6	planes
op	58:40	0:0	6	[
water	58:41	0:0	6	0
op	58:42	0:0	6	]
arg	58:45	58:63	5	ctx->frame.data[0]
water	58:45	0:0	6	ctx
op	58:48	0:0	6	->
water	58:50	0:0	6	frame
op	58:55	0:0	6	.
water	58:56	0:0	6	data
op	58:60	0:0	6	[
water	58:61	0:0	6	0
op	58:62	0:0	6	]
arg	58:65	58:87	5	ctx->frame.linesize[0]
water	58:65	0:0	6	ctx
op	58:68	0:0	6	->
water	58:70	0:0	6	frame
op	58:75	0:0	6	.
water	58:76	0:0	6	linesize
op	58:84	0:0	6	[
water	58:85	0:0	6	0
op	58:86	0:0	6	]
arg	58:89	58:90	5	4
water	58:89	0:0	6	4
water	58:91	0:0	4	;
water	59:4	0:0	4	}
else	59:6	61:4	2
stmts	59:11	61:4	3	
water	59:11	0:0	4	{
call	60:8	60:87	4	ff_ivi_output_plane
arg	60:28	60:43	5	&ctx->planes[0]
op	60:28	0:0	6	&
water	60:29	0:0	6	ctx
op	60:32	0:0	6	->
water	60:34	0:0	6	planes
op	60:40	0:0	6	[
water	60:41	0:0	6	0
op	60:42	0:0	6	]
arg	60:45	60:63	5	ctx->frame.data[0]
water	60:45	0:0	6	ctx
op	60:48	0:0	6	->
water	60:50	0:0	6	frame
op	60:55	0:0	6	.
water	60:56	0:0	6	data
op	60:60	0:0	6	[
water	60:61	0:0	6	0
op	60:62	0:0	6	]
arg	60:65	60:87	5	ctx->frame.linesize[0]
water	60:65	0:0	6	ctx
op	60:68	0:0	6	->
water	60:70	0:0	6	frame
op	60:75	0:0	6	.
water	60:76	0:0	6	linesize
op	60:84	0:0	6	[
water	60:85	0:0	6	0
op	60:86	0:0	6	]
water	60:88	0:0	4	;
water	61:4	0:0	4	}
call	63:4	63:83	2	ff_ivi_output_plane
arg	63:24	63:39	3	&ctx->planes[2]
op	63:24	0:0	4	&
water	63:25	0:0	4	ctx
op	63:28	0:0	4	->
water	63:30	0:0	4	planes
op	63:36	0:0	4	[
water	63:37	0:0	4	2
op	63:38	0:0	4	]
arg	63:41	63:59	3	ctx->frame.data[1]
water	63:41	0:0	4	ctx
op	63:44	0:0	4	->
water	63:46	0:0	4	frame
op	63:51	0:0	4	.
water	63:52	0:0	4	data
op	63:56	0:0	4	[
water	63:57	0:0	4	1
op	63:58	0:0	4	]
arg	63:61	63:83	3	ctx->frame.linesize[1]
water	63:61	0:0	4	ctx
op	63:64	0:0	4	->
water	63:66	0:0	4	frame
op	63:71	0:0	4	.
water	63:72	0:0	4	linesize
op	63:80	0:0	4	[
water	63:81	0:0	4	1
op	63:82	0:0	4	]
water	63:84	0:0	2	;
call	64:4	64:83	2	ff_ivi_output_plane
arg	64:24	64:39	3	&ctx->planes[1]
op	64:24	0:0	4	&
water	64:25	0:0	4	ctx
op	64:28	0:0	4	->
water	64:30	0:0	4	planes
op	64:36	0:0	4	[
water	64:37	0:0	4	1
op	64:38	0:0	4	]
arg	64:41	64:59	3	ctx->frame.data[2]
water	64:41	0:0	4	ctx
op	64:44	0:0	4	->
water	64:46	0:0	4	frame
op	64:51	0:0	4	.
water	64:52	0:0	4	data
op	64:56	0:0	4	[
water	64:57	0:0	4	2
op	64:58	0:0	4	]
arg	64:61	64:83	3	ctx->frame.linesize[2]
water	64:61	0:0	4	ctx
op	64:64	0:0	4	->
water	64:66	0:0	4	frame
op	64:71	0:0	4	.
water	64:72	0:0	4	linesize
op	64:80	0:0	4	[
water	64:81	0:0	4	2
op	64:82	0:0	4	]
water	64:84	0:0	2	;
op	66:4	0:0	2	*
water	66:5	0:0	2	data_size
op	66:15	0:0	2	=
op	66:17	0:0	2	sizeof
water	66:23	0:0	2	(
water	66:24	0:0	2	AVFrame
water	66:31	0:0	2	)
water	66:32	0:0	2	;
op	67:4	0:0	2	*
water	67:5	0:0	2	(
water	67:6	0:0	2	AVFrame
op	67:13	0:0	2	*
water	67:14	0:0	2	)
water	67:15	0:0	2	data
op	67:20	0:0	2	=
water	67:22	0:0	2	ctx
op	67:25	0:0	2	->
water	67:27	0:0	2	frame
water	67:32	0:0	2	;
return	69:4	69:19	2	buf_size
water	69:11	0:0	3	buf_size
