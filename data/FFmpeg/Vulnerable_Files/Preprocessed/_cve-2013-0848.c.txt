func	2:15	100:0	0	int	decode_init
params	2:30	0:0	1	
param	2:31	2:52	2	AVCodecContext *	avctx
stmnts	0:0	99:12	1	
decl	4:4	4:37	2	HYuvContext	*s
op	4:19	0:0	2	=
water	4:21	0:0	2	avctx
op	4:26	0:0	2	->
water	4:28	0:0	2	priv_data
call	6:4	6:21	2	common_init
arg	6:16	6:21	3	avctx
water	6:16	0:0	4	avctx
water	6:22	0:0	2	;
call	7:4	7:35	2	memset
arg	7:11	7:17	3	s->vlc
water	7:11	0:0	4	s
op	7:12	0:0	4	->
water	7:14	0:0	4	vlc
arg	7:19	7:20	3	0
water	7:19	0:0	4	0
arg	7:22	7:35	3	3*sizeof(VLC)
water	7:22	0:0	4	3
op	7:23	0:0	4	*
op	7:24	0:0	4	sizeof
water	7:30	0:0	4	(
water	7:31	0:0	4	VLC
water	7:34	0:0	4	)
water	7:36	0:0	2	;
water	9:4	0:0	2	avctx
op	9:9	0:0	2	->
water	9:11	0:0	2	coded_frame
op	9:22	0:0	2	=
op	9:24	0:0	2	&
water	9:25	0:0	2	s
op	9:26	0:0	2	->
water	9:28	0:0	2	picture
water	9:35	0:0	2	;
call	10:4	10:42	2	avcodec_get_frame_defaults
arg	10:31	10:42	3	&s->picture
op	10:31	0:0	4	&
water	10:32	0:0	4	s
op	10:33	0:0	4	->
water	10:35	0:0	4	picture
water	10:43	0:0	2	;
water	11:4	0:0	2	s
op	11:5	0:0	2	->
water	11:7	0:0	2	interlaced
op	11:17	0:0	2	=
water	11:19	0:0	2	s
op	11:20	0:0	2	->
water	11:22	0:0	2	height
op	11:29	0:0	2	>
water	11:31	0:0	2	288
water	11:34	0:0	2	;
water	13:0	0:0	2	s
op	13:1	0:0	2	->
water	13:3	0:0	2	bgr32
op	13:8	0:0	2	=
water	13:9	0:0	2	1
water	13:10	0:0	2	;
if	16:4	21:4	2	(avctx -> extradata_size)
cond	16:7	16:14	3	avctx -> extradata_size
water	16:7	0:0	4	avctx
op	16:12	0:0	4	->
water	16:14	0:0	4	extradata_size
stmts	16:29	21:4	3	
water	16:29	0:0	4	{
if	17:8	18:24	4	(( avctx -> bits_per_coded_sample & 7 ) && avctx -> bits_per_coded_sample != 12)
cond	17:11	17:79	5	( avctx -> bits_per_coded_sample & 7 ) && avctx -> bits_per_coded_sample != 12
water	17:11	0:0	6	(
water	17:12	0:0	6	avctx
op	17:17	0:0	6	->
water	17:19	0:0	6	bits_per_coded_sample
op	17:40	0:0	6	&
water	17:41	0:0	6	7
water	17:42	0:0	6	)
op	17:44	0:0	6	&&
water	17:47	0:0	6	avctx
op	17:52	0:0	6	->
water	17:54	0:0	6	bits_per_coded_sample
op	17:76	0:0	6	!=
water	17:79	0:0	6	12
stmts	18:12	18:24	5	
water	18:12	0:0	6	s
op	18:13	0:0	6	->
water	18:15	0:0	6	version
op	18:22	0:0	6	=
water	18:23	0:0	6	1
water	18:24	0:0	6	;
else	19:8	20:24	4
stmts	20:12	20:24	5	
water	20:12	0:0	6	s
op	20:13	0:0	6	->
water	20:15	0:0	6	version
op	20:22	0:0	6	=
water	20:23	0:0	6	2
water	20:24	0:0	6	;
water	21:4	0:0	4	}
else	21:5	22:20	2
stmts	22:8	22:20	3	
water	22:8	0:0	4	s
op	22:9	0:0	4	->
water	22:11	0:0	4	version
op	22:18	0:0	4	=
water	22:19	0:0	4	0
water	22:20	0:0	4	;
if	24:4	42:4	2	(s -> version == 2)
cond	24:7	24:19	3	s -> version == 2
water	24:7	0:0	4	s
op	24:8	0:0	4	->
water	24:10	0:0	4	version
op	24:17	0:0	4	==
water	24:19	0:0	4	2
stmts	24:21	42:4	3	
water	24:21	0:0	4	{
decl	25:8	25:29	4	int	method
water	25:18	0:0	4	,
decl	25:8	25:29	4	int	interlace
if	27:8	28:21	4	(avctx -> extradata_size < 4)
cond	27:12	27:36	5	avctx -> extradata_size < 4
water	27:12	0:0	6	avctx
op	27:17	0:0	6	->
water	27:19	0:0	6	extradata_size
op	27:34	0:0	6	<
water	27:36	0:0	6	4
stmts	28:12	28:21	5	
return	28:12	28:21	6	-1
op	28:19	0:0	7	-
water	28:20	0:0	7	1
water	30:8	0:0	4	method
op	30:14	0:0	4	=
water	30:16	0:0	4	(
water	30:17	0:0	4	(
water	30:18	0:0	4	uint8_t
op	30:25	0:0	4	*
water	30:26	0:0	4	)
water	30:27	0:0	4	avctx
op	30:32	0:0	4	->
water	30:34	0:0	4	extradata
water	30:43	0:0	4	)
op	30:44	0:0	4	[
water	30:45	0:0	4	0
op	30:46	0:0	4	]
water	30:47	0:0	4	;
water	31:8	0:0	4	s
op	31:9	0:0	4	->
water	31:11	0:0	4	decorrelate
op	31:22	0:0	4	=
water	31:24	0:0	4	method
op	31:30	0:0	4	&
water	31:31	0:0	4	64
water	31:34	0:0	4	?
water	31:36	0:0	4	1
water	31:38	0:0	4	:
water	31:40	0:0	4	0
water	31:41	0:0	4	;
water	32:8	0:0	4	s
op	32:9	0:0	4	->
water	32:11	0:0	4	predictor
op	32:20	0:0	4	=
water	32:22	0:0	4	method
op	32:28	0:0	4	&
water	32:29	0:0	4	63
water	32:31	0:0	4	;
water	33:8	0:0	4	s
op	33:9	0:0	4	->
water	33:11	0:0	4	bitstream_bpp
op	33:24	0:0	4	=
water	33:26	0:0	4	(
water	33:27	0:0	4	(
water	33:28	0:0	4	uint8_t
op	33:35	0:0	4	*
water	33:36	0:0	4	)
water	33:37	0:0	4	avctx
op	33:42	0:0	4	->
water	33:44	0:0	4	extradata
water	33:53	0:0	4	)
op	33:54	0:0	4	[
water	33:55	0:0	4	1
op	33:56	0:0	4	]
water	33:57	0:0	4	;
if	34:8	35:61	4	(s -> bitstream_bpp == 0)
cond	34:11	34:29	5	s -> bitstream_bpp == 0
water	34:11	0:0	6	s
op	34:12	0:0	6	->
water	34:14	0:0	6	bitstream_bpp
op	34:27	0:0	6	==
water	34:29	0:0	6	0
stmts	35:12	35:61	5	
water	35:12	0:0	6	s
op	35:13	0:0	6	->
water	35:15	0:0	6	bitstream_bpp
op	35:28	0:0	6	=
water	35:30	0:0	6	avctx
op	35:35	0:0	6	->
water	35:37	0:0	6	bits_per_coded_sample
op	35:58	0:0	6	&
water	35:59	0:0	6	~7
water	35:61	0:0	6	;
water	36:8	0:0	4	interlace
op	36:17	0:0	4	=
water	36:19	0:0	4	(
water	36:20	0:0	4	(
water	36:21	0:0	4	(
water	36:22	0:0	4	uint8_t
op	36:29	0:0	4	*
water	36:30	0:0	4	)
water	36:31	0:0	4	avctx
op	36:36	0:0	4	->
water	36:38	0:0	4	extradata
water	36:47	0:0	4	)
op	36:48	0:0	4	[
water	36:49	0:0	4	2
op	36:50	0:0	4	]
op	36:52	0:0	4	&
water	36:54	0:0	4	0
water	36:55	0:0	4	x30
water	36:58	0:0	4	)
op	36:60	0:0	4	>>
water	36:63	0:0	4	4
water	36:64	0:0	4	;
water	37:8	0:0	4	s
op	37:9	0:0	4	->
water	37:11	0:0	4	interlaced
op	37:21	0:0	4	=
water	37:23	0:0	4	(
water	37:24	0:0	4	interlace
op	37:33	0:0	4	==
water	37:35	0:0	4	1
water	37:36	0:0	4	)
water	37:38	0:0	4	?
water	37:40	0:0	4	1
water	37:42	0:0	4	:
water	37:44	0:0	4	(
water	37:45	0:0	4	interlace
op	37:54	0:0	4	==
water	37:56	0:0	4	2
water	37:57	0:0	4	)
water	37:59	0:0	4	?
water	37:61	0:0	4	0
water	37:63	0:0	4	:
water	37:65	0:0	4	s
op	37:66	0:0	4	->
water	37:68	0:0	4	interlaced
water	37:78	0:0	4	;
water	38:8	0:0	4	s
op	38:9	0:0	4	->
water	38:11	0:0	4	context
op	38:18	0:0	4	=
water	38:20	0:0	4	(
water	38:21	0:0	4	(
water	38:22	0:0	4	uint8_t
op	38:29	0:0	4	*
water	38:30	0:0	4	)
water	38:31	0:0	4	avctx
op	38:36	0:0	4	->
water	38:38	0:0	4	extradata
water	38:47	0:0	4	)
op	38:48	0:0	4	[
water	38:49	0:0	4	2
op	38:50	0:0	4	]
op	38:52	0:0	4	&
water	38:54	0:0	4	0
water	38:55	0:0	4	x40
water	38:59	0:0	4	?
water	38:61	0:0	4	1
water	38:63	0:0	4	:
water	38:65	0:0	4	0
water	38:66	0:0	4	;
if	40:8	41:21	4	(read_huffman_tables (s ,( ( uint8_t * ) avctx -> extradata ) + 4 ,avctx -> extradata_size - 4 ) < 0)
cond	40:11	40:93	5	read_huffman_tables (s ,( ( uint8_t * ) avctx -> extradata ) + 4 ,avctx -> extradata_size - 4 ) < 0
call	40:11	40:89	6	read_huffman_tables
arg	40:31	40:32	7	s
water	40:31	0:0	8	s
arg	40:34	40:64	7	((uint8_t*)avctx->extradata)+4
water	40:34	0:0	8	(
water	40:35	0:0	8	(
water	40:36	0:0	8	uint8_t
op	40:43	0:0	8	*
water	40:44	0:0	8	)
water	40:45	0:0	8	avctx
op	40:50	0:0	8	->
water	40:52	0:0	8	extradata
water	40:61	0:0	8	)
op	40:62	0:0	8	+
water	40:63	0:0	8	4
arg	40:66	40:89	7	avctx->extradata_size-4
water	40:66	0:0	8	avctx
op	40:71	0:0	8	->
water	40:73	0:0	8	extradata_size
op	40:87	0:0	8	-
water	40:88	0:0	8	4
op	40:91	0:0	6	<
water	40:93	0:0	6	0
stmts	41:12	41:21	5	
return	41:12	41:21	6	-1
op	41:19	0:0	7	-
water	41:20	0:0	7	1
water	42:4	0:0	4	}
else	42:5	70:4	2
stmts	42:9	70:4	3	
water	42:9	0:0	4	{
switch	43:8	64:8	4	(avctx -> bits_per_coded_sample & 7)
cond	43:15	43:44	5	avctx -> bits_per_coded_sample & 7
water	43:15	0:0	6	avctx
op	43:20	0:0	6	->
water	43:22	0:0	6	bits_per_coded_sample
op	43:43	0:0	6	&
water	43:44	0:0	6	7
stmts	43:46	64:8	5	
water	43:46	0:0	6	{
label	44:8	44:14	6	case 1 :
water	45:12	0:0	6	s
op	45:13	0:0	6	->
water	45:15	0:0	6	predictor
op	45:24	0:0	6	=
water	45:26	0:0	6	LEFT
water	45:30	0:0	6	;
water	46:12	0:0	6	s
op	46:13	0:0	6	->
water	46:15	0:0	6	decorrelate
op	46:26	0:0	6	=
water	46:28	0:0	6	0
water	46:29	0:0	6	;
break	47:12	47:17	6	
label	48:8	48:14	6	case 2 :
water	49:12	0:0	6	s
op	49:13	0:0	6	->
water	49:15	0:0	6	predictor
op	49:24	0:0	6	=
water	49:26	0:0	6	LEFT
water	49:30	0:0	6	;
water	50:12	0:0	6	s
op	50:13	0:0	6	->
water	50:15	0:0	6	decorrelate
op	50:26	0:0	6	=
water	50:28	0:0	6	1
water	50:29	0:0	6	;
break	51:12	51:17	6	
label	52:8	52:14	6	case 3 :
water	53:12	0:0	6	s
op	53:13	0:0	6	->
water	53:15	0:0	6	predictor
op	53:24	0:0	6	=
water	53:26	0:0	6	PLANE
water	53:31	0:0	6	;
water	54:12	0:0	6	s
op	54:13	0:0	6	->
water	54:15	0:0	6	decorrelate
op	54:26	0:0	6	=
water	54:28	0:0	6	avctx
op	54:33	0:0	6	->
water	54:35	0:0	6	bits_per_coded_sample
op	54:57	0:0	6	>=
water	54:60	0:0	6	24
water	54:62	0:0	6	;
break	55:12	55:17	6	
label	56:8	56:14	6	case 4 :
water	57:12	0:0	6	s
op	57:13	0:0	6	->
water	57:15	0:0	6	predictor
op	57:24	0:0	6	=
water	57:26	0:0	6	MEDIAN
water	57:32	0:0	6	;
water	58:12	0:0	6	s
op	58:13	0:0	6	->
water	58:15	0:0	6	decorrelate
op	58:26	0:0	6	=
water	58:28	0:0	6	0
water	58:29	0:0	6	;
break	59:12	59:17	6	
label	60:8	60:15	6	default :
water	61:12	0:0	6	s
op	61:13	0:0	6	->
water	61:15	0:0	6	predictor
op	61:24	0:0	6	=
water	61:26	0:0	6	LEFT
water	61:30	0:0	6	;
water	62:12	0:0	6	s
op	62:13	0:0	6	->
water	62:15	0:0	6	decorrelate
op	62:26	0:0	6	=
water	62:28	0:0	6	0
water	62:29	0:0	6	;
break	63:12	63:17	6	
water	64:8	0:0	6	}
water	65:8	0:0	4	s
op	65:9	0:0	4	->
water	65:11	0:0	4	bitstream_bpp
op	65:24	0:0	4	=
water	65:26	0:0	4	avctx
op	65:31	0:0	4	->
water	65:33	0:0	4	bits_per_coded_sample
op	65:55	0:0	4	&
water	65:57	0:0	4	~7
water	65:59	0:0	4	;
water	66:8	0:0	4	s
op	66:9	0:0	4	->
water	66:11	0:0	4	context
op	66:18	0:0	4	=
water	66:20	0:0	4	0
water	66:21	0:0	4	;
if	68:8	69:21	4	(read_old_huffman_tables (s ) < 0)
cond	68:11	68:40	5	read_old_huffman_tables (s ) < 0
call	68:11	68:36	6	read_old_huffman_tables
arg	68:35	68:36	7	s
water	68:35	0:0	8	s
op	68:38	0:0	6	<
water	68:40	0:0	6	0
stmts	69:12	69:21	5	
return	69:12	69:21	6	-1
op	69:19	0:0	7	-
water	69:20	0:0	7	1
water	70:4	0:0	4	}
switch	72:4	93:4	2	(s -> bitstream_bpp)
cond	72:11	72:14	3	s -> bitstream_bpp
water	72:11	0:0	4	s
op	72:12	0:0	4	->
water	72:14	0:0	4	bitstream_bpp
stmts	72:28	93:4	3	
water	72:28	0:0	4	{
label	73:4	73:11	4	case 12 :
water	74:8	0:0	4	avctx
op	74:13	0:0	4	->
water	74:15	0:0	4	pix_fmt
op	74:23	0:0	4	=
water	74:25	0:0	4	PIX_FMT_YUV420P
water	74:40	0:0	4	;
break	75:8	75:13	4	
label	76:4	76:11	4	case 16 :
if	77:8	79:8	4	(s -> yuy2)
cond	77:11	77:14	5	s -> yuy2
water	77:11	0:0	6	s
op	77:12	0:0	6	->
water	77:14	0:0	6	yuy2
stmts	77:19	79:8	5	
water	77:19	0:0	6	{
water	78:12	0:0	6	avctx
op	78:17	0:0	6	->
water	78:19	0:0	6	pix_fmt
op	78:27	0:0	6	=
water	78:29	0:0	6	PIX_FMT_YUYV422
water	78:44	0:0	6	;
water	79:8	0:0	6	}
else	79:9	81:8	4
stmts	79:13	81:8	5	
water	79:13	0:0	6	{
water	80:12	0:0	6	avctx
op	80:17	0:0	6	->
water	80:19	0:0	6	pix_fmt
op	80:27	0:0	6	=
water	80:29	0:0	6	PIX_FMT_YUV422P
water	80:44	0:0	6	;
water	81:8	0:0	6	}
break	82:8	82:13	4	
label	83:4	83:11	4	case 24 :
label	84:4	84:11	4	case 32 :
if	85:8	87:8	4	(s -> bgr32)
cond	85:11	85:14	5	s -> bgr32
water	85:11	0:0	6	s
op	85:12	0:0	6	->
water	85:14	0:0	6	bgr32
stmts	85:20	87:8	5	
water	85:20	0:0	6	{
water	86:12	0:0	6	avctx
op	86:17	0:0	6	->
water	86:19	0:0	6	pix_fmt
op	86:27	0:0	6	=
water	86:29	0:0	6	PIX_FMT_RGB32
water	86:42	0:0	6	;
water	87:8	0:0	6	}
else	87:9	89:8	4
stmts	87:13	89:8	5	
water	87:13	0:0	6	{
water	88:12	0:0	6	avctx
op	88:17	0:0	6	->
water	88:19	0:0	6	pix_fmt
op	88:27	0:0	6	=
water	88:29	0:0	6	PIX_FMT_BGR24
water	88:42	0:0	6	;
water	89:8	0:0	6	}
break	90:8	90:13	4	
label	91:4	91:11	4	default :
call	92:8	92:16	4	assert
arg	92:15	92:16	5	0
water	92:15	0:0	6	0
water	92:17	0:0	4	;
water	93:4	0:0	4	}
call	95:4	95:16	2	alloc_temp
arg	95:15	95:16	3	s
water	95:15	0:0	4	s
water	95:17	0:0	2	;
return	99:4	99:12	2	0
water	99:11	0:0	3	0
