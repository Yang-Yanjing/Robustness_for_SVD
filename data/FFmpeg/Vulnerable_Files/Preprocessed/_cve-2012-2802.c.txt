func	5:0	139:0	0	static int	ac3_decode_frame
params	5:27	0:0	1	
param	5:28	5:50	2	AVCodecContext *	avctx
param	5:52	5:62	2	void *	data
param	5:64	5:78	2	int *	data_size
param	6:28	6:43	2	AVPacket *	avpkt
stmnts	0:0	138:41	1	
decl	8:4	8:36	2	const uint8_t	*buf
op	8:23	0:0	2	=
water	8:25	0:0	2	avpkt
op	8:30	0:0	2	->
water	8:32	0:0	2	data
decl	9:4	9:30	2	int	buf_size
op	9:17	0:0	2	=
water	9:19	0:0	2	avpkt
op	9:24	0:0	2	->
water	9:26	0:0	2	size
decl	10:4	10:42	2	AC3DecodeContext	*s
op	10:24	0:0	2	=
water	10:26	0:0	2	avctx
op	10:31	0:0	2	->
water	10:33	0:0	2	priv_data
decl	11:4	11:35	2	float	*out_samples_flt
op	11:29	0:0	2	=
water	11:31	0:0	2	data
decl	12:4	12:35	2	int16_t	*out_samples_s16
op	12:29	0:0	2	=
water	12:31	0:0	2	data
decl	13:4	13:20	2	int	blk
water	13:11	0:0	2	,
decl	13:4	13:20	2	int	ch
water	13:15	0:0	2	,
decl	13:4	13:20	2	int	err
decl	14:4	14:37	2	int	data_size_orig
water	14:22	0:0	2	,
decl	14:4	14:37	2	int	data_size_tmp
decl	15:4	15:30	2	const uint8_t	*channel_map
decl	16:4	16:41	2	const float	*output[AC3_MAX_CHANNELS]
if	20:4	24:4	2	(buf_size >= 2 &&AV_RB16 (buf ) == 0 x770B)
cond	20:8	20:42	3	buf_size >= 2 &&AV_RB16 (buf ) == 0 x770B
water	20:8	0:0	4	buf_size
op	20:17	0:0	4	>=
water	20:20	0:0	4	2
op	20:22	0:0	4	&&
call	20:25	20:36	4	AV_RB16
arg	20:33	20:36	5	buf
water	20:33	0:0	6	buf
op	20:38	0:0	4	==
water	20:41	0:0	4	0
water	20:42	0:0	4	x770B
stmts	20:49	24:4	3	
water	20:49	0:0	4	{
decl	22:8	22:61	4	int	cnt
op	22:16	0:0	4	=
call	22:18	22:55	5	FFMIN
arg	22:24	22:32	6	buf_size
water	22:24	0:0	7	buf_size
arg	22:34	22:55	6	AC3_FRAME_BUFFER_SIZE
water	22:34	0:0	7	AC3_FRAME_BUFFER_SIZE
op	22:57	0:0	4	>>
water	22:60	0:0	4	1
call	23:8	23:82	4	s->dsp.bswap16_buf
arg	23:27	23:54	5	(uint16_t*)s->input_buffer
water	23:27	0:0	6	(
water	23:28	0:0	6	uint16_t
op	23:37	0:0	6	*
water	23:38	0:0	6	)
water	23:39	0:0	6	s
op	23:40	0:0	6	->
water	23:42	0:0	6	input_buffer
arg	23:56	23:77	5	(constuint16_t*)buf
water	23:56	0:0	6	(
water	23:57	0:0	6	const
water	23:63	0:0	6	uint16_t
op	23:72	0:0	6	*
water	23:73	0:0	6	)
water	23:74	0:0	6	buf
arg	23:79	23:82	5	cnt
water	23:79	0:0	6	cnt
water	23:83	0:0	4	;
water	24:4	0:0	4	}
else	24:6	25:76	2
stmts	25:8	25:76	3	
call	25:8	25:75	4	memcpy
arg	25:15	25:30	5	s->input_buffer
water	25:15	0:0	6	s
op	25:16	0:0	6	->
water	25:18	0:0	6	input_buffer
arg	25:32	25:35	5	buf
water	25:32	0:0	6	buf
arg	25:37	25:75	5	FFMIN(buf_size,AC3_FRAME_BUFFER_SIZE)
call	25:37	25:74	6	FFMIN
arg	25:43	25:51	7	buf_size
water	25:43	0:0	8	buf_size
arg	25:53	25:74	7	AC3_FRAME_BUFFER_SIZE
water	25:53	0:0	8	AC3_FRAME_BUFFER_SIZE
water	25:76	0:0	4	;
water	26:4	0:0	2	buf
op	26:8	0:0	2	=
water	26:10	0:0	2	s
op	26:11	0:0	2	->
water	26:13	0:0	2	input_buffer
water	26:25	0:0	2	;
call	28:4	28:44	2	init_get_bits
arg	28:18	28:25	3	&s->gbc
op	28:18	0:0	4	&
water	28:19	0:0	4	s
op	28:20	0:0	4	->
water	28:22	0:0	4	gbc
arg	28:27	28:30	3	buf
water	28:27	0:0	4	buf
arg	28:32	28:44	3	buf_size*8
water	28:32	0:0	4	buf_size
op	28:41	0:0	4	*
water	28:43	0:0	4	8
water	28:45	0:0	2	;
water	31:4	0:0	2	data_size_orig
op	31:19	0:0	2	=
op	31:21	0:0	2	*
water	31:22	0:0	2	data_size
water	31:31	0:0	2	;
op	32:4	0:0	2	*
water	32:5	0:0	2	data_size
op	32:15	0:0	2	=
water	32:17	0:0	2	0
water	32:18	0:0	2	;
water	33:4	0:0	2	err
op	33:8	0:0	2	=
call	33:10	33:30	2	parse_frame_header
arg	33:29	33:30	3	s
water	33:29	0:0	4	s
water	33:31	0:0	2	;
if	35:4	63:4	2	(err)
cond	35:8	35:8	3	err
water	35:8	0:0	4	err
stmts	35:13	63:4	3	
water	35:13	0:0	4	{
switch	36:8	62:8	4	(err)
cond	36:15	36:15	5	err
water	36:15	0:0	6	err
stmts	36:20	62:8	5	
water	36:20	0:0	6	{
label	37:12	37:41	6	case AAC_AC3_PARSE_ERROR_SYNC :
call	38:16	38:64	6	av_log
arg	38:23	38:28	7	avctx
water	38:23	0:0	8	avctx
arg	38:30	38:42	7	AV_LOG_ERROR
water	38:30	0:0	8	AV_LOG_ERROR
arg	38:44	38:64	7	"frame sync error\n"
water	38:44	0:0	8	"frame sync error\n"
water	38:65	0:0	6	;
return	39:16	39:25	6	-1
op	39:23	0:0	7	-
water	39:24	0:0	7	1
label	40:12	40:41	6	case AAC_AC3_PARSE_ERROR_BSID :
call	41:16	41:68	6	av_log
arg	41:23	41:28	7	avctx
water	41:23	0:0	8	avctx
arg	41:30	41:42	7	AV_LOG_ERROR
water	41:30	0:0	8	AV_LOG_ERROR
arg	41:44	41:68	7	"invalid bitstream id\n"
water	41:44	0:0	8	"invalid bitstream id\n"
water	41:69	0:0	6	;
break	42:16	42:21	6	
label	43:12	43:48	6	case AAC_AC3_PARSE_ERROR_SAMPLE_RATE :
call	44:16	44:67	6	av_log
arg	44:23	44:28	7	avctx
water	44:23	0:0	8	avctx
arg	44:30	44:42	7	AV_LOG_ERROR
water	44:30	0:0	8	AV_LOG_ERROR
arg	44:44	44:67	7	"invalid sample rate\n"
water	44:44	0:0	8	"invalid sample rate\n"
water	44:68	0:0	6	;
break	45:16	45:21	6	
label	46:12	46:47	6	case AAC_AC3_PARSE_ERROR_FRAME_SIZE :
call	47:16	47:66	6	av_log
arg	47:23	47:28	7	avctx
water	47:23	0:0	8	avctx
arg	47:30	47:42	7	AV_LOG_ERROR
water	47:30	0:0	8	AV_LOG_ERROR
arg	47:44	47:66	7	"invalid frame size\n"
water	47:44	0:0	8	"invalid frame size\n"
water	47:67	0:0	6	;
break	48:16	48:21	6	
label	49:12	49:47	6	case AAC_AC3_PARSE_ERROR_FRAME_TYPE :
if	52:16	55:16	6	(s -> frame_type == EAC3_FRAME_TYPE_DEPENDENT || s -> substreamid)
cond	52:19	52:68	7	s -> frame_type == EAC3_FRAME_TYPE_DEPENDENT || s -> substreamid
water	52:19	0:0	8	s
op	52:20	0:0	8	->
water	52:22	0:0	8	frame_type
op	52:33	0:0	8	==
water	52:36	0:0	8	EAC3_FRAME_TYPE_DEPENDENT
op	52:62	0:0	8	||
water	52:65	0:0	8	s
op	52:66	0:0	8	->
water	52:68	0:0	8	substreamid
stmts	52:81	55:16	7	
water	52:81	0:0	8	{
call	53:20	53:91	8	av_log
arg	53:27	53:32	9	avctx
water	53:27	0:0	10	avctx
arg	53:34	53:46	9	AV_LOG_ERROR
water	53:34	0:0	10	AV_LOG_ERROR
arg	53:48	53:91	9	"unsupported frame type : skipping frame\n"
water	53:48	0:0	10	"unsupported frame type : skipping frame\n"
water	53:92	0:0	8	;
return	54:20	54:40	8	s->frame_size
water	54:27	0:0	9	s
op	54:28	0:0	9	->
water	54:30	0:0	9	frame_size
water	55:16	0:0	8	}
else	55:18	57:16	6
stmts	55:23	57:16	7	
water	55:23	0:0	8	{
call	56:20	56:70	8	av_log
arg	56:27	56:32	9	avctx
water	56:27	0:0	10	avctx
arg	56:34	56:46	9	AV_LOG_ERROR
water	56:34	0:0	10	AV_LOG_ERROR
arg	56:48	56:70	9	"invalid frame type\n"
water	56:48	0:0	10	"invalid frame type\n"
water	56:71	0:0	8	;
water	57:16	0:0	8	}
break	58:16	58:21	6	
label	59:12	59:19	6	default :
call	60:16	60:62	6	av_log
arg	60:23	60:28	7	avctx
water	60:23	0:0	8	avctx
arg	60:30	60:42	7	AV_LOG_ERROR
water	60:30	0:0	8	AV_LOG_ERROR
arg	60:44	60:62	7	"invalid header\n"
water	60:44	0:0	8	"invalid header\n"
water	60:63	0:0	6	;
break	61:16	61:21	6	
water	62:8	0:0	6	}
water	63:4	0:0	4	}
else	63:6	75:4	2
stmts	63:11	75:4	3	
water	63:11	0:0	4	{
if	65:8	68:8	4	(s -> frame_size > buf_size)
cond	65:12	65:28	5	s -> frame_size > buf_size
water	65:12	0:0	6	s
op	65:13	0:0	6	->
water	65:15	0:0	6	frame_size
op	65:26	0:0	6	>
water	65:28	0:0	6	buf_size
stmts	65:38	68:8	5	
water	65:38	0:0	6	{
call	66:12	66:60	6	av_log
arg	66:19	66:24	7	avctx
water	66:19	0:0	8	avctx
arg	66:26	66:38	7	AV_LOG_ERROR
water	66:26	0:0	8	AV_LOG_ERROR
arg	66:40	66:60	7	"incomplete frame\n"
water	66:40	0:0	8	"incomplete frame\n"
water	66:61	0:0	6	;
water	67:12	0:0	6	err
op	67:16	0:0	6	=
water	67:18	0:0	6	AAC_AC3_PARSE_ERROR_FRAME_SIZE
water	67:48	0:0	6	;
water	68:8	0:0	6	}
else	68:10	74:8	4
stmts	68:15	74:8	5	
if	68:15	74:8	6	(avctx -> error_recognition >= FF_ER_CAREFUL)
cond	68:19	68:47	7	avctx -> error_recognition >= FF_ER_CAREFUL
water	68:19	0:0	8	avctx
op	68:24	0:0	8	->
water	68:26	0:0	8	error_recognition
op	68:44	0:0	8	>=
water	68:47	0:0	8	FF_ER_CAREFUL
stmts	68:62	74:8	7	
water	68:62	0:0	8	{
if	70:12	73:12	8	(av_crc (av_crc_get_table (AV_CRC_16_ANSI ) ,0 ,& buf [ 2 ] ,s -> frame_size - 2 ))
cond	70:16	70:84	9	av_crc (av_crc_get_table (AV_CRC_16_ANSI ) ,0 ,& buf [ 2 ] ,s -> frame_size - 2 )
call	70:16	70:84	10	av_crc
arg	70:23	70:55	11	av_crc_get_table(AV_CRC_16_ANSI)
call	70:23	70:54	12	av_crc_get_table
arg	70:40	70:54	13	AV_CRC_16_ANSI
water	70:40	0:0	14	AV_CRC_16_ANSI
arg	70:57	70:58	11	0
water	70:57	0:0	12	0
arg	70:60	70:67	11	&buf[2]
op	70:60	0:0	12	&
water	70:61	0:0	12	buf
op	70:64	0:0	12	[
water	70:65	0:0	12	2
op	70:66	0:0	12	]
arg	70:69	70:84	11	s->frame_size-2
water	70:69	0:0	12	s
op	70:70	0:0	12	->
water	70:72	0:0	12	frame_size
op	70:82	0:0	12	-
water	70:83	0:0	12	2
stmts	70:87	73:12	9	
water	70:87	0:0	10	{
call	71:16	71:66	10	av_log
arg	71:23	71:28	11	avctx
water	71:23	0:0	12	avctx
arg	71:30	71:42	11	AV_LOG_ERROR
water	71:30	0:0	12	AV_LOG_ERROR
arg	71:44	71:66	11	"frame CRC mismatch\n"
water	71:44	0:0	12	"frame CRC mismatch\n"
water	71:67	0:0	10	;
water	72:16	0:0	10	err
op	72:20	0:0	10	=
water	72:22	0:0	10	AAC_AC3_PARSE_ERROR_CRC
water	72:45	0:0	10	;
water	73:12	0:0	10	}
water	74:8	0:0	8	}
water	75:4	0:0	4	}
if	78:4	101:4	2	(! err)
cond	78:8	78:9	3	! err
op	78:8	0:0	4	!
water	78:9	0:0	4	err
stmts	78:14	101:4	3	
water	78:14	0:0	4	{
water	79:8	0:0	4	avctx
op	79:13	0:0	4	->
water	79:15	0:0	4	sample_rate
op	79:27	0:0	4	=
water	79:29	0:0	4	s
op	79:30	0:0	4	->
water	79:32	0:0	4	sample_rate
water	79:43	0:0	4	;
water	80:8	0:0	4	avctx
op	80:13	0:0	4	->
water	80:15	0:0	4	bit_rate
op	80:24	0:0	4	=
water	80:26	0:0	4	s
op	80:27	0:0	4	->
water	80:29	0:0	4	bit_rate
water	80:37	0:0	4	;
water	83:8	0:0	4	s
op	83:9	0:0	4	->
water	83:11	0:0	4	out_channels
op	83:24	0:0	4	=
water	83:26	0:0	4	s
op	83:27	0:0	4	->
water	83:29	0:0	4	channels
water	83:37	0:0	4	;
water	84:8	0:0	4	s
op	84:9	0:0	4	->
water	84:11	0:0	4	output_mode
op	84:23	0:0	4	=
water	84:25	0:0	4	s
op	84:26	0:0	4	->
water	84:28	0:0	4	channel_mode
water	84:40	0:0	4	;
if	85:8	86:46	4	(s -> lfe_on)
cond	85:11	85:14	5	s -> lfe_on
water	85:11	0:0	6	s
op	85:12	0:0	6	->
water	85:14	0:0	6	lfe_on
stmts	86:12	86:46	5	
water	86:12	0:0	6	s
op	86:13	0:0	6	->
water	86:15	0:0	6	output_mode
op	86:27	0:0	6	|=
water	86:30	0:0	6	AC3_OUTPUT_LFEON
water	86:46	0:0	6	;
if	87:8	92:8	4	(avctx -> request_channels > 0 && avctx -> request_channels <= 2 && avctx -> request_channels < s -> channels)
cond	87:12	88:45	5	avctx -> request_channels > 0 && avctx -> request_channels <= 2 && avctx -> request_channels < s -> channels
water	87:12	0:0	6	avctx
op	87:17	0:0	6	->
water	87:19	0:0	6	request_channels
op	87:36	0:0	6	>
water	87:38	0:0	6	0
op	87:40	0:0	6	&&
water	87:43	0:0	6	avctx
op	87:48	0:0	6	->
water	87:50	0:0	6	request_channels
op	87:67	0:0	6	<=
water	87:70	0:0	6	2
op	87:72	0:0	6	&&
water	88:16	0:0	6	avctx
op	88:21	0:0	6	->
water	88:23	0:0	6	request_channels
op	88:40	0:0	6	<
water	88:42	0:0	6	s
op	88:43	0:0	6	->
water	88:45	0:0	6	channels
stmts	88:55	92:8	5	
water	88:55	0:0	6	{
water	89:12	0:0	6	s
op	89:13	0:0	6	->
water	89:15	0:0	6	out_channels
op	89:28	0:0	6	=
water	89:30	0:0	6	avctx
op	89:35	0:0	6	->
water	89:37	0:0	6	request_channels
water	89:53	0:0	6	;
water	90:12	0:0	6	s
op	90:13	0:0	6	->
water	90:15	0:0	6	output_mode
op	90:28	0:0	6	=
water	90:30	0:0	6	avctx
op	90:35	0:0	6	->
water	90:37	0:0	6	request_channels
op	90:54	0:0	6	==
water	90:57	0:0	6	1
water	90:59	0:0	6	?
water	90:61	0:0	6	AC3_CHMODE_MONO
water	90:77	0:0	6	:
water	90:79	0:0	6	AC3_CHMODE_STEREO
water	90:96	0:0	6	;
water	91:12	0:0	6	s
op	91:13	0:0	6	->
water	91:15	0:0	6	channel_layout
op	91:30	0:0	6	=
water	91:32	0:0	6	ff_ac3_channel_layout_tab
op	91:57	0:0	6	[
water	91:58	0:0	6	s
op	91:59	0:0	6	->
water	91:61	0:0	6	output_mode
op	91:72	0:0	6	]
water	91:73	0:0	6	;
water	92:8	0:0	6	}
water	93:8	0:0	4	avctx
op	93:13	0:0	4	->
water	93:15	0:0	4	channels
op	93:24	0:0	4	=
water	93:26	0:0	4	s
op	93:27	0:0	4	->
water	93:29	0:0	4	out_channels
water	93:41	0:0	4	;
water	94:8	0:0	4	avctx
op	94:13	0:0	4	->
water	94:15	0:0	4	channel_layout
op	94:30	0:0	4	=
water	94:32	0:0	4	s
op	94:33	0:0	4	->
water	94:35	0:0	4	channel_layout
water	94:49	0:0	4	;
if	97:8	100:8	4	(s -> channels != s -> out_channels && ! ( ( s -> output_mode & AC3_OUTPUT_LFEON ) && s -> fbw_channels == s -> out_channels ))
cond	97:11	98:50	5	s -> channels != s -> out_channels && ! ( ( s -> output_mode & AC3_OUTPUT_LFEON ) && s -> fbw_channels == s -> out_channels )
water	97:11	0:0	6	s
op	97:12	0:0	6	->
water	97:14	0:0	6	channels
op	97:23	0:0	6	!=
water	97:26	0:0	6	s
op	97:27	0:0	6	->
water	97:29	0:0	6	out_channels
op	97:42	0:0	6	&&
op	97:45	0:0	6	!
water	97:46	0:0	6	(
water	97:47	0:0	6	(
water	97:48	0:0	6	s
op	97:49	0:0	6	->
water	97:51	0:0	6	output_mode
op	97:63	0:0	6	&
water	97:65	0:0	6	AC3_OUTPUT_LFEON
water	97:81	0:0	6	)
op	97:83	0:0	6	&&
water	98:16	0:0	6	s
op	98:17	0:0	6	->
water	98:19	0:0	6	fbw_channels
op	98:32	0:0	6	==
water	98:35	0:0	6	s
op	98:36	0:0	6	->
water	98:38	0:0	6	out_channels
water	98:50	0:0	6	)
stmts	98:53	100:8	5	
water	98:53	0:0	6	{
call	99:12	99:32	6	set_downmix_coeffs
arg	99:31	99:32	7	s
water	99:31	0:0	8	s
water	99:33	0:0	6	;
water	100:8	0:0	6	}
water	101:4	0:0	4	}
else	101:6	105:4	2
stmts	101:11	105:4	3	
if	101:11	105:4	4	(! s -> out_channels)
cond	101:15	101:19	5	! s -> out_channels
op	101:15	0:0	6	!
water	101:16	0:0	6	s
op	101:17	0:0	6	->
water	101:19	0:0	6	out_channels
stmts	101:33	105:4	5	
water	101:33	0:0	6	{
water	102:8	0:0	6	s
op	102:9	0:0	6	->
water	102:11	0:0	6	out_channels
op	102:24	0:0	6	=
water	102:26	0:0	6	avctx
op	102:31	0:0	6	->
water	102:33	0:0	6	channels
water	102:41	0:0	6	;
if	103:8	104:88	6	(s -> out_channels < s -> channels)
cond	103:11	103:32	7	s -> out_channels < s -> channels
water	103:11	0:0	8	s
op	103:12	0:0	8	->
water	103:14	0:0	8	out_channels
op	103:27	0:0	8	<
water	103:29	0:0	8	s
op	103:30	0:0	8	->
water	103:32	0:0	8	channels
stmts	104:12	104:88	7	
water	104:12	0:0	8	s
op	104:13	0:0	8	->
water	104:15	0:0	8	output_mode
op	104:28	0:0	8	=
water	104:30	0:0	8	s
op	104:31	0:0	8	->
water	104:33	0:0	8	out_channels
op	104:46	0:0	8	==
water	104:49	0:0	8	1
water	104:51	0:0	8	?
water	104:53	0:0	8	AC3_CHMODE_MONO
water	104:69	0:0	8	:
water	104:71	0:0	8	AC3_CHMODE_STEREO
water	104:88	0:0	8	;
water	105:4	0:0	6	}
water	107:4	0:0	2	avctx
op	107:9	0:0	2	->
water	107:11	0:0	2	audio_service_type
op	107:30	0:0	2	=
water	107:32	0:0	2	s
op	107:33	0:0	2	->
water	107:35	0:0	2	bitstream_mode
water	107:49	0:0	2	;
if	108:4	109:65	2	(s -> bitstream_mode == 0 x7 && s -> channels > 1)
cond	108:8	108:50	3	s -> bitstream_mode == 0 x7 && s -> channels > 1
water	108:8	0:0	4	s
op	108:9	0:0	4	->
water	108:11	0:0	4	bitstream_mode
op	108:26	0:0	4	==
water	108:29	0:0	4	0
water	108:30	0:0	4	x7
op	108:33	0:0	4	&&
water	108:36	0:0	4	s
op	108:37	0:0	4	->
water	108:39	0:0	4	channels
op	108:48	0:0	4	>
water	108:50	0:0	4	1
stmts	109:8	109:65	3	
water	109:8	0:0	4	avctx
op	109:13	0:0	4	->
water	109:15	0:0	4	audio_service_type
op	109:34	0:0	4	=
water	109:36	0:0	4	AV_AUDIO_SERVICE_TYPE_KARAOKE
water	109:65	0:0	4	;
water	112:4	0:0	2	channel_map
op	112:16	0:0	2	=
water	112:18	0:0	2	ff_ac3_dec_channel_map
op	112:40	0:0	2	[
water	112:41	0:0	2	s
op	112:42	0:0	2	->
water	112:44	0:0	2	output_mode
op	112:56	0:0	2	&
water	112:58	0:0	2	~AC3_OUTPUT_LFEON
op	112:75	0:0	2	]
op	112:76	0:0	2	[
water	112:77	0:0	2	s
op	112:78	0:0	2	->
water	112:80	0:0	2	lfe_on
op	112:86	0:0	2	]
water	112:87	0:0	2	;
for	113:4	114:47	2	(ch = 0 ;ch < s -> out_channels;ch ++)
forinit	113:9	113:15	3	ch = 0 ;
water	113:9	0:0	4	ch
op	113:12	0:0	4	=
water	113:14	0:0	4	0
water	113:15	0:0	4	;
cond	113:17	113:25	3	ch < s -> out_channels
water	113:17	0:0	4	ch
op	113:20	0:0	4	<
water	113:22	0:0	4	s
op	113:23	0:0	4	->
water	113:25	0:0	4	out_channels
forexpr	113:39	113:41	3	ch ++
water	113:39	0:0	4	ch
op	113:41	0:0	4	++
stmts	114:8	114:47	3	
water	114:8	0:0	4	output
op	114:14	0:0	4	[
water	114:15	0:0	4	ch
op	114:17	0:0	4	]
op	114:19	0:0	4	=
water	114:21	0:0	4	s
op	114:22	0:0	4	->
water	114:24	0:0	4	output
op	114:30	0:0	4	[
water	114:31	0:0	4	channel_map
op	114:42	0:0	4	[
water	114:43	0:0	4	ch
op	114:45	0:0	4	]
op	114:46	0:0	4	]
water	114:47	0:0	4	;
water	115:4	0:0	2	data_size_tmp
op	115:18	0:0	2	=
water	115:20	0:0	2	s
op	115:21	0:0	2	->
water	115:23	0:0	2	num_blocks
op	115:34	0:0	2	*
water	115:36	0:0	2	256
op	115:40	0:0	2	*
water	115:42	0:0	2	avctx
op	115:47	0:0	2	->
water	115:49	0:0	2	channels
water	115:57	0:0	2	;
water	116:4	0:0	2	data_size_tmp
op	116:18	0:0	2	*=
water	116:21	0:0	2	avctx
op	116:26	0:0	2	->
water	116:28	0:0	2	sample_fmt
op	116:39	0:0	2	==
water	116:42	0:0	2	AV_SAMPLE_FMT_FLT
water	116:60	0:0	2	?
op	116:62	0:0	2	sizeof
water	116:68	0:0	2	(
op	116:69	0:0	2	*
water	116:70	0:0	2	out_samples_flt
water	116:85	0:0	2	)
water	116:87	0:0	2	:
op	116:89	0:0	2	sizeof
water	116:95	0:0	2	(
op	116:96	0:0	2	*
water	116:97	0:0	2	out_samples_s16
water	116:112	0:0	2	)
water	116:113	0:0	2	;
if	117:4	118:17	2	(data_size_orig < data_size_tmp)
cond	117:8	117:25	3	data_size_orig < data_size_tmp
water	117:8	0:0	4	data_size_orig
op	117:23	0:0	4	<
water	117:25	0:0	4	data_size_tmp
stmts	118:8	118:17	3	
return	118:8	118:17	4	-1
op	118:15	0:0	5	-
water	118:16	0:0	5	1
op	119:4	0:0	2	*
water	119:5	0:0	2	data_size
op	119:15	0:0	2	=
water	119:17	0:0	2	data_size_tmp
water	119:30	0:0	2	;
for	120:4	135:4	2	(blk = 0 ;blk < s -> num_blocks;blk ++)
forinit	120:9	120:16	3	blk = 0 ;
water	120:9	0:0	4	blk
op	120:13	0:0	4	=
water	120:15	0:0	4	0
water	120:16	0:0	4	;
cond	120:18	120:27	3	blk < s -> num_blocks
water	120:18	0:0	4	blk
op	120:22	0:0	4	<
water	120:24	0:0	4	s
op	120:25	0:0	4	->
water	120:27	0:0	4	num_blocks
forexpr	120:39	120:42	3	blk ++
water	120:39	0:0	4	blk
op	120:42	0:0	4	++
stmts	120:46	135:4	3	
water	120:46	0:0	4	{
if	121:8	124:8	4	(! err &&decode_audio_block (s ,blk ))
cond	121:12	121:45	5	! err &&decode_audio_block (s ,blk )
op	121:12	0:0	6	!
water	121:13	0:0	6	err
op	121:17	0:0	6	&&
call	121:20	121:45	6	decode_audio_block
arg	121:39	121:40	7	s
water	121:39	0:0	8	s
arg	121:42	121:45	7	blk
water	121:42	0:0	8	blk
stmts	121:48	124:8	5	
water	121:48	0:0	6	{
call	122:12	122:74	6	av_log
arg	122:19	122:24	7	avctx
water	122:19	0:0	8	avctx
arg	122:26	122:38	7	AV_LOG_ERROR
water	122:26	0:0	8	AV_LOG_ERROR
arg	122:40	122:74	7	"error decoding the audio block\n"
water	122:40	0:0	8	"error decoding the audio block\n"
water	122:75	0:0	6	;
water	123:12	0:0	6	err
op	123:16	0:0	6	=
water	123:18	0:0	6	1
water	123:19	0:0	6	;
water	124:8	0:0	6	}
if	126:8	130:8	4	(avctx -> sample_fmt == AV_SAMPLE_FMT_FLT)
cond	126:12	126:33	5	avctx -> sample_fmt == AV_SAMPLE_FMT_FLT
water	126:12	0:0	6	avctx
op	126:17	0:0	6	->
water	126:19	0:0	6	sample_fmt
op	126:30	0:0	6	==
water	126:33	0:0	6	AV_SAMPLE_FMT_FLT
stmts	126:52	130:8	5	
water	126:52	0:0	6	{
call	127:12	128:56	6	s->fmt_conv.float_interleave
arg	127:41	127:56	7	out_samples_flt
water	127:41	0:0	8	out_samples_flt
arg	127:58	127:64	7	output
water	127:58	0:0	8	output
arg	127:66	127:69	7	256
water	127:66	0:0	8	256
arg	128:41	128:56	7	s->out_channels
water	128:41	0:0	8	s
op	128:42	0:0	8	->
water	128:44	0:0	8	out_channels
water	128:57	0:0	6	;
water	129:12	0:0	6	out_samples_flt
op	129:28	0:0	6	+=
water	129:31	0:0	6	256
op	129:35	0:0	6	*
water	129:37	0:0	6	s
op	129:38	0:0	6	->
water	129:40	0:0	6	out_channels
water	129:52	0:0	6	;
water	130:8	0:0	6	}
else	130:10	134:8	4
stmts	130:15	134:8	5	
water	130:15	0:0	6	{
call	131:12	132:65	6	s->fmt_conv.float_to_int16_interleave
arg	131:50	131:65	7	out_samples_s16
water	131:50	0:0	8	out_samples_s16
arg	131:67	131:73	7	output
water	131:67	0:0	8	output
arg	131:75	131:78	7	256
water	131:75	0:0	8	256
arg	132:50	132:65	7	s->out_channels
water	132:50	0:0	8	s
op	132:51	0:0	8	->
water	132:53	0:0	8	out_channels
water	132:66	0:0	6	;
water	133:12	0:0	6	out_samples_s16
op	133:28	0:0	6	+=
water	133:31	0:0	6	256
op	133:35	0:0	6	*
water	133:37	0:0	6	s
op	133:38	0:0	6	->
water	133:40	0:0	6	out_channels
water	133:52	0:0	6	;
water	134:8	0:0	6	}
water	135:4	0:0	4	}
op	136:4	0:0	2	*
water	136:5	0:0	2	data_size
op	136:15	0:0	2	=
water	136:17	0:0	2	s
op	136:18	0:0	2	->
water	136:20	0:0	2	num_blocks
op	136:31	0:0	2	*
water	136:33	0:0	2	256
op	136:37	0:0	2	*
water	136:39	0:0	2	avctx
op	136:44	0:0	2	->
water	136:46	0:0	2	channels
call	136:55	137:58	2	*av_get_bytes_per_sample
arg	137:41	137:58	3	avctx->sample_fmt
water	137:41	0:0	4	avctx
op	137:46	0:0	4	->
water	137:48	0:0	4	sample_fmt
water	137:59	0:0	2	;
return	138:4	138:41	2	FFMIN(buf_size,s->frame_size)
call	138:11	138:40	3	FFMIN
arg	138:17	138:25	4	buf_size
water	138:17	0:0	5	buf_size
arg	138:27	138:40	4	s->frame_size
water	138:27	0:0	5	s
op	138:28	0:0	5	->
water	138:30	0:0	5	frame_size
