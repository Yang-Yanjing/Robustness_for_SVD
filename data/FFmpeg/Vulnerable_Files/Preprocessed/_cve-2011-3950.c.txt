func	4:0	84:0	0	static int	dirac_decode_data_unit
params	4:33	0:0	1	
param	4:34	4:55	2	AVCodecContext *	avctx
param	4:57	4:75	2	const uint8_t *	buf
param	4:77	4:85	2	int	size
stmnts	0:0	83:12	1	
decl	6:4	6:40	2	DiracContext	*s
op	6:22	0:0	2	=
water	6:24	0:0	2	avctx
op	6:29	0:0	2	->
water	6:31	0:0	2	priv_data
decl	7:4	7:28	2	DiracFrame	*pic
op	7:22	0:0	2	=
water	7:24	0:0	2	NULL
decl	8:4	8:30	2	int	i
water	8:9	0:0	2	,
decl	8:4	8:30	2	int	parse_code
op	8:22	0:0	2	=
water	8:24	0:0	2	buf
op	8:27	0:0	2	[
water	8:28	0:0	2	4
op	8:29	0:0	2	]
if	10:4	11:17	2	(size < DATA_UNIT_HEADER_SIZE)
cond	10:8	10:15	3	size < DATA_UNIT_HEADER_SIZE
water	10:8	0:0	4	size
op	10:13	0:0	4	<
water	10:15	0:0	4	DATA_UNIT_HEADER_SIZE
stmts	11:8	11:17	3	
return	11:8	11:17	4	-1
op	11:15	0:0	5	-
water	11:16	0:0	5	1
call	13:4	13:68	2	init_get_bits
arg	13:18	13:24	3	&s->gb
op	13:18	0:0	4	&
water	13:19	0:0	4	s
op	13:20	0:0	4	->
water	13:22	0:0	4	gb
arg	13:26	13:34	3	&buf[13]
op	13:26	0:0	4	&
water	13:27	0:0	4	buf
op	13:30	0:0	4	[
water	13:31	0:0	4	13
op	13:33	0:0	4	]
arg	13:36	13:68	3	8*(size-DATA_UNIT_HEADER_SIZE)
water	13:36	0:0	4	8
op	13:37	0:0	4	*
water	13:38	0:0	4	(
water	13:39	0:0	4	size
op	13:44	0:0	4	-
water	13:46	0:0	4	DATA_UNIT_HEADER_SIZE
water	13:67	0:0	4	)
water	13:69	0:0	2	;
if	15:4	29:4	2	(parse_code == pc_seq_header)
cond	15:8	15:22	3	parse_code == pc_seq_header
water	15:8	0:0	4	parse_code
op	15:19	0:0	4	==
water	15:22	0:0	4	pc_seq_header
stmts	15:37	29:4	3	
water	15:37	0:0	4	{
if	16:8	17:20	4	(s -> seen_sequence_header)
cond	16:12	16:15	5	s -> seen_sequence_header
water	16:12	0:0	6	s
op	16:13	0:0	6	->
water	16:15	0:0	6	seen_sequence_header
stmts	17:12	17:20	5	
return	17:12	17:20	6	0
water	17:19	0:0	7	0
if	20:8	21:21	4	(avpriv_dirac_parse_sequence_header (avctx ,& s -> gb ,& s -> source ))
cond	20:12	20:72	5	avpriv_dirac_parse_sequence_header (avctx ,& s -> gb ,& s -> source )
call	20:12	20:72	6	avpriv_dirac_parse_sequence_header
arg	20:47	20:52	7	avctx
water	20:47	0:0	8	avctx
arg	20:54	20:60	7	&s->gb
op	20:54	0:0	8	&
water	20:55	0:0	8	s
op	20:56	0:0	8	->
water	20:58	0:0	8	gb
arg	20:62	20:72	7	&s->source
op	20:62	0:0	8	&
water	20:63	0:0	8	s
op	20:64	0:0	8	->
water	20:66	0:0	8	source
stmts	21:12	21:21	5	
return	21:12	21:21	6	-1
op	21:19	0:0	7	-
water	21:20	0:0	7	1
call	23:8	23:92	4	avcodec_get_chroma_sub_sample
arg	23:38	23:52	5	avctx->pix_fmt
water	23:38	0:0	6	avctx
op	23:43	0:0	6	->
water	23:45	0:0	6	pix_fmt
arg	23:54	23:72	5	&s->chroma_x_shift
op	23:54	0:0	6	&
water	23:55	0:0	6	s
op	23:56	0:0	6	->
water	23:58	0:0	6	chroma_x_shift
arg	23:74	23:92	5	&s->chroma_y_shift
op	23:74	0:0	6	&
water	23:75	0:0	6	s
op	23:76	0:0	6	->
water	23:78	0:0	6	chroma_y_shift
water	23:93	0:0	4	;
if	25:8	26:21	4	(alloc_sequence_buffers (s ))
cond	25:12	25:36	5	alloc_sequence_buffers (s )
call	25:12	25:36	6	alloc_sequence_buffers
arg	25:35	25:36	7	s
water	25:35	0:0	8	s
stmts	26:12	26:21	5	
return	26:12	26:21	6	-1
op	26:19	0:0	7	-
water	26:20	0:0	7	1
water	28:8	0:0	4	s
op	28:9	0:0	4	->
water	28:11	0:0	4	seen_sequence_header
op	28:32	0:0	4	=
water	28:34	0:0	4	1
water	28:35	0:0	4	;
water	29:4	0:0	4	}
else	29:6	32:4	2
stmts	29:11	32:4	3	
if	29:11	32:4	4	(parse_code == pc_eos)
cond	29:15	29:29	5	parse_code == pc_eos
water	29:15	0:0	6	parse_code
op	29:26	0:0	6	==
water	29:29	0:0	6	pc_eos
stmts	29:37	32:4	5	
water	29:37	0:0	6	{
call	30:8	30:31	6	free_sequence_buffers
arg	30:30	30:31	7	s
water	30:30	0:0	8	s
water	30:32	0:0	6	;
water	31:8	0:0	6	s
op	31:9	0:0	6	->
water	31:11	0:0	6	seen_sequence_header
op	31:32	0:0	6	=
water	31:34	0:0	6	0
water	31:35	0:0	6	;
water	32:4	0:0	6	}
else	32:6	41:4	2
stmts	32:11	41:4	3	
if	32:11	41:4	4	(parse_code == pc_aux_data)
cond	32:15	32:29	5	parse_code == pc_aux_data
water	32:15	0:0	6	parse_code
op	32:26	0:0	6	==
water	32:29	0:0	6	pc_aux_data
stmts	32:42	41:4	5	
water	32:42	0:0	6	{
if	33:8	40:8	6	(buf [ 13 ] == 1)
cond	33:12	33:23	7	buf [ 13 ] == 1
water	33:12	0:0	8	buf
op	33:15	0:0	8	[
water	33:16	0:0	8	13
op	33:18	0:0	8	]
op	33:20	0:0	8	==
water	33:23	0:0	8	1
stmts	33:26	40:8	7	
water	33:26	0:0	8	{
decl	34:12	34:22	8	int	ver[3]
if	37:12	39:42	8	(sscanf (buf + 14 ,"Schroedinger %d.%d.%d" ,ver ,ver + 1 ,ver + 2 ) == 3)
cond	37:16	37:78	9	sscanf (buf + 14 ,"Schroedinger %d.%d.%d" ,ver ,ver + 1 ,ver + 2 ) == 3
call	37:16	37:73	10	sscanf
arg	37:23	37:29	11	buf+14
water	37:23	0:0	12	buf
op	37:26	0:0	12	+
water	37:27	0:0	12	14
arg	37:31	37:54	11	"Schroedinger %d.%d.%d"
water	37:31	0:0	12	"Schroedinger %d.%d.%d"
arg	37:56	37:59	11	ver
water	37:56	0:0	12	ver
arg	37:61	37:66	11	ver+1
water	37:61	0:0	12	ver
op	37:64	0:0	12	+
water	37:65	0:0	12	1
arg	37:68	37:73	11	ver+2
water	37:68	0:0	12	ver
op	37:71	0:0	12	+
water	37:72	0:0	12	2
op	37:75	0:0	10	==
water	37:78	0:0	10	3
stmts	38:16	39:42	9	
if	38:16	39:42	10	(ver [ 0 ] == 1 && ver [ 1 ] == 0 && ver [ 2 ] <= 7)
cond	38:20	38:60	11	ver [ 0 ] == 1 && ver [ 1 ] == 0 && ver [ 2 ] <= 7
water	38:20	0:0	12	ver
op	38:23	0:0	12	[
water	38:24	0:0	12	0
op	38:25	0:0	12	]
op	38:27	0:0	12	==
water	38:30	0:0	12	1
op	38:32	0:0	12	&&
water	38:35	0:0	12	ver
op	38:38	0:0	12	[
water	38:39	0:0	12	1
op	38:40	0:0	12	]
op	38:42	0:0	12	==
water	38:45	0:0	12	0
op	38:47	0:0	12	&&
water	38:50	0:0	12	ver
op	38:53	0:0	12	[
water	38:54	0:0	12	2
op	38:55	0:0	12	]
op	38:57	0:0	12	<=
water	38:60	0:0	12	7
stmts	39:20	39:42	11	
water	39:20	0:0	12	s
op	39:21	0:0	12	->
water	39:23	0:0	12	old_delta_quant
op	39:39	0:0	12	=
water	39:41	0:0	12	1
water	39:42	0:0	12	;
water	40:8	0:0	8	}
water	41:4	0:0	6	}
else	41:6	82:4	2
stmts	41:11	82:4	3	
if	41:11	82:4	4	(parse_code & 0 x8)
cond	41:15	41:29	5	parse_code & 0 x8
water	41:15	0:0	6	parse_code
op	41:26	0:0	6	&
water	41:28	0:0	6	0
water	41:29	0:0	6	x8
stmts	41:33	82:4	5	
water	41:33	0:0	6	{
if	42:8	45:8	6	(! s -> seen_sequence_header)
cond	42:12	42:16	7	! s -> seen_sequence_header
op	42:12	0:0	8	!
water	42:13	0:0	8	s
op	42:14	0:0	8	->
water	42:16	0:0	8	seen_sequence_header
stmts	42:38	45:8	7	
water	42:38	0:0	8	{
call	43:12	43:82	8	av_log
arg	43:19	43:24	9	avctx
water	43:19	0:0	10	avctx
arg	43:26	43:38	9	AV_LOG_DEBUG
water	43:26	0:0	10	AV_LOG_DEBUG
arg	43:40	43:82	9	"Dropping frame without sequence header\n"
water	43:40	0:0	10	"Dropping frame without sequence header\n"
water	43:83	0:0	8	;
return	44:12	44:21	8	-1
op	44:19	0:0	9	-
water	44:20	0:0	9	1
water	45:8	0:0	8	}
for	48:8	50:39	6	(i = 0 ;i < MAX_FRAMES;i ++)
forinit	48:13	48:18	7	i = 0 ;
water	48:13	0:0	8	i
op	48:15	0:0	8	=
water	48:17	0:0	8	0
water	48:18	0:0	8	;
cond	48:20	48:24	7	i < MAX_FRAMES
water	48:20	0:0	8	i
op	48:22	0:0	8	<
water	48:24	0:0	8	MAX_FRAMES
forexpr	48:36	48:37	7	i ++
water	48:36	0:0	8	i
op	48:37	0:0	8	++
stmts	49:12	50:39	7	
if	49:12	50:39	8	(s -> all_frames [ i ] . avframe . data [ 0 ] == NULL)
cond	49:16	49:52	9	s -> all_frames [ i ] . avframe . data [ 0 ] == NULL
water	49:16	0:0	10	s
op	49:17	0:0	10	->
water	49:19	0:0	10	all_frames
op	49:29	0:0	10	[
water	49:30	0:0	10	i
op	49:31	0:0	10	]
op	49:32	0:0	10	.
water	49:33	0:0	10	avframe
op	49:40	0:0	10	.
water	49:41	0:0	10	data
op	49:45	0:0	10	[
water	49:46	0:0	10	0
op	49:47	0:0	10	]
op	49:49	0:0	10	==
water	49:52	0:0	10	NULL
stmts	50:16	50:39	9	
water	50:16	0:0	10	pic
op	50:20	0:0	10	=
op	50:22	0:0	10	&
water	50:23	0:0	10	s
op	50:24	0:0	10	->
water	50:26	0:0	10	all_frames
op	50:36	0:0	10	[
water	50:37	0:0	10	i
op	50:38	0:0	10	]
water	50:39	0:0	10	;
if	51:8	54:8	6	(! pic)
cond	51:12	51:13	7	! pic
op	51:12	0:0	8	!
water	51:13	0:0	8	pic
stmts	51:18	54:8	7	
water	51:18	0:0	8	{
call	52:12	52:58	8	av_log
arg	52:19	52:24	9	avctx
water	52:19	0:0	10	avctx
arg	52:26	52:38	9	AV_LOG_ERROR
water	52:26	0:0	10	AV_LOG_ERROR
arg	52:40	52:58	9	"framelist full\n"
water	52:40	0:0	10	"framelist full\n"
water	52:59	0:0	8	;
return	53:12	53:21	8	-1
op	53:19	0:0	9	-
water	53:20	0:0	9	1
water	54:8	0:0	8	}
call	56:8	56:48	6	avcodec_get_frame_defaults
arg	56:35	56:48	7	&pic->avframe
op	56:35	0:0	8	&
water	56:36	0:0	8	pic
op	56:39	0:0	8	->
water	56:41	0:0	8	avframe
water	56:49	0:0	6	;
water	59:8	0:0	6	s
op	59:9	0:0	6	->
water	59:11	0:0	6	num_refs
op	59:23	0:0	6	=
water	59:26	0:0	6	parse_code
op	59:37	0:0	6	&
water	59:39	0:0	6	0
water	59:40	0:0	6	x03
water	59:43	0:0	6	;
water	60:8	0:0	6	s
op	60:9	0:0	6	->
water	60:11	0:0	6	is_arith
op	60:23	0:0	6	=
water	60:25	0:0	6	(
water	60:26	0:0	6	parse_code
op	60:37	0:0	6	&
water	60:39	0:0	6	0
water	60:40	0:0	6	x48
water	60:43	0:0	6	)
op	60:45	0:0	6	==
water	60:48	0:0	6	0
water	60:49	0:0	6	x08
water	60:52	0:0	6	;
water	61:8	0:0	6	s
op	61:9	0:0	6	->
water	61:11	0:0	6	low_delay
op	61:23	0:0	6	=
water	61:25	0:0	6	(
water	61:26	0:0	6	parse_code
op	61:37	0:0	6	&
water	61:39	0:0	6	0
water	61:40	0:0	6	x88
water	61:43	0:0	6	)
op	61:45	0:0	6	==
water	61:48	0:0	6	0
water	61:49	0:0	6	x88
water	61:52	0:0	6	;
water	62:8	0:0	6	pic
op	62:11	0:0	6	->
water	62:13	0:0	6	avframe
op	62:20	0:0	6	.
water	62:21	0:0	6	reference
op	62:31	0:0	6	=
water	62:33	0:0	6	(
water	62:34	0:0	6	parse_code
op	62:45	0:0	6	&
water	62:47	0:0	6	0
water	62:48	0:0	6	x0C
water	62:51	0:0	6	)
op	62:53	0:0	6	==
water	62:56	0:0	6	0
water	62:57	0:0	6	x0C
water	62:60	0:0	6	;
water	63:8	0:0	6	pic
op	63:11	0:0	6	->
water	63:13	0:0	6	avframe
op	63:20	0:0	6	.
water	63:21	0:0	6	key_frame
op	63:31	0:0	6	=
water	63:33	0:0	6	s
op	63:34	0:0	6	->
water	63:36	0:0	6	num_refs
op	63:45	0:0	6	==
water	63:48	0:0	6	0
water	63:49	0:0	6	;
water	64:8	0:0	6	pic
op	64:11	0:0	6	->
water	64:13	0:0	6	avframe
op	64:20	0:0	6	.
water	64:21	0:0	6	pict_type
op	64:31	0:0	6	=
water	64:33	0:0	6	s
op	64:34	0:0	6	->
water	64:36	0:0	6	num_refs
op	64:45	0:0	6	+
water	64:47	0:0	6	1
water	64:48	0:0	6	;
if	66:8	69:8	6	(avctx -> get_buffer (avctx ,& pic -> avframe ) < 0)
cond	66:12	66:54	7	avctx -> get_buffer (avctx ,& pic -> avframe ) < 0
call	66:12	66:50	8	avctx->get_buffer
arg	66:30	66:35	9	avctx
water	66:30	0:0	10	avctx
arg	66:37	66:50	9	&pic->avframe
op	66:37	0:0	10	&
water	66:38	0:0	10	pic
op	66:41	0:0	10	->
water	66:43	0:0	10	avframe
op	66:52	0:0	8	<
water	66:54	0:0	8	0
stmts	66:57	69:8	7	
water	66:57	0:0	8	{
call	67:12	67:63	8	av_log
arg	67:19	67:24	9	avctx
water	67:19	0:0	10	avctx
arg	67:26	67:38	9	AV_LOG_ERROR
water	67:26	0:0	10	AV_LOG_ERROR
arg	67:40	67:63	9	"get_buffer() failed\n"
water	67:40	0:0	10	"get_buffer() failed\n"
water	67:64	0:0	8	;
return	68:12	68:21	8	-1
op	68:19	0:0	9	-
water	68:20	0:0	9	1
water	69:8	0:0	8	}
water	70:8	0:0	6	s
op	70:9	0:0	6	->
water	70:11	0:0	6	current_picture
op	70:27	0:0	6	=
water	70:29	0:0	6	pic
water	70:32	0:0	6	;
water	71:8	0:0	6	s
op	71:9	0:0	6	->
water	71:11	0:0	6	plane
op	71:16	0:0	6	[
water	71:17	0:0	6	0
op	71:18	0:0	6	]
op	71:19	0:0	6	.
water	71:20	0:0	6	stride
op	71:27	0:0	6	=
water	71:29	0:0	6	pic
op	71:32	0:0	6	->
water	71:34	0:0	6	avframe
op	71:41	0:0	6	.
water	71:42	0:0	6	linesize
op	71:50	0:0	6	[
water	71:51	0:0	6	0
op	71:52	0:0	6	]
water	71:53	0:0	6	;
water	72:8	0:0	6	s
op	72:9	0:0	6	->
water	72:11	0:0	6	plane
op	72:16	0:0	6	[
water	72:17	0:0	6	1
op	72:18	0:0	6	]
op	72:19	0:0	6	.
water	72:20	0:0	6	stride
op	72:27	0:0	6	=
water	72:29	0:0	6	pic
op	72:32	0:0	6	->
water	72:34	0:0	6	avframe
op	72:41	0:0	6	.
water	72:42	0:0	6	linesize
op	72:50	0:0	6	[
water	72:51	0:0	6	1
op	72:52	0:0	6	]
water	72:53	0:0	6	;
water	73:8	0:0	6	s
op	73:9	0:0	6	->
water	73:11	0:0	6	plane
op	73:16	0:0	6	[
water	73:17	0:0	6	2
op	73:18	0:0	6	]
op	73:19	0:0	6	.
water	73:20	0:0	6	stride
op	73:27	0:0	6	=
water	73:29	0:0	6	pic
op	73:32	0:0	6	->
water	73:34	0:0	6	avframe
op	73:41	0:0	6	.
water	73:42	0:0	6	linesize
op	73:50	0:0	6	[
water	73:51	0:0	6	2
op	73:52	0:0	6	]
water	73:53	0:0	6	;
if	76:8	77:21	6	(dirac_decode_picture_header (s ))
cond	76:12	76:41	7	dirac_decode_picture_header (s )
call	76:12	76:41	8	dirac_decode_picture_header
arg	76:40	76:41	9	s
water	76:40	0:0	10	s
stmts	77:12	77:21	7	
return	77:12	77:21	8	-1
op	77:19	0:0	9	-
water	77:20	0:0	9	1
if	80:8	81:21	6	(dirac_decode_frame_internal (s ))
cond	80:12	80:41	7	dirac_decode_frame_internal (s )
call	80:12	80:41	8	dirac_decode_frame_internal
arg	80:40	80:41	9	s
water	80:40	0:0	10	s
stmts	81:12	81:21	7	
return	81:12	81:21	8	-1
op	81:19	0:0	9	-
water	81:20	0:0	9	1
water	82:4	0:0	6	}
return	83:4	83:12	2	0
water	83:11	0:0	3	0
