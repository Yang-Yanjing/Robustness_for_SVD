func	2:0	142:0	0	static int	old_codec37
params	2:22	0:0	1	
param	2:23	2:44	2	SANMVideoContext *	ctx
param	2:46	2:53	2	int	top
param	3:23	3:31	2	int	left
param	3:33	3:42	2	int	width
param	3:44	3:54	2	int	height
stmnts	0:0	141:12	1	
decl	5:4	5:27	2	int	stride
op	5:15	0:0	2	=
water	5:17	0:0	2	ctx
op	5:20	0:0	2	->
water	5:22	0:0	2	pitch
decl	6:4	6:18	2	int	i
water	6:9	0:0	2	,
decl	6:4	6:18	2	int	j
water	6:12	0:0	2	,
decl	6:4	6:18	2	int	k
water	6:15	0:0	2	,
decl	6:4	6:18	2	int	t
decl	7:4	7:20	2	int	skip_run
op	7:17	0:0	2	=
water	7:19	0:0	2	0
decl	8:4	8:32	2	int	compr
water	8:13	0:0	2	,
decl	8:4	8:32	2	int	mvoff
water	8:20	0:0	2	,
decl	8:4	8:32	2	int	seq
water	8:25	0:0	2	,
decl	8:4	8:32	2	int	flags
decl	9:4	9:25	2	uint32_t	decoded_size
decl	10:4	10:23	2	uint8_t	*dst
water	10:16	0:0	2	,
decl	10:4	10:23	2	uint8_t	*prev
water	12:4	0:0	2	compr
op	12:17	0:0	2	=
call	12:19	12:48	2	bytestream2_get_byte
arg	12:40	12:48	3	&ctx->gb
op	12:40	0:0	4	&
water	12:41	0:0	4	ctx
op	12:44	0:0	4	->
water	12:46	0:0	4	gb
water	12:49	0:0	2	;
water	13:4	0:0	2	mvoff
op	13:17	0:0	2	=
call	13:19	13:48	2	bytestream2_get_byte
arg	13:40	13:48	3	&ctx->gb
op	13:40	0:0	4	&
water	13:41	0:0	4	ctx
op	13:44	0:0	4	->
water	13:46	0:0	4	gb
water	13:49	0:0	2	;
water	14:4	0:0	2	seq
op	14:17	0:0	2	=
call	14:19	14:48	2	bytestream2_get_le16
arg	14:40	14:48	3	&ctx->gb
op	14:40	0:0	4	&
water	14:41	0:0	4	ctx
op	14:44	0:0	4	->
water	14:46	0:0	4	gb
water	14:49	0:0	2	;
water	15:4	0:0	2	decoded_size
op	15:17	0:0	2	=
call	15:19	15:48	2	bytestream2_get_le32
arg	15:40	15:48	3	&ctx->gb
op	15:40	0:0	4	&
water	15:41	0:0	4	ctx
op	15:44	0:0	4	->
water	15:46	0:0	4	gb
water	15:49	0:0	2	;
call	16:4	16:32	2	bytestream2_skip
arg	16:21	16:29	3	&ctx->gb
op	16:21	0:0	4	&
water	16:22	0:0	4	ctx
op	16:25	0:0	4	->
water	16:27	0:0	4	gb
arg	16:31	16:32	3	4
water	16:31	0:0	4	4
water	16:33	0:0	2	;
water	17:4	0:0	2	flags
op	17:17	0:0	2	=
call	17:19	17:48	2	bytestream2_get_byte
arg	17:40	17:48	3	&ctx->gb
op	17:40	0:0	4	&
water	17:41	0:0	4	ctx
op	17:44	0:0	4	->
water	17:46	0:0	4	gb
water	17:49	0:0	2	;
call	18:4	18:32	2	bytestream2_skip
arg	18:21	18:29	3	&ctx->gb
op	18:21	0:0	4	&
water	18:22	0:0	4	ctx
op	18:25	0:0	4	->
water	18:27	0:0	4	gb
arg	18:31	18:32	3	3
water	18:31	0:0	4	3
water	18:33	0:0	2	;
water	20:4	0:0	2	ctx
op	20:7	0:0	2	->
water	20:9	0:0	2	rotate_code
op	20:21	0:0	2	=
water	20:23	0:0	2	0
water	20:24	0:0	2	;
if	22:4	23:27	2	(( ( seq & 1 ) || ! ( flags & 1 ) ) && ( compr && compr != 2 ))
cond	22:8	22:59	3	( ( seq & 1 ) || ! ( flags & 1 ) ) && ( compr && compr != 2 )
water	22:8	0:0	4	(
water	22:9	0:0	4	(
water	22:10	0:0	4	seq
op	22:14	0:0	4	&
water	22:16	0:0	4	1
water	22:17	0:0	4	)
op	22:19	0:0	4	||
op	22:22	0:0	4	!
water	22:23	0:0	4	(
water	22:24	0:0	4	flags
op	22:30	0:0	4	&
water	22:32	0:0	4	1
water	22:33	0:0	4	)
water	22:34	0:0	4	)
op	22:36	0:0	4	&&
water	22:39	0:0	4	(
water	22:40	0:0	4	compr
op	22:46	0:0	4	&&
water	22:49	0:0	4	compr
op	22:55	0:0	4	!=
water	22:58	0:0	4	2
water	22:59	0:0	4	)
stmts	23:8	23:27	3	
call	23:8	23:26	4	rotate_bufs
arg	23:20	23:23	5	ctx
water	23:20	0:0	6	ctx
arg	23:25	23:26	5	1
water	23:25	0:0	6	1
water	23:27	0:0	4	;
water	25:4	0:0	2	dst
op	25:9	0:0	2	=
water	25:11	0:0	2	(
water	25:12	0:0	2	(
water	25:13	0:0	2	uint8_t
op	25:20	0:0	2	*
water	25:21	0:0	2	)
water	25:22	0:0	2	ctx
op	25:25	0:0	2	->
water	25:27	0:0	2	frm0
water	25:31	0:0	2	)
op	25:33	0:0	2	+
water	25:35	0:0	2	left
op	25:40	0:0	2	+
water	25:42	0:0	2	top
op	25:46	0:0	2	*
water	25:48	0:0	2	stride
water	25:54	0:0	2	;
water	26:4	0:0	2	prev
op	26:9	0:0	2	=
water	26:11	0:0	2	(
water	26:12	0:0	2	(
water	26:13	0:0	2	uint8_t
op	26:20	0:0	2	*
water	26:21	0:0	2	)
water	26:22	0:0	2	ctx
op	26:25	0:0	2	->
water	26:27	0:0	2	frm2
water	26:31	0:0	2	)
op	26:33	0:0	2	+
water	26:35	0:0	2	left
op	26:40	0:0	2	+
water	26:42	0:0	2	top
op	26:46	0:0	2	*
water	26:48	0:0	2	stride
water	26:54	0:0	2	;
if	28:4	31:4	2	(mvoff > 2)
cond	28:8	28:16	3	mvoff > 2
water	28:8	0:0	4	mvoff
op	28:14	0:0	4	>
water	28:16	0:0	4	2
stmts	28:19	31:4	3	
water	28:19	0:0	4	{
call	29:8	29:80	4	av_log
arg	29:15	29:25	5	ctx->avctx
water	29:15	0:0	6	ctx
op	29:18	0:0	6	->
water	29:20	0:0	6	avctx
arg	29:27	29:39	5	AV_LOG_ERROR
water	29:27	0:0	6	AV_LOG_ERROR
arg	29:41	29:73	5	"invalid motion base value %d\n"
water	29:41	0:0	6	"invalid motion base value %d\n"
arg	29:75	29:80	5	mvoff
water	29:75	0:0	6	mvoff
water	29:81	0:0	4	;
return	30:8	30:34	4	AVERROR_INVALIDDATA
water	30:15	0:0	5	AVERROR_INVALIDDATA
water	31:4	0:0	4	}
call	32:4	32:49	2	av_dlog
arg	32:12	32:22	3	ctx->avctx
water	32:12	0:0	4	ctx
op	32:15	0:0	4	->
water	32:17	0:0	4	avctx
arg	32:24	32:42	3	"compression %d\n"
water	32:24	0:0	4	"compression %d\n"
arg	32:44	32:49	3	compr
water	32:44	0:0	4	compr
water	32:50	0:0	2	;
switch	33:4	139:4	2	(compr)
cond	33:12	33:12	3	compr
water	33:12	0:0	4	compr
stmts	33:19	139:4	3	
water	33:19	0:0	4	{
label	34:4	34:10	4	case 0 :
for	35:8	38:8	4	(i = 0 ;i < height;i ++)
forinit	35:13	35:18	5	i = 0 ;
water	35:13	0:0	6	i
op	35:15	0:0	6	=
water	35:17	0:0	6	0
water	35:18	0:0	6	;
cond	35:20	35:24	5	i < height
water	35:20	0:0	6	i
op	35:22	0:0	6	<
water	35:24	0:0	6	height
forexpr	35:32	35:33	5	i ++
water	35:32	0:0	6	i
op	35:33	0:0	6	++
stmts	35:37	38:8	5	
water	35:37	0:0	6	{
call	36:12	36:55	6	bytestream2_get_buffer
arg	36:35	36:43	7	&ctx->gb
op	36:35	0:0	8	&
water	36:36	0:0	8	ctx
op	36:39	0:0	8	->
water	36:41	0:0	8	gb
arg	36:45	36:48	7	dst
water	36:45	0:0	8	dst
arg	36:50	36:55	7	width
water	36:50	0:0	8	width
water	36:56	0:0	6	;
water	37:12	0:0	6	dst
op	37:16	0:0	6	+=
water	37:19	0:0	6	stride
water	37:25	0:0	6	;
water	38:8	0:0	6	}
call	39:8	39:49	4	memset
arg	39:15	39:24	5	ctx->frm1
water	39:15	0:0	6	ctx
op	39:18	0:0	6	->
water	39:20	0:0	6	frm1
arg	39:26	39:27	5	0
water	39:26	0:0	6	0
arg	39:29	39:49	5	ctx->height*stride
water	39:29	0:0	6	ctx
op	39:32	0:0	6	->
water	39:34	0:0	6	height
op	39:41	0:0	6	*
water	39:43	0:0	6	stride
water	39:50	0:0	4	;
call	40:8	40:49	4	memset
arg	40:15	40:24	5	ctx->frm2
water	40:15	0:0	6	ctx
op	40:18	0:0	6	->
water	40:20	0:0	6	frm2
arg	40:26	40:27	5	0
water	40:26	0:0	6	0
arg	40:29	40:49	5	ctx->height*stride
water	40:29	0:0	6	ctx
op	40:32	0:0	6	->
water	40:34	0:0	6	height
op	40:41	0:0	6	*
water	40:43	0:0	6	stride
water	40:50	0:0	4	;
break	41:8	41:13	4	
label	42:4	42:10	4	case 2 :
if	43:8	44:38	4	(rle_decode (ctx ,dst ,decoded_size ))
cond	43:12	43:45	5	rle_decode (ctx ,dst ,decoded_size )
call	43:12	43:45	6	rle_decode
arg	43:23	43:26	7	ctx
water	43:23	0:0	8	ctx
arg	43:28	43:31	7	dst
water	43:28	0:0	8	dst
arg	43:33	43:45	7	decoded_size
water	43:33	0:0	8	decoded_size
stmts	44:12	44:38	5	
return	44:12	44:38	6	AVERROR_INVALIDDATA
water	44:19	0:0	7	AVERROR_INVALIDDATA
call	45:8	45:43	4	memset
arg	45:15	45:24	5	ctx->frm1
water	45:15	0:0	6	ctx
op	45:18	0:0	6	->
water	45:20	0:0	6	frm1
arg	45:26	45:27	5	0
water	45:26	0:0	6	0
arg	45:29	45:43	5	ctx->frm1_size
water	45:29	0:0	6	ctx
op	45:32	0:0	6	->
water	45:34	0:0	6	frm1_size
water	45:44	0:0	4	;
call	46:8	46:43	4	memset
arg	46:15	46:24	5	ctx->frm2
water	46:15	0:0	6	ctx
op	46:18	0:0	6	->
water	46:20	0:0	6	frm2
arg	46:26	46:27	5	0
water	46:26	0:0	6	0
arg	46:29	46:43	5	ctx->frm2_size
water	46:29	0:0	6	ctx
op	46:32	0:0	6	->
water	46:34	0:0	6	frm2_size
water	46:44	0:0	4	;
break	47:8	47:13	4	
label	48:4	48:10	4	case 3 :
label	49:4	49:10	4	case 4 :
if	50:8	101:8	4	(flags & 4)
cond	50:12	50:20	5	flags & 4
water	50:12	0:0	6	flags
op	50:18	0:0	6	&
water	50:20	0:0	6	4
stmts	50:23	101:8	5	
water	50:23	0:0	6	{
for	51:12	100:12	6	(j = 0 ;j < height;j += 4)
forinit	51:17	51:22	7	j = 0 ;
water	51:17	0:0	8	j
op	51:19	0:0	8	=
water	51:21	0:0	8	0
water	51:22	0:0	8	;
cond	51:24	51:28	7	j < height
water	51:24	0:0	8	j
op	51:26	0:0	8	<
water	51:28	0:0	8	height
forexpr	51:36	51:41	7	j += 4
water	51:36	0:0	8	j
op	51:38	0:0	8	+=
water	51:41	0:0	8	4
stmts	51:44	100:12	7	
water	51:44	0:0	8	{
for	52:16	97:16	8	(i = 0 ;i < width;i += 4)
forinit	52:21	52:26	9	i = 0 ;
water	52:21	0:0	10	i
op	52:23	0:0	10	=
water	52:25	0:0	10	0
water	52:26	0:0	10	;
cond	52:28	52:32	9	i < width
water	52:28	0:0	10	i
op	52:30	0:0	10	<
water	52:32	0:0	10	width
forexpr	52:39	52:44	9	i += 4
water	52:39	0:0	10	i
op	52:41	0:0	10	+=
water	52:44	0:0	10	4
stmts	52:47	97:16	9	
water	52:47	0:0	10	{
decl	53:20	53:28	10	int	code
if	54:20	58:20	10	(skip_run)
cond	54:24	54:24	11	skip_run
water	54:24	0:0	12	skip_run
stmts	54:34	58:20	11	
water	54:34	0:0	12	{
water	55:24	0:0	12	skip_run
op	55:32	0:0	12	--
water	55:34	0:0	12	;
call	56:24	56:72	12	copy_block4
arg	56:36	56:43	13	dst+i
water	56:36	0:0	14	dst
op	56:40	0:0	14	+
water	56:42	0:0	14	i
arg	56:45	56:53	13	prev+i
water	56:45	0:0	14	prev
op	56:50	0:0	14	+
water	56:52	0:0	14	i
arg	56:55	56:61	13	stride
water	56:55	0:0	14	stride
arg	56:63	56:69	13	stride
water	56:63	0:0	14	stride
arg	56:71	56:72	13	4
water	56:71	0:0	14	4
water	56:73	0:0	12	;
continue	57:24	57:32	12	
water	58:20	0:0	12	}
if	59:20	60:50	10	(bytestream2_get_bytes_left (& ctx -> gb ) < 1)
cond	59:24	59:63	11	bytestream2_get_bytes_left (& ctx -> gb ) < 1
call	59:24	59:59	12	bytestream2_get_bytes_left
arg	59:51	59:59	13	&ctx->gb
op	59:51	0:0	14	&
water	59:52	0:0	14	ctx
op	59:55	0:0	14	->
water	59:57	0:0	14	gb
op	59:61	0:0	12	<
water	59:63	0:0	12	1
stmts	60:24	60:50	11	
return	60:24	60:50	12	AVERROR_INVALIDDATA
water	60:31	0:0	13	AVERROR_INVALIDDATA
water	61:20	0:0	10	code
op	61:25	0:0	10	=
call	61:27	61:57	10	bytestream2_get_byteu
arg	61:49	61:57	11	&ctx->gb
op	61:49	0:0	12	&
water	61:50	0:0	12	ctx
op	61:53	0:0	12	->
water	61:55	0:0	12	gb
water	61:58	0:0	10	;
switch	62:20	96:20	10	(code)
cond	62:28	62:28	11	code
water	62:28	0:0	12	code
stmts	62:34	96:20	11	
water	62:34	0:0	12	{
label	63:20	63:29	12	case 0 xFF :
if	64:24	65:54	12	(bytestream2_get_bytes_left (& ctx -> gb ) < 16)
cond	64:28	64:67	13	bytestream2_get_bytes_left (& ctx -> gb ) < 16
call	64:28	64:63	14	bytestream2_get_bytes_left
arg	64:55	64:63	15	&ctx->gb
op	64:55	0:0	16	&
water	64:56	0:0	16	ctx
op	64:59	0:0	16	->
water	64:61	0:0	16	gb
op	64:65	0:0	14	<
water	64:67	0:0	14	16
stmts	65:28	65:54	13	
return	65:28	65:54	14	AVERROR_INVALIDDATA
water	65:35	0:0	15	AVERROR_INVALIDDATA
for	66:24	67:86	12	(k = 0 ;k < 4;k ++)
forinit	66:29	66:34	13	k = 0 ;
water	66:29	0:0	14	k
op	66:31	0:0	14	=
water	66:33	0:0	14	0
water	66:34	0:0	14	;
cond	66:36	66:40	13	k < 4
water	66:36	0:0	14	k
op	66:38	0:0	14	<
water	66:40	0:0	14	4
forexpr	66:43	66:44	13	k ++
water	66:43	0:0	14	k
op	66:44	0:0	14	++
stmts	67:28	67:86	13	
call	67:28	67:85	14	bytestream2_get_bufferu
arg	67:52	67:60	15	&ctx->gb
op	67:52	0:0	16	&
water	67:53	0:0	16	ctx
op	67:56	0:0	16	->
water	67:58	0:0	16	gb
arg	67:62	67:82	15	dst+i+k*stride
water	67:62	0:0	16	dst
op	67:66	0:0	16	+
water	67:68	0:0	16	i
op	67:70	0:0	16	+
water	67:72	0:0	16	k
op	67:74	0:0	16	*
water	67:76	0:0	16	stride
arg	67:84	67:85	15	4
water	67:84	0:0	16	4
water	67:86	0:0	14	;
break	68:24	68:29	12	
label	69:20	69:29	12	case 0 xFE :
if	70:24	71:54	12	(bytestream2_get_bytes_left (& ctx -> gb ) < 4)
cond	70:28	70:67	13	bytestream2_get_bytes_left (& ctx -> gb ) < 4
call	70:28	70:63	14	bytestream2_get_bytes_left
arg	70:55	70:63	15	&ctx->gb
op	70:55	0:0	16	&
water	70:56	0:0	16	ctx
op	70:59	0:0	16	->
water	70:61	0:0	16	gb
op	70:65	0:0	14	<
water	70:67	0:0	14	4
stmts	71:28	71:54	13	
return	71:28	71:54	14	AVERROR_INVALIDDATA
water	71:35	0:0	15	AVERROR_INVALIDDATA
for	72:24	73:92	12	(k = 0 ;k < 4;k ++)
forinit	72:29	72:34	13	k = 0 ;
water	72:29	0:0	14	k
op	72:31	0:0	14	=
water	72:33	0:0	14	0
water	72:34	0:0	14	;
cond	72:36	72:40	13	k < 4
water	72:36	0:0	14	k
op	72:38	0:0	14	<
water	72:40	0:0	14	4
forexpr	72:43	72:44	13	k ++
water	72:43	0:0	14	k
op	72:44	0:0	14	++
stmts	73:28	73:92	13	
call	73:28	73:91	14	memset
arg	73:35	73:55	15	dst+i+k*stride
water	73:35	0:0	16	dst
op	73:39	0:0	16	+
water	73:41	0:0	16	i
op	73:43	0:0	16	+
water	73:45	0:0	16	k
op	73:47	0:0	16	*
water	73:49	0:0	16	stride
arg	73:57	73:88	15	bytestream2_get_byteu(&ctx->gb)
call	73:57	73:87	16	bytestream2_get_byteu
arg	73:79	73:87	17	&ctx->gb
op	73:79	0:0	18	&
water	73:80	0:0	18	ctx
op	73:83	0:0	18	->
water	73:85	0:0	18	gb
arg	73:90	73:91	15	4
water	73:90	0:0	16	4
water	73:92	0:0	14	;
break	74:24	74:29	12	
label	75:20	75:29	12	case 0 xFD :
if	76:24	77:54	12	(bytestream2_get_bytes_left (& ctx -> gb ) < 1)
cond	76:28	76:67	13	bytestream2_get_bytes_left (& ctx -> gb ) < 1
call	76:28	76:63	14	bytestream2_get_bytes_left
arg	76:55	76:63	15	&ctx->gb
op	76:55	0:0	16	&
water	76:56	0:0	16	ctx
op	76:59	0:0	16	->
water	76:61	0:0	16	gb
op	76:65	0:0	14	<
water	76:67	0:0	14	1
stmts	77:28	77:54	13	
return	77:28	77:54	14	AVERROR_INVALIDDATA
water	77:35	0:0	15	AVERROR_INVALIDDATA
water	78:24	0:0	12	t
op	78:26	0:0	12	=
call	78:28	78:58	12	bytestream2_get_byteu
arg	78:50	78:58	13	&ctx->gb
op	78:50	0:0	14	&
water	78:51	0:0	14	ctx
op	78:54	0:0	14	->
water	78:56	0:0	14	gb
water	78:59	0:0	12	;
for	79:24	80:62	12	(k = 0 ;k < 4;k ++)
forinit	79:29	79:34	13	k = 0 ;
water	79:29	0:0	14	k
op	79:31	0:0	14	=
water	79:33	0:0	14	0
water	79:34	0:0	14	;
cond	79:36	79:40	13	k < 4
water	79:36	0:0	14	k
op	79:38	0:0	14	<
water	79:40	0:0	14	4
forexpr	79:43	79:44	13	k ++
water	79:43	0:0	14	k
op	79:44	0:0	14	++
stmts	80:28	80:62	13	
call	80:28	80:61	14	memset
arg	80:35	80:55	15	dst+i+k*stride
water	80:35	0:0	16	dst
op	80:39	0:0	16	+
water	80:41	0:0	16	i
op	80:43	0:0	16	+
water	80:45	0:0	16	k
op	80:47	0:0	16	*
water	80:49	0:0	16	stride
arg	80:57	80:58	15	t
water	80:57	0:0	16	t
arg	80:60	80:61	15	4
water	80:60	0:0	16	4
water	80:62	0:0	14	;
break	81:24	81:29	12	
label	82:20	82:27	12	default :
if	83:24	88:24	12	(compr == 4 && ! code)
cond	83:28	83:43	13	compr == 4 && ! code
water	83:28	0:0	14	compr
op	83:34	0:0	14	==
water	83:37	0:0	14	4
op	83:39	0:0	14	&&
op	83:42	0:0	14	!
water	83:43	0:0	14	code
stmts	83:49	88:24	13	
water	83:49	0:0	14	{
if	84:28	85:58	14	(bytestream2_get_bytes_left (& ctx -> gb ) < 1)
cond	84:32	84:71	15	bytestream2_get_bytes_left (& ctx -> gb ) < 1
call	84:32	84:67	16	bytestream2_get_bytes_left
arg	84:59	84:67	17	&ctx->gb
op	84:59	0:0	18	&
water	84:60	0:0	18	ctx
op	84:63	0:0	18	->
water	84:65	0:0	18	gb
op	84:69	0:0	16	<
water	84:71	0:0	16	1
stmts	85:32	85:58	15	
return	85:32	85:58	16	AVERROR_INVALIDDATA
water	85:39	0:0	17	AVERROR_INVALIDDATA
water	86:28	0:0	14	skip_run
op	86:37	0:0	14	=
call	86:39	86:69	14	bytestream2_get_byteu
arg	86:61	86:69	15	&ctx->gb
op	86:61	0:0	16	&
water	86:62	0:0	16	ctx
op	86:65	0:0	16	->
water	86:67	0:0	16	gb
op	86:71	0:0	14	+
water	86:73	0:0	14	1
water	86:74	0:0	14	;
water	87:28	0:0	14	i
op	87:30	0:0	14	-=
water	87:33	0:0	14	4
water	87:34	0:0	14	;
water	88:24	0:0	14	}
else	88:26	95:24	12
stmts	88:31	95:24	13	
water	88:31	0:0	14	{
decl	89:28	89:38	14	int	mx
water	89:34	0:0	14	,
decl	89:28	89:38	14	int	my
water	91:28	0:0	14	mx
op	91:31	0:0	14	=
water	91:33	0:0	14	c37_mv
op	91:39	0:0	14	[
water	91:40	0:0	14	(
water	91:41	0:0	14	mvoff
op	91:47	0:0	14	*
water	91:49	0:0	14	255
op	91:53	0:0	14	+
water	91:55	0:0	14	code
water	91:59	0:0	14	)
op	91:61	0:0	14	*
water	91:63	0:0	14	2
op	91:68	0:0	14	]
water	91:69	0:0	14	;
water	92:28	0:0	14	my
op	92:31	0:0	14	=
water	92:33	0:0	14	c37_mv
op	92:39	0:0	14	[
water	92:40	0:0	14	(
water	92:41	0:0	14	mvoff
op	92:47	0:0	14	*
water	92:49	0:0	14	255
op	92:53	0:0	14	+
water	92:55	0:0	14	code
water	92:59	0:0	14	)
op	92:61	0:0	14	*
water	92:63	0:0	14	2
op	92:65	0:0	14	+
water	92:67	0:0	14	1
op	92:68	0:0	14	]
water	92:69	0:0	14	;
call	93:28	94:74	14	codec37_mv
arg	93:39	93:46	15	dst+i
water	93:39	0:0	16	dst
op	93:43	0:0	16	+
water	93:45	0:0	16	i
arg	93:48	93:75	15	prev+i+mx+my*stride
water	93:48	0:0	16	prev
op	93:53	0:0	16	+
water	93:55	0:0	16	i
op	93:57	0:0	16	+
water	93:59	0:0	16	mx
op	93:62	0:0	16	+
water	93:64	0:0	16	my
op	93:67	0:0	16	*
water	93:69	0:0	16	stride
arg	94:39	94:50	15	ctx->height
water	94:39	0:0	16	ctx
op	94:42	0:0	16	->
water	94:44	0:0	16	height
arg	94:52	94:58	15	stride
water	94:52	0:0	16	stride
arg	94:60	94:66	15	i+mx
water	94:60	0:0	16	i
op	94:62	0:0	16	+
water	94:64	0:0	16	mx
arg	94:68	94:74	15	j+my
water	94:68	0:0	16	j
op	94:70	0:0	16	+
water	94:72	0:0	16	my
water	94:75	0:0	14	;
water	95:24	0:0	14	}
water	96:20	0:0	12	}
water	97:16	0:0	10	}
water	98:16	0:0	8	dst
op	98:21	0:0	8	+=
water	98:24	0:0	8	stride
op	98:31	0:0	8	*
water	98:33	0:0	8	4
water	98:34	0:0	8	;
water	99:16	0:0	8	prev
op	99:21	0:0	8	+=
water	99:24	0:0	8	stride
op	99:31	0:0	8	*
water	99:33	0:0	8	4
water	99:34	0:0	8	;
water	100:12	0:0	8	}
water	101:8	0:0	6	}
else	101:10	133:8	4
stmts	101:15	133:8	5	
water	101:15	0:0	6	{
for	102:12	132:12	6	(j = 0 ;j < height;j += 4)
forinit	102:17	102:22	7	j = 0 ;
water	102:17	0:0	8	j
op	102:19	0:0	8	=
water	102:21	0:0	8	0
water	102:22	0:0	8	;
cond	102:24	102:28	7	j < height
water	102:24	0:0	8	j
op	102:26	0:0	8	<
water	102:28	0:0	8	height
forexpr	102:36	102:41	7	j += 4
water	102:36	0:0	8	j
op	102:38	0:0	8	+=
water	102:41	0:0	8	4
stmts	102:44	132:12	7	
water	102:44	0:0	8	{
for	103:16	129:16	8	(i = 0 ;i < width;i += 4)
forinit	103:21	103:26	9	i = 0 ;
water	103:21	0:0	10	i
op	103:23	0:0	10	=
water	103:25	0:0	10	0
water	103:26	0:0	10	;
cond	103:28	103:32	9	i < width
water	103:28	0:0	10	i
op	103:30	0:0	10	<
water	103:32	0:0	10	width
forexpr	103:39	103:44	9	i += 4
water	103:39	0:0	10	i
op	103:41	0:0	10	+=
water	103:44	0:0	10	4
stmts	103:47	129:16	9	
water	103:47	0:0	10	{
decl	104:20	104:28	10	int	code
if	105:20	109:20	10	(skip_run)
cond	105:24	105:24	11	skip_run
water	105:24	0:0	12	skip_run
stmts	105:34	109:20	11	
water	105:34	0:0	12	{
water	106:24	0:0	12	skip_run
op	106:32	0:0	12	--
water	106:34	0:0	12	;
call	107:24	107:72	12	copy_block4
arg	107:36	107:43	13	dst+i
water	107:36	0:0	14	dst
op	107:40	0:0	14	+
water	107:42	0:0	14	i
arg	107:45	107:53	13	prev+i
water	107:45	0:0	14	prev
op	107:50	0:0	14	+
water	107:52	0:0	14	i
arg	107:55	107:61	13	stride
water	107:55	0:0	14	stride
arg	107:63	107:69	13	stride
water	107:63	0:0	14	stride
arg	107:71	107:72	13	4
water	107:71	0:0	14	4
water	107:73	0:0	12	;
continue	108:24	108:32	12	
water	109:20	0:0	12	}
water	110:20	0:0	10	code
op	110:25	0:0	10	=
call	110:27	110:56	10	bytestream2_get_byte
arg	110:48	110:56	11	&ctx->gb
op	110:48	0:0	12	&
water	110:49	0:0	12	ctx
op	110:52	0:0	12	->
water	110:54	0:0	12	gb
water	110:57	0:0	10	;
if	111:20	116:20	10	(code == 0 xFF)
cond	111:24	111:33	11	code == 0 xFF
water	111:24	0:0	12	code
op	111:29	0:0	12	==
water	111:32	0:0	12	0
water	111:33	0:0	12	xFF
stmts	111:38	116:20	11	
water	111:38	0:0	12	{
if	112:24	113:54	12	(bytestream2_get_bytes_left (& ctx -> gb ) < 16)
cond	112:28	112:67	13	bytestream2_get_bytes_left (& ctx -> gb ) < 16
call	112:28	112:63	14	bytestream2_get_bytes_left
arg	112:55	112:63	15	&ctx->gb
op	112:55	0:0	16	&
water	112:56	0:0	16	ctx
op	112:59	0:0	16	->
water	112:61	0:0	16	gb
op	112:65	0:0	14	<
water	112:67	0:0	14	16
stmts	113:28	113:54	13	
return	113:28	113:54	14	AVERROR_INVALIDDATA
water	113:35	0:0	15	AVERROR_INVALIDDATA
for	114:24	115:86	12	(k = 0 ;k < 4;k ++)
forinit	114:29	114:34	13	k = 0 ;
water	114:29	0:0	14	k
op	114:31	0:0	14	=
water	114:33	0:0	14	0
water	114:34	0:0	14	;
cond	114:36	114:40	13	k < 4
water	114:36	0:0	14	k
op	114:38	0:0	14	<
water	114:40	0:0	14	4
forexpr	114:43	114:44	13	k ++
water	114:43	0:0	14	k
op	114:44	0:0	14	++
stmts	115:28	115:86	13	
call	115:28	115:85	14	bytestream2_get_bufferu
arg	115:52	115:60	15	&ctx->gb
op	115:52	0:0	16	&
water	115:53	0:0	16	ctx
op	115:56	0:0	16	->
water	115:58	0:0	16	gb
arg	115:62	115:82	15	dst+i+k*stride
water	115:62	0:0	16	dst
op	115:66	0:0	16	+
water	115:68	0:0	16	i
op	115:70	0:0	16	+
water	115:72	0:0	16	k
op	115:74	0:0	16	*
water	115:76	0:0	16	stride
arg	115:84	115:85	15	4
water	115:84	0:0	16	4
water	115:86	0:0	14	;
water	116:20	0:0	12	}
else	116:22	121:20	10
stmts	116:27	121:20	11	
if	116:27	121:20	12	(compr == 4 && ! code)
cond	116:31	116:46	13	compr == 4 && ! code
water	116:31	0:0	14	compr
op	116:37	0:0	14	==
water	116:40	0:0	14	4
op	116:42	0:0	14	&&
op	116:45	0:0	14	!
water	116:46	0:0	14	code
stmts	116:52	121:20	13	
water	116:52	0:0	14	{
if	117:24	118:54	14	(bytestream2_get_bytes_left (& ctx -> gb ) < 1)
cond	117:28	117:67	15	bytestream2_get_bytes_left (& ctx -> gb ) < 1
call	117:28	117:63	16	bytestream2_get_bytes_left
arg	117:55	117:63	17	&ctx->gb
op	117:55	0:0	18	&
water	117:56	0:0	18	ctx
op	117:59	0:0	18	->
water	117:61	0:0	18	gb
op	117:65	0:0	16	<
water	117:67	0:0	16	1
stmts	118:28	118:54	15	
return	118:28	118:54	16	AVERROR_INVALIDDATA
water	118:35	0:0	17	AVERROR_INVALIDDATA
water	119:24	0:0	14	skip_run
op	119:33	0:0	14	=
call	119:35	119:65	14	bytestream2_get_byteu
arg	119:57	119:65	15	&ctx->gb
op	119:57	0:0	16	&
water	119:58	0:0	16	ctx
op	119:61	0:0	16	->
water	119:63	0:0	16	gb
op	119:67	0:0	14	+
water	119:69	0:0	14	1
water	119:70	0:0	14	;
water	120:24	0:0	14	i
op	120:26	0:0	14	-=
water	120:29	0:0	14	4
water	120:30	0:0	14	;
water	121:20	0:0	14	}
else	121:22	128:20	10
stmts	121:27	128:20	11	
water	121:27	0:0	12	{
decl	122:24	122:34	12	int	mx
water	122:30	0:0	12	,
decl	122:24	122:34	12	int	my
water	124:24	0:0	12	mx
op	124:27	0:0	12	=
water	124:29	0:0	12	c37_mv
op	124:35	0:0	12	[
water	124:36	0:0	12	(
water	124:37	0:0	12	mvoff
op	124:43	0:0	12	*
water	124:45	0:0	12	255
op	124:49	0:0	12	+
water	124:51	0:0	12	code
water	124:55	0:0	12	)
op	124:57	0:0	12	*
water	124:59	0:0	12	2
op	124:60	0:0	12	]
water	124:61	0:0	12	;
water	125:24	0:0	12	my
op	125:27	0:0	12	=
water	125:29	0:0	12	c37_mv
op	125:35	0:0	12	[
water	125:36	0:0	12	(
water	125:37	0:0	12	mvoff
op	125:43	0:0	12	*
water	125:45	0:0	12	255
op	125:49	0:0	12	+
water	125:51	0:0	12	code
water	125:55	0:0	12	)
op	125:57	0:0	12	*
water	125:59	0:0	12	2
op	125:61	0:0	12	+
water	125:63	0:0	12	1
op	125:64	0:0	12	]
water	125:65	0:0	12	;
call	126:24	127:70	12	codec37_mv
arg	126:35	126:42	13	dst+i
water	126:35	0:0	14	dst
op	126:39	0:0	14	+
water	126:41	0:0	14	i
arg	126:44	126:71	13	prev+i+mx+my*stride
water	126:44	0:0	14	prev
op	126:49	0:0	14	+
water	126:51	0:0	14	i
op	126:53	0:0	14	+
water	126:55	0:0	14	mx
op	126:58	0:0	14	+
water	126:60	0:0	14	my
op	126:63	0:0	14	*
water	126:65	0:0	14	stride
arg	127:35	127:46	13	ctx->height
water	127:35	0:0	14	ctx
op	127:38	0:0	14	->
water	127:40	0:0	14	height
arg	127:48	127:54	13	stride
water	127:48	0:0	14	stride
arg	127:56	127:62	13	i+mx
water	127:56	0:0	14	i
op	127:58	0:0	14	+
water	127:60	0:0	14	mx
arg	127:64	127:70	13	j+my
water	127:64	0:0	14	j
op	127:66	0:0	14	+
water	127:68	0:0	14	my
water	127:71	0:0	12	;
water	128:20	0:0	12	}
water	129:16	0:0	10	}
water	130:16	0:0	8	dst
op	130:21	0:0	8	+=
water	130:24	0:0	8	stride
op	130:31	0:0	8	*
water	130:33	0:0	8	4
water	130:34	0:0	8	;
water	131:16	0:0	8	prev
op	131:21	0:0	8	+=
water	131:24	0:0	8	stride
op	131:31	0:0	8	*
water	131:33	0:0	8	4
water	131:34	0:0	8	;
water	132:12	0:0	8	}
water	133:8	0:0	6	}
break	134:8	134:13	4	
label	135:4	135:11	4	default :
call	136:8	137:68	4	av_log
arg	136:15	136:25	5	ctx->avctx
water	136:15	0:0	6	ctx
op	136:18	0:0	6	->
water	136:20	0:0	6	avctx
arg	136:27	136:39	5	AV_LOG_ERROR
water	136:27	0:0	6	AV_LOG_ERROR
arg	137:15	137:61	5	"subcodec 37 compression %d not implemented\n"
water	137:15	0:0	6	"subcodec 37 compression %d not implemented\n"
arg	137:63	137:68	5	compr
water	137:63	0:0	6	compr
water	137:69	0:0	4	;
return	138:8	138:35	4	AVERROR_PATCHWELCOME
water	138:15	0:0	5	AVERROR_PATCHWELCOME
water	139:4	0:0	4	}
return	141:4	141:12	2	0
water	141:11	0:0	3	0
