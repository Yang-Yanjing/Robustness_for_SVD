func	1:0	260:0	0	static int	decode_frame
params	1:23	0:0	1	
param	1:24	1:45	2	AVCodecContext *	avctx
param	1:47	1:57	2	void *	data
param	1:59	1:73	2	int *	got_frame
param	2:24	2:39	2	AVPacket *	avpkt
stmnts	0:0	259:19	1	
decl	4:4	4:36	2	const uint8_t	*buf
op	4:23	0:0	2	=
water	4:25	0:0	2	avpkt
op	4:30	0:0	2	->
water	4:32	0:0	2	data
decl	5:4	5:30	2	int	buf_size
op	5:17	0:0	2	=
water	5:19	0:0	2	avpkt
op	5:24	0:0	2	->
water	5:26	0:0	2	size
decl	6:4	6:40	2	UtvideoContext	*c
op	6:22	0:0	2	=
water	6:24	0:0	2	avctx
op	6:29	0:0	2	->
water	6:31	0:0	2	priv_data
decl	7:4	7:12	2	int	i
water	7:9	0:0	2	,
decl	7:4	7:12	2	int	j
decl	8:4	8:33	2	const uint8_t	*plane_start[5]
decl	9:4	9:74	2	int	plane_size
water	9:18	0:0	2	,
decl	9:4	9:74	2	int	max_slice_size
op	9:35	0:0	2	=
water	9:37	0:0	2	0
water	9:38	0:0	2	,
decl	9:4	9:74	2	int	slice_start
water	9:51	0:0	2	,
decl	9:4	9:74	2	int	slice_end
water	9:62	0:0	2	,
decl	9:4	9:74	2	int	slice_size
decl	10:4	10:11	2	int	ret
decl	11:4	11:21	2	GetByteContext	gb
decl	12:4	12:37	2	ThreadFrame	frame
op	12:22	0:0	2	=
water	12:24	0:0	2	{
op	12:26	0:0	2	.
water	12:27	0:0	2	f
op	12:29	0:0	2	=
water	12:31	0:0	2	data
water	12:36	0:0	2	}
if	14:4	15:18	2	(( ret =ff_thread_get_buffer (avctx ,& frame ,0 ) ) < 0)
cond	14:8	14:57	3	( ret =ff_thread_get_buffer (avctx ,& frame ,0 ) ) < 0
water	14:8	0:0	4	(
water	14:9	0:0	4	ret
op	14:13	0:0	4	=
call	14:15	14:52	4	ff_thread_get_buffer
arg	14:36	14:41	5	avctx
water	14:36	0:0	6	avctx
arg	14:43	14:49	5	&frame
op	14:43	0:0	6	&
water	14:44	0:0	6	frame
arg	14:51	14:52	5	0
water	14:51	0:0	6	0
water	14:53	0:0	4	)
op	14:55	0:0	4	<
water	14:57	0:0	4	0
stmts	15:8	15:18	3	
return	15:8	15:18	4	ret
water	15:15	0:0	5	ret
call	18:4	18:39	2	bytestream2_init
arg	18:21	18:24	3	&gb
op	18:21	0:0	4	&
water	18:22	0:0	4	gb
arg	18:26	18:29	3	buf
water	18:26	0:0	4	buf
arg	18:31	18:39	3	buf_size
water	18:31	0:0	4	buf_size
water	18:40	0:0	2	;
if	19:4	50:4	2	(c -> pro)
cond	19:8	19:11	3	c -> pro
water	19:8	0:0	4	c
op	19:9	0:0	4	->
water	19:11	0:0	4	pro
stmts	19:16	50:4	3	
water	19:16	0:0	4	{
if	20:8	23:8	4	(bytestream2_get_bytes_left (& gb ) < c -> frame_info_size)
cond	20:12	20:49	5	bytestream2_get_bytes_left (& gb ) < c -> frame_info_size
call	20:12	20:42	6	bytestream2_get_bytes_left
arg	20:39	20:42	7	&gb
op	20:39	0:0	8	&
water	20:40	0:0	8	gb
op	20:44	0:0	6	<
water	20:46	0:0	6	c
op	20:47	0:0	6	->
water	20:49	0:0	6	frame_info_size
stmts	20:66	23:8	5	
water	20:66	0:0	6	{
call	21:12	21:81	6	av_log
arg	21:19	21:24	7	avctx
water	21:19	0:0	8	avctx
arg	21:26	21:38	7	AV_LOG_ERROR
water	21:26	0:0	8	AV_LOG_ERROR
arg	21:40	21:81	7	"Not enough data for frame information\n"
water	21:40	0:0	8	"Not enough data for frame information\n"
water	21:82	0:0	6	;
return	22:12	22:38	6	AVERROR_INVALIDDATA
water	22:19	0:0	7	AVERROR_INVALIDDATA
water	23:8	0:0	6	}
water	24:8	0:0	4	c
op	24:9	0:0	4	->
water	24:11	0:0	4	frame_info
op	24:22	0:0	4	=
call	24:24	24:49	4	bytestream2_get_le32u
arg	24:46	24:49	5	&gb
op	24:46	0:0	6	&
water	24:47	0:0	6	gb
water	24:50	0:0	4	;
water	25:8	0:0	4	c
op	25:9	0:0	4	->
water	25:11	0:0	4	slices
op	25:18	0:0	4	=
water	25:20	0:0	4	(
water	25:21	0:0	4	(
water	25:22	0:0	4	c
op	25:23	0:0	4	->
water	25:25	0:0	4	frame_info
op	25:36	0:0	4	>>
water	25:39	0:0	4	16
water	25:41	0:0	4	)
op	25:43	0:0	4	&
water	25:45	0:0	4	0
water	25:46	0:0	4	xff
water	25:49	0:0	4	)
op	25:51	0:0	4	+
water	25:53	0:0	4	1
water	25:54	0:0	4	;
for	26:8	48:8	4	(i = 0 ;i < c -> planes;i ++)
forinit	26:13	26:18	5	i = 0 ;
water	26:13	0:0	6	i
op	26:15	0:0	6	=
water	26:17	0:0	6	0
water	26:18	0:0	6	;
cond	26:20	26:27	5	i < c -> planes
water	26:20	0:0	6	i
op	26:22	0:0	6	<
water	26:24	0:0	6	c
op	26:25	0:0	6	->
water	26:27	0:0	6	planes
forexpr	26:35	26:36	5	i ++
water	26:35	0:0	6	i
op	26:36	0:0	6	++
stmts	26:40	48:8	5	
water	26:40	0:0	6	{
water	27:12	0:0	6	plane_start
op	27:23	0:0	6	[
water	27:24	0:0	6	i
op	27:25	0:0	6	]
op	27:27	0:0	6	=
water	27:29	0:0	6	gb
op	27:31	0:0	6	.
water	27:32	0:0	6	buffer
water	27:38	0:0	6	;
if	28:12	31:12	6	(bytestream2_get_bytes_left (& gb ) < 1024 + 4 * c -> slices)
cond	28:16	28:64	7	bytestream2_get_bytes_left (& gb ) < 1024 + 4 * c -> slices
call	28:16	28:46	8	bytestream2_get_bytes_left
arg	28:43	28:46	9	&gb
op	28:43	0:0	10	&
water	28:44	0:0	10	gb
op	28:48	0:0	8	<
water	28:50	0:0	8	1024
op	28:55	0:0	8	+
water	28:57	0:0	8	4
op	28:59	0:0	8	*
water	28:61	0:0	8	c
op	28:62	0:0	8	->
water	28:64	0:0	8	slices
stmts	28:72	31:12	7	
water	28:72	0:0	8	{
call	29:16	29:77	8	av_log
arg	29:23	29:28	9	avctx
water	29:23	0:0	10	avctx
arg	29:30	29:42	9	AV_LOG_ERROR
water	29:30	0:0	10	AV_LOG_ERROR
arg	29:44	29:77	9	"Insufficient data for a plane\n"
water	29:44	0:0	10	"Insufficient data for a plane\n"
water	29:78	0:0	8	;
return	30:16	30:42	8	AVERROR_INVALIDDATA
water	30:23	0:0	9	AVERROR_INVALIDDATA
water	31:12	0:0	8	}
water	32:12	0:0	6	slice_start
op	32:24	0:0	6	=
water	32:26	0:0	6	0
water	32:27	0:0	6	;
water	33:12	0:0	6	slice_end
op	33:24	0:0	6	=
water	33:26	0:0	6	0
water	33:27	0:0	6	;
for	34:12	44:12	6	(j = 0 ;j < c -> slices;j ++)
forinit	34:17	34:22	7	j = 0 ;
water	34:17	0:0	8	j
op	34:19	0:0	8	=
water	34:21	0:0	8	0
water	34:22	0:0	8	;
cond	34:24	34:31	7	j < c -> slices
water	34:24	0:0	8	j
op	34:26	0:0	8	<
water	34:28	0:0	8	c
op	34:29	0:0	8	->
water	34:31	0:0	8	slices
forexpr	34:39	34:40	7	j ++
water	34:39	0:0	8	j
op	34:40	0:0	8	++
stmts	34:44	44:12	7	
water	34:44	0:0	8	{
water	35:16	0:0	8	slice_end
op	35:28	0:0	8	=
call	35:30	35:55	8	bytestream2_get_le32u
arg	35:52	35:55	9	&gb
op	35:52	0:0	10	&
water	35:53	0:0	10	gb
water	35:56	0:0	8	;
if	36:16	40:16	8	(slice_end < 0 || slice_end < slice_start ||bytestream2_get_bytes_left (& gb ) < slice_end + 1024 LL)
cond	36:20	37:70	9	slice_end < 0 || slice_end < slice_start ||bytestream2_get_bytes_left (& gb ) < slice_end + 1024 LL
water	36:20	0:0	10	slice_end
op	36:30	0:0	10	<
water	36:32	0:0	10	0
op	36:34	0:0	10	||
water	36:37	0:0	10	slice_end
op	36:47	0:0	10	<
water	36:49	0:0	10	slice_start
op	36:61	0:0	10	||
call	37:20	37:50	10	bytestream2_get_bytes_left
arg	37:47	37:50	11	&gb
op	37:47	0:0	12	&
water	37:48	0:0	12	gb
op	37:52	0:0	10	<
water	37:54	0:0	10	slice_end
op	37:64	0:0	10	+
water	37:66	0:0	10	1024
water	37:70	0:0	10	LL
stmts	37:74	40:16	9	
water	37:74	0:0	10	{
call	38:20	38:72	10	av_log
arg	38:27	38:32	11	avctx
water	38:27	0:0	12	avctx
arg	38:34	38:46	11	AV_LOG_ERROR
water	38:34	0:0	12	AV_LOG_ERROR
arg	38:48	38:72	11	"Incorrect slice size\n"
water	38:48	0:0	12	"Incorrect slice size\n"
water	38:73	0:0	10	;
return	39:20	39:46	10	AVERROR_INVALIDDATA
water	39:27	0:0	11	AVERROR_INVALIDDATA
water	40:16	0:0	10	}
water	41:16	0:0	8	slice_size
op	41:28	0:0	8	=
water	41:30	0:0	8	slice_end
op	41:40	0:0	8	-
water	41:42	0:0	8	slice_start
water	41:53	0:0	8	;
water	42:16	0:0	8	slice_start
op	42:28	0:0	8	=
water	42:30	0:0	8	slice_end
water	42:39	0:0	8	;
water	43:16	0:0	8	max_slice_size
op	43:31	0:0	8	=
call	43:33	43:65	8	FFMAX
arg	43:39	43:53	9	max_slice_size
water	43:39	0:0	10	max_slice_size
arg	43:55	43:65	9	slice_size
water	43:55	0:0	10	slice_size
water	43:66	0:0	8	;
water	44:12	0:0	8	}
water	45:12	0:0	6	plane_size
op	45:23	0:0	6	=
water	45:25	0:0	6	slice_end
water	45:34	0:0	6	;
call	46:12	46:45	6	bytestream2_skipu
arg	46:30	46:33	7	&gb
op	46:30	0:0	8	&
water	46:31	0:0	8	gb
arg	46:35	46:45	7	plane_size
water	46:35	0:0	8	plane_size
water	46:46	0:0	6	;
call	47:12	47:39	6	bytestream2_skipu
arg	47:30	47:33	7	&gb
op	47:30	0:0	8	&
water	47:31	0:0	8	gb
arg	47:35	47:39	7	1024
water	47:35	0:0	8	1024
water	47:40	0:0	6	;
water	48:8	0:0	6	}
water	49:8	0:0	4	plane_start
op	49:19	0:0	4	[
water	49:20	0:0	4	c
op	49:21	0:0	4	->
water	49:23	0:0	4	planes
op	49:29	0:0	4	]
op	49:31	0:0	4	=
water	49:33	0:0	4	gb
op	49:35	0:0	4	.
water	49:36	0:0	4	buffer
water	49:42	0:0	4	;
water	50:4	0:0	4	}
else	50:6	80:4	2
stmts	50:11	80:4	3	
water	50:11	0:0	4	{
for	51:8	73:8	4	(i = 0 ;i < c -> planes;i ++)
forinit	51:13	51:18	5	i = 0 ;
water	51:13	0:0	6	i
op	51:15	0:0	6	=
water	51:17	0:0	6	0
water	51:18	0:0	6	;
cond	51:20	51:27	5	i < c -> planes
water	51:20	0:0	6	i
op	51:22	0:0	6	<
water	51:24	0:0	6	c
op	51:25	0:0	6	->
water	51:27	0:0	6	planes
forexpr	51:35	51:36	5	i ++
water	51:35	0:0	6	i
op	51:36	0:0	6	++
stmts	51:40	73:8	5	
water	51:40	0:0	6	{
water	52:12	0:0	6	plane_start
op	52:23	0:0	6	[
water	52:24	0:0	6	i
op	52:25	0:0	6	]
op	52:27	0:0	6	=
water	52:29	0:0	6	gb
op	52:31	0:0	6	.
water	52:32	0:0	6	buffer
water	52:38	0:0	6	;
if	53:12	56:12	6	(bytestream2_get_bytes_left (& gb ) < 256 + 4 * c -> slices)
cond	53:16	53:63	7	bytestream2_get_bytes_left (& gb ) < 256 + 4 * c -> slices
call	53:16	53:46	8	bytestream2_get_bytes_left
arg	53:43	53:46	9	&gb
op	53:43	0:0	10	&
water	53:44	0:0	10	gb
op	53:48	0:0	8	<
water	53:50	0:0	8	256
op	53:54	0:0	8	+
water	53:56	0:0	8	4
op	53:58	0:0	8	*
water	53:60	0:0	8	c
op	53:61	0:0	8	->
water	53:63	0:0	8	slices
stmts	53:71	56:12	7	
water	53:71	0:0	8	{
call	54:16	54:77	8	av_log
arg	54:23	54:28	9	avctx
water	54:23	0:0	10	avctx
arg	54:30	54:42	9	AV_LOG_ERROR
water	54:30	0:0	10	AV_LOG_ERROR
arg	54:44	54:77	9	"Insufficient data for a plane\n"
water	54:44	0:0	10	"Insufficient data for a plane\n"
water	54:78	0:0	8	;
return	55:16	55:42	8	AVERROR_INVALIDDATA
water	55:23	0:0	9	AVERROR_INVALIDDATA
water	56:12	0:0	8	}
call	57:12	57:38	6	bytestream2_skipu
arg	57:30	57:33	7	&gb
op	57:30	0:0	8	&
water	57:31	0:0	8	gb
arg	57:35	57:38	7	256
water	57:35	0:0	8	256
water	57:39	0:0	6	;
water	58:12	0:0	6	slice_start
op	58:24	0:0	6	=
water	58:26	0:0	6	0
water	58:27	0:0	6	;
water	59:12	0:0	6	slice_end
op	59:24	0:0	6	=
water	59:26	0:0	6	0
water	59:27	0:0	6	;
for	60:12	70:12	6	(j = 0 ;j < c -> slices;j ++)
forinit	60:17	60:22	7	j = 0 ;
water	60:17	0:0	8	j
op	60:19	0:0	8	=
water	60:21	0:0	8	0
water	60:22	0:0	8	;
cond	60:24	60:31	7	j < c -> slices
water	60:24	0:0	8	j
op	60:26	0:0	8	<
water	60:28	0:0	8	c
op	60:29	0:0	8	->
water	60:31	0:0	8	slices
forexpr	60:39	60:40	7	j ++
water	60:39	0:0	8	j
op	60:40	0:0	8	++
stmts	60:44	70:12	7	
water	60:44	0:0	8	{
water	61:16	0:0	8	slice_end
op	61:28	0:0	8	=
call	61:30	61:55	8	bytestream2_get_le32u
arg	61:52	61:55	9	&gb
op	61:52	0:0	10	&
water	61:53	0:0	10	gb
water	61:56	0:0	8	;
if	62:16	66:16	8	(slice_end < 0 || slice_end < slice_start ||bytestream2_get_bytes_left (& gb ) < slice_end)
cond	62:20	63:54	9	slice_end < 0 || slice_end < slice_start ||bytestream2_get_bytes_left (& gb ) < slice_end
water	62:20	0:0	10	slice_end
op	62:30	0:0	10	<
water	62:32	0:0	10	0
op	62:34	0:0	10	||
water	62:37	0:0	10	slice_end
op	62:47	0:0	10	<
water	62:49	0:0	10	slice_start
op	62:61	0:0	10	||
call	63:20	63:50	10	bytestream2_get_bytes_left
arg	63:47	63:50	11	&gb
op	63:47	0:0	12	&
water	63:48	0:0	12	gb
op	63:52	0:0	10	<
water	63:54	0:0	10	slice_end
stmts	63:65	66:16	9	
water	63:65	0:0	10	{
call	64:20	64:72	10	av_log
arg	64:27	64:32	11	avctx
water	64:27	0:0	12	avctx
arg	64:34	64:46	11	AV_LOG_ERROR
water	64:34	0:0	12	AV_LOG_ERROR
arg	64:48	64:72	11	"Incorrect slice size\n"
water	64:48	0:0	12	"Incorrect slice size\n"
water	64:73	0:0	10	;
return	65:20	65:46	10	AVERROR_INVALIDDATA
water	65:27	0:0	11	AVERROR_INVALIDDATA
water	66:16	0:0	10	}
water	67:16	0:0	8	slice_size
op	67:28	0:0	8	=
water	67:30	0:0	8	slice_end
op	67:40	0:0	8	-
water	67:42	0:0	8	slice_start
water	67:53	0:0	8	;
water	68:16	0:0	8	slice_start
op	68:28	0:0	8	=
water	68:30	0:0	8	slice_end
water	68:39	0:0	8	;
water	69:16	0:0	8	max_slice_size
op	69:31	0:0	8	=
call	69:33	69:65	8	FFMAX
arg	69:39	69:53	9	max_slice_size
water	69:39	0:0	10	max_slice_size
arg	69:55	69:65	9	slice_size
water	69:55	0:0	10	slice_size
water	69:66	0:0	8	;
water	70:12	0:0	8	}
water	71:12	0:0	6	plane_size
op	71:23	0:0	6	=
water	71:25	0:0	6	slice_end
water	71:34	0:0	6	;
call	72:12	72:45	6	bytestream2_skipu
arg	72:30	72:33	7	&gb
op	72:30	0:0	8	&
water	72:31	0:0	8	gb
arg	72:35	72:45	7	plane_size
water	72:35	0:0	8	plane_size
water	72:46	0:0	6	;
water	73:8	0:0	6	}
water	74:8	0:0	4	plane_start
op	74:19	0:0	4	[
water	74:20	0:0	4	c
op	74:21	0:0	4	->
water	74:23	0:0	4	planes
op	74:29	0:0	4	]
op	74:31	0:0	4	=
water	74:33	0:0	4	gb
op	74:35	0:0	4	.
water	74:36	0:0	4	buffer
water	74:42	0:0	4	;
if	75:8	78:8	4	(bytestream2_get_bytes_left (& gb ) < c -> frame_info_size)
cond	75:12	75:49	5	bytestream2_get_bytes_left (& gb ) < c -> frame_info_size
call	75:12	75:42	6	bytestream2_get_bytes_left
arg	75:39	75:42	7	&gb
op	75:39	0:0	8	&
water	75:40	0:0	8	gb
op	75:44	0:0	6	<
water	75:46	0:0	6	c
op	75:47	0:0	6	->
water	75:49	0:0	6	frame_info_size
stmts	75:66	78:8	5	
water	75:66	0:0	6	{
call	76:12	76:81	6	av_log
arg	76:19	76:24	7	avctx
water	76:19	0:0	8	avctx
arg	76:26	76:38	7	AV_LOG_ERROR
water	76:26	0:0	8	AV_LOG_ERROR
arg	76:40	76:81	7	"Not enough data for frame information\n"
water	76:40	0:0	8	"Not enough data for frame information\n"
water	76:82	0:0	6	;
return	77:12	77:38	6	AVERROR_INVALIDDATA
water	77:19	0:0	7	AVERROR_INVALIDDATA
water	78:8	0:0	6	}
water	79:8	0:0	4	c
op	79:9	0:0	4	->
water	79:11	0:0	4	frame_info
op	79:22	0:0	4	=
call	79:24	79:49	4	bytestream2_get_le32u
arg	79:46	79:49	5	&gb
op	79:46	0:0	6	&
water	79:47	0:0	6	gb
water	79:50	0:0	4	;
water	80:4	0:0	4	}
call	81:4	82:24	2	av_log
arg	81:11	81:16	3	avctx
water	81:11	0:0	4	avctx
arg	81:18	81:30	3	AV_LOG_DEBUG
water	81:18	0:0	4	AV_LOG_DEBUG
arg	81:32	81:69	3	"frame information flags %"PRIX32"\n"
water	81:32	0:0	4	"frame information flags %"
water	81:59	0:0	4	PRIX32
water	81:65	0:0	4	"\n"
arg	82:11	82:24	3	c->frame_info
water	82:11	0:0	4	c
op	82:12	0:0	4	->
water	82:14	0:0	4	frame_info
water	82:25	0:0	2	;
water	84:4	0:0	2	c
op	84:5	0:0	2	->
water	84:7	0:0	2	frame_pred
op	84:18	0:0	2	=
water	84:20	0:0	2	(
water	84:21	0:0	2	c
op	84:22	0:0	2	->
water	84:24	0:0	2	frame_info
op	84:35	0:0	2	>>
water	84:38	0:0	2	8
water	84:39	0:0	2	)
op	84:41	0:0	2	&
water	84:43	0:0	2	3
water	84:44	0:0	2	;
water	86:4	0:0	2	max_slice_size
op	86:19	0:0	2	+=
water	86:22	0:0	2	4
op	86:23	0:0	2	*
water	86:24	0:0	2	avctx
op	86:29	0:0	2	->
water	86:31	0:0	2	width
water	86:36	0:0	2	;
call	88:4	89:64	2	av_fast_malloc
arg	88:19	88:33	3	&c->slice_bits
op	88:19	0:0	4	&
water	88:20	0:0	4	c
op	88:21	0:0	4	->
water	88:23	0:0	4	slice_bits
arg	88:35	88:54	3	&c->slice_bits_size
op	88:35	0:0	4	&
water	88:36	0:0	4	c
op	88:37	0:0	4	->
water	88:39	0:0	4	slice_bits_size
arg	89:19	89:64	3	max_slice_size+AV_INPUT_BUFFER_PADDING_SIZE
water	89:19	0:0	4	max_slice_size
op	89:34	0:0	4	+
water	89:36	0:0	4	AV_INPUT_BUFFER_PADDING_SIZE
water	89:65	0:0	2	;
if	91:4	94:4	2	(! c -> slice_bits)
cond	91:8	91:12	3	! c -> slice_bits
op	91:8	0:0	4	!
water	91:9	0:0	4	c
op	91:10	0:0	4	->
water	91:12	0:0	4	slice_bits
stmts	91:24	94:4	3	
water	91:24	0:0	4	{
call	92:8	92:72	4	av_log
arg	92:15	92:20	5	avctx
water	92:15	0:0	6	avctx
arg	92:22	92:34	5	AV_LOG_ERROR
water	92:22	0:0	6	AV_LOG_ERROR
arg	92:36	92:72	5	"Cannot allocate temporary buffer\n"
water	92:36	0:0	6	"Cannot allocate temporary buffer\n"
water	92:73	0:0	4	;
return	93:8	93:30	4	AVERROR(ENOMEM)
call	93:15	93:29	5	AVERROR
arg	93:23	93:29	6	ENOMEM
water	93:23	0:0	7	ENOMEM
water	94:4	0:0	4	}
switch	96:4	250:4	2	(c -> avctx -> pix_fmt)
cond	96:12	96:22	3	c -> avctx -> pix_fmt
water	96:12	0:0	4	c
op	96:13	0:0	4	->
water	96:15	0:0	4	avctx
op	96:20	0:0	4	->
water	96:22	0:0	4	pix_fmt
stmts	96:31	250:4	3	
water	96:31	0:0	4	{
label	97:4	97:24	4	case AV_PIX_FMT_GBRP :
label	98:4	98:25	4	case AV_PIX_FMT_GBRAP :
for	99:8	129:8	4	(i = 0 ;i < c -> planes;i ++)
forinit	99:13	99:18	5	i = 0 ;
water	99:13	0:0	6	i
op	99:15	0:0	6	=
water	99:17	0:0	6	0
water	99:18	0:0	6	;
cond	99:20	99:27	5	i < c -> planes
water	99:20	0:0	6	i
op	99:22	0:0	6	<
water	99:24	0:0	6	c
op	99:25	0:0	6	->
water	99:27	0:0	6	planes
forexpr	99:35	99:36	5	i ++
water	99:35	0:0	6	i
op	99:36	0:0	6	++
stmts	99:40	129:8	5	
water	99:40	0:0	6	{
water	100:12	0:0	6	ret
op	100:16	0:0	6	=
call	100:18	103:57	6	decode_plane
arg	100:31	100:32	7	c
water	100:31	0:0	8	c
arg	100:34	100:35	7	i
water	100:34	0:0	8	i
arg	100:37	100:53	7	frame.f->data[i]
water	100:37	0:0	8	frame
op	100:42	0:0	8	.
water	100:43	0:0	8	f
op	100:44	0:0	8	->
water	100:46	0:0	8	data
op	100:50	0:0	8	[
water	100:51	0:0	8	i
op	100:52	0:0	8	]
arg	100:55	100:56	7	1
water	100:55	0:0	8	1
arg	101:31	101:51	7	frame.f->linesize[i]
water	101:31	0:0	8	frame
op	101:36	0:0	8	.
water	101:37	0:0	8	f
op	101:38	0:0	8	->
water	101:40	0:0	8	linesize
op	101:48	0:0	8	[
water	101:49	0:0	8	i
op	101:50	0:0	8	]
arg	101:53	101:65	7	avctx->width
water	101:53	0:0	8	avctx
op	101:58	0:0	8	->
water	101:60	0:0	8	width
arg	102:31	102:44	7	avctx->height
water	102:31	0:0	8	avctx
op	102:36	0:0	8	->
water	102:38	0:0	8	height
arg	102:46	102:60	7	plane_start[i]
water	102:46	0:0	8	plane_start
op	102:57	0:0	8	[
water	102:58	0:0	8	i
op	102:59	0:0	8	]
arg	103:31	103:57	7	c->frame_pred==PRED_LEFT
water	103:31	0:0	8	c
op	103:32	0:0	8	->
water	103:34	0:0	8	frame_pred
op	103:45	0:0	8	==
water	103:48	0:0	8	PRED_LEFT
water	103:58	0:0	6	;
if	104:12	105:26	6	(ret)
cond	104:16	104:16	7	ret
water	104:16	0:0	8	ret
stmts	105:16	105:26	7	
return	105:16	105:26	8	ret
water	105:23	0:0	9	ret
if	106:12	117:12	6	(c -> frame_pred == PRED_MEDIAN)
cond	106:16	106:33	7	c -> frame_pred == PRED_MEDIAN
water	106:16	0:0	8	c
op	106:17	0:0	8	->
water	106:19	0:0	8	frame_pred
op	106:30	0:0	8	==
water	106:33	0:0	8	PRED_MEDIAN
stmts	106:46	117:12	7	
water	106:46	0:0	8	{
if	107:16	111:16	8	(! c -> interlaced)
cond	107:20	107:24	9	! c -> interlaced
op	107:20	0:0	10	!
water	107:21	0:0	10	c
op	107:22	0:0	10	->
water	107:24	0:0	10	interlaced
stmts	107:36	111:16	9	
water	107:36	0:0	10	{
call	108:20	110:69	10	restore_median_planar
arg	108:42	108:43	11	c
water	108:42	0:0	12	c
arg	108:45	108:61	11	frame.f->data[i]
water	108:45	0:0	12	frame
op	108:50	0:0	12	.
water	108:51	0:0	12	f
op	108:52	0:0	12	->
water	108:54	0:0	12	data
op	108:58	0:0	12	[
water	108:59	0:0	12	i
op	108:60	0:0	12	]
arg	109:42	109:62	11	frame.f->linesize[i]
water	109:42	0:0	12	frame
op	109:47	0:0	12	.
water	109:48	0:0	12	f
op	109:49	0:0	12	->
water	109:51	0:0	12	linesize
op	109:59	0:0	12	[
water	109:60	0:0	12	i
op	109:61	0:0	12	]
arg	109:64	109:76	11	avctx->width
water	109:64	0:0	12	avctx
op	109:69	0:0	12	->
water	109:71	0:0	12	width
arg	110:42	110:55	11	avctx->height
water	110:42	0:0	12	avctx
op	110:47	0:0	12	->
water	110:49	0:0	12	height
arg	110:57	110:66	11	c->slices
water	110:57	0:0	12	c
op	110:58	0:0	12	->
water	110:60	0:0	12	slices
arg	110:68	110:69	11	0
water	110:68	0:0	12	0
water	110:70	0:0	10	;
water	111:16	0:0	10	}
else	111:18	116:16	8
stmts	111:23	116:16	9	
water	111:23	0:0	10	{
call	112:20	115:46	10	restore_median_planar_il
arg	112:45	112:46	11	c
water	112:45	0:0	12	c
arg	112:48	112:64	11	frame.f->data[i]
water	112:48	0:0	12	frame
op	112:53	0:0	12	.
water	112:54	0:0	12	f
op	112:55	0:0	12	->
water	112:57	0:0	12	data
op	112:61	0:0	12	[
water	112:62	0:0	12	i
op	112:63	0:0	12	]
arg	113:45	113:65	11	frame.f->linesize[i]
water	113:45	0:0	12	frame
op	113:50	0:0	12	.
water	113:51	0:0	12	f
op	113:52	0:0	12	->
water	113:54	0:0	12	linesize
op	113:62	0:0	12	[
water	113:63	0:0	12	i
op	113:64	0:0	12	]
arg	114:45	114:57	11	avctx->width
water	114:45	0:0	12	avctx
op	114:50	0:0	12	->
water	114:52	0:0	12	width
arg	114:59	114:72	11	avctx->height
water	114:59	0:0	12	avctx
op	114:64	0:0	12	->
water	114:66	0:0	12	height
arg	114:74	114:83	11	c->slices
water	114:74	0:0	12	c
op	114:75	0:0	12	->
water	114:77	0:0	12	slices
arg	115:45	115:46	11	0
water	115:45	0:0	12	0
water	115:47	0:0	10	;
water	116:16	0:0	10	}
water	117:12	0:0	8	}
else	117:14	128:12	6
stmts	117:19	128:12	7	
if	117:19	128:12	8	(c -> frame_pred == PRED_GRADIENT)
cond	117:23	117:40	9	c -> frame_pred == PRED_GRADIENT
water	117:23	0:0	10	c
op	117:24	0:0	10	->
water	117:26	0:0	10	frame_pred
op	117:37	0:0	10	==
water	117:40	0:0	10	PRED_GRADIENT
stmts	117:55	128:12	9	
water	117:55	0:0	10	{
if	118:16	122:16	10	(! c -> interlaced)
cond	118:20	118:24	11	! c -> interlaced
op	118:20	0:0	12	!
water	118:21	0:0	12	c
op	118:22	0:0	12	->
water	118:24	0:0	12	interlaced
stmts	118:36	122:16	11	
water	118:36	0:0	12	{
call	119:20	121:71	12	restore_gradient_planar
arg	119:44	119:45	13	c
water	119:44	0:0	14	c
arg	119:47	119:63	13	frame.f->data[i]
water	119:47	0:0	14	frame
op	119:52	0:0	14	.
water	119:53	0:0	14	f
op	119:54	0:0	14	->
water	119:56	0:0	14	data
op	119:60	0:0	14	[
water	119:61	0:0	14	i
op	119:62	0:0	14	]
arg	120:44	120:64	13	frame.f->linesize[i]
water	120:44	0:0	14	frame
op	120:49	0:0	14	.
water	120:50	0:0	14	f
op	120:51	0:0	14	->
water	120:53	0:0	14	linesize
op	120:61	0:0	14	[
water	120:62	0:0	14	i
op	120:63	0:0	14	]
arg	120:66	120:78	13	avctx->width
water	120:66	0:0	14	avctx
op	120:71	0:0	14	->
water	120:73	0:0	14	width
arg	121:44	121:57	13	avctx->height
water	121:44	0:0	14	avctx
op	121:49	0:0	14	->
water	121:51	0:0	14	height
arg	121:59	121:68	13	c->slices
water	121:59	0:0	14	c
op	121:60	0:0	14	->
water	121:62	0:0	14	slices
arg	121:70	121:71	13	0
water	121:70	0:0	14	0
water	121:72	0:0	12	;
water	122:16	0:0	12	}
else	122:18	127:16	10
stmts	122:23	127:16	11	
water	122:23	0:0	12	{
call	123:20	126:48	12	restore_gradient_planar_il
arg	123:47	123:48	13	c
water	123:47	0:0	14	c
arg	123:50	123:66	13	frame.f->data[i]
water	123:50	0:0	14	frame
op	123:55	0:0	14	.
water	123:56	0:0	14	f
op	123:57	0:0	14	->
water	123:59	0:0	14	data
op	123:63	0:0	14	[
water	123:64	0:0	14	i
op	123:65	0:0	14	]
arg	124:47	124:67	13	frame.f->linesize[i]
water	124:47	0:0	14	frame
op	124:52	0:0	14	.
water	124:53	0:0	14	f
op	124:54	0:0	14	->
water	124:56	0:0	14	linesize
op	124:64	0:0	14	[
water	124:65	0:0	14	i
op	124:66	0:0	14	]
arg	125:47	125:59	13	avctx->width
water	125:47	0:0	14	avctx
op	125:52	0:0	14	->
water	125:54	0:0	14	width
arg	125:61	125:74	13	avctx->height
water	125:61	0:0	14	avctx
op	125:66	0:0	14	->
water	125:68	0:0	14	height
arg	125:76	125:85	13	c->slices
water	125:76	0:0	14	c
op	125:77	0:0	14	->
water	125:79	0:0	14	slices
arg	126:47	126:48	13	0
water	126:47	0:0	14	0
water	126:49	0:0	12	;
water	127:16	0:0	12	}
water	128:12	0:0	10	}
water	129:8	0:0	6	}
call	130:8	132:63	4	c->utdsp.restore_rgb_planes
arg	130:36	130:52	5	frame.f->data[2]
water	130:36	0:0	6	frame
op	130:41	0:0	6	.
water	130:42	0:0	6	f
op	130:43	0:0	6	->
water	130:45	0:0	6	data
op	130:49	0:0	6	[
water	130:50	0:0	6	2
op	130:51	0:0	6	]
arg	130:54	130:70	5	frame.f->data[0]
water	130:54	0:0	6	frame
op	130:59	0:0	6	.
water	130:60	0:0	6	f
op	130:61	0:0	6	->
water	130:63	0:0	6	data
op	130:67	0:0	6	[
water	130:68	0:0	6	0
op	130:69	0:0	6	]
arg	130:72	130:88	5	frame.f->data[1]
water	130:72	0:0	6	frame
op	130:77	0:0	6	.
water	130:78	0:0	6	f
op	130:79	0:0	6	->
water	130:81	0:0	6	data
op	130:85	0:0	6	[
water	130:86	0:0	6	1
op	130:87	0:0	6	]
arg	131:36	131:56	5	frame.f->linesize[2]
water	131:36	0:0	6	frame
op	131:41	0:0	6	.
water	131:42	0:0	6	f
op	131:43	0:0	6	->
water	131:45	0:0	6	linesize
op	131:53	0:0	6	[
water	131:54	0:0	6	2
op	131:55	0:0	6	]
arg	131:58	131:78	5	frame.f->linesize[0]
water	131:58	0:0	6	frame
op	131:63	0:0	6	.
water	131:64	0:0	6	f
op	131:65	0:0	6	->
water	131:67	0:0	6	linesize
op	131:75	0:0	6	[
water	131:76	0:0	6	0
op	131:77	0:0	6	]
arg	131:80	131:100	5	frame.f->linesize[1]
water	131:80	0:0	6	frame
op	131:85	0:0	6	.
water	131:86	0:0	6	f
op	131:87	0:0	6	->
water	131:89	0:0	6	linesize
op	131:97	0:0	6	[
water	131:98	0:0	6	1
op	131:99	0:0	6	]
arg	132:36	132:48	5	avctx->width
water	132:36	0:0	6	avctx
op	132:41	0:0	6	->
water	132:43	0:0	6	width
arg	132:50	132:63	5	avctx->height
water	132:50	0:0	6	avctx
op	132:55	0:0	6	->
water	132:57	0:0	6	height
water	132:64	0:0	4	;
break	133:8	133:13	4	
label	134:4	134:27	4	case AV_PIX_FMT_GBRAP10 :
label	135:4	135:26	4	case AV_PIX_FMT_GBRP10 :
for	136:8	144:8	4	(i = 0 ;i < c -> planes;i ++)
forinit	136:13	136:18	5	i = 0 ;
water	136:13	0:0	6	i
op	136:15	0:0	6	=
water	136:17	0:0	6	0
water	136:18	0:0	6	;
cond	136:20	136:27	5	i < c -> planes
water	136:20	0:0	6	i
op	136:22	0:0	6	<
water	136:24	0:0	6	c
op	136:25	0:0	6	->
water	136:27	0:0	6	planes
forexpr	136:35	136:36	5	i ++
water	136:35	0:0	6	i
op	136:36	0:0	6	++
stmts	136:40	144:8	5	
water	136:40	0:0	6	{
water	137:12	0:0	6	ret
op	137:16	0:0	6	=
call	137:18	141:59	6	decode_plane10
arg	137:33	137:34	7	c
water	137:33	0:0	8	c
arg	137:36	137:37	7	i
water	137:36	0:0	8	i
arg	137:39	137:67	7	(uint16_t*)frame.f->data[i]
water	137:39	0:0	8	(
water	137:40	0:0	8	uint16_t
op	137:49	0:0	8	*
water	137:50	0:0	8	)
water	137:51	0:0	8	frame
op	137:56	0:0	8	.
water	137:57	0:0	8	f
op	137:58	0:0	8	->
water	137:60	0:0	8	data
op	137:64	0:0	8	[
water	137:65	0:0	8	i
op	137:66	0:0	8	]
arg	137:69	137:70	7	1
water	137:69	0:0	8	1
arg	138:33	138:57	7	frame.f->linesize[i]/2
water	138:33	0:0	8	frame
op	138:38	0:0	8	.
water	138:39	0:0	8	f
op	138:40	0:0	8	->
water	138:42	0:0	8	linesize
op	138:50	0:0	8	[
water	138:51	0:0	8	i
op	138:52	0:0	8	]
op	138:54	0:0	8	/
water	138:56	0:0	8	2
arg	138:59	138:71	7	avctx->width
water	138:59	0:0	8	avctx
op	138:64	0:0	8	->
water	138:66	0:0	8	width
arg	139:33	139:46	7	avctx->height
water	139:33	0:0	8	avctx
op	139:38	0:0	8	->
water	139:40	0:0	8	height
arg	139:48	139:62	7	plane_start[i]
water	139:48	0:0	8	plane_start
op	139:59	0:0	8	[
water	139:60	0:0	8	i
op	139:61	0:0	8	]
arg	140:33	140:58	7	plane_start[i+1]-1024
water	140:33	0:0	8	plane_start
op	140:44	0:0	8	[
water	140:45	0:0	8	i
op	140:47	0:0	8	+
water	140:49	0:0	8	1
op	140:50	0:0	8	]
op	140:52	0:0	8	-
water	140:54	0:0	8	1024
arg	141:33	141:59	7	c->frame_pred==PRED_LEFT
water	141:33	0:0	8	c
op	141:34	0:0	8	->
water	141:36	0:0	8	frame_pred
op	141:47	0:0	8	==
water	141:50	0:0	8	PRED_LEFT
water	141:60	0:0	6	;
if	142:12	143:26	6	(ret)
cond	142:16	142:16	7	ret
water	142:16	0:0	8	ret
stmts	143:16	143:26	7	
return	143:16	143:26	8	ret
water	143:23	0:0	9	ret
water	144:8	0:0	6	}
call	145:8	147:65	4	c->utdsp.restore_rgb_planes10
arg	145:38	145:66	5	(uint16_t*)frame.f->data[2]
water	145:38	0:0	6	(
water	145:39	0:0	6	uint16_t
op	145:48	0:0	6	*
water	145:49	0:0	6	)
water	145:50	0:0	6	frame
op	145:55	0:0	6	.
water	145:56	0:0	6	f
op	145:57	0:0	6	->
water	145:59	0:0	6	data
op	145:63	0:0	6	[
water	145:64	0:0	6	2
op	145:65	0:0	6	]
arg	145:68	145:96	5	(uint16_t*)frame.f->data[0]
water	145:68	0:0	6	(
water	145:69	0:0	6	uint16_t
op	145:78	0:0	6	*
water	145:79	0:0	6	)
water	145:80	0:0	6	frame
op	145:85	0:0	6	.
water	145:86	0:0	6	f
op	145:87	0:0	6	->
water	145:89	0:0	6	data
op	145:93	0:0	6	[
water	145:94	0:0	6	0
op	145:95	0:0	6	]
arg	145:98	145:126	5	(uint16_t*)frame.f->data[1]
water	145:98	0:0	6	(
water	145:99	0:0	6	uint16_t
op	145:108	0:0	6	*
water	145:109	0:0	6	)
water	145:110	0:0	6	frame
op	145:115	0:0	6	.
water	145:116	0:0	6	f
op	145:117	0:0	6	->
water	145:119	0:0	6	data
op	145:123	0:0	6	[
water	145:124	0:0	6	1
op	145:125	0:0	6	]
arg	146:38	146:62	5	frame.f->linesize[2]/2
water	146:38	0:0	6	frame
op	146:43	0:0	6	.
water	146:44	0:0	6	f
op	146:45	0:0	6	->
water	146:47	0:0	6	linesize
op	146:55	0:0	6	[
water	146:56	0:0	6	2
op	146:57	0:0	6	]
op	146:59	0:0	6	/
water	146:61	0:0	6	2
arg	146:64	146:88	5	frame.f->linesize[0]/2
water	146:64	0:0	6	frame
op	146:69	0:0	6	.
water	146:70	0:0	6	f
op	146:71	0:0	6	->
water	146:73	0:0	6	linesize
op	146:81	0:0	6	[
water	146:82	0:0	6	0
op	146:83	0:0	6	]
op	146:85	0:0	6	/
water	146:87	0:0	6	2
arg	146:90	146:114	5	frame.f->linesize[1]/2
water	146:90	0:0	6	frame
op	146:95	0:0	6	.
water	146:96	0:0	6	f
op	146:97	0:0	6	->
water	146:99	0:0	6	linesize
op	146:107	0:0	6	[
water	146:108	0:0	6	1
op	146:109	0:0	6	]
op	146:111	0:0	6	/
water	146:113	0:0	6	2
arg	147:38	147:50	5	avctx->width
water	147:38	0:0	6	avctx
op	147:43	0:0	6	->
water	147:45	0:0	6	width
arg	147:52	147:65	5	avctx->height
water	147:52	0:0	6	avctx
op	147:57	0:0	6	->
water	147:59	0:0	6	height
water	147:66	0:0	4	;
break	148:8	148:13	4	
label	149:4	149:27	4	case AV_PIX_FMT_YUV420P :
for	150:8	179:8	4	(i = 0 ;i < 3;i ++)
forinit	150:13	150:18	5	i = 0 ;
water	150:13	0:0	6	i
op	150:15	0:0	6	=
water	150:17	0:0	6	0
water	150:18	0:0	6	;
cond	150:20	150:24	5	i < 3
water	150:20	0:0	6	i
op	150:22	0:0	6	<
water	150:24	0:0	6	3
forexpr	150:27	150:28	5	i ++
water	150:27	0:0	6	i
op	150:28	0:0	6	++
stmts	150:32	179:8	5	
water	150:32	0:0	6	{
water	151:12	0:0	6	ret
op	151:16	0:0	6	=
call	151:18	153:73	6	decode_plane
arg	151:31	151:32	7	c
water	151:31	0:0	8	c
arg	151:34	151:35	7	i
water	151:34	0:0	8	i
arg	151:37	151:53	7	frame.f->data[i]
water	151:37	0:0	8	frame
op	151:42	0:0	8	.
water	151:43	0:0	8	f
op	151:44	0:0	8	->
water	151:46	0:0	8	data
op	151:50	0:0	8	[
water	151:51	0:0	8	i
op	151:52	0:0	8	]
arg	151:55	151:56	7	1
water	151:55	0:0	8	1
arg	151:58	151:78	7	frame.f->linesize[i]
water	151:58	0:0	8	frame
op	151:63	0:0	8	.
water	151:64	0:0	8	f
op	151:65	0:0	8	->
water	151:67	0:0	8	linesize
op	151:75	0:0	8	[
water	151:76	0:0	8	i
op	151:77	0:0	8	]
arg	152:31	152:50	7	avctx->width>>!!i
water	152:31	0:0	8	avctx
op	152:36	0:0	8	->
water	152:38	0:0	8	width
op	152:44	0:0	8	>>
op	152:47	0:0	8	!
op	152:48	0:0	8	!
water	152:49	0:0	8	i
arg	152:52	152:72	7	avctx->height>>!!i
water	152:52	0:0	8	avctx
op	152:57	0:0	8	->
water	152:59	0:0	8	height
op	152:66	0:0	8	>>
op	152:69	0:0	8	!
op	152:70	0:0	8	!
water	152:71	0:0	8	i
arg	153:31	153:45	7	plane_start[i]
water	153:31	0:0	8	plane_start
op	153:42	0:0	8	[
water	153:43	0:0	8	i
op	153:44	0:0	8	]
arg	153:47	153:73	7	c->frame_pred==PRED_LEFT
water	153:47	0:0	8	c
op	153:48	0:0	8	->
water	153:50	0:0	8	frame_pred
op	153:61	0:0	8	==
water	153:64	0:0	8	PRED_LEFT
water	153:74	0:0	6	;
if	154:12	155:26	6	(ret)
cond	154:16	154:16	7	ret
water	154:16	0:0	8	ret
stmts	155:16	155:26	7	
return	155:16	155:26	8	ret
water	155:23	0:0	9	ret
if	156:12	167:12	6	(c -> frame_pred == PRED_MEDIAN)
cond	156:16	156:33	7	c -> frame_pred == PRED_MEDIAN
water	156:16	0:0	8	c
op	156:17	0:0	8	->
water	156:19	0:0	8	frame_pred
op	156:30	0:0	8	==
water	156:33	0:0	8	PRED_MEDIAN
stmts	156:46	167:12	7	
water	156:46	0:0	8	{
if	157:16	161:16	8	(! c -> interlaced)
cond	157:20	157:24	9	! c -> interlaced
op	157:20	0:0	10	!
water	157:21	0:0	10	c
op	157:22	0:0	10	->
water	157:24	0:0	10	interlaced
stmts	157:36	161:16	9	
water	157:36	0:0	10	{
call	158:20	160:55	10	restore_median_planar
arg	158:42	158:43	11	c
water	158:42	0:0	12	c
arg	158:45	158:61	11	frame.f->data[i]
water	158:45	0:0	12	frame
op	158:50	0:0	12	.
water	158:51	0:0	12	f
op	158:52	0:0	12	->
water	158:54	0:0	12	data
op	158:58	0:0	12	[
water	158:59	0:0	12	i
op	158:60	0:0	12	]
arg	158:63	158:83	11	frame.f->linesize[i]
water	158:63	0:0	12	frame
op	158:68	0:0	12	.
water	158:69	0:0	12	f
op	158:70	0:0	12	->
water	158:72	0:0	12	linesize
op	158:80	0:0	12	[
water	158:81	0:0	12	i
op	158:82	0:0	12	]
arg	159:42	159:61	11	avctx->width>>!!i
water	159:42	0:0	12	avctx
op	159:47	0:0	12	->
water	159:49	0:0	12	width
op	159:55	0:0	12	>>
op	159:58	0:0	12	!
op	159:59	0:0	12	!
water	159:60	0:0	12	i
arg	159:63	159:83	11	avctx->height>>!!i
water	159:63	0:0	12	avctx
op	159:68	0:0	12	->
water	159:70	0:0	12	height
op	159:77	0:0	12	>>
op	159:80	0:0	12	!
op	159:81	0:0	12	!
water	159:82	0:0	12	i
arg	160:42	160:51	11	c->slices
water	160:42	0:0	12	c
op	160:43	0:0	12	->
water	160:45	0:0	12	slices
arg	160:53	160:55	11	!i
op	160:53	0:0	12	!
water	160:54	0:0	12	i
water	160:56	0:0	10	;
water	161:16	0:0	10	}
else	161:18	166:16	8
stmts	161:23	166:16	9	
water	161:23	0:0	10	{
call	162:20	165:58	10	restore_median_planar_il
arg	162:45	162:46	11	c
water	162:45	0:0	12	c
arg	162:48	162:64	11	frame.f->data[i]
water	162:48	0:0	12	frame
op	162:53	0:0	12	.
water	162:54	0:0	12	f
op	162:55	0:0	12	->
water	162:57	0:0	12	data
op	162:61	0:0	12	[
water	162:62	0:0	12	i
op	162:63	0:0	12	]
arg	162:66	162:86	11	frame.f->linesize[i]
water	162:66	0:0	12	frame
op	162:71	0:0	12	.
water	162:72	0:0	12	f
op	162:73	0:0	12	->
water	162:75	0:0	12	linesize
op	162:83	0:0	12	[
water	162:84	0:0	12	i
op	162:85	0:0	12	]
arg	163:45	163:65	11	avctx->width>>!!i
water	163:45	0:0	12	avctx
op	163:50	0:0	12	->
water	163:52	0:0	12	width
op	163:59	0:0	12	>>
op	163:62	0:0	12	!
op	163:63	0:0	12	!
water	163:64	0:0	12	i
arg	164:45	164:65	11	avctx->height>>!!i
water	164:45	0:0	12	avctx
op	164:50	0:0	12	->
water	164:52	0:0	12	height
op	164:59	0:0	12	>>
op	164:62	0:0	12	!
op	164:63	0:0	12	!
water	164:64	0:0	12	i
arg	165:45	165:54	11	c->slices
water	165:45	0:0	12	c
op	165:46	0:0	12	->
water	165:48	0:0	12	slices
arg	165:56	165:58	11	!i
op	165:56	0:0	12	!
water	165:57	0:0	12	i
water	165:59	0:0	10	;
water	166:16	0:0	10	}
water	167:12	0:0	8	}
else	167:14	178:12	6
stmts	167:19	178:12	7	
if	167:19	178:12	8	(c -> frame_pred == PRED_GRADIENT)
cond	167:23	167:40	9	c -> frame_pred == PRED_GRADIENT
water	167:23	0:0	10	c
op	167:24	0:0	10	->
water	167:26	0:0	10	frame_pred
op	167:37	0:0	10	==
water	167:40	0:0	10	PRED_GRADIENT
stmts	167:55	178:12	9	
water	167:55	0:0	10	{
if	168:16	172:16	10	(! c -> interlaced)
cond	168:20	168:24	11	! c -> interlaced
op	168:20	0:0	12	!
water	168:21	0:0	12	c
op	168:22	0:0	12	->
water	168:24	0:0	12	interlaced
stmts	168:36	172:16	11	
water	168:36	0:0	12	{
call	169:20	171:57	12	restore_gradient_planar
arg	169:44	169:45	13	c
water	169:44	0:0	14	c
arg	169:47	169:63	13	frame.f->data[i]
water	169:47	0:0	14	frame
op	169:52	0:0	14	.
water	169:53	0:0	14	f
op	169:54	0:0	14	->
water	169:56	0:0	14	data
op	169:60	0:0	14	[
water	169:61	0:0	14	i
op	169:62	0:0	14	]
arg	169:65	169:85	13	frame.f->linesize[i]
water	169:65	0:0	14	frame
op	169:70	0:0	14	.
water	169:71	0:0	14	f
op	169:72	0:0	14	->
water	169:74	0:0	14	linesize
op	169:82	0:0	14	[
water	169:83	0:0	14	i
op	169:84	0:0	14	]
arg	170:44	170:63	13	avctx->width>>!!i
water	170:44	0:0	14	avctx
op	170:49	0:0	14	->
water	170:51	0:0	14	width
op	170:57	0:0	14	>>
op	170:60	0:0	14	!
op	170:61	0:0	14	!
water	170:62	0:0	14	i
arg	170:65	170:85	13	avctx->height>>!!i
water	170:65	0:0	14	avctx
op	170:70	0:0	14	->
water	170:72	0:0	14	height
op	170:79	0:0	14	>>
op	170:82	0:0	14	!
op	170:83	0:0	14	!
water	170:84	0:0	14	i
arg	171:44	171:53	13	c->slices
water	171:44	0:0	14	c
op	171:45	0:0	14	->
water	171:47	0:0	14	slices
arg	171:55	171:57	13	!i
op	171:55	0:0	14	!
water	171:56	0:0	14	i
water	171:58	0:0	12	;
water	172:16	0:0	12	}
else	172:18	177:16	10
stmts	172:23	177:16	11	
water	172:23	0:0	12	{
call	173:20	176:60	12	restore_gradient_planar_il
arg	173:47	173:48	13	c
water	173:47	0:0	14	c
arg	173:50	173:66	13	frame.f->data[i]
water	173:50	0:0	14	frame
op	173:55	0:0	14	.
water	173:56	0:0	14	f
op	173:57	0:0	14	->
water	173:59	0:0	14	data
op	173:63	0:0	14	[
water	173:64	0:0	14	i
op	173:65	0:0	14	]
arg	173:68	173:88	13	frame.f->linesize[i]
water	173:68	0:0	14	frame
op	173:73	0:0	14	.
water	173:74	0:0	14	f
op	173:75	0:0	14	->
water	173:77	0:0	14	linesize
op	173:85	0:0	14	[
water	173:86	0:0	14	i
op	173:87	0:0	14	]
arg	174:47	174:67	13	avctx->width>>!!i
water	174:47	0:0	14	avctx
op	174:52	0:0	14	->
water	174:54	0:0	14	width
op	174:61	0:0	14	>>
op	174:64	0:0	14	!
op	174:65	0:0	14	!
water	174:66	0:0	14	i
arg	175:47	175:67	13	avctx->height>>!!i
water	175:47	0:0	14	avctx
op	175:52	0:0	14	->
water	175:54	0:0	14	height
op	175:61	0:0	14	>>
op	175:64	0:0	14	!
op	175:65	0:0	14	!
water	175:66	0:0	14	i
arg	176:47	176:56	13	c->slices
water	176:47	0:0	14	c
op	176:48	0:0	14	->
water	176:50	0:0	14	slices
arg	176:58	176:60	13	!i
op	176:58	0:0	14	!
water	176:59	0:0	14	i
water	176:61	0:0	12	;
water	177:16	0:0	12	}
water	178:12	0:0	10	}
water	179:8	0:0	6	}
break	180:8	180:13	4	
label	181:4	181:27	4	case AV_PIX_FMT_YUV422P :
for	182:8	209:8	4	(i = 0 ;i < 3;i ++)
forinit	182:13	182:18	5	i = 0 ;
water	182:13	0:0	6	i
op	182:15	0:0	6	=
water	182:17	0:0	6	0
water	182:18	0:0	6	;
cond	182:20	182:24	5	i < 3
water	182:20	0:0	6	i
op	182:22	0:0	6	<
water	182:24	0:0	6	3
forexpr	182:27	182:28	5	i ++
water	182:27	0:0	6	i
op	182:28	0:0	6	++
stmts	182:32	209:8	5	
water	182:32	0:0	6	{
water	183:12	0:0	6	ret
op	183:16	0:0	6	=
call	183:18	185:73	6	decode_plane
arg	183:31	183:32	7	c
water	183:31	0:0	8	c
arg	183:34	183:35	7	i
water	183:34	0:0	8	i
arg	183:37	183:53	7	frame.f->data[i]
water	183:37	0:0	8	frame
op	183:42	0:0	8	.
water	183:43	0:0	8	f
op	183:44	0:0	8	->
water	183:46	0:0	8	data
op	183:50	0:0	8	[
water	183:51	0:0	8	i
op	183:52	0:0	8	]
arg	183:55	183:56	7	1
water	183:55	0:0	8	1
arg	183:58	183:78	7	frame.f->linesize[i]
water	183:58	0:0	8	frame
op	183:63	0:0	8	.
water	183:64	0:0	8	f
op	183:65	0:0	8	->
water	183:67	0:0	8	linesize
op	183:75	0:0	8	[
water	183:76	0:0	8	i
op	183:77	0:0	8	]
arg	184:31	184:50	7	avctx->width>>!!i
water	184:31	0:0	8	avctx
op	184:36	0:0	8	->
water	184:38	0:0	8	width
op	184:44	0:0	8	>>
op	184:47	0:0	8	!
op	184:48	0:0	8	!
water	184:49	0:0	8	i
arg	184:52	184:65	7	avctx->height
water	184:52	0:0	8	avctx
op	184:57	0:0	8	->
water	184:59	0:0	8	height
arg	185:31	185:45	7	plane_start[i]
water	185:31	0:0	8	plane_start
op	185:42	0:0	8	[
water	185:43	0:0	8	i
op	185:44	0:0	8	]
arg	185:47	185:73	7	c->frame_pred==PRED_LEFT
water	185:47	0:0	8	c
op	185:48	0:0	8	->
water	185:50	0:0	8	frame_pred
op	185:61	0:0	8	==
water	185:64	0:0	8	PRED_LEFT
water	185:74	0:0	6	;
if	186:12	187:26	6	(ret)
cond	186:16	186:16	7	ret
water	186:16	0:0	8	ret
stmts	187:16	187:26	7	
return	187:16	187:26	8	ret
water	187:23	0:0	9	ret
if	188:12	198:12	6	(c -> frame_pred == PRED_MEDIAN)
cond	188:16	188:33	7	c -> frame_pred == PRED_MEDIAN
water	188:16	0:0	8	c
op	188:17	0:0	8	->
water	188:19	0:0	8	frame_pred
op	188:30	0:0	8	==
water	188:33	0:0	8	PRED_MEDIAN
stmts	188:46	198:12	7	
water	188:46	0:0	8	{
if	189:16	193:16	8	(! c -> interlaced)
cond	189:20	189:24	9	! c -> interlaced
op	189:20	0:0	10	!
water	189:21	0:0	10	c
op	189:22	0:0	10	->
water	189:24	0:0	10	interlaced
stmts	189:36	193:16	9	
water	189:36	0:0	10	{
call	190:20	192:54	10	restore_median_planar
arg	190:42	190:43	11	c
water	190:42	0:0	12	c
arg	190:45	190:61	11	frame.f->data[i]
water	190:45	0:0	12	frame
op	190:50	0:0	12	.
water	190:51	0:0	12	f
op	190:52	0:0	12	->
water	190:54	0:0	12	data
op	190:58	0:0	12	[
water	190:59	0:0	12	i
op	190:60	0:0	12	]
arg	190:63	190:83	11	frame.f->linesize[i]
water	190:63	0:0	12	frame
op	190:68	0:0	12	.
water	190:69	0:0	12	f
op	190:70	0:0	12	->
water	190:72	0:0	12	linesize
op	190:80	0:0	12	[
water	190:81	0:0	12	i
op	190:82	0:0	12	]
arg	191:42	191:61	11	avctx->width>>!!i
water	191:42	0:0	12	avctx
op	191:47	0:0	12	->
water	191:49	0:0	12	width
op	191:55	0:0	12	>>
op	191:58	0:0	12	!
op	191:59	0:0	12	!
water	191:60	0:0	12	i
arg	191:63	191:76	11	avctx->height
water	191:63	0:0	12	avctx
op	191:68	0:0	12	->
water	191:70	0:0	12	height
arg	192:42	192:51	11	c->slices
water	192:42	0:0	12	c
op	192:43	0:0	12	->
water	192:45	0:0	12	slices
arg	192:53	192:54	11	0
water	192:53	0:0	12	0
water	192:55	0:0	10	;
water	193:16	0:0	10	}
else	193:18	197:16	8
stmts	193:23	197:16	9	
water	193:23	0:0	10	{
call	194:20	196:57	10	restore_median_planar_il
arg	194:45	194:46	11	c
water	194:45	0:0	12	c
arg	194:48	194:64	11	frame.f->data[i]
water	194:48	0:0	12	frame
op	194:53	0:0	12	.
water	194:54	0:0	12	f
op	194:55	0:0	12	->
water	194:57	0:0	12	data
op	194:61	0:0	12	[
water	194:62	0:0	12	i
op	194:63	0:0	12	]
arg	194:66	194:86	11	frame.f->linesize[i]
water	194:66	0:0	12	frame
op	194:71	0:0	12	.
water	194:72	0:0	12	f
op	194:73	0:0	12	->
water	194:75	0:0	12	linesize
op	194:83	0:0	12	[
water	194:84	0:0	12	i
op	194:85	0:0	12	]
arg	195:45	195:64	11	avctx->width>>!!i
water	195:45	0:0	12	avctx
op	195:50	0:0	12	->
water	195:52	0:0	12	width
op	195:58	0:0	12	>>
op	195:61	0:0	12	!
op	195:62	0:0	12	!
water	195:63	0:0	12	i
arg	195:66	195:79	11	avctx->height
water	195:66	0:0	12	avctx
op	195:71	0:0	12	->
water	195:73	0:0	12	height
arg	196:45	196:54	11	c->slices
water	196:45	0:0	12	c
op	196:46	0:0	12	->
water	196:48	0:0	12	slices
arg	196:56	196:57	11	0
water	196:56	0:0	12	0
water	196:58	0:0	10	;
water	197:16	0:0	10	}
water	198:12	0:0	8	}
else	198:14	208:12	6
stmts	198:19	208:12	7	
if	198:19	208:12	8	(c -> frame_pred == PRED_GRADIENT)
cond	198:23	198:40	9	c -> frame_pred == PRED_GRADIENT
water	198:23	0:0	10	c
op	198:24	0:0	10	->
water	198:26	0:0	10	frame_pred
op	198:37	0:0	10	==
water	198:40	0:0	10	PRED_GRADIENT
stmts	198:55	208:12	9	
water	198:55	0:0	10	{
if	199:16	203:16	10	(! c -> interlaced)
cond	199:20	199:24	11	! c -> interlaced
op	199:20	0:0	12	!
water	199:21	0:0	12	c
op	199:22	0:0	12	->
water	199:24	0:0	12	interlaced
stmts	199:36	203:16	11	
water	199:36	0:0	12	{
call	200:20	202:56	12	restore_gradient_planar
arg	200:44	200:45	13	c
water	200:44	0:0	14	c
arg	200:47	200:63	13	frame.f->data[i]
water	200:47	0:0	14	frame
op	200:52	0:0	14	.
water	200:53	0:0	14	f
op	200:54	0:0	14	->
water	200:56	0:0	14	data
op	200:60	0:0	14	[
water	200:61	0:0	14	i
op	200:62	0:0	14	]
arg	200:65	200:85	13	frame.f->linesize[i]
water	200:65	0:0	14	frame
op	200:70	0:0	14	.
water	200:71	0:0	14	f
op	200:72	0:0	14	->
water	200:74	0:0	14	linesize
op	200:82	0:0	14	[
water	200:83	0:0	14	i
op	200:84	0:0	14	]
arg	201:44	201:63	13	avctx->width>>!!i
water	201:44	0:0	14	avctx
op	201:49	0:0	14	->
water	201:51	0:0	14	width
op	201:57	0:0	14	>>
op	201:60	0:0	14	!
op	201:61	0:0	14	!
water	201:62	0:0	14	i
arg	201:65	201:78	13	avctx->height
water	201:65	0:0	14	avctx
op	201:70	0:0	14	->
water	201:72	0:0	14	height
arg	202:44	202:53	13	c->slices
water	202:44	0:0	14	c
op	202:45	0:0	14	->
water	202:47	0:0	14	slices
arg	202:55	202:56	13	0
water	202:55	0:0	14	0
water	202:57	0:0	12	;
water	203:16	0:0	12	}
else	203:18	207:16	10
stmts	203:23	207:16	11	
water	203:23	0:0	12	{
call	204:20	206:59	12	restore_gradient_planar_il
arg	204:47	204:48	13	c
water	204:47	0:0	14	c
arg	204:50	204:66	13	frame.f->data[i]
water	204:50	0:0	14	frame
op	204:55	0:0	14	.
water	204:56	0:0	14	f
op	204:57	0:0	14	->
water	204:59	0:0	14	data
op	204:63	0:0	14	[
water	204:64	0:0	14	i
op	204:65	0:0	14	]
arg	204:68	204:88	13	frame.f->linesize[i]
water	204:68	0:0	14	frame
op	204:73	0:0	14	.
water	204:74	0:0	14	f
op	204:75	0:0	14	->
water	204:77	0:0	14	linesize
op	204:85	0:0	14	[
water	204:86	0:0	14	i
op	204:87	0:0	14	]
arg	205:47	205:67	13	avctx->width>>!!i
water	205:47	0:0	14	avctx
op	205:52	0:0	14	->
water	205:54	0:0	14	width
op	205:61	0:0	14	>>
op	205:64	0:0	14	!
op	205:65	0:0	14	!
water	205:66	0:0	14	i
arg	205:69	205:82	13	avctx->height
water	205:69	0:0	14	avctx
op	205:74	0:0	14	->
water	205:76	0:0	14	height
arg	206:47	206:56	13	c->slices
water	206:47	0:0	14	c
op	206:48	0:0	14	->
water	206:50	0:0	14	slices
arg	206:58	206:59	13	0
water	206:58	0:0	14	0
water	206:60	0:0	12	;
water	207:16	0:0	12	}
water	208:12	0:0	10	}
water	209:8	0:0	6	}
break	210:8	210:13	4	
label	211:4	211:27	4	case AV_PIX_FMT_YUV444P :
for	212:8	239:8	4	(i = 0 ;i < 3;i ++)
forinit	212:13	212:18	5	i = 0 ;
water	212:13	0:0	6	i
op	212:15	0:0	6	=
water	212:17	0:0	6	0
water	212:18	0:0	6	;
cond	212:20	212:24	5	i < 3
water	212:20	0:0	6	i
op	212:22	0:0	6	<
water	212:24	0:0	6	3
forexpr	212:27	212:28	5	i ++
water	212:27	0:0	6	i
op	212:28	0:0	6	++
stmts	212:32	239:8	5	
water	212:32	0:0	6	{
water	213:12	0:0	6	ret
op	213:16	0:0	6	=
call	213:18	215:73	6	decode_plane
arg	213:31	213:32	7	c
water	213:31	0:0	8	c
arg	213:34	213:35	7	i
water	213:34	0:0	8	i
arg	213:37	213:53	7	frame.f->data[i]
water	213:37	0:0	8	frame
op	213:42	0:0	8	.
water	213:43	0:0	8	f
op	213:44	0:0	8	->
water	213:46	0:0	8	data
op	213:50	0:0	8	[
water	213:51	0:0	8	i
op	213:52	0:0	8	]
arg	213:55	213:56	7	1
water	213:55	0:0	8	1
arg	213:58	213:78	7	frame.f->linesize[i]
water	213:58	0:0	8	frame
op	213:63	0:0	8	.
water	213:64	0:0	8	f
op	213:65	0:0	8	->
water	213:67	0:0	8	linesize
op	213:75	0:0	8	[
water	213:76	0:0	8	i
op	213:77	0:0	8	]
arg	214:31	214:43	7	avctx->width
water	214:31	0:0	8	avctx
op	214:36	0:0	8	->
water	214:38	0:0	8	width
arg	214:45	214:58	7	avctx->height
water	214:45	0:0	8	avctx
op	214:50	0:0	8	->
water	214:52	0:0	8	height
arg	215:31	215:45	7	plane_start[i]
water	215:31	0:0	8	plane_start
op	215:42	0:0	8	[
water	215:43	0:0	8	i
op	215:44	0:0	8	]
arg	215:47	215:73	7	c->frame_pred==PRED_LEFT
water	215:47	0:0	8	c
op	215:48	0:0	8	->
water	215:50	0:0	8	frame_pred
op	215:61	0:0	8	==
water	215:64	0:0	8	PRED_LEFT
water	215:74	0:0	6	;
if	216:12	217:26	6	(ret)
cond	216:16	216:16	7	ret
water	216:16	0:0	8	ret
stmts	217:16	217:26	7	
return	217:16	217:26	8	ret
water	217:23	0:0	9	ret
if	218:12	228:12	6	(c -> frame_pred == PRED_MEDIAN)
cond	218:16	218:33	7	c -> frame_pred == PRED_MEDIAN
water	218:16	0:0	8	c
op	218:17	0:0	8	->
water	218:19	0:0	8	frame_pred
op	218:30	0:0	8	==
water	218:33	0:0	8	PRED_MEDIAN
stmts	218:46	228:12	7	
water	218:46	0:0	8	{
if	219:16	223:16	8	(! c -> interlaced)
cond	219:20	219:24	9	! c -> interlaced
op	219:20	0:0	10	!
water	219:21	0:0	10	c
op	219:22	0:0	10	->
water	219:24	0:0	10	interlaced
stmts	219:36	223:16	9	
water	219:36	0:0	10	{
call	220:20	222:54	10	restore_median_planar
arg	220:42	220:43	11	c
water	220:42	0:0	12	c
arg	220:45	220:61	11	frame.f->data[i]
water	220:45	0:0	12	frame
op	220:50	0:0	12	.
water	220:51	0:0	12	f
op	220:52	0:0	12	->
water	220:54	0:0	12	data
op	220:58	0:0	12	[
water	220:59	0:0	12	i
op	220:60	0:0	12	]
arg	220:63	220:83	11	frame.f->linesize[i]
water	220:63	0:0	12	frame
op	220:68	0:0	12	.
water	220:69	0:0	12	f
op	220:70	0:0	12	->
water	220:72	0:0	12	linesize
op	220:80	0:0	12	[
water	220:81	0:0	12	i
op	220:82	0:0	12	]
arg	221:42	221:54	11	avctx->width
water	221:42	0:0	12	avctx
op	221:47	0:0	12	->
water	221:49	0:0	12	width
arg	221:56	221:69	11	avctx->height
water	221:56	0:0	12	avctx
op	221:61	0:0	12	->
water	221:63	0:0	12	height
arg	222:42	222:51	11	c->slices
water	222:42	0:0	12	c
op	222:43	0:0	12	->
water	222:45	0:0	12	slices
arg	222:53	222:54	11	0
water	222:53	0:0	12	0
water	222:55	0:0	10	;
water	223:16	0:0	10	}
else	223:18	227:16	8
stmts	223:23	227:16	9	
water	223:23	0:0	10	{
call	224:20	226:57	10	restore_median_planar_il
arg	224:45	224:46	11	c
water	224:45	0:0	12	c
arg	224:48	224:64	11	frame.f->data[i]
water	224:48	0:0	12	frame
op	224:53	0:0	12	.
water	224:54	0:0	12	f
op	224:55	0:0	12	->
water	224:57	0:0	12	data
op	224:61	0:0	12	[
water	224:62	0:0	12	i
op	224:63	0:0	12	]
arg	224:66	224:86	11	frame.f->linesize[i]
water	224:66	0:0	12	frame
op	224:71	0:0	12	.
water	224:72	0:0	12	f
op	224:73	0:0	12	->
water	224:75	0:0	12	linesize
op	224:83	0:0	12	[
water	224:84	0:0	12	i
op	224:85	0:0	12	]
arg	225:45	225:57	11	avctx->width
water	225:45	0:0	12	avctx
op	225:50	0:0	12	->
water	225:52	0:0	12	width
arg	225:59	225:72	11	avctx->height
water	225:59	0:0	12	avctx
op	225:64	0:0	12	->
water	225:66	0:0	12	height
arg	226:45	226:54	11	c->slices
water	226:45	0:0	12	c
op	226:46	0:0	12	->
water	226:48	0:0	12	slices
arg	226:56	226:57	11	0
water	226:56	0:0	12	0
water	226:58	0:0	10	;
water	227:16	0:0	10	}
water	228:12	0:0	8	}
else	228:14	238:12	6
stmts	228:19	238:12	7	
if	228:19	238:12	8	(c -> frame_pred == PRED_GRADIENT)
cond	228:23	228:40	9	c -> frame_pred == PRED_GRADIENT
water	228:23	0:0	10	c
op	228:24	0:0	10	->
water	228:26	0:0	10	frame_pred
op	228:37	0:0	10	==
water	228:40	0:0	10	PRED_GRADIENT
stmts	228:55	238:12	9	
water	228:55	0:0	10	{
if	229:16	233:16	10	(! c -> interlaced)
cond	229:20	229:24	11	! c -> interlaced
op	229:20	0:0	12	!
water	229:21	0:0	12	c
op	229:22	0:0	12	->
water	229:24	0:0	12	interlaced
stmts	229:36	233:16	11	
water	229:36	0:0	12	{
call	230:20	232:56	12	restore_gradient_planar
arg	230:44	230:45	13	c
water	230:44	0:0	14	c
arg	230:47	230:63	13	frame.f->data[i]
water	230:47	0:0	14	frame
op	230:52	0:0	14	.
water	230:53	0:0	14	f
op	230:54	0:0	14	->
water	230:56	0:0	14	data
op	230:60	0:0	14	[
water	230:61	0:0	14	i
op	230:62	0:0	14	]
arg	230:65	230:85	13	frame.f->linesize[i]
water	230:65	0:0	14	frame
op	230:70	0:0	14	.
water	230:71	0:0	14	f
op	230:72	0:0	14	->
water	230:74	0:0	14	linesize
op	230:82	0:0	14	[
water	230:83	0:0	14	i
op	230:84	0:0	14	]
arg	231:44	231:56	13	avctx->width
water	231:44	0:0	14	avctx
op	231:49	0:0	14	->
water	231:51	0:0	14	width
arg	231:58	231:71	13	avctx->height
water	231:58	0:0	14	avctx
op	231:63	0:0	14	->
water	231:65	0:0	14	height
arg	232:44	232:53	13	c->slices
water	232:44	0:0	14	c
op	232:45	0:0	14	->
water	232:47	0:0	14	slices
arg	232:55	232:56	13	0
water	232:55	0:0	14	0
water	232:57	0:0	12	;
water	233:16	0:0	12	}
else	233:18	237:16	10
stmts	233:23	237:16	11	
water	233:23	0:0	12	{
call	234:20	236:59	12	restore_gradient_planar_il
arg	234:47	234:48	13	c
water	234:47	0:0	14	c
arg	234:50	234:66	13	frame.f->data[i]
water	234:50	0:0	14	frame
op	234:55	0:0	14	.
water	234:56	0:0	14	f
op	234:57	0:0	14	->
water	234:59	0:0	14	data
op	234:63	0:0	14	[
water	234:64	0:0	14	i
op	234:65	0:0	14	]
arg	234:68	234:88	13	frame.f->linesize[i]
water	234:68	0:0	14	frame
op	234:73	0:0	14	.
water	234:74	0:0	14	f
op	234:75	0:0	14	->
water	234:77	0:0	14	linesize
op	234:85	0:0	14	[
water	234:86	0:0	14	i
op	234:87	0:0	14	]
arg	235:47	235:59	13	avctx->width
water	235:47	0:0	14	avctx
op	235:52	0:0	14	->
water	235:54	0:0	14	width
arg	235:61	235:74	13	avctx->height
water	235:61	0:0	14	avctx
op	235:66	0:0	14	->
water	235:68	0:0	14	height
arg	236:47	236:56	13	c->slices
water	236:47	0:0	14	c
op	236:48	0:0	14	->
water	236:50	0:0	14	slices
arg	236:58	236:59	13	0
water	236:58	0:0	14	0
water	236:60	0:0	12	;
water	237:16	0:0	12	}
water	238:12	0:0	10	}
water	239:8	0:0	6	}
break	240:8	240:13	4	
label	241:4	241:29	4	case AV_PIX_FMT_YUV422P10 :
for	242:8	248:8	4	(i = 0 ;i < 3;i ++)
forinit	242:13	242:18	5	i = 0 ;
water	242:13	0:0	6	i
op	242:15	0:0	6	=
water	242:17	0:0	6	0
water	242:18	0:0	6	;
cond	242:20	242:24	5	i < 3
water	242:20	0:0	6	i
op	242:22	0:0	6	<
water	242:24	0:0	6	3
forexpr	242:27	242:28	5	i ++
water	242:27	0:0	6	i
op	242:28	0:0	6	++
stmts	242:32	248:8	5	
water	242:32	0:0	6	{
water	243:12	0:0	6	ret
op	243:16	0:0	6	=
call	243:18	245:102	6	decode_plane10
arg	243:33	243:34	7	c
water	243:33	0:0	8	c
arg	243:36	243:37	7	i
water	243:36	0:0	8	i
arg	243:39	243:67	7	(uint16_t*)frame.f->data[i]
water	243:39	0:0	8	(
water	243:40	0:0	8	uint16_t
op	243:49	0:0	8	*
water	243:50	0:0	8	)
water	243:51	0:0	8	frame
op	243:56	0:0	8	.
water	243:57	0:0	8	f
op	243:58	0:0	8	->
water	243:60	0:0	8	data
op	243:64	0:0	8	[
water	243:65	0:0	8	i
op	243:66	0:0	8	]
arg	243:69	243:70	7	1
water	243:69	0:0	8	1
arg	243:72	243:96	7	frame.f->linesize[i]/2
water	243:72	0:0	8	frame
op	243:77	0:0	8	.
water	243:78	0:0	8	f
op	243:79	0:0	8	->
water	243:81	0:0	8	linesize
op	243:89	0:0	8	[
water	243:90	0:0	8	i
op	243:91	0:0	8	]
op	243:93	0:0	8	/
water	243:95	0:0	8	2
arg	244:33	244:52	7	avctx->width>>!!i
water	244:33	0:0	8	avctx
op	244:38	0:0	8	->
water	244:40	0:0	8	width
op	244:46	0:0	8	>>
op	244:49	0:0	8	!
op	244:50	0:0	8	!
water	244:51	0:0	8	i
arg	244:54	244:67	7	avctx->height
water	244:54	0:0	8	avctx
op	244:59	0:0	8	->
water	244:61	0:0	8	height
arg	245:33	245:47	7	plane_start[i]
water	245:33	0:0	8	plane_start
op	245:44	0:0	8	[
water	245:45	0:0	8	i
op	245:46	0:0	8	]
arg	245:49	245:74	7	plane_start[i+1]-1024
water	245:49	0:0	8	plane_start
op	245:60	0:0	8	[
water	245:61	0:0	8	i
op	245:63	0:0	8	+
water	245:65	0:0	8	1
op	245:66	0:0	8	]
op	245:68	0:0	8	-
water	245:70	0:0	8	1024
arg	245:76	245:102	7	c->frame_pred==PRED_LEFT
water	245:76	0:0	8	c
op	245:77	0:0	8	->
water	245:79	0:0	8	frame_pred
op	245:90	0:0	8	==
water	245:93	0:0	8	PRED_LEFT
water	245:103	0:0	6	;
if	246:12	247:26	6	(ret)
cond	246:16	246:16	7	ret
water	246:16	0:0	8	ret
stmts	247:16	247:26	7	
return	247:16	247:26	8	ret
water	247:23	0:0	9	ret
water	248:8	0:0	6	}
break	249:8	249:13	4	
water	250:4	0:0	4	}
water	252:4	0:0	2	frame
op	252:9	0:0	2	.
water	252:10	0:0	2	f
op	252:11	0:0	2	->
water	252:13	0:0	2	key_frame
op	252:23	0:0	2	=
water	252:25	0:0	2	1
water	252:26	0:0	2	;
water	253:4	0:0	2	frame
op	253:9	0:0	2	.
water	253:10	0:0	2	f
op	253:11	0:0	2	->
water	253:13	0:0	2	pict_type
op	253:23	0:0	2	=
water	253:25	0:0	2	AV_PICTURE_TYPE_I
water	253:42	0:0	2	;
water	254:4	0:0	2	frame
op	254:9	0:0	2	.
water	254:10	0:0	2	f
op	254:11	0:0	2	->
water	254:13	0:0	2	interlaced_frame
op	254:30	0:0	2	=
op	254:32	0:0	2	!
op	254:33	0:0	2	!
water	254:34	0:0	2	c
op	254:35	0:0	2	->
water	254:37	0:0	2	interlaced
water	254:47	0:0	2	;
op	256:4	0:0	2	*
water	256:5	0:0	2	got_frame
op	256:15	0:0	2	=
water	256:17	0:0	2	1
water	256:18	0:0	2	;
return	259:4	259:19	2	buf_size
water	259:11	0:0	3	buf_size
