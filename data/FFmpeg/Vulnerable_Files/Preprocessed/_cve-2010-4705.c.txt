func	4:24	146:0	0	int	vorbis_residue_decode_internal
params	4:58	0:0	1	
param	4:59	4:77	2	vorbis_context *	vc
param	5:59	5:77	2	vorbis_residue *	vr
param	6:59	6:74	2	uint_fast8_t	ch
param	7:59	7:86	2	uint_fast8_t *	do_not_decode
param	8:59	8:69	2	float *	vec
param	9:59	9:77	2	uint_fast16_t	vlen
param	10:59	10:70	2	int	vr_type
stmnts	0:0	145:12	1	
decl	12:4	12:31	2	GetBitContext	*gb
op	12:22	0:0	2	=
op	12:24	0:0	2	&
water	12:25	0:0	2	vc
op	12:27	0:0	2	->
water	12:29	0:0	2	gb
decl	13:4	13:64	2	uint_fast8_t	c_p_c
op	13:23	0:0	2	=
water	13:25	0:0	2	vc
op	13:27	0:0	2	->
water	13:29	0:0	2	codebooks
op	13:38	0:0	2	[
water	13:39	0:0	2	vr
op	13:41	0:0	2	->
water	13:43	0:0	2	classbook
op	13:52	0:0	2	]
op	13:53	0:0	2	.
water	13:54	0:0	2	dimensions
decl	14:4	14:47	2	uint_fast16_t	n_to_read
op	14:28	0:0	2	=
water	14:30	0:0	2	vr
op	14:32	0:0	2	->
water	14:34	0:0	2	end
op	14:37	0:0	2	-
water	14:38	0:0	2	vr
op	14:40	0:0	2	->
water	14:42	0:0	2	begin
decl	15:4	15:61	2	uint_fast16_t	ptns_to_read
op	15:31	0:0	2	=
water	15:33	0:0	2	n_to_read
op	15:42	0:0	2	/
water	15:43	0:0	2	vr
op	15:45	0:0	2	->
water	15:47	0:0	2	partition_size
decl	16:4	16:58	2	uint_fast8_t	classifs[ptns_to_read*vc->audio_channels]
decl	17:4	17:21	2	uint_fast8_t	pass
decl	18:4	18:24	2	uint_fast8_t	ch_used
decl	19:4	19:22	2	uint_fast8_t	i
water	19:18	0:0	2	,
decl	19:4	19:22	2	uint_fast8_t	j
water	19:20	0:0	2	,
decl	19:4	19:22	2	uint_fast8_t	l
decl	20:4	20:19	2	uint_fast16_t	k
if	22:4	28:4	2	(vr_type == 2)
cond	22:8	22:19	3	vr_type == 2
water	22:8	0:0	4	vr_type
op	22:16	0:0	4	==
water	22:19	0:0	4	2
stmts	22:22	28:4	3	
water	22:22	0:0	4	{
for	23:8	24:48	4	(j = 1 ;j < ch;++ j)
forinit	23:13	23:18	5	j = 1 ;
water	23:13	0:0	6	j
op	23:15	0:0	6	=
water	23:17	0:0	6	1
water	23:18	0:0	6	;
cond	23:20	23:24	5	j < ch
water	23:20	0:0	6	j
op	23:22	0:0	6	<
water	23:24	0:0	6	ch
forexpr	23:28	23:30	5	++ j
op	23:28	0:0	6	++
water	23:30	0:0	6	j
stmts	24:12	24:48	5	
water	24:12	0:0	6	do_not_decode
op	24:25	0:0	6	[
water	24:26	0:0	6	0
op	24:27	0:0	6	]
op	24:29	0:0	6	&=
water	24:32	0:0	6	do_not_decode
op	24:45	0:0	6	[
water	24:46	0:0	6	j
op	24:47	0:0	6	]
water	24:48	0:0	6	;
if	25:8	26:20	4	(do_not_decode [ 0 ])
cond	25:12	25:27	5	do_not_decode [ 0 ]
water	25:12	0:0	6	do_not_decode
op	25:25	0:0	6	[
water	25:26	0:0	6	0
op	25:27	0:0	6	]
stmts	26:12	26:20	5	
return	26:12	26:20	6	0
water	26:19	0:0	7	0
water	27:8	0:0	4	ch_used
op	27:16	0:0	4	=
water	27:18	0:0	4	1
water	27:19	0:0	4	;
water	28:4	0:0	4	}
else	28:6	30:4	2
stmts	28:11	30:4	3	
water	28:11	0:0	4	{
water	29:8	0:0	4	ch_used
op	29:16	0:0	4	=
water	29:18	0:0	4	ch
water	29:20	0:0	4	;
water	30:4	0:0	4	}
call	32:4	32:78	2	AV_DEBUG
arg	32:13	32:67	3	" residue type 0/1/2 decode begin, ch: %d  cpc %d  \n"
water	32:13	0:0	4	" residue type 0/1/2 decode begin, ch: %d  cpc %d  \n"
arg	32:69	32:71	3	ch
water	32:69	0:0	4	ch
arg	32:73	32:78	3	c_p_c
water	32:73	0:0	4	c_p_c
water	32:79	0:0	2	;
for	34:4	144:4	2	(pass = 0 ;pass <= vr -> maxpass;++ pass)
forinit	34:9	34:17	3	pass = 0 ;
water	34:9	0:0	4	pass
op	34:14	0:0	4	=
water	34:16	0:0	4	0
water	34:17	0:0	4	;
cond	34:19	34:31	3	pass <= vr -> maxpass
water	34:19	0:0	4	pass
op	34:24	0:0	4	<=
water	34:27	0:0	4	vr
op	34:29	0:0	4	->
water	34:31	0:0	4	maxpass
forexpr	34:40	34:42	3	++ pass
op	34:40	0:0	4	++
water	34:42	0:0	4	pass
stmts	34:48	144:4	3	
water	34:48	0:0	4	{
decl	35:8	35:29	4	uint_fast16_t	voffset
decl	36:8	36:37	4	uint_fast16_t	partition_count
decl	37:8	37:42	4	uint_fast16_t	j_times_ptns_to_read
water	39:8	0:0	4	voffset
op	39:16	0:0	4	=
water	39:18	0:0	4	vr
op	39:20	0:0	4	->
water	39:22	0:0	4	begin
water	39:27	0:0	4	;
for	40:8	143:8	4	(partition_count = 0 ;partition_count < ptns_to_read;)
forinit	40:13	40:32	5	partition_count = 0 ;
water	40:13	0:0	6	partition_count
op	40:29	0:0	6	=
water	40:31	0:0	6	0
water	40:32	0:0	6	;
cond	40:34	40:52	5	partition_count < ptns_to_read
water	40:34	0:0	6	partition_count
op	40:50	0:0	6	<
water	40:52	0:0	6	ptns_to_read
forexpr	0:0	0:0	5	
stmts	40:67	143:8	5	
water	40:67	0:0	6	{
if	41:12	62:12	6	(! pass)
cond	41:16	41:17	7	! pass
op	41:16	0:0	8	!
water	41:17	0:0	8	pass
stmts	41:23	62:12	7	
water	41:23	0:0	8	{
decl	42:16	42:77	8	uint_fast32_t	inverse_class
op	42:44	0:0	8	=
water	42:46	0:0	8	ff_inverse
op	42:56	0:0	8	[
water	42:57	0:0	8	vr
op	42:59	0:0	8	->
water	42:61	0:0	8	classifications
op	42:76	0:0	8	]
for	43:16	61:16	8	(j_times_ptns_to_read = 0 , j = 0 ;j < ch_used;++ j)
forinit	43:21	43:52	9	j_times_ptns_to_read = 0 , j = 0 ;
water	43:21	0:0	10	j_times_ptns_to_read
op	43:42	0:0	10	=
water	43:44	0:0	10	0
water	43:45	0:0	10	,
water	43:47	0:0	10	j
op	43:49	0:0	10	=
water	43:51	0:0	10	0
water	43:52	0:0	10	;
cond	43:54	43:58	9	j < ch_used
water	43:54	0:0	10	j
op	43:56	0:0	10	<
water	43:58	0:0	10	ch_used
forexpr	43:67	43:69	9	++ j
op	43:67	0:0	10	++
water	43:69	0:0	10	j
stmts	43:72	61:16	9	
water	43:72	0:0	10	{
if	44:20	59:20	10	(! do_not_decode [ j ])
cond	44:24	44:40	11	! do_not_decode [ j ]
op	44:24	0:0	12	!
water	44:25	0:0	12	do_not_decode
op	44:38	0:0	12	[
water	44:39	0:0	12	j
op	44:40	0:0	12	]
stmts	44:43	59:20	11	
water	44:43	0:0	12	{
decl	45:24	46:64	12	uint_fast32_t	temp
op	45:43	0:0	12	=
call	45:45	46:63	13	get_vlc2
arg	45:54	45:56	14	gb
water	45:54	0:0	15	gb
arg	45:58	45:96	14	vc->codebooks[vr->classbook].vlc.table
water	45:58	0:0	15	vc
op	45:60	0:0	15	->
water	45:62	0:0	15	codebooks
op	45:71	0:0	15	[
water	45:72	0:0	15	vr
op	45:74	0:0	15	->
water	45:76	0:0	15	classbook
op	45:85	0:0	15	]
op	45:86	0:0	15	.
water	45:87	0:0	15	vlc
op	45:90	0:0	15	.
water	45:91	0:0	15	table
arg	46:24	46:60	14	vc->codebooks[vr->classbook].nb_bits
water	46:24	0:0	15	vc
op	46:26	0:0	15	->
water	46:28	0:0	15	codebooks
op	46:37	0:0	15	[
water	46:38	0:0	15	vr
op	46:40	0:0	15	->
water	46:42	0:0	15	classbook
op	46:51	0:0	15	]
op	46:52	0:0	15	.
water	46:53	0:0	15	nb_bits
arg	46:62	46:63	14	3
water	46:62	0:0	15	3
call	48:24	48:57	12	AV_DEBUG
arg	48:33	48:51	13	"Classword: %d \n"
water	48:33	0:0	14	"Classword: %d \n"
arg	48:53	48:57	13	temp
water	48:53	0:0	14	temp
water	48:58	0:0	12	;
call	50:24	50:71	12	assert
arg	50:31	50:71	13	vr->classifications>1&&temp<=65536
water	50:31	0:0	14	vr
op	50:33	0:0	14	->
water	50:35	0:0	14	classifications
op	50:51	0:0	14	>
water	50:53	0:0	14	1
op	50:55	0:0	14	&&
water	50:58	0:0	14	temp
op	50:63	0:0	14	<=
water	50:66	0:0	14	65536
water	50:72	0:0	12	;
for	51:24	58:24	12	(i = 0 ;i < c_p_c;++ i)
forinit	51:29	51:34	13	i = 0 ;
water	51:29	0:0	14	i
op	51:31	0:0	14	=
water	51:33	0:0	14	0
water	51:34	0:0	14	;
cond	51:36	51:40	13	i < c_p_c
water	51:36	0:0	14	i
op	51:38	0:0	14	<
water	51:40	0:0	14	c_p_c
forexpr	51:47	51:49	13	++ i
op	51:47	0:0	14	++
water	51:49	0:0	14	i
stmts	51:52	58:24	13	
water	51:52	0:0	14	{
decl	52:28	52:47	14	uint_fast32_t	temp2
water	54:28	0:0	14	temp2
op	54:34	0:0	14	=
water	54:36	0:0	14	(
water	54:37	0:0	14	(
water	54:38	0:0	14	(
water	54:39	0:0	14	uint_fast64_t
water	54:52	0:0	14	)
water	54:53	0:0	14	temp
water	54:57	0:0	14	)
op	54:59	0:0	14	*
water	54:61	0:0	14	inverse_class
water	54:74	0:0	14	)
op	54:76	0:0	14	>>
water	54:79	0:0	14	32
water	54:81	0:0	14	;
if	55:28	56:133	14	(partition_count + c_p_c - 1 - i < ptns_to_read)
cond	55:32	55:66	15	partition_count + c_p_c - 1 - i < ptns_to_read
water	55:32	0:0	16	partition_count
op	55:48	0:0	16	+
water	55:50	0:0	16	c_p_c
op	55:56	0:0	16	-
water	55:58	0:0	16	1
op	55:60	0:0	16	-
water	55:62	0:0	16	i
op	55:64	0:0	16	<
water	55:66	0:0	16	ptns_to_read
stmts	56:32	56:133	15	
water	56:32	0:0	16	classifs
op	56:40	0:0	16	[
water	56:41	0:0	16	j_times_ptns_to_read
op	56:62	0:0	16	+
water	56:64	0:0	16	partition_count
op	56:80	0:0	16	+
water	56:82	0:0	16	c_p_c
op	56:88	0:0	16	-
water	56:90	0:0	16	1
op	56:92	0:0	16	-
water	56:94	0:0	16	i
op	56:95	0:0	16	]
op	56:97	0:0	16	=
water	56:99	0:0	16	temp
op	56:104	0:0	16	-
water	56:106	0:0	16	temp2
op	56:112	0:0	16	*
water	56:114	0:0	16	vr
op	56:116	0:0	16	->
water	56:118	0:0	16	classifications
water	56:133	0:0	16	;
water	57:28	0:0	14	temp
op	57:33	0:0	14	=
water	57:35	0:0	14	temp2
water	57:40	0:0	14	;
water	58:24	0:0	14	}
water	59:20	0:0	12	}
water	60:20	0:0	10	j_times_ptns_to_read
op	60:41	0:0	10	+=
water	60:44	0:0	10	ptns_to_read
water	60:56	0:0	10	;
water	61:16	0:0	10	}
water	62:12	0:0	8	}
for	63:12	142:12	6	(i = 0 ;( i < c_p_c ) && ( partition_count < ptns_to_read );++ i)
forinit	63:17	63:22	7	i = 0 ;
water	63:17	0:0	8	i
op	63:19	0:0	8	=
water	63:21	0:0	8	0
water	63:22	0:0	8	;
cond	63:24	63:70	7	( i < c_p_c ) && ( partition_count < ptns_to_read )
water	63:24	0:0	8	(
water	63:25	0:0	8	i
op	63:27	0:0	8	<
water	63:29	0:0	8	c_p_c
water	63:34	0:0	8	)
op	63:36	0:0	8	&&
water	63:39	0:0	8	(
water	63:40	0:0	8	partition_count
op	63:56	0:0	8	<
water	63:58	0:0	8	ptns_to_read
water	63:70	0:0	8	)
forexpr	63:73	63:75	7	++ i
op	63:73	0:0	8	++
water	63:75	0:0	8	i
stmts	63:78	142:12	7	
water	63:78	0:0	8	{
for	64:16	139:16	8	(j_times_ptns_to_read = 0 , j = 0 ;j < ch_used;++ j)
forinit	64:21	64:52	9	j_times_ptns_to_read = 0 , j = 0 ;
water	64:21	0:0	10	j_times_ptns_to_read
op	64:42	0:0	10	=
water	64:44	0:0	10	0
water	64:45	0:0	10	,
water	64:47	0:0	10	j
op	64:49	0:0	10	=
water	64:51	0:0	10	0
water	64:52	0:0	10	;
cond	64:54	64:58	9	j < ch_used
water	64:54	0:0	10	j
op	64:56	0:0	10	<
water	64:58	0:0	10	ch_used
forexpr	64:67	64:69	9	++ j
op	64:67	0:0	10	++
water	64:69	0:0	10	j
stmts	64:72	139:16	9	
water	64:72	0:0	10	{
decl	65:20	65:39	10	uint_fast16_t	voffs
if	67:20	137:20	10	(! do_not_decode [ j ])
cond	67:24	67:40	11	! do_not_decode [ j ]
op	67:24	0:0	12	!
water	67:25	0:0	12	do_not_decode
op	67:38	0:0	12	[
water	67:39	0:0	12	j
op	67:40	0:0	12	]
stmts	67:43	137:20	11	
water	67:43	0:0	12	{
decl	68:24	68:93	12	uint_fast8_t	vqclass
op	68:45	0:0	12	=
water	68:47	0:0	12	classifs
op	68:55	0:0	12	[
water	68:56	0:0	12	j_times_ptns_to_read
op	68:76	0:0	12	+
water	68:77	0:0	12	partition_count
op	68:92	0:0	12	]
decl	69:24	69:70	12	int_fast16_t	vqbook
op	69:44	0:0	12	=
water	69:46	0:0	12	vr
op	69:48	0:0	12	->
water	69:50	0:0	12	books
op	69:55	0:0	12	[
water	69:56	0:0	12	vqclass
op	69:63	0:0	12	]
op	69:64	0:0	12	[
water	69:65	0:0	12	pass
op	69:69	0:0	12	]
if	71:24	136:24	12	(vqbook >= 0 && vc -> codebooks [ vqbook ] . codevectors)
cond	71:28	71:65	13	vqbook >= 0 && vc -> codebooks [ vqbook ] . codevectors
water	71:28	0:0	14	vqbook
op	71:35	0:0	14	>=
water	71:38	0:0	14	0
op	71:40	0:0	14	&&
water	71:43	0:0	14	vc
op	71:45	0:0	14	->
water	71:47	0:0	14	codebooks
op	71:56	0:0	14	[
water	71:57	0:0	14	vqbook
op	71:63	0:0	14	]
op	71:64	0:0	14	.
water	71:65	0:0	14	codevectors
stmts	71:78	136:24	13	
water	71:78	0:0	14	{
decl	72:28	72:47	14	uint_fast16_t	coffs
water	73:28	0:0	14	unsigned
water	73:37	0:0	14	dim
op	73:41	0:0	14	=
water	73:44	0:0	14	vc
op	73:46	0:0	14	->
water	73:48	0:0	14	codebooks
op	73:57	0:0	14	[
water	73:58	0:0	14	vqbook
op	73:64	0:0	14	]
op	73:65	0:0	14	.
water	73:66	0:0	14	dimensions
water	73:76	0:0	14	;
decl	74:28	75:92	14	uint_fast16_t	step
op	74:47	0:0	14	=
water	74:49	0:0	14	dim
op	74:53	0:0	14	==
water	74:56	0:0	14	1
water	74:58	0:0	14	?
water	74:60	0:0	14	vr
op	74:62	0:0	14	->
water	74:64	0:0	14	partition_size
water	75:58	0:0	14	:
call	75:60	75:91	15	FASTDIV
arg	75:68	75:86	16	vr->partition_size
water	75:68	0:0	17	vr
op	75:70	0:0	17	->
water	75:72	0:0	17	partition_size
arg	75:88	75:91	16	dim
water	75:88	0:0	17	dim
decl	76:28	76:76	14	vorbis_codebook	codebook
op	76:53	0:0	14	=
water	76:55	0:0	14	vc
op	76:57	0:0	14	->
water	76:59	0:0	14	codebooks
op	76:68	0:0	14	[
water	76:69	0:0	14	vqbook
op	76:75	0:0	14	]
if	78:28	86:28	14	(vr_type == 0)
cond	78:32	78:43	15	vr_type == 0
water	78:32	0:0	16	vr_type
op	78:40	0:0	16	==
water	78:43	0:0	16	0
stmts	78:46	86:28	15	
water	78:46	0:0	16	{
water	80:32	0:0	16	voffs
op	80:38	0:0	16	=
water	80:40	0:0	16	voffset
op	80:47	0:0	16	+
water	80:48	0:0	16	j
op	80:49	0:0	16	*
water	80:50	0:0	16	vlen
water	80:54	0:0	16	;
for	81:32	85:32	16	(k = 0 ;k < step;++ k)
forinit	81:37	81:42	17	k = 0 ;
water	81:37	0:0	18	k
op	81:39	0:0	18	=
water	81:41	0:0	18	0
water	81:42	0:0	18	;
cond	81:44	81:48	17	k < step
water	81:44	0:0	18	k
op	81:46	0:0	18	<
water	81:48	0:0	18	step
forexpr	81:54	81:56	17	++ k
op	81:54	0:0	18	++
water	81:56	0:0	18	k
stmts	81:59	85:32	17	
water	81:59	0:0	18	{
water	82:36	0:0	18	coffs
op	82:42	0:0	18	=
call	82:44	82:96	18	get_vlc2
arg	82:53	82:55	19	gb
water	82:53	0:0	20	gb
arg	82:57	82:75	19	codebook.vlc.table
water	82:57	0:0	20	codebook
op	82:65	0:0	20	.
water	82:66	0:0	20	vlc
op	82:69	0:0	20	.
water	82:70	0:0	20	table
arg	82:77	82:93	19	codebook.nb_bits
water	82:77	0:0	20	codebook
op	82:85	0:0	20	.
water	82:86	0:0	20	nb_bits
arg	82:95	82:96	19	3
water	82:95	0:0	20	3
op	82:98	0:0	18	*
water	82:100	0:0	18	dim
water	82:103	0:0	18	;
for	83:36	84:100	18	(l = 0 ;l < dim;++ l)
forinit	83:41	83:46	19	l = 0 ;
water	83:41	0:0	20	l
op	83:43	0:0	20	=
water	83:45	0:0	20	0
water	83:46	0:0	20	;
cond	83:48	83:52	19	l < dim
water	83:48	0:0	20	l
op	83:50	0:0	20	<
water	83:52	0:0	20	dim
forexpr	83:57	83:59	19	++ l
op	83:57	0:0	20	++
water	83:59	0:0	20	l
stmts	84:40	84:100	19	
water	84:40	0:0	20	vec
op	84:43	0:0	20	[
water	84:44	0:0	20	voffs
op	84:50	0:0	20	+
water	84:52	0:0	20	k
op	84:54	0:0	20	+
water	84:56	0:0	20	l
op	84:58	0:0	20	*
water	84:60	0:0	20	step
op	84:64	0:0	20	]
op	84:66	0:0	20	+=
water	84:69	0:0	20	codebook
op	84:77	0:0	20	.
water	84:78	0:0	20	codevectors
op	84:89	0:0	20	[
water	84:90	0:0	20	coffs
op	84:96	0:0	20	+
water	84:98	0:0	20	l
op	84:99	0:0	20	]
water	84:100	0:0	20	;
water	85:32	0:0	18	}
water	86:28	0:0	16	}
else	86:30	96:28	14
stmts	86:35	96:28	15	
if	86:35	96:28	16	(vr_type == 1)
cond	86:39	86:50	17	vr_type == 1
water	86:39	0:0	18	vr_type
op	86:47	0:0	18	==
water	86:50	0:0	18	1
stmts	86:53	96:28	17	
water	86:53	0:0	18	{
water	87:32	0:0	18	voffs
op	87:38	0:0	18	=
water	87:40	0:0	18	voffset
op	87:48	0:0	18	+
water	87:50	0:0	18	j
op	87:52	0:0	18	*
water	87:54	0:0	18	vlen
water	87:58	0:0	18	;
for	88:32	95:32	18	(k = 0 ;k < step;++ k)
forinit	88:37	88:42	19	k = 0 ;
water	88:37	0:0	20	k
op	88:39	0:0	20	=
water	88:41	0:0	20	0
water	88:42	0:0	20	;
cond	88:44	88:48	19	k < step
water	88:44	0:0	20	k
op	88:46	0:0	20	<
water	88:48	0:0	20	step
forexpr	88:54	88:56	19	++ k
op	88:54	0:0	20	++
water	88:56	0:0	20	k
stmts	88:59	95:32	19	
water	88:59	0:0	20	{
water	89:36	0:0	20	coffs
op	89:42	0:0	20	=
call	89:44	89:96	20	get_vlc2
arg	89:53	89:55	21	gb
water	89:53	0:0	22	gb
arg	89:57	89:75	21	codebook.vlc.table
water	89:57	0:0	22	codebook
op	89:65	0:0	22	.
water	89:66	0:0	22	vlc
op	89:69	0:0	22	.
water	89:70	0:0	22	table
arg	89:77	89:93	21	codebook.nb_bits
water	89:77	0:0	22	codebook
op	89:85	0:0	22	.
water	89:86	0:0	22	nb_bits
arg	89:95	89:96	21	3
water	89:95	0:0	22	3
op	89:98	0:0	20	*
water	89:100	0:0	20	dim
water	89:103	0:0	20	;
for	90:36	94:36	20	(l = 0 ;l < dim;++ l , ++ voffs)
forinit	90:41	90:46	21	l = 0 ;
water	90:41	0:0	22	l
op	90:43	0:0	22	=
water	90:45	0:0	22	0
water	90:46	0:0	22	;
cond	90:48	90:52	21	l < dim
water	90:48	0:0	22	l
op	90:50	0:0	22	<
water	90:52	0:0	22	dim
forexpr	90:57	90:64	21	++ l , ++ voffs
op	90:57	0:0	22	++
water	90:59	0:0	22	l
water	90:60	0:0	22	,
op	90:62	0:0	22	++
water	90:64	0:0	22	voffs
stmts	90:71	94:36	21	
water	90:71	0:0	22	{
water	91:40	0:0	22	vec
op	91:43	0:0	22	[
water	91:44	0:0	22	voffs
op	91:49	0:0	22	]
op	91:50	0:0	22	+=
water	91:52	0:0	22	codebook
op	91:60	0:0	22	.
water	91:61	0:0	22	codevectors
op	91:72	0:0	22	[
water	91:73	0:0	22	coffs
op	91:78	0:0	22	+
water	91:79	0:0	22	l
op	91:80	0:0	22	]
water	91:81	0:0	22	;
call	93:40	93:168	22	AV_DEBUG
arg	93:49	93:105	23	" pass %d offs: %d curr: %f change: %f cv offs.: %d  \n"
water	93:49	0:0	24	" pass %d offs: %d curr: %f change: %f cv offs.: %d  \n"
arg	93:107	93:111	23	pass
water	93:107	0:0	24	pass
arg	93:113	93:118	23	voffs
water	93:113	0:0	24	voffs
arg	93:120	93:130	23	vec[voffs]
water	93:120	0:0	24	vec
op	93:123	0:0	24	[
water	93:124	0:0	24	voffs
op	93:129	0:0	24	]
arg	93:132	93:161	23	codebook.codevectors[coffs+l]
water	93:132	0:0	24	codebook
op	93:140	0:0	24	.
water	93:141	0:0	24	codevectors
op	93:152	0:0	24	[
water	93:153	0:0	24	coffs
op	93:158	0:0	24	+
water	93:159	0:0	24	l
op	93:160	0:0	24	]
arg	93:163	93:168	23	coffs
water	93:163	0:0	24	coffs
water	93:169	0:0	22	;
water	94:36	0:0	22	}
water	95:32	0:0	20	}
water	96:28	0:0	18	}
else	96:30	124:28	14
stmts	96:35	124:28	15	
if	96:35	124:28	16	(vr_type == 2 && ch == 2 && ( voffset & 1 ) == 0 && ( dim & 1 ) == 0)
cond	96:39	96:101	17	vr_type == 2 && ch == 2 && ( voffset & 1 ) == 0 && ( dim & 1 ) == 0
water	96:39	0:0	18	vr_type
op	96:47	0:0	18	==
water	96:50	0:0	18	2
op	96:52	0:0	18	&&
water	96:55	0:0	18	ch
op	96:58	0:0	18	==
water	96:61	0:0	18	2
op	96:63	0:0	18	&&
water	96:66	0:0	18	(
water	96:67	0:0	18	voffset
op	96:75	0:0	18	&
water	96:77	0:0	18	1
water	96:78	0:0	18	)
op	96:80	0:0	18	==
water	96:83	0:0	18	0
op	96:85	0:0	18	&&
water	96:88	0:0	18	(
water	96:89	0:0	18	dim
op	96:93	0:0	18	&
water	96:95	0:0	18	1
water	96:96	0:0	18	)
op	96:98	0:0	18	==
water	96:101	0:0	18	0
stmts	96:104	124:28	17	
water	96:104	0:0	18	{
water	97:32	0:0	18	voffs
op	97:38	0:0	18	=
water	97:40	0:0	18	voffset
op	97:48	0:0	18	>>
water	97:51	0:0	18	1
water	97:52	0:0	18	;
if	99:32	105:32	18	(dim == 2)
cond	99:36	99:43	19	dim == 2
water	99:36	0:0	20	dim
op	99:40	0:0	20	==
water	99:43	0:0	20	2
stmts	99:46	105:32	19	
water	99:46	0:0	20	{
for	100:36	104:36	20	(k = 0 ;k < step;++ k)
forinit	100:41	100:46	21	k = 0 ;
water	100:41	0:0	22	k
op	100:43	0:0	22	=
water	100:45	0:0	22	0
water	100:46	0:0	22	;
cond	100:48	100:52	21	k < step
water	100:48	0:0	22	k
op	100:50	0:0	22	<
water	100:52	0:0	22	step
forexpr	100:58	100:60	21	++ k
op	100:58	0:0	22	++
water	100:60	0:0	22	k
stmts	100:63	104:36	21	
water	100:63	0:0	22	{
water	101:40	0:0	22	coffs
op	101:46	0:0	22	=
call	101:48	101:100	22	get_vlc2
arg	101:57	101:59	23	gb
water	101:57	0:0	24	gb
arg	101:61	101:79	23	codebook.vlc.table
water	101:61	0:0	24	codebook
op	101:69	0:0	24	.
water	101:70	0:0	24	vlc
op	101:73	0:0	24	.
water	101:74	0:0	24	table
arg	101:81	101:97	23	codebook.nb_bits
water	101:81	0:0	24	codebook
op	101:89	0:0	24	.
water	101:90	0:0	24	nb_bits
arg	101:99	101:100	23	3
water	101:99	0:0	24	3
op	101:102	0:0	22	*
water	101:104	0:0	22	2
water	101:105	0:0	22	;
water	102:40	0:0	22	vec
op	102:43	0:0	22	[
water	102:44	0:0	22	voffs
op	102:50	0:0	22	+
water	102:52	0:0	22	k
op	102:60	0:0	22	]
op	102:62	0:0	22	+=
water	102:65	0:0	22	codebook
op	102:73	0:0	22	.
water	102:74	0:0	22	codevectors
op	102:85	0:0	22	[
water	102:86	0:0	22	coffs
op	102:95	0:0	22	]
water	102:96	0:0	22	;
water	103:40	0:0	22	vec
op	103:43	0:0	22	[
water	103:44	0:0	22	voffs
op	103:50	0:0	22	+
water	103:52	0:0	22	k
op	103:54	0:0	22	+
water	103:56	0:0	22	vlen
op	103:60	0:0	22	]
op	103:62	0:0	22	+=
water	103:65	0:0	22	codebook
op	103:73	0:0	22	.
water	103:74	0:0	22	codevectors
op	103:85	0:0	22	[
water	103:86	0:0	22	coffs
op	103:92	0:0	22	+
water	103:94	0:0	22	1
op	103:95	0:0	22	]
water	103:96	0:0	22	;
water	104:36	0:0	22	}
water	105:32	0:0	20	}
else	105:34	113:32	18
stmts	105:39	113:32	19	
if	105:39	113:32	20	(dim == 4)
cond	105:43	105:50	21	dim == 4
water	105:43	0:0	22	dim
op	105:47	0:0	22	==
water	105:50	0:0	22	4
stmts	105:53	113:32	21	
water	105:53	0:0	22	{
for	106:36	112:36	22	(k = 0 ;k < step;++ k , voffs += 2)
forinit	106:41	106:46	23	k = 0 ;
water	106:41	0:0	24	k
op	106:43	0:0	24	=
water	106:45	0:0	24	0
water	106:46	0:0	24	;
cond	106:48	106:52	23	k < step
water	106:48	0:0	24	k
op	106:50	0:0	24	<
water	106:52	0:0	24	step
forexpr	106:58	106:72	23	++ k , voffs += 2
op	106:58	0:0	24	++
water	106:60	0:0	24	k
water	106:61	0:0	24	,
water	106:63	0:0	24	voffs
op	106:69	0:0	24	+=
water	106:72	0:0	24	2
stmts	106:75	112:36	23	
water	106:75	0:0	24	{
water	107:40	0:0	24	coffs
op	107:46	0:0	24	=
call	107:48	107:100	24	get_vlc2
arg	107:57	107:59	25	gb
water	107:57	0:0	26	gb
arg	107:61	107:79	25	codebook.vlc.table
water	107:61	0:0	26	codebook
op	107:69	0:0	26	.
water	107:70	0:0	26	vlc
op	107:73	0:0	26	.
water	107:74	0:0	26	table
arg	107:81	107:97	25	codebook.nb_bits
water	107:81	0:0	26	codebook
op	107:89	0:0	26	.
water	107:90	0:0	26	nb_bits
arg	107:99	107:100	25	3
water	107:99	0:0	26	3
op	107:102	0:0	24	*
water	107:104	0:0	24	4
water	107:105	0:0	24	;
water	108:40	0:0	24	vec
op	108:43	0:0	24	[
water	108:44	0:0	24	voffs
op	108:60	0:0	24	]
op	108:62	0:0	24	+=
water	108:65	0:0	24	codebook
op	108:73	0:0	24	.
water	108:74	0:0	24	codevectors
op	108:85	0:0	24	[
water	108:86	0:0	24	coffs
op	108:95	0:0	24	]
water	108:96	0:0	24	;
water	109:40	0:0	24	vec
op	109:43	0:0	24	[
water	109:44	0:0	24	voffs
op	109:50	0:0	24	+
water	109:52	0:0	24	1
op	109:60	0:0	24	]
op	109:62	0:0	24	+=
water	109:65	0:0	24	codebook
op	109:73	0:0	24	.
water	109:74	0:0	24	codevectors
op	109:85	0:0	24	[
water	109:86	0:0	24	coffs
op	109:92	0:0	24	+
water	109:94	0:0	24	2
op	109:95	0:0	24	]
water	109:96	0:0	24	;
water	110:40	0:0	24	vec
op	110:43	0:0	24	[
water	110:44	0:0	24	voffs
op	110:50	0:0	24	+
water	110:52	0:0	24	vlen
op	110:60	0:0	24	]
op	110:62	0:0	24	+=
water	110:65	0:0	24	codebook
op	110:73	0:0	24	.
water	110:74	0:0	24	codevectors
op	110:85	0:0	24	[
water	110:86	0:0	24	coffs
op	110:92	0:0	24	+
water	110:94	0:0	24	1
op	110:95	0:0	24	]
water	110:96	0:0	24	;
water	111:40	0:0	24	vec
op	111:43	0:0	24	[
water	111:44	0:0	24	voffs
op	111:50	0:0	24	+
water	111:52	0:0	24	vlen
op	111:57	0:0	24	+
water	111:59	0:0	24	1
op	111:60	0:0	24	]
op	111:62	0:0	24	+=
water	111:65	0:0	24	codebook
op	111:73	0:0	24	.
water	111:74	0:0	24	codevectors
op	111:85	0:0	24	[
water	111:86	0:0	24	coffs
op	111:92	0:0	24	+
water	111:94	0:0	24	3
op	111:95	0:0	24	]
water	111:96	0:0	24	;
water	112:36	0:0	24	}
water	113:32	0:0	22	}
else	113:34	122:32	18
stmts	114:32	122:32	19	
for	114:32	122:32	20	(k = 0 ;k < step;++ k)
forinit	114:37	114:42	21	k = 0 ;
water	114:37	0:0	22	k
op	114:39	0:0	22	=
water	114:41	0:0	22	0
water	114:42	0:0	22	;
cond	114:44	114:48	21	k < step
water	114:44	0:0	22	k
op	114:46	0:0	22	<
water	114:48	0:0	22	step
forexpr	114:54	114:56	21	++ k
op	114:54	0:0	22	++
water	114:56	0:0	22	k
stmts	114:59	122:32	21	
water	114:59	0:0	22	{
water	115:36	0:0	22	coffs
op	115:42	0:0	22	=
call	115:44	115:96	22	get_vlc2
arg	115:53	115:55	23	gb
water	115:53	0:0	24	gb
arg	115:57	115:75	23	codebook.vlc.table
water	115:57	0:0	24	codebook
op	115:65	0:0	24	.
water	115:66	0:0	24	vlc
op	115:69	0:0	24	.
water	115:70	0:0	24	table
arg	115:77	115:93	23	codebook.nb_bits
water	115:77	0:0	24	codebook
op	115:85	0:0	24	.
water	115:86	0:0	24	nb_bits
arg	115:95	115:96	23	3
water	115:95	0:0	24	3
op	115:98	0:0	22	*
water	115:100	0:0	22	dim
water	115:103	0:0	22	;
for	116:36	121:36	22	(l = 0 ;l < dim;l += 2 , voffs ++)
forinit	116:41	116:46	23	l = 0 ;
water	116:41	0:0	24	l
op	116:43	0:0	24	=
water	116:45	0:0	24	0
water	116:46	0:0	24	;
cond	116:48	116:52	23	l < dim
water	116:48	0:0	24	l
op	116:50	0:0	24	<
water	116:52	0:0	24	dim
forexpr	116:57	116:70	23	l += 2 , voffs ++
water	116:57	0:0	24	l
op	116:59	0:0	24	+=
water	116:62	0:0	24	2
water	116:63	0:0	24	,
water	116:65	0:0	24	voffs
op	116:70	0:0	24	++
stmts	116:74	121:36	23	
water	116:74	0:0	24	{
water	117:40	0:0	24	vec
op	117:43	0:0	24	[
water	117:44	0:0	24	voffs
op	117:56	0:0	24	]
op	117:58	0:0	24	+=
water	117:61	0:0	24	codebook
op	117:69	0:0	24	.
water	117:70	0:0	24	codevectors
op	117:81	0:0	24	[
water	117:82	0:0	24	coffs
op	117:88	0:0	24	+
water	117:90	0:0	24	l
op	117:95	0:0	24	]
water	117:96	0:0	24	;
water	118:40	0:0	24	vec
op	118:43	0:0	24	[
water	118:44	0:0	24	voffs
op	118:50	0:0	24	+
water	118:52	0:0	24	vlen
op	118:56	0:0	24	]
op	118:58	0:0	24	+=
water	118:61	0:0	24	codebook
op	118:69	0:0	24	.
water	118:70	0:0	24	codevectors
op	118:81	0:0	24	[
water	118:82	0:0	24	coffs
op	118:88	0:0	24	+
water	118:90	0:0	24	l
op	118:92	0:0	24	+
water	118:94	0:0	24	1
op	118:95	0:0	24	]
water	118:96	0:0	24	;
call	120:40	120:234	24	AV_DEBUG
arg	120:49	120:108	25	" pass %d offs: %d curr: %f change: %f cv offs.: %d+%d  \n"
water	120:49	0:0	26	" pass %d offs: %d curr: %f change: %f cv offs.: %d+%d  \n"
arg	120:110	120:114	25	pass
water	120:110	0:0	26	pass
arg	120:116	120:150	25	voffset/ch+(voffs%ch)*vlen
water	120:116	0:0	26	voffset
op	120:124	0:0	26	/
water	120:126	0:0	26	ch
op	120:129	0:0	26	+
water	120:131	0:0	26	(
water	120:132	0:0	26	voffs
op	120:138	0:0	26	%
water	120:140	0:0	26	ch
water	120:142	0:0	26	)
op	120:144	0:0	26	*
water	120:146	0:0	26	vlen
arg	120:152	120:191	25	vec[voffset/ch+(voffs%ch)*vlen]
water	120:152	0:0	26	vec
op	120:155	0:0	26	[
water	120:156	0:0	26	voffset
op	120:164	0:0	26	/
water	120:166	0:0	26	ch
op	120:169	0:0	26	+
water	120:171	0:0	26	(
water	120:172	0:0	26	voffs
op	120:178	0:0	26	%
water	120:180	0:0	26	ch
water	120:182	0:0	26	)
op	120:184	0:0	26	*
water	120:186	0:0	26	vlen
op	120:190	0:0	26	]
arg	120:193	120:224	25	codebook.codevectors[coffs+l]
water	120:193	0:0	26	codebook
op	120:201	0:0	26	.
water	120:202	0:0	26	codevectors
op	120:213	0:0	26	[
water	120:214	0:0	26	coffs
op	120:220	0:0	26	+
water	120:222	0:0	26	l
op	120:223	0:0	26	]
arg	120:226	120:231	25	coffs
water	120:226	0:0	26	coffs
arg	120:233	120:234	25	l
water	120:233	0:0	26	l
water	120:235	0:0	24	;
water	121:36	0:0	24	}
water	122:32	0:0	22	}
water	124:28	0:0	18	}
else	124:30	135:28	14
stmts	124:35	135:28	15	
if	124:35	135:28	16	(vr_type == 2)
cond	124:39	124:50	17	vr_type == 2
water	124:39	0:0	18	vr_type
op	124:47	0:0	18	==
water	124:50	0:0	18	2
stmts	124:53	135:28	17	
water	124:53	0:0	18	{
water	125:32	0:0	18	voffs
op	125:38	0:0	18	=
water	125:40	0:0	18	voffset
water	125:47	0:0	18	;
for	127:32	134:32	18	(k = 0 ;k < step;++ k)
forinit	127:37	127:42	19	k = 0 ;
water	127:37	0:0	20	k
op	127:39	0:0	20	=
water	127:41	0:0	20	0
water	127:42	0:0	20	;
cond	127:44	127:48	19	k < step
water	127:44	0:0	20	k
op	127:46	0:0	20	<
water	127:48	0:0	20	step
forexpr	127:54	127:56	19	++ k
op	127:54	0:0	20	++
water	127:56	0:0	20	k
stmts	127:59	134:32	19	
water	127:59	0:0	20	{
water	128:36	0:0	20	coffs
op	128:42	0:0	20	=
call	128:44	128:96	20	get_vlc2
arg	128:53	128:55	21	gb
water	128:53	0:0	22	gb
arg	128:57	128:75	21	codebook.vlc.table
water	128:57	0:0	22	codebook
op	128:65	0:0	22	.
water	128:66	0:0	22	vlc
op	128:69	0:0	22	.
water	128:70	0:0	22	table
arg	128:77	128:93	21	codebook.nb_bits
water	128:77	0:0	22	codebook
op	128:85	0:0	22	.
water	128:86	0:0	22	nb_bits
arg	128:95	128:96	21	3
water	128:95	0:0	22	3
op	128:98	0:0	20	*
water	128:100	0:0	20	dim
water	128:103	0:0	20	;
for	129:36	133:36	20	(l = 0 ;l < dim;++ l , ++ voffs)
forinit	129:41	129:46	21	l = 0 ;
water	129:41	0:0	22	l
op	129:43	0:0	22	=
water	129:45	0:0	22	0
water	129:46	0:0	22	;
cond	129:48	129:52	21	l < dim
water	129:48	0:0	22	l
op	129:50	0:0	22	<
water	129:52	0:0	22	dim
forexpr	129:57	129:64	21	++ l , ++ voffs
op	129:57	0:0	22	++
water	129:59	0:0	22	l
water	129:60	0:0	22	,
op	129:62	0:0	22	++
water	129:64	0:0	22	voffs
stmts	129:71	133:36	21	
water	129:71	0:0	22	{
water	130:40	0:0	22	vec
op	130:43	0:0	22	[
water	130:44	0:0	22	voffs
op	130:50	0:0	22	/
water	130:52	0:0	22	ch
op	130:55	0:0	22	+
water	130:57	0:0	22	(
water	130:58	0:0	22	voffs
op	130:64	0:0	22	%
water	130:66	0:0	22	ch
water	130:68	0:0	22	)
op	130:70	0:0	22	*
water	130:72	0:0	22	vlen
op	130:76	0:0	22	]
op	130:78	0:0	22	+=
water	130:81	0:0	22	codebook
op	130:89	0:0	22	.
water	130:90	0:0	22	codevectors
op	130:101	0:0	22	[
water	130:102	0:0	22	coffs
op	130:108	0:0	22	+
water	130:110	0:0	22	l
op	130:111	0:0	22	]
water	130:112	0:0	22	;
call	132:40	132:234	22	AV_DEBUG
arg	132:49	132:108	23	" pass %d offs: %d curr: %f change: %f cv offs.: %d+%d  \n"
water	132:49	0:0	24	" pass %d offs: %d curr: %f change: %f cv offs.: %d+%d  \n"
arg	132:110	132:114	23	pass
water	132:110	0:0	24	pass
arg	132:116	132:150	23	voffset/ch+(voffs%ch)*vlen
water	132:116	0:0	24	voffset
op	132:124	0:0	24	/
water	132:126	0:0	24	ch
op	132:129	0:0	24	+
water	132:131	0:0	24	(
water	132:132	0:0	24	voffs
op	132:138	0:0	24	%
water	132:140	0:0	24	ch
water	132:142	0:0	24	)
op	132:144	0:0	24	*
water	132:146	0:0	24	vlen
arg	132:152	132:191	23	vec[voffset/ch+(voffs%ch)*vlen]
water	132:152	0:0	24	vec
op	132:155	0:0	24	[
water	132:156	0:0	24	voffset
op	132:164	0:0	24	/
water	132:166	0:0	24	ch
op	132:169	0:0	24	+
water	132:171	0:0	24	(
water	132:172	0:0	24	voffs
op	132:178	0:0	24	%
water	132:180	0:0	24	ch
water	132:182	0:0	24	)
op	132:184	0:0	24	*
water	132:186	0:0	24	vlen
op	132:190	0:0	24	]
arg	132:193	132:224	23	codebook.codevectors[coffs+l]
water	132:193	0:0	24	codebook
op	132:201	0:0	24	.
water	132:202	0:0	24	codevectors
op	132:213	0:0	24	[
water	132:214	0:0	24	coffs
op	132:220	0:0	24	+
water	132:222	0:0	24	l
op	132:223	0:0	24	]
arg	132:226	132:231	23	coffs
water	132:226	0:0	24	coffs
arg	132:233	132:234	23	l
water	132:233	0:0	24	l
water	132:235	0:0	22	;
water	133:36	0:0	22	}
water	134:32	0:0	20	}
water	135:28	0:0	18	}
water	136:24	0:0	14	}
water	137:20	0:0	12	}
water	138:20	0:0	10	j_times_ptns_to_read
op	138:41	0:0	10	+=
water	138:44	0:0	10	ptns_to_read
water	138:56	0:0	10	;
water	139:16	0:0	10	}
op	140:16	0:0	8	++
water	140:18	0:0	8	partition_count
water	140:33	0:0	8	;
water	141:16	0:0	8	voffset
op	141:24	0:0	8	+=
water	141:27	0:0	8	vr
op	141:29	0:0	8	->
water	141:31	0:0	8	partition_size
water	141:45	0:0	8	;
water	142:12	0:0	8	}
water	143:8	0:0	6	}
water	144:4	0:0	4	}
return	145:4	145:12	2	0
water	145:11	0:0	3	0
