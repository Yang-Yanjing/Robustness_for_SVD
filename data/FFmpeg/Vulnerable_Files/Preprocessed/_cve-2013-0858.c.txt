func	8:15	172:0	0	int	atrac3_decode_init
params	8:37	0:0	1	
param	8:38	8:59	2	AVCodecContext *	avctx
stmnts	0:0	171:12	1	
decl	10:4	10:14	2	int	i
water	10:9	0:0	2	,
decl	10:4	10:14	2	int	ret
decl	11:4	11:47	2	const uint8_t	*edata_ptr
op	11:29	0:0	2	=
water	11:31	0:0	2	avctx
op	11:36	0:0	2	->
water	11:38	0:0	2	extradata
decl	12:4	12:39	2	ATRAC3Context	*q
op	12:21	0:0	2	=
water	12:23	0:0	2	avctx
op	12:28	0:0	2	->
water	12:30	0:0	2	priv_data
water	13:4	0:0	2	static
water	13:11	0:0	2	VLC_TYPE
water	13:20	0:0	2	atrac3_vlc_table
op	13:36	0:0	2	[
water	13:37	0:0	2	4096
op	13:41	0:0	2	]
op	13:42	0:0	2	[
water	13:43	0:0	2	2
op	13:44	0:0	2	]
water	13:45	0:0	2	;
water	14:4	0:0	2	static
water	14:11	0:0	2	int
water	14:15	0:0	2	vlcs_initialized
op	14:32	0:0	2	=
water	14:34	0:0	2	0
water	14:35	0:0	2	;
water	17:4	0:0	2	q
op	17:5	0:0	2	->
water	17:7	0:0	2	sample_rate
op	17:19	0:0	2	=
water	17:21	0:0	2	avctx
op	17:26	0:0	2	->
water	17:28	0:0	2	sample_rate
water	17:39	0:0	2	;
water	18:4	0:0	2	q
op	18:5	0:0	2	->
water	18:7	0:0	2	channels
op	18:16	0:0	2	=
water	18:18	0:0	2	avctx
op	18:23	0:0	2	->
water	18:25	0:0	2	channels
water	18:33	0:0	2	;
water	19:4	0:0	2	q
op	19:5	0:0	2	->
water	19:7	0:0	2	bit_rate
op	19:16	0:0	2	=
water	19:18	0:0	2	avctx
op	19:23	0:0	2	->
water	19:25	0:0	2	bit_rate
water	19:33	0:0	2	;
water	20:4	0:0	2	q
op	20:5	0:0	2	->
water	20:7	0:0	2	bits_per_frame
op	20:22	0:0	2	=
water	20:24	0:0	2	avctx
op	20:29	0:0	2	->
water	20:31	0:0	2	block_align
op	20:43	0:0	2	*
water	20:45	0:0	2	8
water	20:46	0:0	2	;
water	21:4	0:0	2	q
op	21:5	0:0	2	->
water	21:7	0:0	2	bytes_per_frame
op	21:23	0:0	2	=
water	21:25	0:0	2	avctx
op	21:30	0:0	2	->
water	21:32	0:0	2	block_align
water	21:43	0:0	2	;
if	24:4	50:4	2	(avctx -> extradata_size == 14)
cond	24:8	24:33	3	avctx -> extradata_size == 14
water	24:8	0:0	4	avctx
op	24:13	0:0	4	->
water	24:15	0:0	4	extradata_size
op	24:30	0:0	4	==
water	24:33	0:0	4	14
stmts	24:37	50:4	3	
water	24:37	0:0	4	{
call	26:8	26:78	4	av_log
arg	26:15	26:20	5	avctx
water	26:15	0:0	6	avctx
arg	26:21	26:33	5	AV_LOG_DEBUG
water	26:21	0:0	6	AV_LOG_DEBUG
arg	26:34	26:46	5	"[0-1] %d\n"
water	26:34	0:0	6	"[0-1] %d\n"
arg	26:47	26:78	5	bytestream_get_le16(&edata_ptr)
call	26:47	26:77	6	bytestream_get_le16
arg	26:67	26:77	7	&edata_ptr
op	26:67	0:0	8	&
water	26:68	0:0	8	edata_ptr
water	26:79	0:0	4	;
water	27:8	0:0	4	q
op	27:9	0:0	4	->
water	27:11	0:0	4	samples_per_channel
op	27:31	0:0	4	=
call	27:33	27:63	4	bytestream_get_le32
arg	27:53	27:63	5	&edata_ptr
op	27:53	0:0	6	&
water	27:54	0:0	6	edata_ptr
water	27:64	0:0	4	;
water	28:8	0:0	4	q
op	28:9	0:0	4	->
water	28:11	0:0	4	codingMode
op	28:22	0:0	4	=
call	28:24	28:54	4	bytestream_get_le16
arg	28:44	28:54	5	&edata_ptr
op	28:44	0:0	6	&
water	28:45	0:0	6	edata_ptr
water	28:55	0:0	4	;
call	29:8	29:78	4	av_log
arg	29:15	29:20	5	avctx
water	29:15	0:0	6	avctx
arg	29:21	29:33	5	AV_LOG_DEBUG
water	29:21	0:0	6	AV_LOG_DEBUG
arg	29:34	29:46	5	"[8-9] %d\n"
water	29:34	0:0	6	"[8-9] %d\n"
arg	29:47	29:78	5	bytestream_get_le16(&edata_ptr)
call	29:47	29:77	6	bytestream_get_le16
arg	29:67	29:77	7	&edata_ptr
op	29:67	0:0	8	&
water	29:68	0:0	8	edata_ptr
water	29:79	0:0	4	;
water	30:8	0:0	4	q
op	30:9	0:0	4	->
water	30:11	0:0	4	frame_factor
op	30:24	0:0	4	=
call	30:26	30:56	4	bytestream_get_le16
arg	30:46	30:56	5	&edata_ptr
op	30:46	0:0	6	&
water	30:47	0:0	6	edata_ptr
water	30:57	0:0	4	;
call	31:8	31:80	4	av_log
arg	31:15	31:20	5	avctx
water	31:15	0:0	6	avctx
arg	31:21	31:33	5	AV_LOG_DEBUG
water	31:21	0:0	6	AV_LOG_DEBUG
arg	31:34	31:48	5	"[12-13] %d\n"
water	31:34	0:0	6	"[12-13] %d\n"
arg	31:49	31:80	5	bytestream_get_le16(&edata_ptr)
call	31:49	31:79	6	bytestream_get_le16
arg	31:69	31:79	7	&edata_ptr
op	31:69	0:0	8	&
water	31:70	0:0	8	edata_ptr
water	31:81	0:0	4	;
water	34:8	0:0	4	q
op	34:9	0:0	4	->
water	34:11	0:0	4	samples_per_frame
op	34:29	0:0	4	=
water	34:31	0:0	4	SAMPLES_PER_FRAME
op	34:49	0:0	4	*
water	34:51	0:0	4	q
op	34:52	0:0	4	->
water	34:54	0:0	4	channels
water	34:62	0:0	4	;
water	35:8	0:0	4	q
op	35:9	0:0	4	->
water	35:11	0:0	4	atrac3version
op	35:25	0:0	4	=
water	35:27	0:0	4	4
water	35:28	0:0	4	;
water	36:8	0:0	4	q
op	36:9	0:0	4	->
water	36:11	0:0	4	delay
op	36:17	0:0	4	=
water	36:19	0:0	4	0
water	36:20	0:0	4	x88E
water	36:24	0:0	4	;
if	37:8	38:40	4	(q -> codingMode)
cond	37:12	37:15	5	q -> codingMode
water	37:12	0:0	6	q
op	37:13	0:0	6	->
water	37:15	0:0	6	codingMode
stmts	38:12	38:40	5	
water	38:12	0:0	6	q
op	38:13	0:0	6	->
water	38:15	0:0	6	codingMode
op	38:26	0:0	6	=
water	38:28	0:0	6	JOINT_STEREO
water	38:40	0:0	6	;
else	39:8	40:34	4
stmts	40:12	40:34	5	
water	40:12	0:0	6	q
op	40:13	0:0	6	->
water	40:15	0:0	6	codingMode
op	40:26	0:0	6	=
water	40:28	0:0	6	STEREO
water	40:34	0:0	6	;
water	42:8	0:0	4	q
op	42:9	0:0	4	->
water	42:11	0:0	4	scrambled_stream
op	42:28	0:0	4	=
water	42:30	0:0	4	0
water	42:31	0:0	4	;
if	44:8	45:8	4	(( q -> bytes_per_frame == 96 * q -> channels * q -> frame_factor ) || ( q -> bytes_per_frame == 152 * q -> channels * q -> frame_factor ) || ( q -> bytes_per_frame == 192 * q -> channels * q -> frame_factor ))
cond	44:12	44:183	5	( q -> bytes_per_frame == 96 * q -> channels * q -> frame_factor ) || ( q -> bytes_per_frame == 152 * q -> channels * q -> frame_factor ) || ( q -> bytes_per_frame == 192 * q -> channels * q -> frame_factor )
water	44:12	0:0	6	(
water	44:13	0:0	6	q
op	44:14	0:0	6	->
water	44:16	0:0	6	bytes_per_frame
op	44:32	0:0	6	==
water	44:35	0:0	6	96
op	44:37	0:0	6	*
water	44:38	0:0	6	q
op	44:39	0:0	6	->
water	44:41	0:0	6	channels
op	44:49	0:0	6	*
water	44:50	0:0	6	q
op	44:51	0:0	6	->
water	44:53	0:0	6	frame_factor
water	44:65	0:0	6	)
op	44:67	0:0	6	||
water	44:70	0:0	6	(
water	44:71	0:0	6	q
op	44:72	0:0	6	->
water	44:74	0:0	6	bytes_per_frame
op	44:90	0:0	6	==
water	44:93	0:0	6	152
op	44:96	0:0	6	*
water	44:97	0:0	6	q
op	44:98	0:0	6	->
water	44:100	0:0	6	channels
op	44:108	0:0	6	*
water	44:109	0:0	6	q
op	44:110	0:0	6	->
water	44:112	0:0	6	frame_factor
water	44:124	0:0	6	)
op	44:126	0:0	6	||
water	44:129	0:0	6	(
water	44:130	0:0	6	q
op	44:131	0:0	6	->
water	44:133	0:0	6	bytes_per_frame
op	44:149	0:0	6	==
water	44:152	0:0	6	192
op	44:155	0:0	6	*
water	44:156	0:0	6	q
op	44:157	0:0	6	->
water	44:159	0:0	6	channels
op	44:167	0:0	6	*
water	44:168	0:0	6	q
op	44:169	0:0	6	->
water	44:171	0:0	6	frame_factor
water	44:183	0:0	6	)
stmts	44:186	45:8	5	
water	44:186	0:0	6	{
water	0:0	0:0	6	STATEMENTS
water	45:8	0:0	6	}
else	45:10	48:8	4
stmts	45:15	48:8	5	
water	45:15	0:0	6	{
call	46:12	46:149	6	av_log
arg	46:19	46:24	7	avctx
water	46:19	0:0	8	avctx
arg	46:25	46:37	7	AV_LOG_ERROR
water	46:25	0:0	8	AV_LOG_ERROR
arg	46:38	46:99	7	"Unknown frame/channel/frame_factor configuration %d/%d/%d\n"
water	46:38	0:0	8	"Unknown frame/channel/frame_factor configuration %d/%d/%d\n"
arg	46:101	46:119	7	q->bytes_per_frame
water	46:101	0:0	8	q
op	46:102	0:0	8	->
water	46:104	0:0	8	bytes_per_frame
arg	46:121	46:132	7	q->channels
water	46:121	0:0	8	q
op	46:122	0:0	8	->
water	46:124	0:0	8	channels
arg	46:134	46:149	7	q->frame_factor
water	46:134	0:0	8	q
op	46:135	0:0	8	->
water	46:137	0:0	8	frame_factor
water	46:150	0:0	6	;
return	47:12	47:38	6	AVERROR_INVALIDDATA
water	47:19	0:0	7	AVERROR_INVALIDDATA
water	48:8	0:0	6	}
water	50:4	0:0	4	}
else	50:6	60:4	2
stmts	50:11	60:4	3	
if	50:11	60:4	4	(avctx -> extradata_size == 10)
cond	50:15	50:40	5	avctx -> extradata_size == 10
water	50:15	0:0	6	avctx
op	50:20	0:0	6	->
water	50:22	0:0	6	extradata_size
op	50:37	0:0	6	==
water	50:40	0:0	6	10
stmts	50:44	60:4	5	
water	50:44	0:0	6	{
water	52:8	0:0	6	q
op	52:9	0:0	6	->
water	52:11	0:0	6	atrac3version
op	52:25	0:0	6	=
call	52:27	52:57	6	bytestream_get_be32
arg	52:47	52:57	7	&edata_ptr
op	52:47	0:0	8	&
water	52:48	0:0	8	edata_ptr
water	52:58	0:0	6	;
water	53:8	0:0	6	q
op	53:9	0:0	6	->
water	53:11	0:0	6	samples_per_frame
op	53:29	0:0	6	=
call	53:31	53:61	6	bytestream_get_be16
arg	53:51	53:61	7	&edata_ptr
op	53:51	0:0	8	&
water	53:52	0:0	8	edata_ptr
water	53:62	0:0	6	;
water	54:8	0:0	6	q
op	54:9	0:0	6	->
water	54:11	0:0	6	delay
op	54:17	0:0	6	=
call	54:19	54:49	6	bytestream_get_be16
arg	54:39	54:49	7	&edata_ptr
op	54:39	0:0	8	&
water	54:40	0:0	8	edata_ptr
water	54:50	0:0	6	;
water	55:8	0:0	6	q
op	55:9	0:0	6	->
water	55:11	0:0	6	codingMode
op	55:22	0:0	6	=
call	55:24	55:54	6	bytestream_get_be16
arg	55:44	55:54	7	&edata_ptr
op	55:44	0:0	8	&
water	55:45	0:0	8	edata_ptr
water	55:55	0:0	6	;
water	57:8	0:0	6	q
op	57:9	0:0	6	->
water	57:11	0:0	6	samples_per_channel
op	57:31	0:0	6	=
water	57:33	0:0	6	q
op	57:34	0:0	6	->
water	57:36	0:0	6	samples_per_frame
op	57:54	0:0	6	/
water	57:56	0:0	6	q
op	57:57	0:0	6	->
water	57:59	0:0	6	channels
water	57:67	0:0	6	;
water	58:8	0:0	6	q
op	58:9	0:0	6	->
water	58:11	0:0	6	scrambled_stream
op	58:28	0:0	6	=
water	58:30	0:0	6	1
water	58:31	0:0	6	;
water	60:4	0:0	6	}
else	60:6	62:4	2
stmts	60:11	62:4	3	
water	60:11	0:0	4	{
call	61:8	61:85	4	av_log
arg	61:15	61:19	5	NULL
water	61:15	0:0	6	NULL
arg	61:20	61:32	5	AV_LOG_ERROR
water	61:20	0:0	6	AV_LOG_ERROR
arg	61:33	61:63	5	"Unknown extradata size %d.\n"
water	61:33	0:0	6	"Unknown extradata size %d.\n"
arg	61:64	61:85	5	avctx->extradata_size
water	61:64	0:0	6	avctx
op	61:69	0:0	6	->
water	61:71	0:0	6	extradata_size
water	61:86	0:0	4	;
water	62:4	0:0	4	}
if	65:4	68:4	2	(q -> atrac3version != 4)
cond	65:8	65:28	3	q -> atrac3version != 4
water	65:8	0:0	4	q
op	65:9	0:0	4	->
water	65:11	0:0	4	atrac3version
op	65:25	0:0	4	!=
water	65:28	0:0	4	4
stmts	65:31	68:4	3	
water	65:31	0:0	4	{
call	66:8	66:71	4	av_log
arg	66:15	66:20	5	avctx
water	66:15	0:0	6	avctx
arg	66:21	66:33	5	AV_LOG_ERROR
water	66:21	0:0	6	AV_LOG_ERROR
arg	66:34	66:54	5	"Version %d != 4.\n"
water	66:34	0:0	6	"Version %d != 4.\n"
arg	66:55	66:71	5	q->atrac3version
water	66:55	0:0	6	q
op	66:56	0:0	6	->
water	66:58	0:0	6	atrac3version
water	66:72	0:0	4	;
return	67:8	67:34	4	AVERROR_INVALIDDATA
water	67:15	0:0	5	AVERROR_INVALIDDATA
water	68:4	0:0	4	}
if	70:4	73:4	2	(q -> samples_per_frame != SAMPLES_PER_FRAME && q -> samples_per_frame != SAMPLES_PER_FRAME * 2)
cond	70:8	70:95	3	q -> samples_per_frame != SAMPLES_PER_FRAME && q -> samples_per_frame != SAMPLES_PER_FRAME * 2
water	70:8	0:0	4	q
op	70:9	0:0	4	->
water	70:11	0:0	4	samples_per_frame
op	70:29	0:0	4	!=
water	70:32	0:0	4	SAMPLES_PER_FRAME
op	70:50	0:0	4	&&
water	70:53	0:0	4	q
op	70:54	0:0	4	->
water	70:56	0:0	4	samples_per_frame
op	70:74	0:0	4	!=
water	70:77	0:0	4	SAMPLES_PER_FRAME
op	70:94	0:0	4	*
water	70:95	0:0	4	2
stmts	70:98	73:4	3	
water	70:98	0:0	4	{
call	71:8	71:98	4	av_log
arg	71:15	71:20	5	avctx
water	71:15	0:0	6	avctx
arg	71:21	71:33	5	AV_LOG_ERROR
water	71:21	0:0	6	AV_LOG_ERROR
arg	71:34	71:77	5	"Unknown amount of samples per frame %d.\n"
water	71:34	0:0	6	"Unknown amount of samples per frame %d.\n"
arg	71:78	71:98	5	q->samples_per_frame
water	71:78	0:0	6	q
op	71:79	0:0	6	->
water	71:81	0:0	6	samples_per_frame
water	71:99	0:0	4	;
return	72:8	72:34	4	AVERROR_INVALIDDATA
water	72:15	0:0	5	AVERROR_INVALIDDATA
water	73:4	0:0	4	}
if	75:4	78:4	2	(q -> delay != 0 x88E)
cond	75:8	75:21	3	q -> delay != 0 x88E
water	75:8	0:0	4	q
op	75:9	0:0	4	->
water	75:11	0:0	4	delay
op	75:17	0:0	4	!=
water	75:20	0:0	4	0
water	75:21	0:0	4	x88E
stmts	75:27	78:4	3	
water	75:27	0:0	4	{
call	76:8	76:83	4	av_log
arg	76:15	76:20	5	avctx
water	76:15	0:0	6	avctx
arg	76:21	76:33	5	AV_LOG_ERROR
water	76:21	0:0	6	AV_LOG_ERROR
arg	76:34	76:74	5	"Unknown amount of delay %x != 0x88E.\n"
water	76:34	0:0	6	"Unknown amount of delay %x != 0x88E.\n"
arg	76:75	76:83	5	q->delay
water	76:75	0:0	6	q
op	76:76	0:0	6	->
water	76:78	0:0	6	delay
water	76:84	0:0	4	;
return	77:8	77:34	4	AVERROR_INVALIDDATA
water	77:15	0:0	5	AVERROR_INVALIDDATA
water	78:4	0:0	4	}
if	80:4	82:4	2	(q -> codingMode == STEREO)
cond	80:8	80:25	3	q -> codingMode == STEREO
water	80:8	0:0	4	q
op	80:9	0:0	4	->
water	80:11	0:0	4	codingMode
op	80:22	0:0	4	==
water	80:25	0:0	4	STEREO
stmts	80:33	82:4	3	
water	80:33	0:0	4	{
call	81:8	81:61	4	av_log
arg	81:15	81:20	5	avctx
water	81:15	0:0	6	avctx
arg	81:21	81:33	5	AV_LOG_DEBUG
water	81:21	0:0	6	AV_LOG_DEBUG
arg	81:34	81:61	5	"Normal stereo detected.\n"
water	81:34	0:0	6	"Normal stereo detected.\n"
water	81:62	0:0	4	;
water	82:4	0:0	4	}
else	82:6	84:4	2
stmts	82:11	84:4	3	
if	82:11	84:4	4	(q -> codingMode == JOINT_STEREO)
cond	82:15	82:32	5	q -> codingMode == JOINT_STEREO
water	82:15	0:0	6	q
op	82:16	0:0	6	->
water	82:18	0:0	6	codingMode
op	82:29	0:0	6	==
water	82:32	0:0	6	JOINT_STEREO
stmts	82:46	84:4	5	
water	82:46	0:0	6	{
call	83:8	83:60	6	av_log
arg	83:15	83:20	7	avctx
water	83:15	0:0	8	avctx
arg	83:21	83:33	7	AV_LOG_DEBUG
water	83:21	0:0	8	AV_LOG_DEBUG
arg	83:34	83:60	7	"Joint stereo detected.\n"
water	83:34	0:0	8	"Joint stereo detected.\n"
water	83:61	0:0	6	;
water	84:4	0:0	6	}
else	84:6	87:4	2
stmts	84:11	87:4	3	
water	84:11	0:0	4	{
call	85:8	85:83	4	av_log
arg	85:15	85:20	5	avctx
water	85:15	0:0	6	avctx
arg	85:21	85:33	5	AV_LOG_ERROR
water	85:21	0:0	6	AV_LOG_ERROR
arg	85:34	85:69	5	"Unknown channel coding mode %x!\n"
water	85:34	0:0	6	"Unknown channel coding mode %x!\n"
arg	85:70	85:83	5	q->codingMode
water	85:70	0:0	6	q
op	85:71	0:0	6	->
water	85:73	0:0	6	codingMode
water	85:84	0:0	4	;
return	86:8	86:34	4	AVERROR_INVALIDDATA
water	86:15	0:0	5	AVERROR_INVALIDDATA
water	87:4	0:0	4	}
if	89:4	92:4	2	(avctx -> channels <= 0 || avctx -> channels > 2)
cond	89:8	89:50	3	avctx -> channels <= 0 || avctx -> channels > 2
water	89:8	0:0	4	avctx
op	89:13	0:0	4	->
water	89:15	0:0	4	channels
op	89:24	0:0	4	<=
water	89:27	0:0	4	0
op	89:29	0:0	4	||
water	89:32	0:0	4	avctx
op	89:37	0:0	4	->
water	89:39	0:0	4	channels
op	89:48	0:0	4	>
water	89:50	0:0	4	2
stmts	89:54	92:4	3	
water	89:54	0:0	4	{
call	90:8	90:66	4	av_log
arg	90:15	90:20	5	avctx
water	90:15	0:0	6	avctx
arg	90:21	90:33	5	AV_LOG_ERROR
water	90:21	0:0	6	AV_LOG_ERROR
arg	90:34	90:66	5	"Channel configuration error!\n"
water	90:34	0:0	6	"Channel configuration error!\n"
water	90:67	0:0	4	;
return	91:8	91:30	4	AVERROR(EINVAL)
call	91:15	91:29	5	AVERROR
arg	91:23	91:29	6	EINVAL
water	91:23	0:0	7	EINVAL
water	92:4	0:0	4	}
if	95:4	96:30	2	(avctx -> block_align >= UINT_MAX / 2)
cond	95:7	95:38	3	avctx -> block_align >= UINT_MAX / 2
water	95:7	0:0	4	avctx
op	95:12	0:0	4	->
water	95:14	0:0	4	block_align
op	95:26	0:0	4	>=
water	95:29	0:0	4	UINT_MAX
op	95:37	0:0	4	/
water	95:38	0:0	4	2
stmts	96:8	96:30	3	
return	96:8	96:30	4	AVERROR(EINVAL)
call	96:15	96:29	5	AVERROR
arg	96:23	96:29	6	EINVAL
water	96:23	0:0	7	EINVAL
if	100:4	101:30	2	(( q -> decoded_bytes_buffer =av_mallocz (( avctx -> block_align + ( 4 - avctx -> block_align % 4 ) + FF_INPUT_BUFFER_PADDING_SIZE ) ) ) == NULL)
cond	100:8	100:129	3	( q -> decoded_bytes_buffer =av_mallocz (( avctx -> block_align + ( 4 - avctx -> block_align % 4 ) + FF_INPUT_BUFFER_PADDING_SIZE ) ) ) == NULL
water	100:8	0:0	4	(
water	100:9	0:0	4	q
op	100:10	0:0	4	->
water	100:12	0:0	4	decoded_bytes_buffer
op	100:33	0:0	4	=
call	100:35	100:122	4	av_mallocz
arg	100:46	100:122	5	(avctx->block_align+(4-avctx->block_align%4)+FF_INPUT_BUFFER_PADDING_SIZE)
water	100:46	0:0	6	(
water	100:47	0:0	6	avctx
op	100:52	0:0	6	->
water	100:54	0:0	6	block_align
op	100:65	0:0	6	+
water	100:66	0:0	6	(
water	100:67	0:0	6	4
op	100:68	0:0	6	-
water	100:69	0:0	6	avctx
op	100:74	0:0	6	->
water	100:76	0:0	6	block_align
op	100:87	0:0	6	%
water	100:88	0:0	6	4
water	100:89	0:0	6	)
op	100:91	0:0	6	+
water	100:93	0:0	6	FF_INPUT_BUFFER_PADDING_SIZE
water	100:121	0:0	6	)
water	100:123	0:0	4	)
op	100:126	0:0	4	==
water	100:129	0:0	4	NULL
stmts	101:8	101:30	3	
return	101:8	101:30	4	AVERROR(ENOMEM)
call	101:15	101:29	5	AVERROR
arg	101:23	101:29	6	ENOMEM
water	101:23	0:0	7	ENOMEM
if	105:4	114:4	2	(! vlcs_initialized)
cond	105:8	105:9	3	! vlcs_initialized
op	105:8	0:0	4	!
water	105:9	0:0	4	vlcs_initialized
stmts	105:27	114:4	3	
water	105:27	0:0	4	{
for	106:8	112:8	4	(i = 0 ;i < 7;i ++)
forinit	106:13	106:17	5	i = 0 ;
water	106:13	0:0	6	i
op	106:14	0:0	6	=
water	106:15	0:0	6	0
water	106:17	0:0	6	;
cond	106:19	106:21	5	i < 7
water	106:19	0:0	6	i
op	106:20	0:0	6	<
water	106:21	0:0	6	7
forexpr	106:25	106:26	5	i ++
water	106:25	0:0	6	i
op	106:26	0:0	6	++
stmts	106:30	112:8	5	
water	106:30	0:0	6	{
water	107:12	0:0	6	spectral_coeff_tab
op	107:30	0:0	6	[
water	107:31	0:0	6	i
op	107:32	0:0	6	]
op	107:33	0:0	6	.
water	107:34	0:0	6	table
op	107:40	0:0	6	=
op	107:42	0:0	6	&
water	107:43	0:0	6	atrac3_vlc_table
op	107:59	0:0	6	[
water	107:60	0:0	6	atrac3_vlc_offs
op	107:75	0:0	6	[
water	107:76	0:0	6	i
op	107:77	0:0	6	]
op	107:78	0:0	6	]
water	107:79	0:0	6	;
water	108:12	0:0	6	spectral_coeff_tab
op	108:30	0:0	6	[
water	108:31	0:0	6	i
op	108:32	0:0	6	]
op	108:33	0:0	6	.
water	108:34	0:0	6	table_allocated
op	108:50	0:0	6	=
water	108:52	0:0	6	atrac3_vlc_offs
op	108:67	0:0	6	[
water	108:68	0:0	6	i
op	108:70	0:0	6	+
water	108:72	0:0	6	1
op	108:73	0:0	6	]
op	108:75	0:0	6	-
water	108:77	0:0	6	atrac3_vlc_offs
op	108:92	0:0	6	[
water	108:93	0:0	6	i
op	108:94	0:0	6	]
water	108:95	0:0	6	;
call	109:12	111:60	6	init_vlc
arg	109:22	109:44	7	&spectral_coeff_tab[i]
op	109:22	0:0	8	&
water	109:23	0:0	8	spectral_coeff_tab
op	109:41	0:0	8	[
water	109:42	0:0	8	i
op	109:43	0:0	8	]
arg	109:46	109:47	7	9
water	109:46	0:0	8	9
arg	109:49	109:66	7	huff_tab_sizes[i]
water	109:49	0:0	8	huff_tab_sizes
op	109:63	0:0	8	[
water	109:64	0:0	8	i
op	109:65	0:0	8	]
arg	110:16	110:28	7	huff_bits[i]
water	110:16	0:0	8	huff_bits
op	110:25	0:0	8	[
water	110:26	0:0	8	i
op	110:27	0:0	8	]
arg	110:30	110:31	7	1
water	110:30	0:0	8	1
arg	110:33	110:34	7	1
water	110:33	0:0	8	1
arg	111:16	111:29	7	huff_codes[i]
water	111:16	0:0	8	huff_codes
op	111:26	0:0	8	[
water	111:27	0:0	8	i
op	111:28	0:0	8	]
arg	111:31	111:32	7	1
water	111:31	0:0	8	1
arg	111:34	111:35	7	1
water	111:34	0:0	8	1
arg	111:37	111:60	7	INIT_VLC_USE_NEW_STATIC
water	111:37	0:0	8	INIT_VLC_USE_NEW_STATIC
water	111:61	0:0	6	;
water	112:8	0:0	6	}
water	113:8	0:0	4	vlcs_initialized
op	113:25	0:0	4	=
water	113:27	0:0	4	1
water	113:28	0:0	4	;
water	114:4	0:0	4	}
if	116:4	117:45	2	(avctx -> request_sample_fmt == AV_SAMPLE_FMT_FLT)
cond	116:8	116:37	3	avctx -> request_sample_fmt == AV_SAMPLE_FMT_FLT
water	116:8	0:0	4	avctx
op	116:13	0:0	4	->
water	116:15	0:0	4	request_sample_fmt
op	116:34	0:0	4	==
water	116:37	0:0	4	AV_SAMPLE_FMT_FLT
stmts	117:8	117:45	3	
water	117:8	0:0	4	avctx
op	117:13	0:0	4	->
water	117:15	0:0	4	sample_fmt
op	117:26	0:0	4	=
water	117:28	0:0	4	AV_SAMPLE_FMT_FLT
water	117:45	0:0	4	;
else	118:4	119:45	2
stmts	119:8	119:45	3	
water	119:8	0:0	4	avctx
op	119:13	0:0	4	->
water	119:15	0:0	4	sample_fmt
op	119:26	0:0	4	=
water	119:28	0:0	4	AV_SAMPLE_FMT_S16
water	119:45	0:0	4	;
if	121:4	125:4	2	(( ret =init_atrac3_transforms (q ,avctx -> sample_fmt == AV_SAMPLE_FMT_FLT ) ))
cond	121:8	121:80	3	( ret =init_atrac3_transforms (q ,avctx -> sample_fmt == AV_SAMPLE_FMT_FLT ) )
water	121:8	0:0	4	(
water	121:9	0:0	4	ret
op	121:13	0:0	4	=
call	121:15	121:79	4	init_atrac3_transforms
arg	121:38	121:39	5	q
water	121:38	0:0	6	q
arg	121:41	121:79	5	avctx->sample_fmt==AV_SAMPLE_FMT_FLT
water	121:41	0:0	6	avctx
op	121:46	0:0	6	->
water	121:48	0:0	6	sample_fmt
op	121:59	0:0	6	==
water	121:62	0:0	6	AV_SAMPLE_FMT_FLT
water	121:80	0:0	4	)
stmts	121:83	125:4	3	
water	121:83	0:0	4	{
call	122:8	122:63	4	av_log
arg	122:15	122:20	5	avctx
water	122:15	0:0	6	avctx
arg	122:22	122:34	5	AV_LOG_ERROR
water	122:22	0:0	6	AV_LOG_ERROR
arg	122:36	122:63	5	"Error initializing MDCT\n"
water	122:36	0:0	6	"Error initializing MDCT\n"
water	122:64	0:0	4	;
call	123:8	123:41	4	av_freep
arg	123:17	123:41	5	&q->decoded_bytes_buffer
op	123:17	0:0	6	&
water	123:18	0:0	6	q
op	123:19	0:0	6	->
water	123:21	0:0	6	decoded_bytes_buffer
water	123:42	0:0	4	;
return	124:8	124:18	4	ret
water	124:15	0:0	5	ret
water	125:4	0:0	4	}
call	127:4	127:26	2	atrac_generate_tables
water	127:27	0:0	2	;
for	130:4	131:42	2	(i = 0 ;i < 16;i ++)
forinit	130:9	130:13	3	i = 0 ;
water	130:9	0:0	4	i
op	130:10	0:0	4	=
water	130:11	0:0	4	0
water	130:13	0:0	4	;
cond	130:15	130:17	3	i < 16
water	130:15	0:0	4	i
op	130:16	0:0	4	<
water	130:17	0:0	4	16
forexpr	130:22	130:23	3	i ++
water	130:22	0:0	4	i
op	130:23	0:0	4	++
stmts	131:8	131:42	3	
water	131:8	0:0	4	gain_tab1
op	131:17	0:0	4	[
water	131:18	0:0	4	i
op	131:19	0:0	4	]
op	131:21	0:0	4	=
call	131:23	131:41	4	powf
arg	131:29	131:32	5	2.0
water	131:29	0:0	6	2
op	131:30	0:0	6	.
water	131:31	0:0	6	0
arg	131:34	131:41	5	(4-i)
water	131:34	0:0	6	(
water	131:35	0:0	6	4
op	131:37	0:0	6	-
water	131:39	0:0	6	i
water	131:40	0:0	6	)
water	131:42	0:0	4	;
for	133:4	134:48	2	(i = - 15 ;i < 16;i ++)
forinit	133:9	133:15	3	i = - 15 ;
water	133:9	0:0	4	i
op	133:10	0:0	4	=
op	133:11	0:0	4	-
water	133:12	0:0	4	15
water	133:15	0:0	4	;
cond	133:17	133:19	3	i < 16
water	133:17	0:0	4	i
op	133:18	0:0	4	<
water	133:19	0:0	4	16
forexpr	133:24	133:25	3	i ++
water	133:24	0:0	4	i
op	133:25	0:0	4	++
stmts	134:8	134:48	3	
water	134:8	0:0	4	gain_tab2
op	134:17	0:0	4	[
water	134:18	0:0	4	i
op	134:19	0:0	4	+
water	134:20	0:0	4	15
op	134:22	0:0	4	]
op	134:24	0:0	4	=
call	134:26	134:47	4	powf
arg	134:32	134:35	5	2.0
water	134:32	0:0	6	2
op	134:33	0:0	6	.
water	134:34	0:0	6	0
arg	134:37	134:47	5	i*-0.125
water	134:37	0:0	6	i
op	134:39	0:0	6	*
op	134:41	0:0	6	-
water	134:42	0:0	6	0
op	134:43	0:0	6	.
water	134:44	0:0	6	125
water	134:48	0:0	4	;
water	137:4	0:0	2	q
op	137:5	0:0	2	->
water	137:7	0:0	2	weighting_delay
op	137:22	0:0	2	[
water	137:23	0:0	2	0
op	137:24	0:0	2	]
op	137:26	0:0	2	=
water	137:28	0:0	2	0
water	137:29	0:0	2	;
water	138:4	0:0	2	q
op	138:5	0:0	2	->
water	138:7	0:0	2	weighting_delay
op	138:22	0:0	2	[
water	138:23	0:0	2	1
op	138:24	0:0	2	]
op	138:26	0:0	2	=
water	138:28	0:0	2	7
water	138:29	0:0	2	;
water	139:4	0:0	2	q
op	139:5	0:0	2	->
water	139:7	0:0	2	weighting_delay
op	139:22	0:0	2	[
water	139:23	0:0	2	2
op	139:24	0:0	2	]
op	139:26	0:0	2	=
water	139:28	0:0	2	0
water	139:29	0:0	2	;
water	140:4	0:0	2	q
op	140:5	0:0	2	->
water	140:7	0:0	2	weighting_delay
op	140:22	0:0	2	[
water	140:23	0:0	2	3
op	140:24	0:0	2	]
op	140:26	0:0	2	=
water	140:28	0:0	2	7
water	140:29	0:0	2	;
water	141:4	0:0	2	q
op	141:5	0:0	2	->
water	141:7	0:0	2	weighting_delay
op	141:22	0:0	2	[
water	141:23	0:0	2	4
op	141:24	0:0	2	]
op	141:26	0:0	2	=
water	141:28	0:0	2	0
water	141:29	0:0	2	;
water	142:4	0:0	2	q
op	142:5	0:0	2	->
water	142:7	0:0	2	weighting_delay
op	142:22	0:0	2	[
water	142:23	0:0	2	5
op	142:24	0:0	2	]
op	142:26	0:0	2	=
water	142:28	0:0	2	7
water	142:29	0:0	2	;
for	144:4	148:4	2	(i = 0 ;i < 4;i ++)
forinit	144:9	144:12	3	i = 0 ;
water	144:9	0:0	4	i
op	144:10	0:0	4	=
water	144:11	0:0	4	0
water	144:12	0:0	4	;
cond	144:14	144:16	3	i < 4
water	144:14	0:0	4	i
op	144:15	0:0	4	<
water	144:16	0:0	4	4
forexpr	144:19	144:20	3	i ++
water	144:19	0:0	4	i
op	144:20	0:0	4	++
stmts	144:24	148:4	3	
water	144:24	0:0	4	{
water	145:8	0:0	4	q
op	145:9	0:0	4	->
water	145:11	0:0	4	matrix_coeff_index_prev
op	145:34	0:0	4	[
water	145:35	0:0	4	i
op	145:36	0:0	4	]
op	145:38	0:0	4	=
water	145:40	0:0	4	3
water	145:41	0:0	4	;
water	146:8	0:0	4	q
op	146:9	0:0	4	->
water	146:11	0:0	4	matrix_coeff_index_now
op	146:33	0:0	4	[
water	146:34	0:0	4	i
op	146:35	0:0	4	]
op	146:37	0:0	4	=
water	146:39	0:0	4	3
water	146:40	0:0	4	;
water	147:8	0:0	4	q
op	147:9	0:0	4	->
water	147:11	0:0	4	matrix_coeff_index_next
op	147:34	0:0	4	[
water	147:35	0:0	4	i
op	147:36	0:0	4	]
op	147:38	0:0	4	=
water	147:40	0:0	4	3
water	147:41	0:0	4	;
water	148:4	0:0	4	}
call	150:4	150:28	2	dsputil_init
arg	150:17	150:21	3	&dsp
op	150:17	0:0	4	&
water	150:18	0:0	4	dsp
arg	150:23	150:28	3	avctx
water	150:23	0:0	4	avctx
water	150:29	0:0	2	;
call	151:4	151:43	2	ff_fmt_convert_init
arg	151:24	151:36	3	&q->fmt_conv
op	151:24	0:0	4	&
water	151:25	0:0	4	q
op	151:26	0:0	4	->
water	151:28	0:0	4	fmt_conv
arg	151:38	151:43	3	avctx
water	151:38	0:0	4	avctx
water	151:44	0:0	2	;
water	153:4	0:0	2	q
op	153:5	0:0	2	->
water	153:7	0:0	2	pUnits
op	153:14	0:0	2	=
call	153:16	153:59	2	av_mallocz
arg	153:27	153:59	3	sizeof(channel_unit)*q->channels
op	153:27	0:0	4	sizeof
water	153:33	0:0	4	(
water	153:34	0:0	4	channel_unit
water	153:46	0:0	4	)
op	153:47	0:0	4	*
water	153:48	0:0	4	q
op	153:49	0:0	4	->
water	153:51	0:0	4	channels
water	153:60	0:0	2	;
if	154:4	157:4	2	(! q -> pUnits)
cond	154:8	154:12	3	! q -> pUnits
op	154:8	0:0	4	!
water	154:9	0:0	4	q
op	154:10	0:0	4	->
water	154:12	0:0	4	pUnits
stmts	154:20	157:4	3	
water	154:20	0:0	4	{
call	155:8	155:33	4	atrac3_decode_close
arg	155:28	155:33	5	avctx
water	155:28	0:0	6	avctx
water	155:34	0:0	4	;
return	156:8	156:30	4	AVERROR(ENOMEM)
call	156:15	156:29	5	AVERROR
arg	156:23	156:29	6	ENOMEM
water	156:23	0:0	7	ENOMEM
water	157:4	0:0	4	}
if	159:4	166:4	2	(avctx -> channels > 1 || avctx -> sample_fmt == AV_SAMPLE_FMT_S16)
cond	159:8	159:52	3	avctx -> channels > 1 || avctx -> sample_fmt == AV_SAMPLE_FMT_S16
water	159:8	0:0	4	avctx
op	159:13	0:0	4	->
water	159:15	0:0	4	channels
op	159:24	0:0	4	>
water	159:26	0:0	4	1
op	159:28	0:0	4	||
water	159:31	0:0	4	avctx
op	159:36	0:0	4	->
water	159:38	0:0	4	sample_fmt
op	159:49	0:0	4	==
water	159:52	0:0	4	AV_SAMPLE_FMT_S16
stmts	159:71	166:4	3	
water	159:71	0:0	4	{
water	160:8	0:0	4	q
op	160:9	0:0	4	->
water	160:11	0:0	4	outSamples
op	160:21	0:0	4	[
water	160:22	0:0	4	0
op	160:23	0:0	4	]
op	160:25	0:0	4	=
call	160:27	160:101	4	av_mallocz
arg	160:38	160:101	5	SAMPLES_PER_FRAME*avctx->channels*sizeof(*q->outSamples[0])
water	160:38	0:0	6	SAMPLES_PER_FRAME
op	160:56	0:0	6	*
water	160:58	0:0	6	avctx
op	160:63	0:0	6	->
water	160:65	0:0	6	channels
op	160:74	0:0	6	*
op	160:76	0:0	6	sizeof
water	160:82	0:0	6	(
op	160:83	0:0	6	*
water	160:84	0:0	6	q
op	160:85	0:0	6	->
water	160:87	0:0	6	outSamples
op	160:97	0:0	6	[
water	160:98	0:0	6	0
op	160:99	0:0	6	]
water	160:100	0:0	6	)
water	160:102	0:0	4	;
water	161:8	0:0	4	q
op	161:9	0:0	4	->
water	161:11	0:0	4	outSamples
op	161:21	0:0	4	[
water	161:22	0:0	4	1
op	161:23	0:0	4	]
op	161:25	0:0	4	=
water	161:27	0:0	4	q
op	161:28	0:0	4	->
water	161:30	0:0	4	outSamples
op	161:40	0:0	4	[
water	161:41	0:0	4	0
op	161:42	0:0	4	]
op	161:44	0:0	4	+
water	161:46	0:0	4	SAMPLES_PER_FRAME
water	161:63	0:0	4	;
if	162:8	165:8	4	(! q -> outSamples [ 0 ])
cond	162:12	162:28	5	! q -> outSamples [ 0 ]
op	162:12	0:0	6	!
water	162:13	0:0	6	q
op	162:14	0:0	6	->
water	162:16	0:0	6	outSamples
op	162:26	0:0	6	[
water	162:27	0:0	6	0
op	162:28	0:0	6	]
stmts	162:31	165:8	5	
water	162:31	0:0	6	{
call	163:12	163:37	6	atrac3_decode_close
arg	163:32	163:37	7	avctx
water	163:32	0:0	8	avctx
water	163:38	0:0	6	;
return	164:12	164:34	6	AVERROR(ENOMEM)
call	164:19	164:33	7	AVERROR
arg	164:27	164:33	8	ENOMEM
water	164:27	0:0	9	ENOMEM
water	165:8	0:0	6	}
water	166:4	0:0	4	}
call	168:4	168:40	2	avcodec_get_frame_defaults
arg	168:31	168:40	3	&q->frame
op	168:31	0:0	4	&
water	168:32	0:0	4	q
op	168:33	0:0	4	->
water	168:35	0:0	4	frame
water	168:41	0:0	2	;
water	169:4	0:0	2	avctx
op	169:9	0:0	2	->
water	169:11	0:0	2	coded_frame
op	169:23	0:0	2	=
op	169:25	0:0	2	&
water	169:26	0:0	2	q
op	169:27	0:0	2	->
water	169:29	0:0	2	frame
water	169:34	0:0	2	;
return	171:4	171:12	2	0
water	171:11	0:0	3	0
