func	1:0	103:0	0	static int	decode_plane
params	1:23	0:0	1	
param	1:24	1:41	2	UtvideoContext *	c
param	1:43	1:55	2	int	plane_no
param	2:24	2:36	2	uint8_t *	dst
param	2:38	2:46	2	int	step
param	2:48	2:64	2	ptrdiff_t	stride
param	3:24	3:33	2	int	width
param	3:35	3:45	2	int	height
param	4:24	4:42	2	const uint8_t *	src
param	4:44	4:56	2	int	use_pred
stmnts	0:0	102:30	1	
decl	6:4	6:24	2	int	i
water	6:9	0:0	2	,
decl	6:4	6:24	2	int	j
water	6:12	0:0	2	,
decl	6:4	6:24	2	int	slice
water	6:19	0:0	2	,
decl	6:4	6:24	2	int	pix
decl	7:4	7:20	2	int	sstart
water	7:14	0:0	2	,
decl	7:4	7:20	2	int	send
decl	8:4	8:11	2	VLC	vlc
decl	9:4	9:20	2	GetBitContext	gb
decl	10:4	10:18	2	int	prev
water	10:12	0:0	2	,
decl	10:4	10:18	2	int	fsym
decl	11:4	11:161	2	const int	cmask
op	11:20	0:0	2	=
water	11:22	0:0	2	c
op	11:23	0:0	2	->
water	11:25	0:0	2	interlaced
water	11:36	0:0	2	?
op	11:38	0:0	2	~
water	11:39	0:0	2	(
water	11:40	0:0	2	1
op	11:42	0:0	2	+
water	11:44	0:0	2	2
op	11:46	0:0	2	*
water	11:48	0:0	2	(
op	11:49	0:0	2	!
water	11:50	0:0	2	plane_no
op	11:59	0:0	2	&&
water	11:62	0:0	2	c
op	11:63	0:0	2	->
water	11:65	0:0	2	avctx
op	11:70	0:0	2	->
water	11:72	0:0	2	pix_fmt
op	11:80	0:0	2	==
water	11:83	0:0	2	AV_PIX_FMT_YUV420P
water	11:101	0:0	2	)
water	11:102	0:0	2	)
water	11:104	0:0	2	:
op	11:106	0:0	2	~
water	11:107	0:0	2	(
op	11:108	0:0	2	!
water	11:109	0:0	2	plane_no
op	11:118	0:0	2	&&
water	11:121	0:0	2	c
op	11:122	0:0	2	->
water	11:124	0:0	2	avctx
op	11:129	0:0	2	->
water	11:131	0:0	2	pix_fmt
op	11:139	0:0	2	==
water	11:142	0:0	2	AV_PIX_FMT_YUV420P
water	11:160	0:0	2	)
if	13:4	16:4	2	(build_huff (src ,& vlc ,& fsym ))
cond	13:8	13:35	3	build_huff (src ,& vlc ,& fsym )
call	13:8	13:35	4	build_huff
arg	13:19	13:22	5	src
water	13:19	0:0	6	src
arg	13:24	13:28	5	&vlc
op	13:24	0:0	6	&
water	13:25	0:0	6	vlc
arg	13:30	13:35	5	&fsym
op	13:30	0:0	6	&
water	13:31	0:0	6	fsym
stmts	13:38	16:4	3	
water	13:38	0:0	4	{
call	14:8	14:69	4	av_log
arg	14:15	14:23	5	c->avctx
water	14:15	0:0	6	c
op	14:16	0:0	6	->
water	14:18	0:0	6	avctx
arg	14:25	14:37	5	AV_LOG_ERROR
water	14:25	0:0	6	AV_LOG_ERROR
arg	14:39	14:69	5	"Cannot build Huffman codes\n"
water	14:39	0:0	6	"Cannot build Huffman codes\n"
water	14:70	0:0	4	;
return	15:8	15:34	4	AVERROR_INVALIDDATA
water	15:15	0:0	5	AVERROR_INVALIDDATA
water	16:4	0:0	4	}
if	17:4	40:4	2	(fsym >= 0)
cond	17:8	17:16	3	fsym >= 0
water	17:8	0:0	4	fsym
op	17:13	0:0	4	>=
water	17:16	0:0	4	0
stmts	17:19	40:4	3	
water	17:19	0:0	4	{
water	18:8	0:0	4	send
op	18:13	0:0	4	=
water	18:15	0:0	4	0
water	18:16	0:0	4	;
for	19:8	38:8	4	(slice = 0 ;slice < c -> slices;slice ++)
forinit	19:13	19:22	5	slice = 0 ;
water	19:13	0:0	6	slice
op	19:19	0:0	6	=
water	19:21	0:0	6	0
water	19:22	0:0	6	;
cond	19:24	19:35	5	slice < c -> slices
water	19:24	0:0	6	slice
op	19:30	0:0	6	<
water	19:32	0:0	6	c
op	19:33	0:0	6	->
water	19:35	0:0	6	slices
forexpr	19:43	19:48	5	slice ++
water	19:43	0:0	6	slice
op	19:48	0:0	6	++
stmts	19:52	38:8	5	
water	19:52	0:0	6	{
decl	20:12	20:25	6	uint8_t	*dest
water	22:12	0:0	6	sstart
op	22:19	0:0	6	=
water	22:21	0:0	6	send
water	22:25	0:0	6	;
water	23:12	0:0	6	send
op	23:19	0:0	6	=
water	23:21	0:0	6	(
water	23:22	0:0	6	height
op	23:29	0:0	6	*
water	23:31	0:0	6	(
water	23:32	0:0	6	slice
op	23:38	0:0	6	+
water	23:40	0:0	6	1
water	23:41	0:0	6	)
op	23:43	0:0	6	/
water	23:45	0:0	6	c
op	23:46	0:0	6	->
water	23:48	0:0	6	slices
water	23:54	0:0	6	)
op	23:56	0:0	6	&
water	23:58	0:0	6	cmask
water	23:63	0:0	6	;
water	24:12	0:0	6	dest
op	24:19	0:0	6	=
water	24:21	0:0	6	dst
op	24:25	0:0	6	+
water	24:27	0:0	6	sstart
op	24:34	0:0	6	*
water	24:36	0:0	6	stride
water	24:42	0:0	6	;
water	26:12	0:0	6	prev
op	26:17	0:0	6	=
water	26:19	0:0	6	0
water	26:20	0:0	6	x80
water	26:23	0:0	6	;
for	27:12	37:12	6	(j = sstart ;j < send;j ++)
forinit	27:17	27:27	7	j = sstart ;
water	27:17	0:0	8	j
op	27:19	0:0	8	=
water	27:21	0:0	8	sstart
water	27:27	0:0	8	;
cond	27:29	27:33	7	j < send
water	27:29	0:0	8	j
op	27:31	0:0	8	<
water	27:33	0:0	8	send
forexpr	27:39	27:40	7	j ++
water	27:39	0:0	8	j
op	27:40	0:0	8	++
stmts	27:44	37:12	7	
water	27:44	0:0	8	{
for	28:16	35:16	8	(i = 0 ;i < width * step;i += step)
forinit	28:21	28:26	9	i = 0 ;
water	28:21	0:0	10	i
op	28:23	0:0	10	=
water	28:25	0:0	10	0
water	28:26	0:0	10	;
cond	28:28	28:40	9	i < width * step
water	28:28	0:0	10	i
op	28:30	0:0	10	<
water	28:32	0:0	10	width
op	28:38	0:0	10	*
water	28:40	0:0	10	step
forexpr	28:46	28:51	9	i += step
water	28:46	0:0	10	i
op	28:48	0:0	10	+=
water	28:51	0:0	10	step
stmts	28:57	35:16	9	
water	28:57	0:0	10	{
water	29:20	0:0	10	pix
op	29:24	0:0	10	=
water	29:26	0:0	10	fsym
water	29:30	0:0	10	;
if	30:20	33:20	10	(use_pred)
cond	30:24	30:24	11	use_pred
water	30:24	0:0	12	use_pred
stmts	30:34	33:20	11	
water	30:34	0:0	12	{
water	31:24	0:0	12	prev
op	31:29	0:0	12	+=
water	31:32	0:0	12	pix
water	31:35	0:0	12	;
water	32:24	0:0	12	pix
op	32:30	0:0	12	=
water	32:32	0:0	12	prev
water	32:36	0:0	12	;
water	33:20	0:0	12	}
water	34:20	0:0	10	dest
op	34:24	0:0	10	[
water	34:25	0:0	10	i
op	34:26	0:0	10	]
op	34:28	0:0	10	=
water	34:30	0:0	10	pix
water	34:33	0:0	10	;
water	35:16	0:0	10	}
water	36:16	0:0	8	dest
op	36:21	0:0	8	+=
water	36:24	0:0	8	stride
water	36:30	0:0	8	;
water	37:12	0:0	8	}
water	38:8	0:0	6	}
return	39:8	39:16	4	0
water	39:15	0:0	5	0
water	40:4	0:0	4	}
water	42:4	0:0	2	src
op	42:13	0:0	2	+=
water	42:16	0:0	2	256
water	42:19	0:0	2	;
water	44:4	0:0	2	send
op	44:9	0:0	2	=
water	44:11	0:0	2	0
water	44:12	0:0	2	;
for	45:4	95:4	2	(slice = 0 ;slice < c -> slices;slice ++)
forinit	45:9	45:18	3	slice = 0 ;
water	45:9	0:0	4	slice
op	45:15	0:0	4	=
water	45:17	0:0	4	0
water	45:18	0:0	4	;
cond	45:20	45:31	3	slice < c -> slices
water	45:20	0:0	4	slice
op	45:26	0:0	4	<
water	45:28	0:0	4	c
op	45:29	0:0	4	->
water	45:31	0:0	4	slices
forexpr	45:39	45:44	3	slice ++
water	45:39	0:0	4	slice
op	45:44	0:0	4	++
stmts	45:48	95:4	3	
water	45:48	0:0	4	{
decl	46:8	46:21	4	uint8_t	*dest
decl	47:8	47:56	4	int	slice_data_start
water	47:28	0:0	4	,
decl	47:8	47:56	4	int	slice_data_end
water	47:44	0:0	4	,
decl	47:8	47:56	4	int	slice_size
water	49:8	0:0	4	sstart
op	49:15	0:0	4	=
water	49:17	0:0	4	send
water	49:21	0:0	4	;
water	50:8	0:0	4	send
op	50:15	0:0	4	=
water	50:17	0:0	4	(
water	50:18	0:0	4	height
op	50:25	0:0	4	*
water	50:27	0:0	4	(
water	50:28	0:0	4	slice
op	50:34	0:0	4	+
water	50:36	0:0	4	1
water	50:37	0:0	4	)
op	50:39	0:0	4	/
water	50:41	0:0	4	c
op	50:42	0:0	4	->
water	50:44	0:0	4	slices
water	50:50	0:0	4	)
op	50:52	0:0	4	&
water	50:54	0:0	4	cmask
water	50:59	0:0	4	;
water	51:8	0:0	4	dest
op	51:15	0:0	4	=
water	51:17	0:0	4	dst
op	51:21	0:0	4	+
water	51:23	0:0	4	sstart
op	51:30	0:0	4	*
water	51:32	0:0	4	stride
water	51:38	0:0	4	;
water	54:8	0:0	4	slice_data_start
op	54:25	0:0	4	=
water	54:27	0:0	4	slice
water	54:33	0:0	4	?
call	54:35	54:62	4	AV_RL32
arg	54:43	54:62	5	src+slice*4-4
water	54:43	0:0	6	src
op	54:47	0:0	6	+
water	54:49	0:0	6	slice
op	54:55	0:0	6	*
water	54:57	0:0	6	4
op	54:59	0:0	6	-
water	54:61	0:0	6	4
water	54:64	0:0	4	:
water	54:66	0:0	4	0
water	54:67	0:0	4	;
water	55:8	0:0	4	slice_data_end
op	55:25	0:0	4	=
call	55:27	55:50	4	AV_RL32
arg	55:35	55:50	5	src+slice*4
water	55:35	0:0	6	src
op	55:39	0:0	6	+
water	55:41	0:0	6	slice
op	55:47	0:0	6	*
water	55:49	0:0	6	4
water	55:51	0:0	4	;
water	56:8	0:0	4	slice_size
op	56:25	0:0	4	=
water	56:27	0:0	4	slice_data_end
op	56:42	0:0	4	-
water	56:44	0:0	4	slice_data_start
water	56:60	0:0	4	;
if	58:8	62:8	4	(! slice_size)
cond	58:12	58:13	5	! slice_size
op	58:12	0:0	6	!
water	58:13	0:0	6	slice_size
stmts	58:25	62:8	5	
water	58:25	0:0	6	{
call	59:12	60:56	6	av_log
arg	59:19	59:27	7	c->avctx
water	59:19	0:0	8	c
op	59:20	0:0	8	->
water	59:22	0:0	8	avctx
arg	59:29	59:41	7	AV_LOG_ERROR
water	59:29	0:0	8	AV_LOG_ERROR
arg	59:43	60:56	7	"Plane has more than one symbol ""yet a slice has a length of zero.\n"
water	59:43	0:0	8	"Plane has more than one symbol "
water	60:19	0:0	8	"yet a slice has a length of zero.\n"
water	60:57	0:0	6	;
goto	61:12	61:21	6	fail
water	61:17	0:0	7	fail
water	62:8	0:0	6	}
call	64:8	64:74	4	memset
arg	64:15	64:41	5	c->slice_bits+slice_size
water	64:15	0:0	6	c
op	64:16	0:0	6	->
water	64:18	0:0	6	slice_bits
op	64:29	0:0	6	+
water	64:31	0:0	6	slice_size
arg	64:43	64:44	5	0
water	64:43	0:0	6	0
arg	64:46	64:74	5	AV_INPUT_BUFFER_PADDING_SIZE
water	64:46	0:0	6	AV_INPUT_BUFFER_PADDING_SIZE
water	64:75	0:0	4	;
call	65:8	67:70	4	c->bdsp.bswap_buf
arg	65:26	65:52	5	(uint32_t*)c->slice_bits
water	65:26	0:0	6	(
water	65:27	0:0	6	uint32_t
op	65:36	0:0	6	*
water	65:37	0:0	6	)
water	65:39	0:0	6	c
op	65:40	0:0	6	->
water	65:42	0:0	6	slice_bits
arg	66:26	66:78	5	(uint32_t*)(src+slice_data_start+c->slices*4)
call	66:26	66:77	6	(uint32_t*)
arg	66:39	66:77	7	src+slice_data_start+c->slices*4
water	66:39	0:0	8	src
op	66:43	0:0	8	+
water	66:45	0:0	8	slice_data_start
op	66:62	0:0	8	+
water	66:64	0:0	8	c
op	66:65	0:0	8	->
water	66:67	0:0	8	slices
op	66:74	0:0	8	*
water	66:76	0:0	8	4
arg	67:26	67:70	5	(slice_data_end-slice_data_start+3)>>2
water	67:26	0:0	6	(
water	67:27	0:0	6	slice_data_end
op	67:42	0:0	6	-
water	67:44	0:0	6	slice_data_start
op	67:61	0:0	6	+
water	67:63	0:0	6	3
water	67:64	0:0	6	)
op	67:66	0:0	6	>>
water	67:69	0:0	6	2
water	67:71	0:0	4	;
call	68:8	68:56	4	init_get_bits
arg	68:22	68:25	5	&gb
op	68:22	0:0	6	&
water	68:23	0:0	6	gb
arg	68:27	68:40	5	c->slice_bits
water	68:27	0:0	6	c
op	68:28	0:0	6	->
water	68:30	0:0	6	slice_bits
arg	68:42	68:56	5	slice_size*8
water	68:42	0:0	6	slice_size
op	68:53	0:0	6	*
water	68:55	0:0	6	8
water	68:57	0:0	4	;
water	70:8	0:0	4	prev
op	70:13	0:0	4	=
water	70:15	0:0	4	0
water	70:16	0:0	4	x80
water	70:19	0:0	4	;
for	71:8	91:8	4	(j = sstart ;j < send;j ++)
forinit	71:13	71:23	5	j = sstart ;
water	71:13	0:0	6	j
op	71:15	0:0	6	=
water	71:17	0:0	6	sstart
water	71:23	0:0	6	;
cond	71:25	71:29	5	j < send
water	71:25	0:0	6	j
op	71:27	0:0	6	<
water	71:29	0:0	6	send
forexpr	71:35	71:36	5	j ++
water	71:35	0:0	6	j
op	71:36	0:0	6	++
stmts	71:40	91:8	5	
water	71:40	0:0	6	{
decl	72:12	72:33	6	int	ws
op	72:19	0:0	6	=
water	72:21	0:0	6	width
op	72:27	0:0	6	*
water	72:29	0:0	6	step
for	73:12	84:12	6	(i = 0 ;i < ws;i += step)
forinit	73:17	73:22	7	i = 0 ;
water	73:17	0:0	8	i
op	73:19	0:0	8	=
water	73:21	0:0	8	0
water	73:22	0:0	8	;
cond	73:24	73:28	7	i < ws
water	73:24	0:0	8	i
op	73:26	0:0	8	<
water	73:28	0:0	8	ws
forexpr	73:32	73:37	7	i += step
water	73:32	0:0	8	i
op	73:34	0:0	8	+=
water	73:37	0:0	8	step
stmts	73:43	84:12	7	
water	73:43	0:0	8	{
water	74:16	0:0	8	pix
op	74:20	0:0	8	=
call	74:22	74:58	8	get_vlc2
arg	74:31	74:34	9	&gb
op	74:31	0:0	10	&
water	74:32	0:0	10	gb
arg	74:36	74:45	9	vlc.table
water	74:36	0:0	10	vlc
op	74:39	0:0	10	.
water	74:40	0:0	10	table
arg	74:47	74:55	9	VLC_BITS
water	74:47	0:0	10	VLC_BITS
arg	74:57	74:58	9	3
water	74:57	0:0	10	3
water	74:59	0:0	8	;
if	75:16	78:16	8	(pix < 0)
cond	75:20	75:26	9	pix < 0
water	75:20	0:0	10	pix
op	75:24	0:0	10	<
water	75:26	0:0	10	0
stmts	75:29	78:16	9	
water	75:29	0:0	10	{
call	76:20	76:69	10	av_log
arg	76:27	76:35	11	c->avctx
water	76:27	0:0	12	c
op	76:28	0:0	12	->
water	76:30	0:0	12	avctx
arg	76:37	76:49	11	AV_LOG_ERROR
water	76:37	0:0	12	AV_LOG_ERROR
arg	76:51	76:69	11	"Decoding error\n"
water	76:51	0:0	12	"Decoding error\n"
water	76:70	0:0	10	;
goto	77:20	77:29	10	fail
water	77:25	0:0	11	fail
water	78:16	0:0	10	}
if	79:16	82:16	8	(use_pred)
cond	79:20	79:20	9	use_pred
water	79:20	0:0	10	use_pred
stmts	79:30	82:16	9	
water	79:30	0:0	10	{
water	80:20	0:0	10	prev
op	80:25	0:0	10	+=
water	80:28	0:0	10	pix
water	80:31	0:0	10	;
water	81:20	0:0	10	pix
op	81:26	0:0	10	=
water	81:28	0:0	10	prev
water	81:32	0:0	10	;
water	82:16	0:0	10	}
water	83:16	0:0	8	dest
op	83:20	0:0	8	[
water	83:21	0:0	8	i
op	83:22	0:0	8	]
op	83:24	0:0	8	=
water	83:26	0:0	8	pix
water	83:29	0:0	8	;
water	84:12	0:0	8	}
if	85:12	89:12	6	(get_bits_left (& gb ) < 0)
cond	85:16	85:37	7	get_bits_left (& gb ) < 0
call	85:16	85:33	8	get_bits_left
arg	85:30	85:33	9	&gb
op	85:30	0:0	10	&
water	85:31	0:0	10	gb
op	85:35	0:0	8	<
water	85:37	0:0	8	0
stmts	85:40	89:12	7	
water	85:40	0:0	8	{
call	86:16	87:58	8	av_log
arg	86:23	86:31	9	c->avctx
water	86:23	0:0	10	c
op	86:24	0:0	10	->
water	86:26	0:0	10	avctx
arg	86:33	86:45	9	AV_LOG_ERROR
water	86:33	0:0	10	AV_LOG_ERROR
arg	87:24	87:58	9	"Slice decoding ran out of bits\n"
water	87:24	0:0	10	"Slice decoding ran out of bits\n"
water	87:59	0:0	8	;
goto	88:16	88:25	8	fail
water	88:21	0:0	9	fail
water	89:12	0:0	8	}
water	90:12	0:0	6	dest
op	90:17	0:0	6	+=
water	90:20	0:0	6	stride
water	90:26	0:0	6	;
water	91:8	0:0	6	}
if	92:8	94:77	4	(get_bits_left (& gb ) > 32)
cond	92:12	92:33	5	get_bits_left (& gb ) > 32
call	92:12	92:29	6	get_bits_left
arg	92:26	92:29	7	&gb
op	92:26	0:0	8	&
water	92:27	0:0	8	gb
op	92:31	0:0	6	>
water	92:33	0:0	6	32
stmts	93:12	94:77	5	
call	93:12	94:76	6	av_log
arg	93:19	93:27	7	c->avctx
water	93:19	0:0	8	c
op	93:20	0:0	8	->
water	93:22	0:0	8	avctx
arg	93:29	93:43	7	AV_LOG_WARNING
water	93:29	0:0	8	AV_LOG_WARNING
arg	94:19	94:56	7	"%d bits left after decoding slice\n"
water	94:19	0:0	8	"%d bits left after decoding slice\n"
arg	94:58	94:76	7	get_bits_left(&gb)
call	94:58	94:75	8	get_bits_left
arg	94:72	94:75	9	&gb
op	94:72	0:0	10	&
water	94:73	0:0	10	gb
water	94:77	0:0	6	;
water	95:4	0:0	4	}
call	97:4	97:20	2	ff_free_vlc
arg	97:16	97:20	3	&vlc
op	97:16	0:0	4	&
water	97:17	0:0	4	vlc
water	97:21	0:0	2	;
return	99:4	99:12	2	0
water	99:11	0:0	3	0
label	100:0	100:4	2	fail :
call	101:4	101:20	2	ff_free_vlc
arg	101:16	101:20	3	&vlc
op	101:16	0:0	4	&
water	101:17	0:0	4	vlc
water	101:21	0:0	2	;
return	102:4	102:30	2	AVERROR_INVALIDDATA
water	102:11	0:0	3	AVERROR_INVALIDDATA
