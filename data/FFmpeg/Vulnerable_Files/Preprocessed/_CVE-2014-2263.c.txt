func	1:0	165:0	0	static int	mpegts_write_pmt
params	1:27	0:0	1	
param	1:28	1:46	2	AVFormatContext *	s
param	1:48	1:70	2	MpegTSService *	service
stmnts	0:0	164:12	1	
decl	3:4	3:34	2	MpegTSWrite	*ts
op	3:20	0:0	2	=
water	3:22	0:0	2	s
op	3:23	0:0	2	->
water	3:25	0:0	2	priv_data
decl	4:4	4:70	2	uint8_t	data[1012]
water	4:22	0:0	2	,
decl	4:4	4:70	2	uint8_t	*q
water	4:26	0:0	2	,
decl	4:4	4:70	2	uint8_t	*desc_length_ptr
water	4:44	0:0	2	,
decl	4:4	4:70	2	uint8_t	*program_info_length_ptr
decl	5:4	5:27	2	int	val
water	5:11	0:0	2	,
decl	5:4	5:27	2	int	stream_type
water	5:24	0:0	2	,
decl	5:4	5:27	2	int	i
water	7:4	0:0	2	q
op	7:6	0:0	2	=
water	7:8	0:0	2	data
water	7:12	0:0	2	;
call	8:4	8:39	2	put16
arg	8:10	8:12	3	&q
op	8:10	0:0	4	&
water	8:11	0:0	4	q
arg	8:14	8:39	3	0xe000|service->pcr_pid
water	8:14	0:0	4	0
water	8:15	0:0	4	xe000
op	8:21	0:0	4	|
water	8:23	0:0	4	service
op	8:30	0:0	4	->
water	8:32	0:0	4	pcr_pid
water	8:40	0:0	2	;
water	10:4	0:0	2	program_info_length_ptr
op	10:28	0:0	2	=
water	10:30	0:0	2	q
water	10:31	0:0	2	;
water	11:4	0:0	2	q
op	11:6	0:0	2	+=
water	11:9	0:0	2	2
water	11:10	0:0	2	;
water	15:4	0:0	2	val
op	15:8	0:0	2	=
water	15:10	0:0	2	0
water	15:11	0:0	2	xf000
op	15:17	0:0	2	|
water	15:19	0:0	2	(
water	15:20	0:0	2	q
op	15:22	0:0	2	-
water	15:24	0:0	2	program_info_length_ptr
op	15:48	0:0	2	-
water	15:50	0:0	2	2
water	15:51	0:0	2	)
water	15:52	0:0	2	;
water	16:4	0:0	2	program_info_length_ptr
op	16:27	0:0	2	[
water	16:28	0:0	2	0
op	16:29	0:0	2	]
op	16:31	0:0	2	=
water	16:33	0:0	2	val
op	16:37	0:0	2	>>
water	16:40	0:0	2	8
water	16:41	0:0	2	;
water	17:4	0:0	2	program_info_length_ptr
op	17:27	0:0	2	[
water	17:28	0:0	2	1
op	17:29	0:0	2	]
op	17:31	0:0	2	=
water	17:33	0:0	2	val
water	17:36	0:0	2	;
for	19:4	161:4	2	(i = 0 ;i < s -> nb_streams;i ++)
forinit	19:8	19:13	3	i = 0 ;
water	19:8	0:0	4	i
op	19:10	0:0	4	=
water	19:12	0:0	4	0
water	19:13	0:0	4	;
cond	19:15	19:22	3	i < s -> nb_streams
water	19:15	0:0	4	i
op	19:17	0:0	4	<
water	19:19	0:0	4	s
op	19:20	0:0	4	->
water	19:22	0:0	4	nb_streams
forexpr	19:34	19:35	3	i ++
water	19:34	0:0	4	i
op	19:35	0:0	4	++
stmts	19:39	161:4	3	
water	19:39	0:0	4	{
decl	20:8	20:36	4	AVStream	*st
op	20:21	0:0	4	=
water	20:23	0:0	4	s
op	20:24	0:0	4	->
water	20:26	0:0	4	streams
op	20:33	0:0	4	[
water	20:34	0:0	4	i
op	20:35	0:0	4	]
decl	21:8	21:48	4	MpegTSWriteStream	*ts_st
op	21:33	0:0	4	=
water	21:35	0:0	4	st
op	21:37	0:0	4	->
water	21:39	0:0	4	priv_data
decl	22:8	22:79	4	AVDictionaryEntry	*lang
op	22:32	0:0	4	=
call	22:34	22:78	5	av_dict_get
arg	22:46	22:58	6	st->metadata
water	22:46	0:0	7	st
op	22:48	0:0	7	->
water	22:50	0:0	7	metadata
arg	22:60	22:70	6	"language"
water	22:60	0:0	7	"language"
arg	22:72	22:76	6	NULL
water	22:72	0:0	7	NULL
arg	22:77	22:78	6	0
water	22:77	0:0	7	0
switch	23:8	56:8	4	(st -> codec -> codec_id)
cond	23:15	23:26	5	st -> codec -> codec_id
water	23:15	0:0	6	st
op	23:17	0:0	6	->
water	23:19	0:0	6	codec
op	23:24	0:0	6	->
water	23:26	0:0	6	codec_id
stmts	23:36	56:8	5	
water	23:36	0:0	6	{
label	24:8	24:35	6	case AV_CODEC_ID_MPEG1VIDEO :
label	25:8	25:35	6	case AV_CODEC_ID_MPEG2VIDEO :
water	26:12	0:0	6	stream_type
op	26:24	0:0	6	=
water	26:26	0:0	6	STREAM_TYPE_VIDEO_MPEG2
water	26:49	0:0	6	;
break	27:12	27:17	6	
label	28:8	28:30	6	case AV_CODEC_ID_MPEG4 :
water	29:12	0:0	6	stream_type
op	29:24	0:0	6	=
water	29:26	0:0	6	STREAM_TYPE_VIDEO_MPEG4
water	29:49	0:0	6	;
break	30:12	30:17	6	
label	31:8	31:29	6	case AV_CODEC_ID_H264 :
water	32:12	0:0	6	stream_type
op	32:24	0:0	6	=
water	32:26	0:0	6	STREAM_TYPE_VIDEO_H264
water	32:48	0:0	6	;
break	33:12	33:17	6	
label	34:8	34:29	6	case AV_CODEC_ID_CAVS :
water	35:12	0:0	6	stream_type
op	35:24	0:0	6	=
water	35:26	0:0	6	STREAM_TYPE_VIDEO_CAVS
water	35:48	0:0	6	;
break	36:12	36:17	6	
label	37:8	37:30	6	case AV_CODEC_ID_DIRAC :
water	38:12	0:0	6	stream_type
op	38:24	0:0	6	=
water	38:26	0:0	6	STREAM_TYPE_VIDEO_DIRAC
water	38:49	0:0	6	;
break	39:12	39:17	6	
label	40:8	40:28	6	case AV_CODEC_ID_MP2 :
label	41:8	41:28	6	case AV_CODEC_ID_MP3 :
water	42:12	0:0	6	stream_type
op	42:24	0:0	6	=
water	42:26	0:0	6	STREAM_TYPE_AUDIO_MPEG1
water	42:49	0:0	6	;
break	43:12	43:17	6	
label	44:8	44:28	6	case AV_CODEC_ID_AAC :
water	45:12	0:0	6	stream_type
op	45:24	0:0	6	=
water	45:26	0:0	6	(
water	45:27	0:0	6	ts
op	45:29	0:0	6	->
water	45:31	0:0	6	flags
op	45:37	0:0	6	&
water	45:39	0:0	6	MPEGTS_FLAG_AAC_LATM
water	45:59	0:0	6	)
water	45:61	0:0	6	?
water	45:63	0:0	6	STREAM_TYPE_AUDIO_AAC_LATM
water	45:90	0:0	6	:
water	45:92	0:0	6	STREAM_TYPE_AUDIO_AAC
water	45:113	0:0	6	;
break	46:12	46:17	6	
label	47:8	47:33	6	case AV_CODEC_ID_AAC_LATM :
water	48:12	0:0	6	stream_type
op	48:24	0:0	6	=
water	48:26	0:0	6	STREAM_TYPE_AUDIO_AAC_LATM
water	48:52	0:0	6	;
break	49:12	49:17	6	
label	50:8	50:28	6	case AV_CODEC_ID_AC3 :
water	51:12	0:0	6	stream_type
op	51:24	0:0	6	=
water	51:26	0:0	6	STREAM_TYPE_AUDIO_AC3
water	51:47	0:0	6	;
break	52:12	52:17	6	
label	53:8	53:15	6	default :
water	54:12	0:0	6	stream_type
op	54:24	0:0	6	=
water	54:26	0:0	6	STREAM_TYPE_PRIVATE_DATA
water	54:50	0:0	6	;
break	55:12	55:17	6	
water	56:8	0:0	6	}
if	58:8	59:34	4	(q - data > sizeof ( data ) - 32)
cond	58:12	58:38	5	q - data > sizeof ( data ) - 32
water	58:12	0:0	6	q
op	58:14	0:0	6	-
water	58:16	0:0	6	data
op	58:21	0:0	6	>
op	58:23	0:0	6	sizeof
water	58:29	0:0	6	(
water	58:30	0:0	6	data
water	58:34	0:0	6	)
op	58:36	0:0	6	-
water	58:38	0:0	6	32
stmts	59:12	59:34	5	
return	59:12	59:34	6	AVERROR(EINVAL)
call	59:19	59:33	7	AVERROR
arg	59:27	59:33	8	EINVAL
water	59:27	0:0	9	EINVAL
op	61:8	0:0	4	*
water	61:9	0:0	4	q
op	61:10	0:0	4	++
op	61:13	0:0	4	=
water	61:15	0:0	4	stream_type
water	61:26	0:0	4	;
call	62:8	62:37	4	put16
arg	62:14	62:16	5	&q
op	62:14	0:0	6	&
water	62:15	0:0	6	q
arg	62:18	62:37	5	0xe000|ts_st->pid
water	62:18	0:0	6	0
water	62:19	0:0	6	xe000
op	62:25	0:0	6	|
water	62:27	0:0	6	ts_st
op	62:32	0:0	6	->
water	62:34	0:0	6	pid
water	62:38	0:0	4	;
water	63:8	0:0	4	desc_length_ptr
op	63:24	0:0	4	=
water	63:26	0:0	4	q
water	63:27	0:0	4	;
water	64:8	0:0	4	q
op	64:10	0:0	4	+=
water	64:13	0:0	4	2
water	64:14	0:0	4	;
switch	67:8	156:8	4	(st -> codec -> codec_type)
cond	67:15	67:26	5	st -> codec -> codec_type
water	67:15	0:0	6	st
op	67:17	0:0	6	->
water	67:19	0:0	6	codec
op	67:24	0:0	6	->
water	67:26	0:0	6	codec_type
stmts	67:38	156:8	5	
water	67:38	0:0	6	{
label	68:8	68:31	6	case AVMEDIA_TYPE_AUDIO :
if	69:12	73:12	6	(st -> codec -> codec_id == AV_CODEC_ID_EAC3)
cond	69:15	69:36	7	st -> codec -> codec_id == AV_CODEC_ID_EAC3
water	69:15	0:0	8	st
op	69:17	0:0	8	->
water	69:19	0:0	8	codec
op	69:24	0:0	8	->
water	69:26	0:0	8	codec_id
op	69:34	0:0	8	==
water	69:36	0:0	8	AV_CODEC_ID_EAC3
stmts	69:53	73:12	7	
water	69:53	0:0	8	{
op	70:16	0:0	8	*
water	70:17	0:0	8	q
op	70:18	0:0	8	++
op	70:20	0:0	8	=
water	70:21	0:0	8	0
water	70:22	0:0	8	x7a
water	70:25	0:0	8	;
op	71:16	0:0	8	*
water	71:17	0:0	8	q
op	71:18	0:0	8	++
op	71:20	0:0	8	=
water	71:21	0:0	8	1
water	71:22	0:0	8	;
op	72:16	0:0	8	*
water	72:17	0:0	8	q
op	72:18	0:0	8	++
op	72:20	0:0	8	=
water	72:21	0:0	8	0
water	72:22	0:0	8	;
water	73:12	0:0	8	}
if	74:12	81:12	6	(st -> codec -> codec_id == AV_CODEC_ID_S302M)
cond	74:15	74:36	7	st -> codec -> codec_id == AV_CODEC_ID_S302M
water	74:15	0:0	8	st
op	74:17	0:0	8	->
water	74:19	0:0	8	codec
op	74:24	0:0	8	->
water	74:26	0:0	8	codec_id
op	74:34	0:0	8	==
water	74:36	0:0	8	AV_CODEC_ID_S302M
stmts	74:54	81:12	7	
water	74:54	0:0	8	{
op	75:16	0:0	8	*
water	75:17	0:0	8	q
op	75:18	0:0	8	++
op	75:21	0:0	8	=
water	75:23	0:0	8	0
water	75:24	0:0	8	x05
water	75:27	0:0	8	;
op	76:16	0:0	8	*
water	76:17	0:0	8	q
op	76:18	0:0	8	++
op	76:21	0:0	8	=
water	76:23	0:0	8	4
water	76:24	0:0	8	;
op	77:16	0:0	8	*
water	77:17	0:0	8	q
op	77:18	0:0	8	++
op	77:21	0:0	8	=
water	77:23	0:0	8	'B'
water	77:26	0:0	8	;
op	78:16	0:0	8	*
water	78:17	0:0	8	q
op	78:18	0:0	8	++
op	78:21	0:0	8	=
water	78:23	0:0	8	'S'
water	78:26	0:0	8	;
op	79:16	0:0	8	*
water	79:17	0:0	8	q
op	79:18	0:0	8	++
op	79:21	0:0	8	=
water	79:23	0:0	8	'S'
water	79:26	0:0	8	;
op	80:16	0:0	8	*
water	80:17	0:0	8	q
op	80:18	0:0	8	++
op	80:21	0:0	8	=
water	80:23	0:0	8	'D'
water	80:26	0:0	8	;
water	81:12	0:0	8	}
if	83:12	115:12	6	(lang)
cond	83:16	83:16	7	lang
water	83:16	0:0	8	lang
stmts	83:22	115:12	7	
water	83:22	0:0	8	{
decl	84:16	84:23	8	char	*p
decl	85:16	85:40	8	char	*next
op	85:27	0:0	8	=
water	85:29	0:0	8	lang
op	85:33	0:0	8	->
water	85:35	0:0	8	value
decl	86:16	86:32	8	uint8_t	*len_ptr
op	88:16	0:0	8	*
water	88:17	0:0	8	q
op	88:18	0:0	8	++
op	88:21	0:0	8	=
water	88:23	0:0	8	0
water	88:24	0:0	8	x0a
water	88:27	0:0	8	;
water	89:16	0:0	8	len_ptr
op	89:24	0:0	8	=
water	89:26	0:0	8	q
op	89:27	0:0	8	++
water	89:29	0:0	8	;
op	90:16	0:0	8	*
water	90:17	0:0	8	len_ptr
op	90:25	0:0	8	=
water	90:27	0:0	8	0
water	90:28	0:0	8	;
for	92:16	111:16	8	(p = lang -> value ;next && * len_ptr < 255 / 4 * 4 && q - data < sizeof ( data ) - 4;p = next + 1)
forinit	92:21	92:36	9	p = lang -> value ;
water	92:21	0:0	10	p
op	92:23	0:0	10	=
water	92:25	0:0	10	lang
op	92:29	0:0	10	->
water	92:31	0:0	10	value
water	92:36	0:0	10	;
cond	92:38	92:98	9	next && * len_ptr < 255 / 4 * 4 && q - data < sizeof ( data ) - 4
water	92:38	0:0	10	next
op	92:43	0:0	10	&&
op	92:46	0:0	10	*
water	92:47	0:0	10	len_ptr
op	92:55	0:0	10	<
water	92:57	0:0	10	255
op	92:61	0:0	10	/
water	92:63	0:0	10	4
op	92:65	0:0	10	*
water	92:67	0:0	10	4
op	92:69	0:0	10	&&
water	92:72	0:0	10	q
op	92:74	0:0	10	-
water	92:76	0:0	10	data
op	92:81	0:0	10	<
op	92:83	0:0	10	sizeof
water	92:89	0:0	10	(
water	92:90	0:0	10	data
water	92:94	0:0	10	)
op	92:96	0:0	10	-
water	92:98	0:0	10	4
forexpr	92:101	92:112	9	p = next + 1
water	92:101	0:0	10	p
op	92:103	0:0	10	=
water	92:105	0:0	10	next
op	92:110	0:0	10	+
water	92:112	0:0	10	1
stmts	92:115	111:16	9	
water	92:115	0:0	10	{
water	93:20	0:0	10	next
op	93:25	0:0	10	=
call	93:27	93:40	10	strchr
arg	93:34	93:35	11	p
water	93:34	0:0	12	p
arg	93:37	93:40	11	','
water	93:37	0:0	12	','
water	93:41	0:0	10	;
if	94:20	95:32	10	(strlen (p ) != 3 && ( ! next || next != p + 3 ))
cond	94:24	94:65	11	strlen (p ) != 3 && ( ! next || next != p + 3 )
call	94:24	94:32	12	strlen
arg	94:31	94:32	13	p
water	94:31	0:0	14	p
op	94:34	0:0	12	!=
water	94:37	0:0	12	3
op	94:39	0:0	12	&&
water	94:42	0:0	12	(
op	94:43	0:0	12	!
water	94:44	0:0	12	next
op	94:49	0:0	12	||
water	94:52	0:0	12	next
op	94:57	0:0	12	!=
water	94:60	0:0	12	p
op	94:62	0:0	12	+
water	94:64	0:0	12	3
water	94:65	0:0	12	)
stmts	95:24	95:32	11	
continue	95:24	95:32	12	
op	97:20	0:0	10	*
water	97:21	0:0	10	q
op	97:22	0:0	10	++
op	97:25	0:0	10	=
op	97:27	0:0	10	*
water	97:28	0:0	10	p
op	97:29	0:0	10	++
water	97:31	0:0	10	;
op	98:20	0:0	10	*
water	98:21	0:0	10	q
op	98:22	0:0	10	++
op	98:25	0:0	10	=
op	98:27	0:0	10	*
water	98:28	0:0	10	p
op	98:29	0:0	10	++
water	98:31	0:0	10	;
op	99:20	0:0	10	*
water	99:21	0:0	10	q
op	99:22	0:0	10	++
op	99:25	0:0	10	=
op	99:27	0:0	10	*
water	99:28	0:0	10	p
op	99:29	0:0	10	++
water	99:31	0:0	10	;
if	101:16	102:31	10	(st -> disposition & AV_DISPOSITION_CLEAN_EFFECTS)
cond	101:20	101:38	11	st -> disposition & AV_DISPOSITION_CLEAN_EFFECTS
water	101:20	0:0	12	st
op	101:22	0:0	12	->
water	101:24	0:0	12	disposition
op	101:36	0:0	12	&
water	101:38	0:0	12	AV_DISPOSITION_CLEAN_EFFECTS
stmts	102:20	102:31	11	
op	102:20	0:0	12	*
water	102:21	0:0	12	q
op	102:22	0:0	12	++
op	102:25	0:0	12	=
water	102:27	0:0	12	0
water	102:28	0:0	12	x01
water	102:31	0:0	12	;
else	103:16	104:31	10
stmts	103:21	104:31	11	
if	103:21	104:31	12	(st -> disposition & AV_DISPOSITION_HEARING_IMPAIRED)
cond	103:25	103:43	13	st -> disposition & AV_DISPOSITION_HEARING_IMPAIRED
water	103:25	0:0	14	st
op	103:27	0:0	14	->
water	103:29	0:0	14	disposition
op	103:41	0:0	14	&
water	103:43	0:0	14	AV_DISPOSITION_HEARING_IMPAIRED
stmts	104:20	104:31	13	
op	104:20	0:0	14	*
water	104:21	0:0	14	q
op	104:22	0:0	14	++
op	104:25	0:0	14	=
water	104:27	0:0	14	0
water	104:28	0:0	14	x02
water	104:31	0:0	14	;
else	105:16	106:31	10
stmts	105:21	106:31	11	
if	105:21	106:31	12	(st -> disposition & AV_DISPOSITION_VISUAL_IMPAIRED)
cond	105:25	105:43	13	st -> disposition & AV_DISPOSITION_VISUAL_IMPAIRED
water	105:25	0:0	14	st
op	105:27	0:0	14	->
water	105:29	0:0	14	disposition
op	105:41	0:0	14	&
water	105:43	0:0	14	AV_DISPOSITION_VISUAL_IMPAIRED
stmts	106:20	106:31	13	
op	106:20	0:0	14	*
water	106:21	0:0	14	q
op	106:22	0:0	14	++
op	106:25	0:0	14	=
water	106:27	0:0	14	0
water	106:28	0:0	14	x03
water	106:31	0:0	14	;
else	107:16	108:28	10
stmts	108:20	108:28	11	
op	108:20	0:0	12	*
water	108:21	0:0	12	q
op	108:22	0:0	12	++
op	108:25	0:0	12	=
water	108:27	0:0	12	0
water	108:28	0:0	12	;
op	110:20	0:0	10	*
water	110:21	0:0	10	len_ptr
op	110:29	0:0	10	+=
water	110:32	0:0	10	4
water	110:33	0:0	10	;
water	111:16	0:0	10	}
if	113:16	114:26	8	(* len_ptr == 0)
cond	113:20	113:32	9	* len_ptr == 0
op	113:20	0:0	10	*
water	113:21	0:0	10	len_ptr
op	113:29	0:0	10	==
water	113:32	0:0	10	0
stmts	114:20	114:26	9	
water	114:20	0:0	10	q
op	114:22	0:0	10	-=
water	114:25	0:0	10	2
water	114:26	0:0	10	;
water	115:12	0:0	8	}
break	116:12	116:17	6	
label	117:8	117:34	6	case AVMEDIA_TYPE_SUBTITLE :
water	118:12	0:0	6	{
decl	119:16	119:36	6	const char	*language
water	120:16	0:0	6	language
op	120:25	0:0	6	=
water	120:27	0:0	6	lang
op	120:32	0:0	6	&&
call	120:35	120:53	6	strlen
arg	120:42	120:53	7	lang->value
water	120:42	0:0	8	lang
op	120:46	0:0	8	->
water	120:48	0:0	8	value
op	120:54	0:0	6	==
water	120:56	0:0	6	3
water	120:58	0:0	6	?
water	120:60	0:0	6	lang
op	120:64	0:0	6	->
water	120:66	0:0	6	value
water	120:72	0:0	6	:
water	120:74	0:0	6	"eng"
water	120:79	0:0	6	;
op	121:16	0:0	6	*
water	121:17	0:0	6	q
op	121:18	0:0	6	++
op	121:21	0:0	6	=
water	121:23	0:0	6	0
water	121:24	0:0	6	x59
water	121:27	0:0	6	;
op	122:16	0:0	6	*
water	122:17	0:0	6	q
op	122:18	0:0	6	++
op	122:21	0:0	6	=
water	122:23	0:0	6	8
water	122:24	0:0	6	;
op	123:16	0:0	6	*
water	123:17	0:0	6	q
op	123:18	0:0	6	++
op	123:21	0:0	6	=
water	123:23	0:0	6	language
op	123:31	0:0	6	[
water	123:32	0:0	6	0
op	123:33	0:0	6	]
water	123:34	0:0	6	;
op	124:16	0:0	6	*
water	124:17	0:0	6	q
op	124:18	0:0	6	++
op	124:21	0:0	6	=
water	124:23	0:0	6	language
op	124:31	0:0	6	[
water	124:32	0:0	6	1
op	124:33	0:0	6	]
water	124:34	0:0	6	;
op	125:16	0:0	6	*
water	125:17	0:0	6	q
op	125:18	0:0	6	++
op	125:21	0:0	6	=
water	125:23	0:0	6	language
op	125:31	0:0	6	[
water	125:32	0:0	6	2
op	125:33	0:0	6	]
water	125:34	0:0	6	;
op	126:16	0:0	6	*
water	126:17	0:0	6	q
op	126:18	0:0	6	++
op	126:21	0:0	6	=
water	126:23	0:0	6	0
water	126:24	0:0	6	x10
water	126:27	0:0	6	;
if	127:16	130:16	6	(st -> codec -> extradata_size == 4)
cond	127:19	127:48	7	st -> codec -> extradata_size == 4
water	127:19	0:0	8	st
op	127:21	0:0	8	->
water	127:23	0:0	8	codec
op	127:28	0:0	8	->
water	127:30	0:0	8	extradata_size
op	127:45	0:0	8	==
water	127:48	0:0	8	4
stmts	127:51	130:16	7	
water	127:51	0:0	8	{
call	128:20	128:53	8	memcpy
arg	128:27	128:28	9	q
water	128:27	0:0	10	q
arg	128:30	128:50	9	st->codec->extradata
water	128:30	0:0	10	st
op	128:32	0:0	10	->
water	128:34	0:0	10	codec
op	128:39	0:0	10	->
water	128:41	0:0	10	extradata
arg	128:52	128:53	9	4
water	128:52	0:0	10	4
water	128:54	0:0	8	;
water	129:20	0:0	8	q
op	129:22	0:0	8	+=
water	129:25	0:0	8	4
water	129:26	0:0	8	;
water	130:16	0:0	8	}
else	130:18	133:16	6
stmts	130:23	133:16	7	
water	130:23	0:0	8	{
call	131:20	131:31	8	put16
arg	131:26	131:28	9	&q
op	131:26	0:0	10	&
water	131:27	0:0	10	q
arg	131:30	131:31	9	1
water	131:30	0:0	10	1
water	131:32	0:0	8	;
call	132:20	132:31	8	put16
arg	132:26	132:28	9	&q
op	132:26	0:0	10	&
water	132:27	0:0	10	q
arg	132:30	132:31	9	1
water	132:30	0:0	10	1
water	132:32	0:0	8	;
water	133:16	0:0	8	}
water	134:12	0:0	6	}
break	135:12	135:17	6	
label	136:8	136:31	6	case AVMEDIA_TYPE_VIDEO :
if	137:12	144:12	6	(stream_type == STREAM_TYPE_VIDEO_DIRAC)
cond	137:16	137:31	7	stream_type == STREAM_TYPE_VIDEO_DIRAC
water	137:16	0:0	8	stream_type
op	137:28	0:0	8	==
water	137:31	0:0	8	STREAM_TYPE_VIDEO_DIRAC
stmts	137:56	144:12	7	
water	137:56	0:0	8	{
op	138:16	0:0	8	*
water	138:17	0:0	8	q
op	138:18	0:0	8	++
op	138:21	0:0	8	=
water	138:23	0:0	8	0
water	138:24	0:0	8	x05
water	138:27	0:0	8	;
op	139:16	0:0	8	*
water	139:17	0:0	8	q
op	139:18	0:0	8	++
op	139:21	0:0	8	=
water	139:23	0:0	8	4
water	139:24	0:0	8	;
op	140:16	0:0	8	*
water	140:17	0:0	8	q
op	140:18	0:0	8	++
op	140:21	0:0	8	=
water	140:23	0:0	8	'd'
water	140:26	0:0	8	;
op	141:16	0:0	8	*
water	141:17	0:0	8	q
op	141:18	0:0	8	++
op	141:21	0:0	8	=
water	141:23	0:0	8	'r'
water	141:26	0:0	8	;
op	142:16	0:0	8	*
water	142:17	0:0	8	q
op	142:18	0:0	8	++
op	142:21	0:0	8	=
water	142:23	0:0	8	'a'
water	142:26	0:0	8	;
op	143:16	0:0	8	*
water	143:17	0:0	8	q
op	143:18	0:0	8	++
op	143:21	0:0	8	=
water	143:23	0:0	8	'c'
water	143:26	0:0	8	;
water	144:12	0:0	8	}
break	145:12	145:17	6	
label	146:8	146:30	6	case AVMEDIA_TYPE_DATA :
if	147:12	154:12	6	(st -> codec -> codec_id == AV_CODEC_ID_SMPTE_KLV)
cond	147:16	147:39	7	st -> codec -> codec_id == AV_CODEC_ID_SMPTE_KLV
water	147:16	0:0	8	st
op	147:18	0:0	8	->
water	147:20	0:0	8	codec
op	147:25	0:0	8	->
water	147:27	0:0	8	codec_id
op	147:36	0:0	8	==
water	147:39	0:0	8	AV_CODEC_ID_SMPTE_KLV
stmts	147:62	154:12	7	
water	147:62	0:0	8	{
op	148:16	0:0	8	*
water	148:17	0:0	8	q
op	148:18	0:0	8	++
op	148:21	0:0	8	=
water	148:23	0:0	8	0
water	148:24	0:0	8	x05
water	148:27	0:0	8	;
op	149:16	0:0	8	*
water	149:17	0:0	8	q
op	149:18	0:0	8	++
op	149:21	0:0	8	=
water	149:23	0:0	8	4
water	149:24	0:0	8	;
op	150:16	0:0	8	*
water	150:17	0:0	8	q
op	150:18	0:0	8	++
op	150:21	0:0	8	=
water	150:23	0:0	8	'K'
water	150:26	0:0	8	;
op	151:16	0:0	8	*
water	151:17	0:0	8	q
op	151:18	0:0	8	++
op	151:21	0:0	8	=
water	151:23	0:0	8	'L'
water	151:26	0:0	8	;
op	152:16	0:0	8	*
water	152:17	0:0	8	q
op	152:18	0:0	8	++
op	152:21	0:0	8	=
water	152:23	0:0	8	'V'
water	152:26	0:0	8	;
op	153:16	0:0	8	*
water	153:17	0:0	8	q
op	153:18	0:0	8	++
op	153:21	0:0	8	=
water	153:23	0:0	8	'A'
water	153:26	0:0	8	;
water	154:12	0:0	8	}
break	155:12	155:17	6	
water	156:8	0:0	6	}
water	158:8	0:0	4	val
op	158:12	0:0	4	=
water	158:14	0:0	4	0
water	158:15	0:0	4	xf000
op	158:21	0:0	4	|
water	158:23	0:0	4	(
water	158:24	0:0	4	q
op	158:26	0:0	4	-
water	158:28	0:0	4	desc_length_ptr
op	158:44	0:0	4	-
water	158:46	0:0	4	2
water	158:47	0:0	4	)
water	158:48	0:0	4	;
water	159:8	0:0	4	desc_length_ptr
op	159:23	0:0	4	[
water	159:24	0:0	4	0
op	159:25	0:0	4	]
op	159:27	0:0	4	=
water	159:29	0:0	4	val
op	159:33	0:0	4	>>
water	159:36	0:0	4	8
water	159:37	0:0	4	;
water	160:8	0:0	4	desc_length_ptr
op	160:23	0:0	4	[
water	160:24	0:0	4	1
op	160:25	0:0	4	]
op	160:27	0:0	4	=
water	160:29	0:0	4	val
water	160:32	0:0	4	;
water	161:4	0:0	4	}
call	162:4	163:40	2	mpegts_write_section1
arg	162:26	162:39	3	&service->pmt
op	162:26	0:0	4	&
water	162:27	0:0	4	service
op	162:34	0:0	4	->
water	162:36	0:0	4	pmt
arg	162:41	162:48	3	PMT_TID
water	162:41	0:0	4	PMT_TID
arg	162:50	162:62	3	service->sid
water	162:50	0:0	4	service
op	162:57	0:0	4	->
water	162:59	0:0	4	sid
arg	162:64	162:65	3	0
water	162:64	0:0	4	0
arg	162:67	162:68	3	0
water	162:67	0:0	4	0
arg	162:70	162:71	3	0
water	162:70	0:0	4	0
arg	163:26	163:30	3	data
water	163:26	0:0	4	data
arg	163:32	163:40	3	q-data
water	163:32	0:0	4	q
op	163:34	0:0	4	-
water	163:36	0:0	4	data
water	163:41	0:0	2	;
return	164:4	164:12	2	0
water	164:11	0:0	3	0
