func	1:0	96:0	0	static int	msrle_decode_pal4
params	1:28	0:0	1	
param	1:29	1:50	2	AVCodecContext *	avctx
param	1:52	1:66	2	AVPicture *	pic
param	2:29	2:47	2	GetByteContext *	gb
stmnts	0:0	95:12	1	
decl	4:4	4:26	2	unsigned char	rle_code
decl	5:4	5:39	2	unsigned char	extra_byte
water	5:28	0:0	2	,
decl	5:4	5:39	2	unsigned char	odd_pixel
decl	6:4	6:29	2	unsigned char	stream_byte
decl	7:4	7:30	2	unsigned int	pixel_ptr
op	7:27	0:0	2	=
water	7:29	0:0	2	0
decl	8:4	8:34	2	int	row_dec
op	8:16	0:0	2	=
water	8:18	0:0	2	pic
op	8:21	0:0	2	->
water	8:23	0:0	2	linesize
op	8:31	0:0	2	[
water	8:32	0:0	2	0
op	8:33	0:0	2	]
decl	9:4	9:47	2	int	row_ptr
op	9:16	0:0	2	=
water	9:18	0:0	2	(
water	9:19	0:0	2	avctx
op	9:24	0:0	2	->
water	9:26	0:0	2	height
op	9:33	0:0	2	-
water	9:35	0:0	2	1
water	9:36	0:0	2	)
op	9:38	0:0	2	*
water	9:40	0:0	2	row_dec
decl	10:4	10:44	2	int	frame_size
op	10:19	0:0	2	=
water	10:21	0:0	2	row_dec
op	10:29	0:0	2	*
water	10:31	0:0	2	avctx
op	10:36	0:0	2	->
water	10:38	0:0	2	height
decl	11:4	11:9	2	int	i
while	13:4	85:4	2	(row_ptr >= 0)
cond	13:11	13:22	3	row_ptr >= 0
water	13:11	0:0	4	row_ptr
op	13:19	0:0	4	>=
water	13:22	0:0	4	0
stmts	13:25	85:4	3	
water	13:25	0:0	4	{
if	14:8	19:8	4	(bytestream2_get_bytes_left (gb ) <= 0)
cond	14:12	14:46	5	bytestream2_get_bytes_left (gb ) <= 0
call	14:12	14:41	6	bytestream2_get_bytes_left
arg	14:39	14:41	7	gb
water	14:39	0:0	8	gb
op	14:43	0:0	6	<=
water	14:46	0:0	6	0
stmts	14:49	19:8	5	
water	14:49	0:0	6	{
call	15:12	17:26	6	av_log
arg	15:19	15:24	7	avctx
water	15:19	0:0	8	avctx
arg	15:26	15:38	7	AV_LOG_ERROR
water	15:26	0:0	8	AV_LOG_ERROR
arg	16:19	16:63	7	"MS RLE: bytestream overrun, %d rows left\n"
water	16:19	0:0	8	"MS RLE: bytestream overrun, %d rows left\n"
arg	17:19	17:26	7	row_ptr
water	17:19	0:0	8	row_ptr
water	17:27	0:0	6	;
return	18:12	18:38	6	AVERROR_INVALIDDATA
water	18:19	0:0	7	AVERROR_INVALIDDATA
water	19:8	0:0	6	}
water	20:8	0:0	4	rle_code
op	20:17	0:0	4	=
water	20:19	0:0	4	stream_byte
op	20:31	0:0	4	=
call	20:33	20:57	4	bytestream2_get_byteu
arg	20:55	20:57	5	gb
water	20:55	0:0	6	gb
water	20:58	0:0	4	;
if	21:8	67:8	4	(rle_code == 0)
cond	21:12	21:24	5	rle_code == 0
water	21:12	0:0	6	rle_code
op	21:21	0:0	6	==
water	21:24	0:0	6	0
stmts	21:27	67:8	5	
water	21:27	0:0	6	{
water	23:12	0:0	6	stream_byte
op	23:24	0:0	6	=
call	23:26	23:49	6	bytestream2_get_byte
arg	23:47	23:49	7	gb
water	23:47	0:0	8	gb
water	23:50	0:0	6	;
if	24:12	28:12	6	(stream_byte == 0)
cond	24:16	24:31	7	stream_byte == 0
water	24:16	0:0	8	stream_byte
op	24:28	0:0	8	==
water	24:31	0:0	8	0
stmts	24:34	28:12	7	
water	24:34	0:0	8	{
water	26:16	0:0	8	row_ptr
op	26:24	0:0	8	-=
water	26:27	0:0	8	row_dec
water	26:34	0:0	8	;
water	27:16	0:0	8	pixel_ptr
op	27:26	0:0	8	=
water	27:28	0:0	8	0
water	27:29	0:0	8	;
water	28:12	0:0	8	}
else	28:14	31:12	6
stmts	28:19	31:12	7	
if	28:19	31:12	8	(stream_byte == 1)
cond	28:23	28:38	9	stream_byte == 1
water	28:23	0:0	10	stream_byte
op	28:35	0:0	10	==
water	28:38	0:0	10	1
stmts	28:41	31:12	9	
water	28:41	0:0	10	{
return	30:16	30:24	10	0
water	30:23	0:0	11	0
water	31:12	0:0	10	}
else	31:14	37:12	6
stmts	31:19	37:12	7	
if	31:19	37:12	8	(stream_byte == 2)
cond	31:23	31:38	9	stream_byte == 2
water	31:23	0:0	10	stream_byte
op	31:35	0:0	10	==
water	31:38	0:0	10	2
stmts	31:41	37:12	9	
water	31:41	0:0	10	{
water	33:16	0:0	10	stream_byte
op	33:28	0:0	10	=
call	33:30	33:53	10	bytestream2_get_byte
arg	33:51	33:53	11	gb
water	33:51	0:0	12	gb
water	33:54	0:0	10	;
water	34:16	0:0	10	pixel_ptr
op	34:26	0:0	10	+=
water	34:29	0:0	10	stream_byte
water	34:40	0:0	10	;
water	35:16	0:0	10	stream_byte
op	35:28	0:0	10	=
call	35:30	35:53	10	bytestream2_get_byte
arg	35:51	35:53	11	gb
water	35:51	0:0	12	gb
water	35:54	0:0	10	;
water	36:16	0:0	10	row_ptr
op	36:24	0:0	10	-=
water	36:27	0:0	10	stream_byte
op	36:39	0:0	10	*
water	36:41	0:0	10	row_dec
water	36:48	0:0	10	;
water	37:12	0:0	10	}
else	37:14	66:12	6
stmts	37:19	66:12	7	
water	37:19	0:0	8	{
water	39:16	0:0	8	odd_pixel
op	39:26	0:0	8	=
water	39:29	0:0	8	stream_byte
op	39:41	0:0	8	&
water	39:43	0:0	8	1
water	39:44	0:0	8	;
water	40:16	0:0	8	rle_code
op	40:25	0:0	8	=
water	40:27	0:0	8	(
water	40:28	0:0	8	stream_byte
op	40:40	0:0	8	+
water	40:42	0:0	8	1
water	40:43	0:0	8	)
op	40:45	0:0	8	/
water	40:47	0:0	8	2
water	40:48	0:0	8	;
water	41:16	0:0	8	extra_byte
op	41:27	0:0	8	=
water	41:29	0:0	8	rle_code
op	41:38	0:0	8	&
water	41:40	0:0	8	0
water	41:41	0:0	8	x01
water	41:44	0:0	8	;
if	42:16	47:16	8	(row_ptr + pixel_ptr + stream_byte > frame_size ||bytestream2_get_bytes_left (gb ) < rle_code)
cond	42:20	43:53	9	row_ptr + pixel_ptr + stream_byte > frame_size ||bytestream2_get_bytes_left (gb ) < rle_code
water	42:20	0:0	10	row_ptr
op	42:28	0:0	10	+
water	42:30	0:0	10	pixel_ptr
op	42:40	0:0	10	+
water	42:42	0:0	10	stream_byte
op	42:54	0:0	10	>
water	42:56	0:0	10	frame_size
op	42:67	0:0	10	||
call	43:20	43:49	10	bytestream2_get_bytes_left
arg	43:47	43:49	11	gb
water	43:47	0:0	12	gb
op	43:51	0:0	10	<
water	43:53	0:0	10	rle_code
stmts	43:63	47:16	9	
water	43:63	0:0	10	{
call	44:20	45:86	10	av_log
arg	44:27	44:32	11	avctx
water	44:27	0:0	12	avctx
arg	44:34	44:46	11	AV_LOG_ERROR
water	44:34	0:0	12	AV_LOG_ERROR
arg	45:27	45:86	11	"MS RLE: frame/stream ptr just went out of bounds (copy)\n"
water	45:27	0:0	12	"MS RLE: frame/stream ptr just went out of bounds (copy)\n"
water	45:87	0:0	10	;
return	46:20	46:46	10	AVERROR_INVALIDDATA
water	46:27	0:0	11	AVERROR_INVALIDDATA
water	47:16	0:0	10	}
for	49:16	61:16	8	(i = 0 ;i < rle_code;i ++)
forinit	49:21	49:26	9	i = 0 ;
water	49:21	0:0	10	i
op	49:23	0:0	10	=
water	49:25	0:0	10	0
water	49:26	0:0	10	;
cond	49:28	49:32	9	i < rle_code
water	49:28	0:0	10	i
op	49:30	0:0	10	<
water	49:32	0:0	10	rle_code
forexpr	49:42	49:43	9	i ++
water	49:42	0:0	10	i
op	49:43	0:0	10	++
stmts	49:47	61:16	9	
water	49:47	0:0	10	{
if	50:20	51:29	10	(pixel_ptr >= avctx -> width)
cond	50:24	50:44	11	pixel_ptr >= avctx -> width
water	50:24	0:0	12	pixel_ptr
op	50:34	0:0	12	>=
water	50:37	0:0	12	avctx
op	50:42	0:0	12	->
water	50:44	0:0	12	width
stmts	51:24	51:29	11	
break	51:24	51:29	12	
water	52:20	0:0	10	stream_byte
op	52:32	0:0	10	=
call	52:34	52:58	10	bytestream2_get_byteu
arg	52:56	52:58	11	gb
water	52:56	0:0	12	gb
water	52:59	0:0	10	;
water	53:20	0:0	10	pic
op	53:23	0:0	10	->
water	53:25	0:0	10	data
op	53:29	0:0	10	[
water	53:30	0:0	10	0
op	53:31	0:0	10	]
op	53:32	0:0	10	[
water	53:33	0:0	10	row_ptr
op	53:41	0:0	10	+
water	53:43	0:0	10	pixel_ptr
op	53:52	0:0	10	]
op	53:54	0:0	10	=
water	53:56	0:0	10	stream_byte
op	53:68	0:0	10	>>
water	53:71	0:0	10	4
water	53:72	0:0	10	;
water	54:20	0:0	10	pixel_ptr
op	54:29	0:0	10	++
water	54:31	0:0	10	;
if	55:20	56:29	10	(i + 1 == rle_code && odd_pixel)
cond	55:24	55:45	11	i + 1 == rle_code && odd_pixel
water	55:24	0:0	12	i
op	55:26	0:0	12	+
water	55:28	0:0	12	1
op	55:30	0:0	12	==
water	55:33	0:0	12	rle_code
op	55:42	0:0	12	&&
water	55:45	0:0	12	odd_pixel
stmts	56:24	56:29	11	
break	56:24	56:29	12	
if	57:20	58:29	10	(pixel_ptr >= avctx -> width)
cond	57:24	57:44	11	pixel_ptr >= avctx -> width
water	57:24	0:0	12	pixel_ptr
op	57:34	0:0	12	>=
water	57:37	0:0	12	avctx
op	57:42	0:0	12	->
water	57:44	0:0	12	width
stmts	58:24	58:29	11	
break	58:24	58:29	12	
water	59:20	0:0	10	pic
op	59:23	0:0	10	->
water	59:25	0:0	10	data
op	59:29	0:0	10	[
water	59:30	0:0	10	0
op	59:31	0:0	10	]
op	59:32	0:0	10	[
water	59:33	0:0	10	row_ptr
op	59:41	0:0	10	+
water	59:43	0:0	10	pixel_ptr
op	59:52	0:0	10	]
op	59:54	0:0	10	=
water	59:56	0:0	10	stream_byte
op	59:68	0:0	10	&
water	59:70	0:0	10	0
water	59:71	0:0	10	x0F
water	59:74	0:0	10	;
water	60:20	0:0	10	pixel_ptr
op	60:29	0:0	10	++
water	60:31	0:0	10	;
water	61:16	0:0	10	}
if	64:16	65:43	8	(extra_byte)
cond	64:20	64:20	9	extra_byte
water	64:20	0:0	10	extra_byte
stmts	65:20	65:43	9	
call	65:20	65:42	10	bytestream2_skip
arg	65:37	65:39	11	gb
water	65:37	0:0	12	gb
arg	65:41	65:42	11	1
water	65:41	0:0	12	1
water	65:43	0:0	10	;
water	66:12	0:0	8	}
water	67:8	0:0	6	}
else	67:10	84:8	4
stmts	67:15	84:8	5	
water	67:15	0:0	6	{
if	69:12	73:12	6	(row_ptr + pixel_ptr + stream_byte > frame_size)
cond	69:16	69:52	7	row_ptr + pixel_ptr + stream_byte > frame_size
water	69:16	0:0	8	row_ptr
op	69:24	0:0	8	+
water	69:26	0:0	8	pixel_ptr
op	69:36	0:0	8	+
water	69:38	0:0	8	stream_byte
op	69:50	0:0	8	>
water	69:52	0:0	8	frame_size
stmts	69:64	73:12	7	
water	69:64	0:0	8	{
call	70:16	71:74	8	av_log
arg	70:23	70:28	9	avctx
water	70:23	0:0	10	avctx
arg	70:30	70:42	9	AV_LOG_ERROR
water	70:30	0:0	10	AV_LOG_ERROR
arg	71:23	71:74	9	"MS RLE: frame ptr just went out of bounds (run)\n"
water	71:23	0:0	10	"MS RLE: frame ptr just went out of bounds (run)\n"
water	71:75	0:0	8	;
return	72:16	72:42	8	AVERROR_INVALIDDATA
water	72:23	0:0	9	AVERROR_INVALIDDATA
water	73:12	0:0	8	}
water	74:12	0:0	6	stream_byte
op	74:24	0:0	6	=
call	74:26	74:49	6	bytestream2_get_byte
arg	74:47	74:49	7	gb
water	74:47	0:0	8	gb
water	74:50	0:0	6	;
for	75:12	83:12	6	(i = 0 ;i < rle_code;i ++)
forinit	75:17	75:22	7	i = 0 ;
water	75:17	0:0	8	i
op	75:19	0:0	8	=
water	75:21	0:0	8	0
water	75:22	0:0	8	;
cond	75:24	75:28	7	i < rle_code
water	75:24	0:0	8	i
op	75:26	0:0	8	<
water	75:28	0:0	8	rle_code
forexpr	75:38	75:39	7	i ++
water	75:38	0:0	8	i
op	75:39	0:0	8	++
stmts	75:43	83:12	7	
water	75:43	0:0	8	{
if	76:16	77:25	8	(pixel_ptr >= avctx -> width)
cond	76:20	76:40	9	pixel_ptr >= avctx -> width
water	76:20	0:0	10	pixel_ptr
op	76:30	0:0	10	>=
water	76:33	0:0	10	avctx
op	76:38	0:0	10	->
water	76:40	0:0	10	width
stmts	77:20	77:25	9	
break	77:20	77:25	10	
if	78:16	79:72	8	(( i & 1 ) == 0)
cond	78:20	78:31	9	( i & 1 ) == 0
water	78:20	0:0	10	(
water	78:21	0:0	10	i
op	78:23	0:0	10	&
water	78:25	0:0	10	1
water	78:26	0:0	10	)
op	78:28	0:0	10	==
water	78:31	0:0	10	0
stmts	79:20	79:72	9	
water	79:20	0:0	10	pic
op	79:23	0:0	10	->
water	79:25	0:0	10	data
op	79:29	0:0	10	[
water	79:30	0:0	10	0
op	79:31	0:0	10	]
op	79:32	0:0	10	[
water	79:33	0:0	10	row_ptr
op	79:41	0:0	10	+
water	79:43	0:0	10	pixel_ptr
op	79:52	0:0	10	]
op	79:54	0:0	10	=
water	79:56	0:0	10	stream_byte
op	79:68	0:0	10	>>
water	79:71	0:0	10	4
water	79:72	0:0	10	;
else	80:16	81:74	8
stmts	81:20	81:74	9	
water	81:20	0:0	10	pic
op	81:23	0:0	10	->
water	81:25	0:0	10	data
op	81:29	0:0	10	[
water	81:30	0:0	10	0
op	81:31	0:0	10	]
op	81:32	0:0	10	[
water	81:33	0:0	10	row_ptr
op	81:41	0:0	10	+
water	81:43	0:0	10	pixel_ptr
op	81:52	0:0	10	]
op	81:54	0:0	10	=
water	81:56	0:0	10	stream_byte
op	81:68	0:0	10	&
water	81:70	0:0	10	0
water	81:71	0:0	10	x0F
water	81:74	0:0	10	;
water	82:16	0:0	8	pixel_ptr
op	82:25	0:0	8	++
water	82:27	0:0	8	;
water	83:12	0:0	8	}
water	84:8	0:0	6	}
water	85:4	0:0	4	}
if	88:4	93:4	2	(bytestream2_get_bytes_left (gb ))
cond	88:8	88:37	3	bytestream2_get_bytes_left (gb )
call	88:8	88:37	4	bytestream2_get_bytes_left
arg	88:35	88:37	5	gb
water	88:35	0:0	6	gb
stmts	88:40	93:4	3	
water	88:40	0:0	4	{
call	89:8	91:45	4	av_log
arg	89:15	89:20	5	avctx
water	89:15	0:0	6	avctx
arg	89:22	89:34	5	AV_LOG_ERROR
water	89:22	0:0	6	AV_LOG_ERROR
arg	90:15	90:69	5	"MS RLE: ended frame decode with %d bytes left over\n"
water	90:15	0:0	6	"MS RLE: ended frame decode with %d bytes left over\n"
arg	91:15	91:45	5	bytestream2_get_bytes_left(gb)
call	91:15	91:44	6	bytestream2_get_bytes_left
arg	91:42	91:44	7	gb
water	91:42	0:0	8	gb
water	91:46	0:0	4	;
return	92:8	92:34	4	AVERROR_INVALIDDATA
water	92:15	0:0	5	AVERROR_INVALIDDATA
water	93:4	0:0	4	}
return	95:4	95:12	2	0
water	95:11	0:0	3	0
