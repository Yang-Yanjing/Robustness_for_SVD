func	2:0	65:0	0	int	ff_combine_frame
params	2:20	0:0	1	
param	2:21	2:37	2	ParseContext *	pc
param	2:39	2:47	2	int	next
param	2:49	2:68	2	const uint8_t * *	buf
param	2:70	2:83	2	int *	buf_size
stmnts	4:4	64:12	1	
if	4:4	8:4	2	(pc -> overread)
cond	4:7	4:11	3	pc -> overread
water	4:7	0:0	4	pc
op	4:9	0:0	4	->
water	4:11	0:0	4	overread
stmts	4:20	8:4	3	
water	4:20	0:0	4	{
call	5:8	6:76	4	av_dlog
arg	5:16	5:20	5	NULL
water	5:16	0:0	6	NULL
arg	5:22	5:75	5	"overread %d, state:%X next:%d index:%d o_index:%d\n"
water	5:22	0:0	6	"overread %d, state:%X next:%d index:%d o_index:%d\n"
arg	6:16	6:28	5	pc->overread
water	6:16	0:0	6	pc
op	6:18	0:0	6	->
water	6:20	0:0	6	overread
arg	6:30	6:39	5	pc->state
water	6:30	0:0	6	pc
op	6:32	0:0	6	->
water	6:34	0:0	6	state
arg	6:41	6:45	5	next
water	6:41	0:0	6	next
arg	6:47	6:56	5	pc->index
water	6:47	0:0	6	pc
op	6:49	0:0	6	->
water	6:51	0:0	6	index
arg	6:58	6:76	5	pc->overread_index
water	6:58	0:0	6	pc
op	6:60	0:0	6	->
water	6:62	0:0	6	overread_index
water	6:77	0:0	4	;
call	7:8	7:81	4	av_dlog
arg	7:16	7:20	5	NULL
water	7:16	0:0	6	NULL
arg	7:22	7:37	5	"%X %X %X %X\n"
water	7:22	0:0	6	"%X %X %X %X\n"
arg	7:39	7:48	5	(*buf)[0]
water	7:39	0:0	6	(
op	7:40	0:0	6	*
water	7:41	0:0	6	buf
water	7:44	0:0	6	)
op	7:45	0:0	6	[
water	7:46	0:0	6	0
op	7:47	0:0	6	]
arg	7:50	7:59	5	(*buf)[1]
water	7:50	0:0	6	(
op	7:51	0:0	6	*
water	7:52	0:0	6	buf
water	7:55	0:0	6	)
op	7:56	0:0	6	[
water	7:57	0:0	6	1
op	7:58	0:0	6	]
arg	7:61	7:70	5	(*buf)[2]
water	7:61	0:0	6	(
op	7:62	0:0	6	*
water	7:63	0:0	6	buf
water	7:66	0:0	6	)
op	7:67	0:0	6	[
water	7:68	0:0	6	2
op	7:69	0:0	6	]
arg	7:72	7:81	5	(*buf)[3]
water	7:72	0:0	6	(
op	7:73	0:0	6	*
water	7:74	0:0	6	buf
water	7:77	0:0	6	)
op	7:78	0:0	6	[
water	7:79	0:0	6	3
op	7:80	0:0	6	]
water	7:82	0:0	4	;
water	8:4	0:0	4	}
for	11:4	13:4	2	(;pc -> overread > 0;pc -> overread --)
forinit	11:8	11:8	3	;
water	11:8	0:0	4	;
cond	11:10	11:23	3	pc -> overread > 0
water	11:10	0:0	4	pc
op	11:12	0:0	4	->
water	11:14	0:0	4	overread
op	11:22	0:0	4	>
water	11:23	0:0	4	0
forexpr	11:26	11:38	3	pc -> overread --
water	11:26	0:0	4	pc
op	11:28	0:0	4	->
water	11:30	0:0	4	overread
op	11:38	0:0	4	--
stmts	11:41	13:4	3	
water	11:41	0:0	4	{
water	12:8	0:0	4	pc
op	12:10	0:0	4	->
water	12:12	0:0	4	buffer
op	12:18	0:0	4	[
water	12:19	0:0	4	pc
op	12:21	0:0	4	->
water	12:23	0:0	4	index
op	12:28	0:0	4	++
op	12:30	0:0	4	]
op	12:31	0:0	4	=
water	12:33	0:0	4	pc
op	12:35	0:0	4	->
water	12:37	0:0	4	buffer
op	12:43	0:0	4	[
water	12:44	0:0	4	pc
op	12:46	0:0	4	->
water	12:48	0:0	4	overread_index
op	12:62	0:0	4	++
op	12:64	0:0	4	]
water	12:65	0:0	4	;
water	13:4	0:0	4	}
if	16:4	18:4	2	(! * buf_size && next == END_NOT_FOUND)
cond	16:7	16:29	3	! * buf_size && next == END_NOT_FOUND
op	16:7	0:0	4	!
op	16:8	0:0	4	*
water	16:9	0:0	4	buf_size
op	16:18	0:0	4	&&
water	16:21	0:0	4	next
op	16:26	0:0	4	==
water	16:29	0:0	4	END_NOT_FOUND
stmts	16:43	18:4	3	
water	16:43	0:0	4	{
water	17:8	0:0	4	next
op	17:12	0:0	4	=
water	17:14	0:0	4	0
water	17:15	0:0	4	;
water	18:4	0:0	4	}
water	20:4	0:0	2	pc
op	20:6	0:0	2	->
water	20:8	0:0	2	last_index
op	20:18	0:0	2	=
water	20:20	0:0	2	pc
op	20:22	0:0	2	->
water	20:24	0:0	2	index
water	20:29	0:0	2	;
if	23:4	32:4	2	(next == END_NOT_FOUND)
cond	23:7	23:15	3	next == END_NOT_FOUND
water	23:7	0:0	4	next
op	23:12	0:0	4	==
water	23:15	0:0	4	END_NOT_FOUND
stmts	23:29	32:4	3	
water	23:29	0:0	4	{
decl	24:8	24:128	4	void	*new_buffer
op	24:25	0:0	4	=
call	24:27	24:127	5	av_fast_realloc
arg	24:43	24:53	6	pc->buffer
water	24:43	0:0	7	pc
op	24:45	0:0	7	->
water	24:47	0:0	7	buffer
arg	24:55	24:71	6	&pc->buffer_size
op	24:55	0:0	7	&
water	24:56	0:0	7	pc
op	24:58	0:0	7	->
water	24:60	0:0	7	buffer_size
arg	24:73	24:127	6	(*buf_size)+pc->index+FF_INPUT_BUFFER_PADDING_SIZE
water	24:73	0:0	7	(
op	24:74	0:0	7	*
water	24:75	0:0	7	buf_size
water	24:83	0:0	7	)
op	24:85	0:0	7	+
water	24:87	0:0	7	pc
op	24:89	0:0	7	->
water	24:91	0:0	7	index
op	24:97	0:0	7	+
water	24:99	0:0	7	FF_INPUT_BUFFER_PADDING_SIZE
if	26:8	27:34	4	(! new_buffer)
cond	26:11	26:12	5	! new_buffer
op	26:11	0:0	6	!
water	26:12	0:0	6	new_buffer
stmts	27:12	27:34	5	
return	27:12	27:34	6	AVERROR(ENOMEM)
call	27:19	27:33	7	AVERROR
arg	27:27	27:33	8	ENOMEM
water	27:27	0:0	9	ENOMEM
water	28:8	0:0	4	pc
op	28:10	0:0	4	->
water	28:12	0:0	4	buffer
op	28:19	0:0	4	=
water	28:21	0:0	4	new_buffer
water	28:31	0:0	4	;
call	29:8	29:54	4	memcpy
arg	29:15	29:37	5	&pc->buffer[pc->index]
op	29:15	0:0	6	&
water	29:16	0:0	6	pc
op	29:18	0:0	6	->
water	29:20	0:0	6	buffer
op	29:26	0:0	6	[
water	29:27	0:0	6	pc
op	29:29	0:0	6	->
water	29:31	0:0	6	index
op	29:36	0:0	6	]
arg	29:39	29:43	5	*buf
op	29:39	0:0	6	*
water	29:40	0:0	6	buf
arg	29:45	29:54	5	*buf_size
op	29:45	0:0	6	*
water	29:46	0:0	6	buf_size
water	29:55	0:0	4	;
water	30:8	0:0	4	pc
op	30:10	0:0	4	->
water	30:12	0:0	4	index
op	30:18	0:0	4	+=
op	30:21	0:0	4	*
water	30:22	0:0	4	buf_size
water	30:30	0:0	4	;
return	31:8	31:17	4	-1
op	31:15	0:0	5	-
water	31:16	0:0	5	1
water	32:4	0:0	4	}
op	34:4	0:0	2	*
water	34:5	0:0	2	buf_size
op	34:13	0:0	2	=
water	35:4	0:0	2	pc
op	35:6	0:0	2	->
water	35:8	0:0	2	overread_index
op	35:22	0:0	2	=
water	35:24	0:0	2	pc
op	35:26	0:0	2	->
water	35:28	0:0	2	index
op	35:34	0:0	2	+
water	35:36	0:0	2	next
water	35:40	0:0	2	;
if	38:4	49:4	2	(pc -> index)
cond	38:7	38:11	3	pc -> index
water	38:7	0:0	4	pc
op	38:9	0:0	4	->
water	38:11	0:0	4	index
stmts	38:17	49:4	3	
water	38:17	0:0	4	{
decl	39:8	39:121	4	void	*new_buffer
op	39:25	0:0	4	=
call	39:27	39:120	5	av_fast_realloc
arg	39:43	39:53	6	pc->buffer
water	39:43	0:0	7	pc
op	39:45	0:0	7	->
water	39:47	0:0	7	buffer
arg	39:55	39:71	6	&pc->buffer_size
op	39:55	0:0	7	&
water	39:56	0:0	7	pc
op	39:58	0:0	7	->
water	39:60	0:0	7	buffer_size
arg	39:73	39:120	6	next+pc->index+FF_INPUT_BUFFER_PADDING_SIZE
water	39:73	0:0	7	next
op	39:78	0:0	7	+
water	39:80	0:0	7	pc
op	39:82	0:0	7	->
water	39:84	0:0	7	index
op	39:90	0:0	7	+
water	39:92	0:0	7	FF_INPUT_BUFFER_PADDING_SIZE
if	41:8	42:34	4	(! new_buffer)
cond	41:11	41:12	5	! new_buffer
op	41:11	0:0	6	!
water	41:12	0:0	6	new_buffer
stmts	42:12	42:34	5	
return	42:12	42:34	6	AVERROR(ENOMEM)
call	42:19	42:33	7	AVERROR
arg	42:27	42:33	8	ENOMEM
water	42:27	0:0	9	ENOMEM
water	43:8	0:0	4	pc
op	43:10	0:0	4	->
water	43:12	0:0	4	buffer
op	43:19	0:0	4	=
water	43:21	0:0	4	new_buffer
water	43:31	0:0	4	;
if	44:8	46:55	4	(next > - FF_INPUT_BUFFER_PADDING_SIZE)
cond	44:12	44:20	5	next > - FF_INPUT_BUFFER_PADDING_SIZE
water	44:12	0:0	6	next
op	44:17	0:0	6	>
op	44:19	0:0	6	-
water	44:20	0:0	6	FF_INPUT_BUFFER_PADDING_SIZE
stmts	45:12	46:55	5	
call	45:12	46:54	6	memcpy
arg	45:19	45:41	7	&pc->buffer[pc->index]
op	45:19	0:0	8	&
water	45:20	0:0	8	pc
op	45:22	0:0	8	->
water	45:24	0:0	8	buffer
op	45:30	0:0	8	[
water	45:31	0:0	8	pc
op	45:33	0:0	8	->
water	45:35	0:0	8	index
op	45:40	0:0	8	]
arg	45:43	45:47	7	*buf
op	45:43	0:0	8	*
water	45:44	0:0	8	buf
arg	46:19	46:54	7	next+FF_INPUT_BUFFER_PADDING_SIZE
water	46:19	0:0	8	next
op	46:24	0:0	8	+
water	46:26	0:0	8	FF_INPUT_BUFFER_PADDING_SIZE
water	46:55	0:0	6	;
water	47:8	0:0	4	pc
op	47:10	0:0	4	->
water	47:12	0:0	4	index
op	47:18	0:0	4	=
water	47:20	0:0	4	0
water	47:21	0:0	4	;
op	48:8	0:0	4	*
water	48:9	0:0	4	buf
op	48:12	0:0	4	=
water	48:14	0:0	4	pc
op	48:16	0:0	4	->
water	48:18	0:0	4	buffer
water	48:24	0:0	4	;
water	49:4	0:0	4	}
for	52:4	56:4	2	(;next < 0;next ++)
forinit	52:8	52:8	3	;
water	52:8	0:0	4	;
cond	52:9	52:16	3	next < 0
water	52:9	0:0	4	next
op	52:14	0:0	4	<
water	52:16	0:0	4	0
forexpr	52:19	52:23	3	next ++
water	52:19	0:0	4	next
op	52:23	0:0	4	++
stmts	52:26	56:4	3	
water	52:26	0:0	4	{
water	53:8	0:0	4	pc
op	53:10	0:0	4	->
water	53:12	0:0	4	state
op	53:18	0:0	4	=
water	53:20	0:0	4	(
water	53:21	0:0	4	pc
op	53:23	0:0	4	->
water	53:25	0:0	4	state
op	53:30	0:0	4	<<
water	53:32	0:0	4	8
water	53:33	0:0	4	)
op	53:35	0:0	4	|
water	53:37	0:0	4	pc
op	53:39	0:0	4	->
water	53:41	0:0	4	buffer
op	53:47	0:0	4	[
water	53:48	0:0	4	pc
op	53:50	0:0	4	->
water	53:52	0:0	4	last_index
op	53:63	0:0	4	+
water	53:65	0:0	4	next
op	53:69	0:0	4	]
water	53:70	0:0	4	;
water	54:8	0:0	4	pc
op	54:10	0:0	4	->
water	54:12	0:0	4	state64
op	54:20	0:0	4	=
water	54:22	0:0	4	(
water	54:23	0:0	4	pc
op	54:25	0:0	4	->
water	54:27	0:0	4	state64
op	54:34	0:0	4	<<
water	54:36	0:0	4	8
water	54:37	0:0	4	)
op	54:39	0:0	4	|
water	54:41	0:0	4	pc
op	54:43	0:0	4	->
water	54:45	0:0	4	buffer
op	54:51	0:0	4	[
water	54:52	0:0	4	pc
op	54:54	0:0	4	->
water	54:56	0:0	4	last_index
op	54:67	0:0	4	+
water	54:69	0:0	4	next
op	54:73	0:0	4	]
water	54:74	0:0	4	;
water	55:8	0:0	4	pc
op	55:10	0:0	4	->
water	55:12	0:0	4	overread
op	55:20	0:0	4	++
water	55:22	0:0	4	;
water	56:4	0:0	4	}
if	58:4	62:4	2	(pc -> overread)
cond	58:7	58:11	3	pc -> overread
water	58:7	0:0	4	pc
op	58:9	0:0	4	->
water	58:11	0:0	4	overread
stmts	58:20	62:4	3	
water	58:20	0:0	4	{
call	59:8	60:76	4	av_dlog
arg	59:16	59:20	5	NULL
water	59:16	0:0	6	NULL
arg	59:22	59:75	5	"overread %d, state:%X next:%d index:%d o_index:%d\n"
water	59:22	0:0	6	"overread %d, state:%X next:%d index:%d o_index:%d\n"
arg	60:16	60:28	5	pc->overread
water	60:16	0:0	6	pc
op	60:18	0:0	6	->
water	60:20	0:0	6	overread
arg	60:30	60:39	5	pc->state
water	60:30	0:0	6	pc
op	60:32	0:0	6	->
water	60:34	0:0	6	state
arg	60:41	60:45	5	next
water	60:41	0:0	6	next
arg	60:47	60:56	5	pc->index
water	60:47	0:0	6	pc
op	60:49	0:0	6	->
water	60:51	0:0	6	index
arg	60:58	60:76	5	pc->overread_index
water	60:58	0:0	6	pc
op	60:60	0:0	6	->
water	60:62	0:0	6	overread_index
water	60:77	0:0	4	;
call	61:8	61:79	4	av_dlog
arg	61:16	61:20	5	NULL
water	61:16	0:0	6	NULL
arg	61:22	61:37	5	"%X %X %X %X\n"
water	61:22	0:0	6	"%X %X %X %X\n"
arg	61:39	61:48	5	(*buf)[0]
water	61:39	0:0	6	(
op	61:40	0:0	6	*
water	61:41	0:0	6	buf
water	61:44	0:0	6	)
op	61:45	0:0	6	[
water	61:46	0:0	6	0
op	61:47	0:0	6	]
arg	61:50	61:59	5	(*buf)[1]
water	61:50	0:0	6	(
op	61:51	0:0	6	*
water	61:52	0:0	6	buf
water	61:55	0:0	6	)
op	61:56	0:0	6	[
water	61:57	0:0	6	1
op	61:58	0:0	6	]
arg	61:60	61:69	5	(*buf)[2]
water	61:60	0:0	6	(
op	61:61	0:0	6	*
water	61:62	0:0	6	buf
water	61:65	0:0	6	)
op	61:66	0:0	6	[
water	61:67	0:0	6	2
op	61:68	0:0	6	]
arg	61:70	61:79	5	(*buf)[3]
water	61:70	0:0	6	(
op	61:71	0:0	6	*
water	61:72	0:0	6	buf
water	61:75	0:0	6	)
op	61:76	0:0	6	[
water	61:77	0:0	6	3
op	61:78	0:0	6	]
water	61:80	0:0	4	;
water	62:4	0:0	4	}
return	64:4	64:12	2	0
water	64:11	0:0	3	0
