func	2:0	125:0	0	static int	str_read_packet
params	2:26	0:0	1	
param	2:27	2:45	2	AVFormatContext *	s
param	3:27	3:44	2	AVPacket *	ret_pkt
stmnts	0:0	124:4	1	
decl	8:4	8:29	2	ByteIOContext	*pb
op	8:22	0:0	2	=
water	8:24	0:0	2	s
op	8:25	0:0	2	->
water	8:27	0:0	2	pb
decl	9:4	9:39	2	StrDemuxContext	*str
op	9:25	0:0	2	=
water	9:27	0:0	2	s
op	9:28	0:0	2	->
water	9:30	0:0	2	priv_data
decl	10:4	10:44	2	unsigned char	sector[RAW_CD_SECTOR_SIZE]
decl	11:4	11:15	2	int	channel
decl	12:4	12:17	2	AVPacket	*pkt
decl	13:4	13:16	2	AVStream	*st
while	15:4	124:4	2	(1)
cond	15:11	15:11	3	1
water	15:11	0:0	4	1
stmts	15:14	124:4	3	
water	15:14	0:0	4	{
if	17:8	18:31	4	(get_buffer (pb ,sector ,RAW_CD_SECTOR_SIZE ) != RAW_CD_SECTOR_SIZE)
cond	17:12	17:58	5	get_buffer (pb ,sector ,RAW_CD_SECTOR_SIZE ) != RAW_CD_SECTOR_SIZE
call	17:12	17:53	6	get_buffer
arg	17:23	17:25	7	pb
water	17:23	0:0	8	pb
arg	17:27	17:33	7	sector
water	17:27	0:0	8	sector
arg	17:35	17:53	7	RAW_CD_SECTOR_SIZE
water	17:35	0:0	8	RAW_CD_SECTOR_SIZE
op	17:55	0:0	6	!=
water	17:58	0:0	6	RAW_CD_SECTOR_SIZE
stmts	18:12	18:31	5	
return	18:12	18:31	6	AVERROR(EIO)
call	18:19	18:30	7	AVERROR
arg	18:27	18:30	8	EIO
water	18:27	0:0	9	EIO
water	20:8	0:0	4	channel
op	20:16	0:0	4	=
water	20:18	0:0	4	sector
op	20:24	0:0	4	[
water	20:25	0:0	4	0
water	20:26	0:0	4	x11
op	20:29	0:0	4	]
water	20:30	0:0	4	;
if	21:8	22:38	4	(channel >= 32)
cond	21:12	21:23	5	channel >= 32
water	21:12	0:0	6	channel
op	21:20	0:0	6	>=
water	21:23	0:0	6	32
stmts	22:12	22:38	5	
return	22:12	22:38	6	AVERROR_INVALIDDATA
water	22:19	0:0	7	AVERROR_INVALIDDATA
switch	24:8	120:8	4	(sector [ 0 x12 ] & CDXA_TYPE_MASK)
cond	24:16	24:31	5	sector [ 0 x12 ] & CDXA_TYPE_MASK
water	24:16	0:0	6	sector
op	24:22	0:0	6	[
water	24:23	0:0	6	0
water	24:24	0:0	6	x12
op	24:27	0:0	6	]
op	24:29	0:0	6	&
water	24:31	0:0	6	CDXA_TYPE_MASK
stmts	24:47	120:8	5	
water	24:47	0:0	6	{
label	26:8	26:27	6	case CDXA_TYPE_DATA :
label	27:8	27:28	6	case CDXA_TYPE_VIDEO :
water	28:12	0:0	6	{
decl	30:16	30:59	6	int	current_sector
op	30:35	0:0	6	=
call	30:37	30:58	7	AV_RL16
arg	30:45	30:58	8	&sector[0x1C]
op	30:45	0:0	9	&
water	30:46	0:0	9	sector
op	30:52	0:0	9	[
water	30:53	0:0	9	0
water	30:54	0:0	9	x1C
op	30:57	0:0	9	]
decl	31:16	31:59	6	int	sector_count
op	31:35	0:0	6	=
call	31:37	31:58	7	AV_RL16
arg	31:45	31:58	8	&sector[0x1E]
op	31:45	0:0	9	&
water	31:46	0:0	9	sector
op	31:52	0:0	9	[
water	31:53	0:0	9	0
water	31:54	0:0	9	x1E
op	31:57	0:0	9	]
decl	32:16	32:55	6	int	frame_size
op	32:31	0:0	6	=
call	32:33	32:54	7	AV_RL32
arg	32:41	32:54	8	&sector[0x24]
op	32:41	0:0	9	&
water	32:42	0:0	9	sector
op	32:48	0:0	9	[
water	32:49	0:0	9	0
water	32:50	0:0	9	x24
op	32:53	0:0	9	]
if	34:16	39:16	6	(! ( frame_size >= 0 && current_sector < sector_count && sector_count * VIDEO_DATA_CHUNK_SIZE >= frame_size ))
cond	34:19	36:71	7	! ( frame_size >= 0 && current_sector < sector_count && sector_count * VIDEO_DATA_CHUNK_SIZE >= frame_size )
op	34:19	0:0	8	!
water	34:20	0:0	8	(
water	34:24	0:0	8	frame_size
op	34:34	0:0	8	>=
water	34:36	0:0	8	0
op	35:21	0:0	8	&&
water	35:24	0:0	8	current_sector
op	35:39	0:0	8	<
water	35:41	0:0	8	sector_count
op	36:21	0:0	8	&&
water	36:24	0:0	8	sector_count
op	36:36	0:0	8	*
water	36:37	0:0	8	VIDEO_DATA_CHUNK_SIZE
op	36:59	0:0	8	>=
water	36:61	0:0	8	frame_size
water	36:71	0:0	8	)
stmts	36:73	39:16	7	
water	36:73	0:0	8	{
call	37:20	37:117	8	av_log
arg	37:27	37:28	9	s
water	37:27	0:0	10	s
arg	37:30	37:42	9	AV_LOG_ERROR
water	37:30	0:0	10	AV_LOG_ERROR
arg	37:44	37:75	9	"Invalid parameters %d %d %d\n"
water	37:44	0:0	10	"Invalid parameters %d %d %d\n"
arg	37:77	37:91	9	current_sector
water	37:77	0:0	10	current_sector
arg	37:93	37:105	9	sector_count
water	37:93	0:0	10	sector_count
arg	37:107	37:117	9	frame_size
water	37:107	0:0	10	frame_size
water	37:118	0:0	8	;
break	38:20	38:25	8	
water	39:16	0:0	8	}
if	41:16	55:16	6	(str -> channels [ channel ] . video_stream_index < 0)
cond	41:19	41:63	7	str -> channels [ channel ] . video_stream_index < 0
water	41:19	0:0	8	str
op	41:22	0:0	8	->
water	41:24	0:0	8	channels
op	41:32	0:0	8	[
water	41:33	0:0	8	channel
op	41:40	0:0	8	]
op	41:41	0:0	8	.
water	41:42	0:0	8	video_stream_index
op	41:61	0:0	8	<
water	41:63	0:0	8	0
stmts	41:65	55:16	7	
water	41:65	0:0	8	{
water	43:20	0:0	8	st
op	43:23	0:0	8	=
call	43:25	43:43	8	av_new_stream
arg	43:39	43:40	9	s
water	43:39	0:0	10	s
arg	43:42	43:43	9	0
water	43:42	0:0	10	0
water	43:44	0:0	8	;
if	44:20	45:46	8	(! st)
cond	44:24	44:25	9	! st
op	44:24	0:0	10	!
water	44:25	0:0	10	st
stmts	45:24	45:46	9	
return	45:24	45:46	10	AVERROR(ENOMEM)
call	45:31	45:45	11	AVERROR
arg	45:39	45:45	12	ENOMEM
water	45:39	0:0	13	ENOMEM
call	46:20	46:49	8	av_set_pts_info
arg	46:36	46:38	9	st
water	46:36	0:0	10	st
arg	46:40	46:42	9	64
water	46:40	0:0	10	64
arg	46:44	46:45	9	1
water	46:44	0:0	10	1
arg	46:47	46:49	9	15
water	46:47	0:0	10	15
water	46:50	0:0	8	;
water	48:20	0:0	8	str
op	48:23	0:0	8	->
water	48:25	0:0	8	channels
op	48:33	0:0	8	[
water	48:34	0:0	8	channel
op	48:41	0:0	8	]
op	48:42	0:0	8	.
water	48:43	0:0	8	video_stream_index
op	48:62	0:0	8	=
water	48:64	0:0	8	st
op	48:66	0:0	8	->
water	48:68	0:0	8	index
water	48:73	0:0	8	;
water	50:20	0:0	8	st
op	50:22	0:0	8	->
water	50:24	0:0	8	codec
op	50:29	0:0	8	->
water	50:31	0:0	8	codec_type
op	50:42	0:0	8	=
water	50:44	0:0	8	CODEC_TYPE_VIDEO
water	50:60	0:0	8	;
water	51:20	0:0	8	st
op	51:22	0:0	8	->
water	51:24	0:0	8	codec
op	51:29	0:0	8	->
water	51:31	0:0	8	codec_id
op	51:42	0:0	8	=
water	51:44	0:0	8	CODEC_ID_MDEC
water	51:57	0:0	8	;
water	52:20	0:0	8	st
op	52:22	0:0	8	->
water	52:24	0:0	8	codec
op	52:29	0:0	8	->
water	52:31	0:0	8	codec_tag
op	52:42	0:0	8	=
water	52:44	0:0	8	0
water	52:45	0:0	8	;
water	53:20	0:0	8	st
op	53:22	0:0	8	->
water	53:24	0:0	8	codec
op	53:29	0:0	8	->
water	53:31	0:0	8	width
op	53:42	0:0	8	=
call	53:44	53:65	8	AV_RL16
arg	53:52	53:65	9	&sector[0x28]
op	53:52	0:0	10	&
water	53:53	0:0	10	sector
op	53:59	0:0	10	[
water	53:60	0:0	10	0
water	53:61	0:0	10	x28
op	53:64	0:0	10	]
water	53:66	0:0	8	;
water	54:20	0:0	8	st
op	54:22	0:0	8	->
water	54:24	0:0	8	codec
op	54:29	0:0	8	->
water	54:31	0:0	8	height
op	54:42	0:0	8	=
call	54:44	54:65	8	AV_RL16
arg	54:52	54:65	9	&sector[0x2A]
op	54:52	0:0	10	&
water	54:53	0:0	10	sector
op	54:59	0:0	10	[
water	54:60	0:0	10	0
water	54:61	0:0	10	x2A
op	54:64	0:0	10	]
water	54:66	0:0	8	;
water	55:16	0:0	8	}
water	58:16	0:0	6	pkt
op	58:20	0:0	6	=
op	58:22	0:0	6	&
water	58:23	0:0	6	str
op	58:26	0:0	6	->
water	58:28	0:0	6	channels
op	58:36	0:0	6	[
water	58:37	0:0	6	channel
op	58:44	0:0	6	]
op	58:45	0:0	6	.
water	58:46	0:0	6	tmp_pkt
water	58:53	0:0	6	;
if	60:16	70:16	6	(pkt -> size != sector_count * VIDEO_DATA_CHUNK_SIZE)
cond	60:19	60:45	7	pkt -> size != sector_count * VIDEO_DATA_CHUNK_SIZE
water	60:19	0:0	8	pkt
op	60:22	0:0	8	->
water	60:24	0:0	8	size
op	60:29	0:0	8	!=
water	60:32	0:0	8	sector_count
op	60:44	0:0	8	*
water	60:45	0:0	8	VIDEO_DATA_CHUNK_SIZE
stmts	60:67	70:16	7	
water	60:67	0:0	8	{
if	61:20	62:78	8	(pkt -> data)
cond	61:23	61:28	9	pkt -> data
water	61:23	0:0	10	pkt
op	61:26	0:0	10	->
water	61:28	0:0	10	data
stmts	62:24	62:78	9	
call	62:24	62:77	10	av_log
arg	62:31	62:32	11	s
water	62:31	0:0	12	s
arg	62:34	62:46	11	AV_LOG_ERROR
water	62:34	0:0	12	AV_LOG_ERROR
arg	62:48	62:77	11	"missmatching sector_count\n"
water	62:48	0:0	12	"missmatching sector_count\n"
water	62:78	0:0	10	;
call	63:20	63:38	8	av_free_packet
arg	63:35	63:38	9	pkt
water	63:35	0:0	10	pkt
water	63:39	0:0	8	;
if	64:20	65:43	8	(av_new_packet (pkt ,sector_count * VIDEO_DATA_CHUNK_SIZE ))
cond	64:24	64:77	9	av_new_packet (pkt ,sector_count * VIDEO_DATA_CHUNK_SIZE )
call	64:24	64:77	10	av_new_packet
arg	64:38	64:41	11	pkt
water	64:38	0:0	12	pkt
arg	64:43	64:77	11	sector_count*VIDEO_DATA_CHUNK_SIZE
water	64:43	0:0	12	sector_count
op	64:55	0:0	12	*
water	64:56	0:0	12	VIDEO_DATA_CHUNK_SIZE
stmts	65:24	65:43	9	
return	65:24	65:43	10	AVERROR(EIO)
call	65:31	65:42	11	AVERROR
arg	65:39	65:42	12	EIO
water	65:39	0:0	13	EIO
water	67:20	0:0	8	pkt
op	67:23	0:0	8	->
water	67:25	0:0	8	pos
op	67:28	0:0	8	=
call	67:30	67:42	8	url_ftell
arg	67:40	67:42	9	pb
water	67:40	0:0	10	pb
op	67:44	0:0	8	-
water	67:46	0:0	8	RAW_CD_SECTOR_SIZE
water	67:64	0:0	8	;
water	68:20	0:0	8	pkt
op	68:23	0:0	8	->
water	68:25	0:0	8	stream_index
op	68:38	0:0	8	=
water	69:24	0:0	8	str
op	69:27	0:0	8	->
water	69:29	0:0	8	channels
op	69:37	0:0	8	[
water	69:38	0:0	8	channel
op	69:45	0:0	8	]
op	69:46	0:0	8	.
water	69:47	0:0	8	video_stream_index
water	69:65	0:0	8	;
water	70:16	0:0	8	}
call	72:16	74:44	6	memcpy
arg	72:23	72:71	7	pkt->data+current_sector*VIDEO_DATA_CHUNK_SIZE
water	72:23	0:0	8	pkt
op	72:26	0:0	8	->
water	72:28	0:0	8	data
op	72:33	0:0	8	+
water	72:35	0:0	8	current_sector
op	72:49	0:0	8	*
water	72:50	0:0	8	VIDEO_DATA_CHUNK_SIZE
arg	73:23	73:54	7	sector+VIDEO_DATA_HEADER_SIZE
water	73:23	0:0	8	sector
op	73:30	0:0	8	+
water	73:32	0:0	8	VIDEO_DATA_HEADER_SIZE
arg	74:23	74:44	7	VIDEO_DATA_CHUNK_SIZE
water	74:23	0:0	8	VIDEO_DATA_CHUNK_SIZE
water	74:45	0:0	6	;
if	76:16	82:16	6	(current_sector == sector_count - 1)
cond	76:20	76:51	7	current_sector == sector_count - 1
water	76:20	0:0	8	current_sector
op	76:35	0:0	8	==
water	76:38	0:0	8	sector_count
op	76:50	0:0	8	-
water	76:51	0:0	8	1
stmts	76:54	82:16	7	
water	76:54	0:0	8	{
water	77:20	0:0	8	pkt
op	77:23	0:0	8	->
water	77:25	0:0	8	size
op	77:29	0:0	8	=
water	77:31	0:0	8	frame_size
water	77:41	0:0	8	;
op	78:20	0:0	8	*
water	78:21	0:0	8	ret_pkt
op	78:29	0:0	8	=
op	78:31	0:0	8	*
water	78:32	0:0	8	pkt
water	78:35	0:0	8	;
water	79:20	0:0	8	pkt
op	79:23	0:0	8	->
water	79:25	0:0	8	data
op	79:29	0:0	8	=
water	79:31	0:0	8	NULL
water	79:35	0:0	8	;
water	80:20	0:0	8	pkt
op	80:23	0:0	8	->
water	80:25	0:0	8	size
op	80:29	0:0	8	=
op	80:31	0:0	8	-
water	80:32	0:0	8	1
water	80:33	0:0	8	;
return	81:20	81:28	8	0
water	81:27	0:0	9	0
water	82:16	0:0	8	}
water	84:12	0:0	6	}
break	85:12	85:17	6	
label	87:8	87:28	6	case CDXA_TYPE_AUDIO :
if	88:12	106:12	6	(str -> channels [ channel ] . audio_stream_index < 0)
cond	88:15	88:59	7	str -> channels [ channel ] . audio_stream_index < 0
water	88:15	0:0	8	str
op	88:18	0:0	8	->
water	88:20	0:0	8	channels
op	88:28	0:0	8	[
water	88:29	0:0	8	channel
op	88:36	0:0	8	]
op	88:37	0:0	8	.
water	88:38	0:0	8	audio_stream_index
op	88:57	0:0	8	<
water	88:59	0:0	8	0
stmts	88:61	106:12	7	
water	88:61	0:0	8	{
decl	89:16	89:38	8	int	fmt
op	89:24	0:0	8	=
water	89:26	0:0	8	sector
op	89:32	0:0	8	[
water	89:33	0:0	8	0
water	89:34	0:0	8	x13
op	89:37	0:0	8	]
water	91:16	0:0	8	st
op	91:19	0:0	8	=
call	91:21	91:39	8	av_new_stream
arg	91:35	91:36	9	s
water	91:35	0:0	10	s
arg	91:38	91:39	9	0
water	91:38	0:0	10	0
water	91:40	0:0	8	;
if	92:16	93:42	8	(! st)
cond	92:20	92:21	9	! st
op	92:20	0:0	10	!
water	92:21	0:0	10	st
stmts	93:20	93:42	9	
return	93:20	93:42	10	AVERROR(ENOMEM)
call	93:27	93:41	11	AVERROR
arg	93:35	93:41	12	ENOMEM
water	93:35	0:0	13	ENOMEM
water	95:16	0:0	8	str
op	95:19	0:0	8	->
water	95:21	0:0	8	channels
op	95:29	0:0	8	[
water	95:30	0:0	8	channel
op	95:37	0:0	8	]
op	95:38	0:0	8	.
water	95:39	0:0	8	audio_stream_index
op	95:58	0:0	8	=
water	95:60	0:0	8	st
op	95:62	0:0	8	->
water	95:64	0:0	8	index
water	95:69	0:0	8	;
water	97:16	0:0	8	st
op	97:18	0:0	8	->
water	97:20	0:0	8	codec
op	97:25	0:0	8	->
water	97:27	0:0	8	codec_type
op	97:39	0:0	8	=
water	97:41	0:0	8	CODEC_TYPE_AUDIO
water	97:57	0:0	8	;
water	98:16	0:0	8	st
op	98:18	0:0	8	->
water	98:20	0:0	8	codec
op	98:25	0:0	8	->
water	98:27	0:0	8	codec_id
op	98:39	0:0	8	=
water	98:41	0:0	8	CODEC_ID_ADPCM_XA
water	98:58	0:0	8	;
water	99:16	0:0	8	st
op	99:18	0:0	8	->
water	99:20	0:0	8	codec
op	99:25	0:0	8	->
water	99:27	0:0	8	codec_tag
op	99:39	0:0	8	=
water	99:41	0:0	8	0
water	99:42	0:0	8	;
water	100:16	0:0	8	st
op	100:18	0:0	8	->
water	100:20	0:0	8	codec
op	100:25	0:0	8	->
water	100:27	0:0	8	channels
op	100:39	0:0	8	=
water	100:41	0:0	8	(
water	100:42	0:0	8	fmt
op	100:45	0:0	8	&
water	100:46	0:0	8	1
water	100:47	0:0	8	)
water	100:48	0:0	8	?
water	100:49	0:0	8	2
water	100:50	0:0	8	:
water	100:51	0:0	8	1
water	100:52	0:0	8	;
water	101:16	0:0	8	st
op	101:18	0:0	8	->
water	101:20	0:0	8	codec
op	101:25	0:0	8	->
water	101:27	0:0	8	sample_rate
op	101:39	0:0	8	=
water	101:41	0:0	8	(
water	101:42	0:0	8	fmt
op	101:45	0:0	8	&
water	101:46	0:0	8	4
water	101:47	0:0	8	)
water	101:48	0:0	8	?
water	101:49	0:0	8	18900
water	101:54	0:0	8	:
water	101:55	0:0	8	37800
water	101:60	0:0	8	;
water	103:16	0:0	8	st
op	103:18	0:0	8	->
water	103:20	0:0	8	codec
op	103:25	0:0	8	->
water	103:27	0:0	8	block_align
op	103:39	0:0	8	=
water	103:41	0:0	8	128
water	103:44	0:0	8	;
call	105:16	105:67	8	av_set_pts_info
arg	105:32	105:34	9	st
water	105:32	0:0	10	st
arg	105:36	105:38	9	64
water	105:36	0:0	10	64
arg	105:40	105:43	9	128
water	105:40	0:0	10	128
arg	105:45	105:67	9	st->codec->sample_rate
water	105:45	0:0	10	st
op	105:47	0:0	10	->
water	105:49	0:0	10	codec
op	105:54	0:0	10	->
water	105:56	0:0	10	sample_rate
water	105:68	0:0	8	;
water	106:12	0:0	8	}
water	107:12	0:0	6	pkt
op	107:16	0:0	6	=
water	107:18	0:0	6	ret_pkt
water	107:25	0:0	6	;
if	108:12	109:35	6	(av_new_packet (pkt ,2304 ))
cond	108:16	108:39	7	av_new_packet (pkt ,2304 )
call	108:16	108:39	8	av_new_packet
arg	108:30	108:33	9	pkt
water	108:30	0:0	10	pkt
arg	108:35	108:39	9	2304
water	108:35	0:0	10	2304
stmts	109:16	109:35	7	
return	109:16	109:35	8	AVERROR(EIO)
call	109:23	109:34	9	AVERROR
arg	109:31	109:34	10	EIO
water	109:31	0:0	11	EIO
call	110:12	110:43	6	memcpy
arg	110:19	110:28	7	pkt->data
water	110:19	0:0	8	pkt
op	110:22	0:0	8	->
water	110:24	0:0	8	data
arg	110:29	110:38	7	sector+24
water	110:29	0:0	8	sector
op	110:35	0:0	8	+
water	110:36	0:0	8	24
arg	110:39	110:43	7	2304
water	110:39	0:0	8	2304
water	110:44	0:0	6	;
water	112:12	0:0	6	pkt
op	112:15	0:0	6	->
water	112:17	0:0	6	stream_index
op	112:30	0:0	6	=
water	113:16	0:0	6	str
op	113:19	0:0	6	->
water	113:21	0:0	6	channels
op	113:29	0:0	6	[
water	113:30	0:0	6	channel
op	113:37	0:0	6	]
op	113:38	0:0	6	.
water	113:39	0:0	6	audio_stream_index
water	113:57	0:0	6	;
return	114:12	114:20	6	0
water	114:19	0:0	7	0
break	115:12	115:17	6	
label	116:8	116:15	6	default :
call	117:12	117:80	6	av_log
arg	117:19	117:20	7	s
water	117:19	0:0	8	s
arg	117:22	117:36	7	AV_LOG_WARNING
water	117:22	0:0	8	AV_LOG_WARNING
arg	117:38	117:66	7	"Unknown sector type %02X\n"
water	117:38	0:0	8	"Unknown sector type %02X\n"
arg	117:68	117:80	7	sector[0x12]
water	117:68	0:0	8	sector
op	117:74	0:0	8	[
water	117:75	0:0	8	0
water	117:76	0:0	8	x12
op	117:79	0:0	8	]
water	117:81	0:0	6	;
break	119:12	119:17	6	
water	120:8	0:0	6	}
if	122:8	123:31	4	(url_feof (pb ))
cond	122:12	122:23	5	url_feof (pb )
call	122:12	122:23	6	url_feof
arg	122:21	122:23	7	pb
water	122:21	0:0	8	pb
stmts	123:12	123:31	5	
return	123:12	123:31	6	AVERROR(EIO)
call	123:19	123:30	7	AVERROR
arg	123:27	123:30	8	EIO
water	123:27	0:0	9	EIO
water	124:4	0:0	4	}
