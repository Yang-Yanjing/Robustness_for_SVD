func	2:0	754:0	0	static int	adpcm_decode_frame
params	2:29	0:0	1	
param	2:30	2:51	2	AVCodecContext *	avctx
param	3:28	3:38	2	void *	data
param	3:40	3:54	2	int *	data_size
param	4:28	4:43	2	AVPacket *	avpkt
stmnts	0:0	753:20	1	
decl	6:4	6:36	2	const uint8_t	*buf
op	6:23	0:0	2	=
water	6:25	0:0	2	avpkt
op	6:30	0:0	2	->
water	6:32	0:0	2	data
decl	7:4	7:30	2	int	buf_size
op	7:17	0:0	2	=
water	7:19	0:0	2	avpkt
op	7:24	0:0	2	->
water	7:26	0:0	2	size
decl	8:4	8:38	2	ADPCMContext	*c
op	8:20	0:0	2	=
water	8:22	0:0	2	avctx
op	8:27	0:0	2	->
water	8:29	0:0	2	priv_data
decl	9:4	9:26	2	ADPCMChannelStatus	*cs
decl	10:4	10:24	2	int	n
water	10:9	0:0	2	,
decl	10:4	10:24	2	int	m
water	10:12	0:0	2	,
decl	10:4	10:24	2	int	channel
water	10:21	0:0	2	,
decl	10:4	10:24	2	int	i
decl	11:4	11:26	2	int	block_predictor[2]
decl	12:4	12:18	2	short	*samples
decl	13:4	13:22	2	short	*samples_end
decl	14:4	14:22	2	const uint8_t	*src
decl	15:4	15:10	2	int	st
decl	18:4	18:31	2	unsigned char	last_byte
op	18:28	0:0	2	=
water	18:30	0:0	2	0
decl	19:4	19:24	2	unsigned char	nibble
decl	20:4	20:34	2	int	decode_top_nibble_next
op	20:31	0:0	2	=
water	20:33	0:0	2	0
decl	21:4	21:20	2	int	diff_channel
decl	24:4	24:29	2	uint32_t	samples_in_chunk
decl	25:4	25:55	2	int32_t	previous_left_sample
water	25:32	0:0	2	,
decl	25:4	25:55	2	int32_t	previous_right_sample
decl	26:4	26:53	2	int32_t	current_left_sample
water	26:31	0:0	2	,
decl	26:4	26:53	2	int32_t	current_right_sample
decl	27:4	27:47	2	int32_t	next_left_sample
water	27:28	0:0	2	,
decl	27:4	27:47	2	int32_t	next_right_sample
decl	28:4	28:46	2	int32_t	coeff1l
water	28:19	0:0	2	,
decl	28:4	28:46	2	int32_t	coeff2l
water	28:28	0:0	2	,
decl	28:4	28:46	2	int32_t	coeff1r
water	28:37	0:0	2	,
decl	28:4	28:46	2	int32_t	coeff2r
decl	29:4	29:35	2	uint8_t	shift_left
water	29:22	0:0	2	,
decl	29:4	29:35	2	uint8_t	shift_right
decl	30:4	30:22	2	int	count1
water	30:14	0:0	2	,
decl	30:4	30:22	2	int	count2
water	31:4	0:0	2	int
water	31:8	0:0	2	coeff
op	31:13	0:0	2	[
water	31:14	0:0	2	2
op	31:15	0:0	2	]
op	31:16	0:0	2	[
water	31:17	0:0	2	2
op	31:18	0:0	2	]
water	31:19	0:0	2	,
water	31:21	0:0	2	shift
op	31:26	0:0	2	[
water	31:27	0:0	2	2
op	31:28	0:0	2	]
water	31:29	0:0	2	;
if	33:4	34:16	2	(! buf_size)
cond	33:8	33:9	3	! buf_size
op	33:8	0:0	4	!
water	33:9	0:0	4	buf_size
stmts	34:8	34:16	3	
return	34:8	34:16	4	0
water	34:15	0:0	5	0
if	39:4	40:17	2	(* data_size / 4 < buf_size + 8)
cond	39:7	39:33	3	* data_size / 4 < buf_size + 8
op	39:7	0:0	4	*
water	39:8	0:0	4	data_size
op	39:17	0:0	4	/
water	39:18	0:0	4	4
op	39:20	0:0	4	<
water	39:22	0:0	4	buf_size
op	39:31	0:0	4	+
water	39:33	0:0	4	8
stmts	40:8	40:17	3	
return	40:8	40:17	4	-1
op	40:15	0:0	5	-
water	40:16	0:0	5	1
water	42:4	0:0	2	samples
op	42:12	0:0	2	=
water	42:14	0:0	2	data
water	42:18	0:0	2	;
water	43:4	0:0	2	samples_end
op	43:15	0:0	2	=
water	43:17	0:0	2	samples
op	43:25	0:0	2	+
op	43:27	0:0	2	*
water	43:28	0:0	2	data_size
op	43:37	0:0	2	/
water	43:38	0:0	2	2
water	43:39	0:0	2	;
op	44:4	0:0	2	*
water	44:5	0:0	2	data_size
op	44:14	0:0	2	=
water	44:16	0:0	2	0
water	44:17	0:0	2	;
water	45:4	0:0	2	src
op	45:8	0:0	2	=
water	45:10	0:0	2	buf
water	45:13	0:0	2	;
water	47:4	0:0	2	st
op	47:7	0:0	2	=
water	47:9	0:0	2	avctx
op	47:14	0:0	2	->
water	47:16	0:0	2	channels
op	47:25	0:0	2	==
water	47:28	0:0	2	2
water	47:30	0:0	2	?
water	47:32	0:0	2	1
water	47:34	0:0	2	:
water	47:36	0:0	2	0
water	47:37	0:0	2	;
switch	49:4	751:4	2	(avctx -> codec -> id)
cond	49:11	49:25	3	avctx -> codec -> id
water	49:11	0:0	4	avctx
op	49:16	0:0	4	->
water	49:18	0:0	4	codec
op	49:23	0:0	4	->
water	49:25	0:0	4	id
stmts	49:29	751:4	3	
water	49:29	0:0	4	{
label	50:4	50:30	4	case CODEC_ID_ADPCM_IMA_QT :
water	51:8	0:0	4	n
op	51:10	0:0	4	=
water	51:12	0:0	4	buf_size
op	51:21	0:0	4	-
water	51:23	0:0	4	2
op	51:24	0:0	4	*
water	51:25	0:0	4	avctx
op	51:30	0:0	4	->
water	51:32	0:0	4	channels
water	51:40	0:0	4	;
for	52:8	91:8	4	(channel = 0 ;channel < avctx -> channels;channel ++)
forinit	52:13	52:24	5	channel = 0 ;
water	52:13	0:0	6	channel
op	52:21	0:0	6	=
water	52:23	0:0	6	0
water	52:24	0:0	6	;
cond	52:26	52:43	5	channel < avctx -> channels
water	52:26	0:0	6	channel
op	52:34	0:0	6	<
water	52:36	0:0	6	avctx
op	52:41	0:0	6	->
water	52:43	0:0	6	channels
forexpr	52:53	52:60	5	channel ++
water	52:53	0:0	6	channel
op	52:60	0:0	6	++
stmts	52:64	91:8	5	
water	52:64	0:0	6	{
decl	53:12	53:29	6	int16_t	predictor
decl	54:12	54:26	6	int	step_index
water	55:12	0:0	6	cs
op	55:15	0:0	6	=
op	55:17	0:0	6	&
water	55:18	0:0	6	(
water	55:19	0:0	6	c
op	55:20	0:0	6	->
water	55:22	0:0	6	status
op	55:28	0:0	6	[
water	55:29	0:0	6	channel
op	55:36	0:0	6	]
water	55:37	0:0	6	)
water	55:38	0:0	6	;
water	59:12	0:0	6	predictor
op	59:22	0:0	6	=
call	59:24	59:35	6	AV_RB16
arg	59:32	59:35	7	src
water	59:32	0:0	8	src
water	59:36	0:0	6	;
water	60:12	0:0	6	step_index
op	60:23	0:0	6	=
water	60:25	0:0	6	predictor
op	60:35	0:0	6	&
water	60:37	0:0	6	0
water	60:38	0:0	6	x7F
water	60:41	0:0	6	;
water	61:12	0:0	6	predictor
op	61:22	0:0	6	&=
water	61:25	0:0	6	0
water	61:26	0:0	6	xFF80
water	61:31	0:0	6	;
water	63:12	0:0	6	src
op	63:16	0:0	6	+=
water	63:19	0:0	6	2
water	63:20	0:0	6	;
if	65:12	71:12	6	(cs -> step_index == step_index)
cond	65:16	65:34	7	cs -> step_index == step_index
water	65:16	0:0	8	cs
op	65:18	0:0	8	->
water	65:20	0:0	8	step_index
op	65:31	0:0	8	==
water	65:34	0:0	8	step_index
stmts	65:46	71:12	7	
water	65:46	0:0	8	{
decl	66:16	66:57	8	int	diff
op	66:25	0:0	8	=
water	66:27	0:0	8	(
water	66:28	0:0	8	int
water	66:31	0:0	8	)
water	66:32	0:0	8	predictor
op	66:42	0:0	8	-
water	66:44	0:0	8	cs
op	66:46	0:0	8	->
water	66:48	0:0	8	predictor
if	67:16	68:33	8	(diff < 0)
cond	67:20	67:27	9	diff < 0
water	67:20	0:0	10	diff
op	67:25	0:0	10	<
water	67:27	0:0	10	0
stmts	68:20	68:33	9	
water	68:20	0:0	10	diff
op	68:25	0:0	10	=
op	68:27	0:0	10	-
water	68:29	0:0	10	diff
water	68:33	0:0	10	;
if	69:16	70:31	8	(diff > 0 x7f)
cond	69:20	69:28	9	diff > 0 x7f
water	69:20	0:0	10	diff
op	69:25	0:0	10	>
water	69:27	0:0	10	0
water	69:28	0:0	10	x7f
stmts	70:20	70:31	9	
goto	70:20	70:31	10	update
water	70:25	0:0	11	update
water	71:12	0:0	8	}
else	71:14	75:12	6
stmts	71:19	75:12	7	
water	71:19	0:0	8	{
label	72:12	72:18	8	update :
water	73:16	0:0	8	cs
op	73:18	0:0	8	->
water	73:20	0:0	8	step_index
op	73:31	0:0	8	=
water	73:33	0:0	8	step_index
water	73:43	0:0	8	;
water	74:16	0:0	8	cs
op	74:18	0:0	8	->
water	74:20	0:0	8	predictor
op	74:30	0:0	8	=
water	74:32	0:0	8	predictor
water	74:41	0:0	8	;
water	75:12	0:0	8	}
if	77:12	80:12	6	(cs -> step_index > 88)
cond	77:16	77:33	7	cs -> step_index > 88
water	77:16	0:0	8	cs
op	77:18	0:0	8	->
water	77:20	0:0	8	step_index
op	77:31	0:0	8	>
water	77:33	0:0	8	88
stmts	77:36	80:12	7	
water	77:36	0:0	8	{
call	78:16	78:86	8	av_log
arg	78:23	78:28	9	avctx
water	78:23	0:0	10	avctx
arg	78:30	78:42	9	AV_LOG_ERROR
water	78:30	0:0	10	AV_LOG_ERROR
arg	78:44	78:70	9	"ERROR: step_index = %i\n"
water	78:44	0:0	10	"ERROR: step_index = %i\n"
arg	78:72	78:86	9	cs->step_index
water	78:72	0:0	10	cs
op	78:74	0:0	10	->
water	78:76	0:0	10	step_index
water	78:87	0:0	8	;
water	79:16	0:0	8	cs
op	79:18	0:0	8	->
water	79:20	0:0	8	step_index
op	79:31	0:0	8	=
water	79:33	0:0	8	88
water	79:35	0:0	8	;
water	80:12	0:0	8	}
water	82:12	0:0	6	samples
op	82:20	0:0	6	=
water	82:22	0:0	6	(
water	82:23	0:0	6	short
op	82:28	0:0	6	*
water	82:29	0:0	6	)
water	82:30	0:0	6	data
op	82:35	0:0	6	+
water	82:37	0:0	6	channel
water	82:44	0:0	6	;
for	84:12	90:12	6	(m = 32 ;n > 0 && m > 0;n -- , m --)
forinit	84:16	84:20	7	m = 32 ;
water	84:16	0:0	8	m
op	84:17	0:0	8	=
water	84:18	0:0	8	32
water	84:20	0:0	8	;
cond	84:22	84:31	7	n > 0 && m > 0
water	84:22	0:0	8	n
op	84:23	0:0	8	>
water	84:24	0:0	8	0
op	84:26	0:0	8	&&
water	84:29	0:0	8	m
op	84:30	0:0	8	>
water	84:31	0:0	8	0
forexpr	84:34	84:40	7	n -- , m --
water	84:34	0:0	8	n
op	84:35	0:0	8	--
water	84:37	0:0	8	,
water	84:39	0:0	8	m
op	84:40	0:0	8	--
stmts	84:44	90:12	7	
water	84:44	0:0	8	{
op	85:16	0:0	8	*
water	85:17	0:0	8	samples
op	85:25	0:0	8	=
call	85:27	85:74	8	adpcm_ima_qt_expand_nibble
arg	85:54	85:56	9	cs
water	85:54	0:0	10	cs
arg	85:58	85:71	9	src[0]&0x0F
water	85:58	0:0	10	src
op	85:61	0:0	10	[
water	85:62	0:0	10	0
op	85:63	0:0	10	]
op	85:65	0:0	10	&
water	85:67	0:0	10	0
water	85:68	0:0	10	x0F
arg	85:73	85:74	9	3
water	85:73	0:0	10	3
water	85:75	0:0	8	;
water	86:16	0:0	8	samples
op	86:24	0:0	8	+=
water	86:27	0:0	8	avctx
op	86:32	0:0	8	->
water	86:34	0:0	8	channels
water	86:42	0:0	8	;
op	87:16	0:0	8	*
water	87:17	0:0	8	samples
op	87:25	0:0	8	=
call	87:27	87:74	8	adpcm_ima_qt_expand_nibble
arg	87:54	87:56	9	cs
water	87:54	0:0	10	cs
arg	87:58	87:71	9	src[0]>>4
water	87:58	0:0	10	src
op	87:61	0:0	10	[
water	87:62	0:0	10	0
op	87:63	0:0	10	]
op	87:65	0:0	10	>>
water	87:68	0:0	10	4
arg	87:73	87:74	9	3
water	87:73	0:0	10	3
water	87:75	0:0	8	;
water	88:16	0:0	8	samples
op	88:24	0:0	8	+=
water	88:27	0:0	8	avctx
op	88:32	0:0	8	->
water	88:34	0:0	8	channels
water	88:42	0:0	8	;
water	89:16	0:0	8	src
op	89:20	0:0	8	++
water	89:22	0:0	8	;
water	90:12	0:0	8	}
water	91:8	0:0	6	}
if	92:8	93:21	4	(st)
cond	92:12	92:12	5	st
water	92:12	0:0	6	st
stmts	93:12	93:21	5	
water	93:12	0:0	6	samples
op	93:19	0:0	6	--
water	93:21	0:0	6	;
break	94:8	94:13	4	
label	95:4	95:31	4	case CODEC_ID_ADPCM_IMA_WAV :
if	96:8	97:41	4	(avctx -> block_align != 0 && buf_size > avctx -> block_align)
cond	96:12	96:57	5	avctx -> block_align != 0 && buf_size > avctx -> block_align
water	96:12	0:0	6	avctx
op	96:17	0:0	6	->
water	96:19	0:0	6	block_align
op	96:31	0:0	6	!=
water	96:34	0:0	6	0
op	96:36	0:0	6	&&
water	96:39	0:0	6	buf_size
op	96:48	0:0	6	>
water	96:50	0:0	6	avctx
op	96:55	0:0	6	->
water	96:57	0:0	6	block_align
stmts	97:12	97:41	5	
water	97:12	0:0	6	buf_size
op	97:21	0:0	6	=
water	97:23	0:0	6	avctx
op	97:28	0:0	6	->
water	97:30	0:0	6	block_align
water	97:41	0:0	6	;
for	101:8	111:8	4	(i = 0 ;i < avctx -> channels;i ++)
forinit	101:12	101:15	5	i = 0 ;
water	101:12	0:0	6	i
op	101:13	0:0	6	=
water	101:14	0:0	6	0
water	101:15	0:0	6	;
cond	101:17	101:26	5	i < avctx -> channels
water	101:17	0:0	6	i
op	101:18	0:0	6	<
water	101:19	0:0	6	avctx
op	101:24	0:0	6	->
water	101:26	0:0	6	channels
forexpr	101:36	101:37	5	i ++
water	101:36	0:0	6	i
op	101:37	0:0	6	++
stmts	101:40	111:8	5	
water	101:40	0:0	6	{
water	102:12	0:0	6	cs
op	102:15	0:0	6	=
op	102:17	0:0	6	&
water	102:18	0:0	6	(
water	102:19	0:0	6	c
op	102:20	0:0	6	->
water	102:22	0:0	6	status
op	102:28	0:0	6	[
water	102:29	0:0	6	i
op	102:30	0:0	6	]
water	102:31	0:0	6	)
water	102:32	0:0	6	;
water	103:12	0:0	6	cs
op	103:14	0:0	6	->
water	103:16	0:0	6	predictor
op	103:26	0:0	6	=
op	103:28	0:0	6	*
water	103:29	0:0	6	samples
op	103:36	0:0	6	++
op	103:39	0:0	6	=
water	103:41	0:0	6	(
water	103:42	0:0	6	int16_t
water	103:49	0:0	6	)
call	103:50	103:74	6	bytestream_get_le16
arg	103:70	103:74	7	&src
op	103:70	0:0	8	&
water	103:71	0:0	8	src
water	103:75	0:0	6	;
water	105:12	0:0	6	cs
op	105:14	0:0	6	->
water	105:16	0:0	6	step_index
op	105:27	0:0	6	=
op	105:29	0:0	6	*
water	105:30	0:0	6	src
op	105:33	0:0	6	++
water	105:35	0:0	6	;
if	106:12	109:12	6	(cs -> step_index > 88)
cond	106:16	106:33	7	cs -> step_index > 88
water	106:16	0:0	8	cs
op	106:18	0:0	8	->
water	106:20	0:0	8	step_index
op	106:31	0:0	8	>
water	106:33	0:0	8	88
stmts	106:36	109:12	7	
water	106:36	0:0	8	{
call	107:16	107:86	8	av_log
arg	107:23	107:28	9	avctx
water	107:23	0:0	10	avctx
arg	107:30	107:42	9	AV_LOG_ERROR
water	107:30	0:0	10	AV_LOG_ERROR
arg	107:44	107:70	9	"ERROR: step_index = %i\n"
water	107:44	0:0	10	"ERROR: step_index = %i\n"
arg	107:72	107:86	9	cs->step_index
water	107:72	0:0	10	cs
op	107:74	0:0	10	->
water	107:76	0:0	10	step_index
water	107:87	0:0	8	;
water	108:16	0:0	8	cs
op	108:18	0:0	8	->
water	108:20	0:0	8	step_index
op	108:31	0:0	8	=
water	108:33	0:0	8	88
water	108:35	0:0	8	;
water	109:12	0:0	8	}
if	110:12	110:104	6	(* src ++)
cond	110:16	110:20	7	* src ++
op	110:16	0:0	8	*
water	110:17	0:0	8	src
op	110:20	0:0	8	++
stmts	110:24	110:104	7	
call	110:24	110:103	8	av_log
arg	110:31	110:36	9	avctx
water	110:31	0:0	10	avctx
arg	110:38	110:50	9	AV_LOG_ERROR
water	110:38	0:0	10	AV_LOG_ERROR
arg	110:52	110:94	9	"unused byte should be null but is %d!!\n"
water	110:52	0:0	10	"unused byte should be null but is %d!!\n"
arg	110:96	110:103	9	src[-1]
water	110:96	0:0	10	src
op	110:99	0:0	10	[
op	110:100	0:0	10	-
water	110:101	0:0	10	1
op	110:102	0:0	10	]
water	110:104	0:0	8	;
water	111:8	0:0	6	}
while	113:8	122:8	4	(src < buf + buf_size)
cond	113:14	113:26	5	src < buf + buf_size
water	113:14	0:0	6	src
op	113:18	0:0	6	<
water	113:20	0:0	6	buf
op	113:24	0:0	6	+
water	113:26	0:0	6	buf_size
stmts	113:35	122:8	5	
water	113:35	0:0	6	{
for	114:12	120:12	6	(m = 0 ;m < 4;m ++)
forinit	114:16	114:19	7	m = 0 ;
water	114:16	0:0	8	m
op	114:17	0:0	8	=
water	114:18	0:0	8	0
water	114:19	0:0	8	;
cond	114:21	114:23	7	m < 4
water	114:21	0:0	8	m
op	114:22	0:0	8	<
water	114:23	0:0	8	4
forexpr	114:26	114:27	7	m ++
water	114:26	0:0	8	m
op	114:27	0:0	8	++
stmts	114:30	120:12	7	
water	114:30	0:0	8	{
for	115:16	116:91	8	(i = 0 ;i <= st;i ++)
forinit	115:20	115:23	9	i = 0 ;
water	115:20	0:0	10	i
op	115:21	0:0	10	=
water	115:22	0:0	10	0
water	115:23	0:0	10	;
cond	115:25	115:28	9	i <= st
water	115:25	0:0	10	i
op	115:26	0:0	10	<=
water	115:28	0:0	10	st
forexpr	115:32	115:33	9	i ++
water	115:32	0:0	10	i
op	115:33	0:0	10	++
stmts	116:20	116:91	9	
op	116:20	0:0	10	*
water	116:21	0:0	10	samples
op	116:28	0:0	10	++
op	116:31	0:0	10	=
call	116:33	116:90	10	adpcm_ima_expand_nibble
arg	116:57	116:70	11	&c->status[i]
op	116:57	0:0	12	&
water	116:58	0:0	12	c
op	116:59	0:0	12	->
water	116:61	0:0	12	status
op	116:67	0:0	12	[
water	116:68	0:0	12	i
op	116:69	0:0	12	]
arg	116:72	116:87	11	src[4*i]&0x0F
water	116:72	0:0	12	src
op	116:75	0:0	12	[
water	116:76	0:0	12	4
op	116:77	0:0	12	*
water	116:78	0:0	12	i
op	116:79	0:0	12	]
op	116:81	0:0	12	&
water	116:83	0:0	12	0
water	116:84	0:0	12	x0F
arg	116:89	116:90	11	3
water	116:89	0:0	12	3
water	116:91	0:0	10	;
for	117:16	118:91	8	(i = 0 ;i <= st;i ++)
forinit	117:20	117:23	9	i = 0 ;
water	117:20	0:0	10	i
op	117:21	0:0	10	=
water	117:22	0:0	10	0
water	117:23	0:0	10	;
cond	117:25	117:28	9	i <= st
water	117:25	0:0	10	i
op	117:26	0:0	10	<=
water	117:28	0:0	10	st
forexpr	117:32	117:33	9	i ++
water	117:32	0:0	10	i
op	117:33	0:0	10	++
stmts	118:20	118:91	9	
op	118:20	0:0	10	*
water	118:21	0:0	10	samples
op	118:28	0:0	10	++
op	118:31	0:0	10	=
call	118:33	118:90	10	adpcm_ima_expand_nibble
arg	118:57	118:70	11	&c->status[i]
op	118:57	0:0	12	&
water	118:58	0:0	12	c
op	118:59	0:0	12	->
water	118:61	0:0	12	status
op	118:67	0:0	12	[
water	118:68	0:0	12	i
op	118:69	0:0	12	]
arg	118:72	118:87	11	src[4*i]>>4
water	118:72	0:0	12	src
op	118:75	0:0	12	[
water	118:76	0:0	12	4
op	118:77	0:0	12	*
water	118:78	0:0	12	i
op	118:79	0:0	12	]
op	118:81	0:0	12	>>
water	118:84	0:0	12	4
arg	118:89	118:90	11	3
water	118:89	0:0	12	3
water	118:91	0:0	10	;
water	119:16	0:0	8	src
op	119:19	0:0	8	++
water	119:21	0:0	8	;
water	120:12	0:0	8	}
water	121:12	0:0	6	src
op	121:16	0:0	6	+=
water	121:19	0:0	6	4
op	121:20	0:0	6	*
water	121:21	0:0	6	st
water	121:23	0:0	6	;
water	122:8	0:0	6	}
break	123:8	123:13	4	
label	124:4	124:27	4	case CODEC_ID_ADPCM_4XM :
water	125:8	0:0	4	cs
op	125:11	0:0	4	=
op	125:13	0:0	4	&
water	125:14	0:0	4	(
water	125:15	0:0	4	c
op	125:16	0:0	4	->
water	125:18	0:0	4	status
op	125:24	0:0	4	[
water	125:25	0:0	4	0
op	125:26	0:0	4	]
water	125:27	0:0	4	)
water	125:28	0:0	4	;
water	126:8	0:0	4	c
op	126:9	0:0	4	->
water	126:11	0:0	4	status
op	126:17	0:0	4	[
water	126:18	0:0	4	0
op	126:19	0:0	4	]
op	126:20	0:0	4	.
water	126:21	0:0	4	predictor
op	126:30	0:0	4	=
water	126:32	0:0	4	(
water	126:33	0:0	4	int16_t
water	126:40	0:0	4	)
call	126:41	126:65	4	bytestream_get_le16
arg	126:61	126:65	5	&src
op	126:61	0:0	6	&
water	126:62	0:0	6	src
water	126:66	0:0	4	;
if	127:8	129:8	4	(st)
cond	127:11	127:11	5	st
water	127:11	0:0	6	st
stmts	127:14	129:8	5	
water	127:14	0:0	6	{
water	128:12	0:0	6	c
op	128:13	0:0	6	->
water	128:15	0:0	6	status
op	128:21	0:0	6	[
water	128:22	0:0	6	1
op	128:23	0:0	6	]
op	128:24	0:0	6	.
water	128:25	0:0	6	predictor
op	128:34	0:0	6	=
water	128:36	0:0	6	(
water	128:37	0:0	6	int16_t
water	128:44	0:0	6	)
call	128:45	128:69	6	bytestream_get_le16
arg	128:65	128:69	7	&src
op	128:65	0:0	8	&
water	128:66	0:0	8	src
water	128:70	0:0	6	;
water	129:8	0:0	6	}
water	130:8	0:0	4	c
op	130:9	0:0	4	->
water	130:11	0:0	4	status
op	130:17	0:0	4	[
water	130:18	0:0	4	0
op	130:19	0:0	4	]
op	130:20	0:0	4	.
water	130:21	0:0	4	step_index
op	130:31	0:0	4	=
water	130:33	0:0	4	(
water	130:34	0:0	4	int16_t
water	130:41	0:0	4	)
call	130:42	130:66	4	bytestream_get_le16
arg	130:62	130:66	5	&src
op	130:62	0:0	6	&
water	130:63	0:0	6	src
water	130:67	0:0	4	;
if	131:8	133:8	4	(st)
cond	131:11	131:11	5	st
water	131:11	0:0	6	st
stmts	131:14	133:8	5	
water	131:14	0:0	6	{
water	132:12	0:0	6	c
op	132:13	0:0	6	->
water	132:15	0:0	6	status
op	132:21	0:0	6	[
water	132:22	0:0	6	1
op	132:23	0:0	6	]
op	132:24	0:0	6	.
water	132:25	0:0	6	step_index
op	132:35	0:0	6	=
water	132:37	0:0	6	(
water	132:38	0:0	6	int16_t
water	132:45	0:0	6	)
call	132:46	132:70	6	bytestream_get_le16
arg	132:66	132:70	7	&src
op	132:66	0:0	8	&
water	132:67	0:0	8	src
water	132:71	0:0	6	;
water	133:8	0:0	6	}
if	134:8	134:50	4	(cs -> step_index < 0)
cond	134:12	134:29	5	cs -> step_index < 0
water	134:12	0:0	6	cs
op	134:14	0:0	6	->
water	134:16	0:0	6	step_index
op	134:27	0:0	6	<
water	134:29	0:0	6	0
stmts	134:32	134:50	5	
water	134:32	0:0	6	cs
op	134:34	0:0	6	->
water	134:36	0:0	6	step_index
op	134:47	0:0	6	=
water	134:49	0:0	6	0
water	134:50	0:0	6	;
if	135:8	135:52	4	(cs -> step_index > 88)
cond	135:12	135:29	5	cs -> step_index > 88
water	135:12	0:0	6	cs
op	135:14	0:0	6	->
water	135:16	0:0	6	step_index
op	135:27	0:0	6	>
water	135:29	0:0	6	88
stmts	135:33	135:52	5	
water	135:33	0:0	6	cs
op	135:35	0:0	6	->
water	135:37	0:0	6	step_index
op	135:48	0:0	6	=
water	135:50	0:0	6	88
water	135:52	0:0	6	;
water	137:8	0:0	4	m
op	137:9	0:0	4	=
water	137:11	0:0	4	(
water	137:12	0:0	4	buf_size
op	137:21	0:0	4	-
water	137:23	0:0	4	(
water	137:24	0:0	4	src
op	137:28	0:0	4	-
water	137:30	0:0	4	buf
water	137:33	0:0	4	)
water	137:34	0:0	4	)
op	137:35	0:0	4	>>
water	137:37	0:0	4	st
water	137:39	0:0	4	;
for	138:8	145:8	4	(i = 0 ;i < m;i ++)
forinit	138:12	138:15	5	i = 0 ;
water	138:12	0:0	6	i
op	138:13	0:0	6	=
water	138:14	0:0	6	0
water	138:15	0:0	6	;
cond	138:17	138:19	5	i < m
water	138:17	0:0	6	i
op	138:18	0:0	6	<
water	138:19	0:0	6	m
forexpr	138:22	138:23	5	i ++
water	138:22	0:0	6	i
op	138:23	0:0	6	++
stmts	138:27	145:8	5	
water	138:27	0:0	6	{
op	139:12	0:0	6	*
water	139:13	0:0	6	samples
op	139:20	0:0	6	++
op	139:23	0:0	6	=
call	139:25	139:80	6	adpcm_ima_expand_nibble
arg	139:49	139:62	7	&c->status[0]
op	139:49	0:0	8	&
water	139:50	0:0	8	c
op	139:51	0:0	8	->
water	139:53	0:0	8	status
op	139:59	0:0	8	[
water	139:60	0:0	8	0
op	139:61	0:0	8	]
arg	139:64	139:77	7	src[i]&0x0F
water	139:64	0:0	8	src
op	139:67	0:0	8	[
water	139:68	0:0	8	i
op	139:69	0:0	8	]
op	139:71	0:0	8	&
water	139:73	0:0	8	0
water	139:74	0:0	8	x0F
arg	139:79	139:80	7	4
water	139:79	0:0	8	4
water	139:81	0:0	6	;
if	140:12	141:87	6	(st)
cond	140:16	140:16	7	st
water	140:16	0:0	8	st
stmts	141:16	141:87	7	
op	141:16	0:0	8	*
water	141:17	0:0	8	samples
op	141:24	0:0	8	++
op	141:27	0:0	8	=
call	141:29	141:86	8	adpcm_ima_expand_nibble
arg	141:53	141:66	9	&c->status[1]
op	141:53	0:0	10	&
water	141:54	0:0	10	c
op	141:55	0:0	10	->
water	141:57	0:0	10	status
op	141:63	0:0	10	[
water	141:64	0:0	10	1
op	141:65	0:0	10	]
arg	141:68	141:83	9	src[i+m]&0x0F
water	141:68	0:0	10	src
op	141:71	0:0	10	[
water	141:72	0:0	10	i
op	141:73	0:0	10	+
water	141:74	0:0	10	m
op	141:75	0:0	10	]
op	141:77	0:0	10	&
water	141:79	0:0	10	0
water	141:80	0:0	10	x0F
arg	141:85	141:86	9	4
water	141:85	0:0	10	4
water	141:87	0:0	8	;
op	142:12	0:0	6	*
water	142:13	0:0	6	samples
op	142:20	0:0	6	++
op	142:23	0:0	6	=
call	142:25	142:78	6	adpcm_ima_expand_nibble
arg	142:49	142:62	7	&c->status[0]
op	142:49	0:0	8	&
water	142:50	0:0	8	c
op	142:51	0:0	8	->
water	142:53	0:0	8	status
op	142:59	0:0	8	[
water	142:60	0:0	8	0
op	142:61	0:0	8	]
arg	142:64	142:75	7	src[i]>>4
water	142:64	0:0	8	src
op	142:67	0:0	8	[
water	142:68	0:0	8	i
op	142:69	0:0	8	]
op	142:71	0:0	8	>>
water	142:74	0:0	8	4
arg	142:77	142:78	7	4
water	142:77	0:0	8	4
water	142:79	0:0	6	;
if	143:12	144:85	6	(st)
cond	143:16	143:16	7	st
water	143:16	0:0	8	st
stmts	144:16	144:85	7	
op	144:16	0:0	8	*
water	144:17	0:0	8	samples
op	144:24	0:0	8	++
op	144:27	0:0	8	=
call	144:29	144:84	8	adpcm_ima_expand_nibble
arg	144:53	144:66	9	&c->status[1]
op	144:53	0:0	10	&
water	144:54	0:0	10	c
op	144:55	0:0	10	->
water	144:57	0:0	10	status
op	144:63	0:0	10	[
water	144:64	0:0	10	1
op	144:65	0:0	10	]
arg	144:68	144:81	9	src[i+m]>>4
water	144:68	0:0	10	src
op	144:71	0:0	10	[
water	144:72	0:0	10	i
op	144:73	0:0	10	+
water	144:74	0:0	10	m
op	144:75	0:0	10	]
op	144:77	0:0	10	>>
water	144:80	0:0	10	4
arg	144:83	144:84	9	4
water	144:83	0:0	10	4
water	144:85	0:0	8	;
water	145:8	0:0	6	}
water	147:8	0:0	4	src
op	147:12	0:0	4	+=
water	147:15	0:0	4	m
op	147:16	0:0	4	<<
water	147:18	0:0	4	st
water	147:20	0:0	4	;
break	149:8	149:13	4	
label	150:4	150:26	4	case CODEC_ID_ADPCM_MS :
if	151:8	152:41	4	(avctx -> block_align != 0 && buf_size > avctx -> block_align)
cond	151:12	151:57	5	avctx -> block_align != 0 && buf_size > avctx -> block_align
water	151:12	0:0	6	avctx
op	151:17	0:0	6	->
water	151:19	0:0	6	block_align
op	151:31	0:0	6	!=
water	151:34	0:0	6	0
op	151:36	0:0	6	&&
water	151:39	0:0	6	buf_size
op	151:48	0:0	6	>
water	151:50	0:0	6	avctx
op	151:55	0:0	6	->
water	151:57	0:0	6	block_align
stmts	152:12	152:41	5	
water	152:12	0:0	6	buf_size
op	152:21	0:0	6	=
water	152:23	0:0	6	avctx
op	152:28	0:0	6	->
water	152:30	0:0	6	block_align
water	152:41	0:0	6	;
water	153:8	0:0	4	n
op	153:10	0:0	4	=
water	153:12	0:0	4	buf_size
op	153:21	0:0	4	-
water	153:23	0:0	4	7
op	153:25	0:0	4	*
water	153:27	0:0	4	avctx
op	153:32	0:0	4	->
water	153:34	0:0	4	channels
water	153:42	0:0	4	;
if	154:8	155:21	4	(n < 0)
cond	154:12	154:16	5	n < 0
water	154:12	0:0	6	n
op	154:14	0:0	6	<
water	154:16	0:0	6	0
stmts	155:12	155:21	5	
return	155:12	155:21	6	-1
op	155:19	0:0	7	-
water	155:20	0:0	7	1
water	156:8	0:0	4	block_predictor
op	156:23	0:0	4	[
water	156:24	0:0	4	0
op	156:25	0:0	4	]
op	156:27	0:0	4	=
call	156:29	156:49	4	av_clip
arg	156:37	156:43	5	*src++
op	156:37	0:0	6	*
water	156:38	0:0	6	src
op	156:41	0:0	6	++
arg	156:45	156:46	5	0
water	156:45	0:0	6	0
arg	156:48	156:49	5	6
water	156:48	0:0	6	6
water	156:50	0:0	4	;
water	157:8	0:0	4	block_predictor
op	157:23	0:0	4	[
water	157:24	0:0	4	1
op	157:25	0:0	4	]
op	157:27	0:0	4	=
water	157:29	0:0	4	0
water	157:30	0:0	4	;
if	158:8	159:54	4	(st)
cond	158:12	158:12	5	st
water	158:12	0:0	6	st
stmts	159:12	159:54	5	
water	159:12	0:0	6	block_predictor
op	159:27	0:0	6	[
water	159:28	0:0	6	1
op	159:29	0:0	6	]
op	159:31	0:0	6	=
call	159:33	159:53	6	av_clip
arg	159:41	159:47	7	*src++
op	159:41	0:0	8	*
water	159:42	0:0	8	src
op	159:45	0:0	8	++
arg	159:49	159:50	7	0
water	159:49	0:0	8	0
arg	159:52	159:53	7	6
water	159:52	0:0	8	6
water	159:54	0:0	6	;
water	160:8	0:0	4	c
op	160:9	0:0	4	->
water	160:11	0:0	4	status
op	160:17	0:0	4	[
water	160:18	0:0	4	0
op	160:19	0:0	4	]
op	160:20	0:0	4	.
water	160:21	0:0	4	idelta
op	160:28	0:0	4	=
water	160:30	0:0	4	(
water	160:31	0:0	4	int16_t
water	160:38	0:0	4	)
call	160:39	160:63	4	bytestream_get_le16
arg	160:59	160:63	5	&src
op	160:59	0:0	6	&
water	160:60	0:0	6	src
water	160:64	0:0	4	;
if	161:8	163:8	4	(st)
cond	161:12	161:12	5	st
water	161:12	0:0	6	st
stmts	161:15	163:8	5	
water	161:15	0:0	6	{
water	162:12	0:0	6	c
op	162:13	0:0	6	->
water	162:15	0:0	6	status
op	162:21	0:0	6	[
water	162:22	0:0	6	1
op	162:23	0:0	6	]
op	162:24	0:0	6	.
water	162:25	0:0	6	idelta
op	162:32	0:0	6	=
water	162:34	0:0	6	(
water	162:35	0:0	6	int16_t
water	162:42	0:0	6	)
call	162:43	162:67	6	bytestream_get_le16
arg	162:63	162:67	7	&src
op	162:63	0:0	8	&
water	162:64	0:0	8	src
water	162:68	0:0	6	;
water	163:8	0:0	6	}
water	164:8	0:0	4	c
op	164:9	0:0	4	->
water	164:11	0:0	4	status
op	164:17	0:0	4	[
water	164:18	0:0	4	0
op	164:19	0:0	4	]
op	164:20	0:0	4	.
water	164:21	0:0	4	coeff1
op	164:28	0:0	4	=
water	164:30	0:0	4	AdaptCoeff1
op	164:41	0:0	4	[
water	164:42	0:0	4	block_predictor
op	164:57	0:0	4	[
water	164:58	0:0	4	0
op	164:59	0:0	4	]
op	164:60	0:0	4	]
water	164:61	0:0	4	;
water	165:8	0:0	4	c
op	165:9	0:0	4	->
water	165:11	0:0	4	status
op	165:17	0:0	4	[
water	165:18	0:0	4	0
op	165:19	0:0	4	]
op	165:20	0:0	4	.
water	165:21	0:0	4	coeff2
op	165:28	0:0	4	=
water	165:30	0:0	4	AdaptCoeff2
op	165:41	0:0	4	[
water	165:42	0:0	4	block_predictor
op	165:57	0:0	4	[
water	165:58	0:0	4	0
op	165:59	0:0	4	]
op	165:60	0:0	4	]
water	165:61	0:0	4	;
water	166:8	0:0	4	c
op	166:9	0:0	4	->
water	166:11	0:0	4	status
op	166:17	0:0	4	[
water	166:18	0:0	4	1
op	166:19	0:0	4	]
op	166:20	0:0	4	.
water	166:21	0:0	4	coeff1
op	166:28	0:0	4	=
water	166:30	0:0	4	AdaptCoeff1
op	166:41	0:0	4	[
water	166:42	0:0	4	block_predictor
op	166:57	0:0	4	[
water	166:58	0:0	4	1
op	166:59	0:0	4	]
op	166:60	0:0	4	]
water	166:61	0:0	4	;
water	167:8	0:0	4	c
op	167:9	0:0	4	->
water	167:11	0:0	4	status
op	167:17	0:0	4	[
water	167:18	0:0	4	1
op	167:19	0:0	4	]
op	167:20	0:0	4	.
water	167:21	0:0	4	coeff2
op	167:28	0:0	4	=
water	167:30	0:0	4	AdaptCoeff2
op	167:41	0:0	4	[
water	167:42	0:0	4	block_predictor
op	167:57	0:0	4	[
water	167:58	0:0	4	1
op	167:59	0:0	4	]
op	167:60	0:0	4	]
water	167:61	0:0	4	;
water	169:8	0:0	4	c
op	169:9	0:0	4	->
water	169:11	0:0	4	status
op	169:17	0:0	4	[
water	169:18	0:0	4	0
op	169:19	0:0	4	]
op	169:20	0:0	4	.
water	169:21	0:0	4	sample1
op	169:29	0:0	4	=
call	169:31	169:55	4	bytestream_get_le16
arg	169:51	169:55	5	&src
op	169:51	0:0	6	&
water	169:52	0:0	6	src
water	169:56	0:0	4	;
if	170:8	170:64	4	(st)
cond	170:12	170:12	5	st
water	170:12	0:0	6	st
stmts	170:16	170:64	5	
water	170:16	0:0	6	c
op	170:17	0:0	6	->
water	170:19	0:0	6	status
op	170:25	0:0	6	[
water	170:26	0:0	6	1
op	170:27	0:0	6	]
op	170:28	0:0	6	.
water	170:29	0:0	6	sample1
op	170:37	0:0	6	=
call	170:39	170:63	6	bytestream_get_le16
arg	170:59	170:63	7	&src
op	170:59	0:0	8	&
water	170:60	0:0	8	src
water	170:64	0:0	6	;
water	171:8	0:0	4	c
op	171:9	0:0	4	->
water	171:11	0:0	4	status
op	171:17	0:0	4	[
water	171:18	0:0	4	0
op	171:19	0:0	4	]
op	171:20	0:0	4	.
water	171:21	0:0	4	sample2
op	171:29	0:0	4	=
call	171:31	171:55	4	bytestream_get_le16
arg	171:51	171:55	5	&src
op	171:51	0:0	6	&
water	171:52	0:0	6	src
water	171:56	0:0	4	;
if	172:8	172:64	4	(st)
cond	172:12	172:12	5	st
water	172:12	0:0	6	st
stmts	172:16	172:64	5	
water	172:16	0:0	6	c
op	172:17	0:0	6	->
water	172:19	0:0	6	status
op	172:25	0:0	6	[
water	172:26	0:0	6	1
op	172:27	0:0	6	]
op	172:28	0:0	6	.
water	172:29	0:0	6	sample2
op	172:37	0:0	6	=
call	172:39	172:63	6	bytestream_get_le16
arg	172:59	172:63	7	&src
op	172:59	0:0	8	&
water	172:60	0:0	8	src
water	172:64	0:0	6	;
op	174:8	0:0	4	*
water	174:9	0:0	4	samples
op	174:16	0:0	4	++
op	174:19	0:0	4	=
water	174:21	0:0	4	c
op	174:22	0:0	4	->
water	174:24	0:0	4	status
op	174:30	0:0	4	[
water	174:31	0:0	4	0
op	174:32	0:0	4	]
op	174:33	0:0	4	.
water	174:34	0:0	4	sample2
water	174:41	0:0	4	;
if	175:8	175:49	4	(st)
cond	175:12	175:12	5	st
water	175:12	0:0	6	st
stmts	175:16	175:49	5	
op	175:16	0:0	6	*
water	175:17	0:0	6	samples
op	175:24	0:0	6	++
op	175:27	0:0	6	=
water	175:29	0:0	6	c
op	175:30	0:0	6	->
water	175:32	0:0	6	status
op	175:38	0:0	6	[
water	175:39	0:0	6	1
op	175:40	0:0	6	]
op	175:41	0:0	6	.
water	175:42	0:0	6	sample2
water	175:49	0:0	6	;
op	176:8	0:0	4	*
water	176:9	0:0	4	samples
op	176:16	0:0	4	++
op	176:19	0:0	4	=
water	176:21	0:0	4	c
op	176:22	0:0	4	->
water	176:24	0:0	4	status
op	176:30	0:0	4	[
water	176:31	0:0	4	0
op	176:32	0:0	4	]
op	176:33	0:0	4	.
water	176:34	0:0	4	sample1
water	176:41	0:0	4	;
if	177:8	177:49	4	(st)
cond	177:12	177:12	5	st
water	177:12	0:0	6	st
stmts	177:16	177:49	5	
op	177:16	0:0	6	*
water	177:17	0:0	6	samples
op	177:24	0:0	6	++
op	177:27	0:0	6	=
water	177:29	0:0	6	c
op	177:30	0:0	6	->
water	177:32	0:0	6	status
op	177:38	0:0	6	[
water	177:39	0:0	6	1
op	177:40	0:0	6	]
op	177:41	0:0	6	.
water	177:42	0:0	6	sample1
water	177:49	0:0	6	;
for	178:8	182:8	4	(;n > 0;n --)
forinit	178:12	178:12	5	;
water	178:12	0:0	6	;
cond	178:13	178:15	5	n > 0
water	178:13	0:0	6	n
op	178:14	0:0	6	>
water	178:15	0:0	6	0
forexpr	178:17	178:18	5	n --
water	178:17	0:0	6	n
op	178:18	0:0	6	--
stmts	178:22	182:8	5	
water	178:22	0:0	6	{
op	179:12	0:0	6	*
water	179:13	0:0	6	samples
op	179:20	0:0	6	++
op	179:23	0:0	6	=
call	179:25	179:77	6	adpcm_ms_expand_nibble
arg	179:48	179:62	7	&c->status[0]
op	179:48	0:0	8	&
water	179:49	0:0	8	c
op	179:50	0:0	8	->
water	179:52	0:0	8	status
op	179:58	0:0	8	[
water	179:59	0:0	8	0
op	179:61	0:0	8	]
arg	179:64	179:77	7	src[0]>>4
water	179:64	0:0	8	src
op	179:67	0:0	8	[
water	179:68	0:0	8	0
op	179:69	0:0	8	]
op	179:71	0:0	8	>>
water	179:74	0:0	8	4
water	179:78	0:0	6	;
op	180:12	0:0	6	*
water	180:13	0:0	6	samples
op	180:20	0:0	6	++
op	180:23	0:0	6	=
call	180:25	180:77	6	adpcm_ms_expand_nibble
arg	180:48	180:62	7	&c->status[st]
op	180:48	0:0	8	&
water	180:49	0:0	8	c
op	180:50	0:0	8	->
water	180:52	0:0	8	status
op	180:58	0:0	8	[
water	180:59	0:0	8	st
op	180:61	0:0	8	]
arg	180:64	180:77	7	src[0]&0x0F
water	180:64	0:0	8	src
op	180:67	0:0	8	[
water	180:68	0:0	8	0
op	180:69	0:0	8	]
op	180:71	0:0	8	&
water	180:73	0:0	8	0
water	180:74	0:0	8	x0F
water	180:78	0:0	6	;
water	181:12	0:0	6	src
op	181:16	0:0	6	++
water	181:18	0:0	6	;
water	182:8	0:0	6	}
break	183:8	183:13	4	
label	184:4	184:31	4	case CODEC_ID_ADPCM_IMA_DK4 :
if	185:8	186:41	4	(avctx -> block_align != 0 && buf_size > avctx -> block_align)
cond	185:12	185:57	5	avctx -> block_align != 0 && buf_size > avctx -> block_align
water	185:12	0:0	6	avctx
op	185:17	0:0	6	->
water	185:19	0:0	6	block_align
op	185:31	0:0	6	!=
water	185:34	0:0	6	0
op	185:36	0:0	6	&&
water	185:39	0:0	6	buf_size
op	185:48	0:0	6	>
water	185:50	0:0	6	avctx
op	185:55	0:0	6	->
water	185:57	0:0	6	block_align
stmts	186:12	186:41	5	
water	186:12	0:0	6	buf_size
op	186:21	0:0	6	=
water	186:23	0:0	6	avctx
op	186:28	0:0	6	->
water	186:30	0:0	6	block_align
water	186:41	0:0	6	;
water	188:8	0:0	4	c
op	188:9	0:0	4	->
water	188:11	0:0	4	status
op	188:17	0:0	4	[
water	188:18	0:0	4	0
op	188:19	0:0	4	]
op	188:20	0:0	4	.
water	188:21	0:0	4	predictor
op	188:32	0:0	4	=
water	188:34	0:0	4	(
water	188:35	0:0	4	int16_t
water	188:42	0:0	4	)
call	188:43	188:67	4	bytestream_get_le16
arg	188:63	188:67	5	&src
op	188:63	0:0	6	&
water	188:64	0:0	6	src
water	188:68	0:0	4	;
water	189:8	0:0	4	c
op	189:9	0:0	4	->
water	189:11	0:0	4	status
op	189:17	0:0	4	[
water	189:18	0:0	4	0
op	189:19	0:0	4	]
op	189:20	0:0	4	.
water	189:21	0:0	4	step_index
op	189:32	0:0	4	=
op	189:34	0:0	4	*
water	189:35	0:0	4	src
op	189:38	0:0	4	++
water	189:40	0:0	4	;
water	190:8	0:0	4	src
op	190:11	0:0	4	++
water	190:13	0:0	4	;
op	191:8	0:0	4	*
water	191:9	0:0	4	samples
op	191:16	0:0	4	++
op	191:19	0:0	4	=
water	191:21	0:0	4	c
op	191:22	0:0	4	->
water	191:24	0:0	4	status
op	191:30	0:0	4	[
water	191:31	0:0	4	0
op	191:32	0:0	4	]
op	191:33	0:0	4	.
water	191:34	0:0	4	predictor
water	191:43	0:0	4	;
if	192:8	197:8	4	(st)
cond	192:12	192:12	5	st
water	192:12	0:0	6	st
stmts	192:16	197:8	5	
water	192:16	0:0	6	{
water	193:12	0:0	6	c
op	193:13	0:0	6	->
water	193:15	0:0	6	status
op	193:21	0:0	6	[
water	193:22	0:0	6	1
op	193:23	0:0	6	]
op	193:24	0:0	6	.
water	193:25	0:0	6	predictor
op	193:36	0:0	6	=
water	193:38	0:0	6	(
water	193:39	0:0	6	int16_t
water	193:46	0:0	6	)
call	193:47	193:71	6	bytestream_get_le16
arg	193:67	193:71	7	&src
op	193:67	0:0	8	&
water	193:68	0:0	8	src
water	193:72	0:0	6	;
water	194:12	0:0	6	c
op	194:13	0:0	6	->
water	194:15	0:0	6	status
op	194:21	0:0	6	[
water	194:22	0:0	6	1
op	194:23	0:0	6	]
op	194:24	0:0	6	.
water	194:25	0:0	6	step_index
op	194:36	0:0	6	=
op	194:38	0:0	6	*
water	194:39	0:0	6	src
op	194:42	0:0	6	++
water	194:44	0:0	6	;
water	195:12	0:0	6	src
op	195:15	0:0	6	++
water	195:17	0:0	6	;
op	196:12	0:0	6	*
water	196:13	0:0	6	samples
op	196:20	0:0	6	++
op	196:23	0:0	6	=
water	196:25	0:0	6	c
op	196:26	0:0	6	->
water	196:28	0:0	6	status
op	196:34	0:0	6	[
water	196:35	0:0	6	1
op	196:36	0:0	6	]
op	196:37	0:0	6	.
water	196:38	0:0	6	predictor
water	196:47	0:0	6	;
water	197:8	0:0	6	}
while	198:8	214:8	4	(src < buf + buf_size)
cond	198:15	198:27	5	src < buf + buf_size
water	198:15	0:0	6	src
op	198:19	0:0	6	<
water	198:21	0:0	6	buf
op	198:25	0:0	6	+
water	198:27	0:0	6	buf_size
stmts	198:37	214:8	5	
water	198:37	0:0	6	{
op	201:12	0:0	6	*
water	201:13	0:0	6	samples
op	201:20	0:0	6	++
op	201:23	0:0	6	=
call	201:25	202:30	6	adpcm_ima_expand_nibble
arg	201:49	201:62	7	&c->status[0]
op	201:49	0:0	8	&
water	201:50	0:0	8	c
op	201:51	0:0	8	->
water	201:53	0:0	8	status
op	201:59	0:0	8	[
water	201:60	0:0	8	0
op	201:61	0:0	8	]
arg	202:16	202:27	7	src[0]>>4
water	202:16	0:0	8	src
op	202:19	0:0	8	[
water	202:20	0:0	8	0
op	202:21	0:0	8	]
op	202:23	0:0	8	>>
water	202:26	0:0	8	4
arg	202:29	202:30	7	3
water	202:29	0:0	8	3
water	202:31	0:0	6	;
if	206:12	208:37	6	(st)
cond	206:16	206:16	7	st
water	206:16	0:0	8	st
stmts	207:16	208:37	7	
op	207:16	0:0	8	*
water	207:17	0:0	8	samples
op	207:24	0:0	8	++
op	207:27	0:0	8	=
call	207:29	208:36	8	adpcm_ima_expand_nibble
arg	207:53	207:66	9	&c->status[1]
op	207:53	0:0	10	&
water	207:54	0:0	10	c
op	207:55	0:0	10	->
water	207:57	0:0	10	status
op	207:63	0:0	10	[
water	207:64	0:0	10	1
op	207:65	0:0	10	]
arg	208:20	208:33	9	src[0]&0x0F
water	208:20	0:0	10	src
op	208:23	0:0	10	[
water	208:24	0:0	10	0
op	208:25	0:0	10	]
op	208:27	0:0	10	&
water	208:29	0:0	10	0
water	208:30	0:0	10	x0F
arg	208:35	208:36	9	3
water	208:35	0:0	10	3
water	208:37	0:0	8	;
else	209:12	211:37	6
stmts	210:16	211:37	7	
op	210:16	0:0	8	*
water	210:17	0:0	8	samples
op	210:24	0:0	8	++
op	210:27	0:0	8	=
call	210:29	211:36	8	adpcm_ima_expand_nibble
arg	210:53	210:66	9	&c->status[0]
op	210:53	0:0	10	&
water	210:54	0:0	10	c
op	210:55	0:0	10	->
water	210:57	0:0	10	status
op	210:63	0:0	10	[
water	210:64	0:0	10	0
op	210:65	0:0	10	]
arg	211:20	211:33	9	src[0]&0x0F
water	211:20	0:0	10	src
op	211:23	0:0	10	[
water	211:24	0:0	10	0
op	211:25	0:0	10	]
op	211:27	0:0	10	&
water	211:29	0:0	10	0
water	211:30	0:0	10	x0F
arg	211:35	211:36	9	3
water	211:35	0:0	10	3
water	211:37	0:0	8	;
water	213:12	0:0	6	src
op	213:15	0:0	6	++
water	213:17	0:0	6	;
water	214:8	0:0	6	}
break	215:8	215:13	4	
label	216:4	216:31	4	case CODEC_ID_ADPCM_IMA_DK3 :
if	217:8	218:41	4	(avctx -> block_align != 0 && buf_size > avctx -> block_align)
cond	217:12	217:57	5	avctx -> block_align != 0 && buf_size > avctx -> block_align
water	217:12	0:0	6	avctx
op	217:17	0:0	6	->
water	217:19	0:0	6	block_align
op	217:31	0:0	6	!=
water	217:34	0:0	6	0
op	217:36	0:0	6	&&
water	217:39	0:0	6	buf_size
op	217:48	0:0	6	>
water	217:50	0:0	6	avctx
op	217:55	0:0	6	->
water	217:57	0:0	6	block_align
stmts	218:12	218:41	5	
water	218:12	0:0	6	buf_size
op	218:21	0:0	6	=
water	218:23	0:0	6	avctx
op	218:28	0:0	6	->
water	218:30	0:0	6	block_align
water	218:41	0:0	6	;
if	220:8	221:21	4	(buf_size + 16 > ( samples_end - samples ) * 3 / 8)
cond	220:11	220:53	5	buf_size + 16 > ( samples_end - samples ) * 3 / 8
water	220:11	0:0	6	buf_size
op	220:20	0:0	6	+
water	220:22	0:0	6	16
op	220:25	0:0	6	>
water	220:27	0:0	6	(
water	220:28	0:0	6	samples_end
op	220:40	0:0	6	-
water	220:42	0:0	6	samples
water	220:49	0:0	6	)
op	220:50	0:0	6	*
water	220:51	0:0	6	3
op	220:52	0:0	6	/
water	220:53	0:0	6	8
stmts	221:12	221:21	5	
return	221:12	221:21	6	-1
op	221:19	0:0	7	-
water	221:20	0:0	7	1
water	223:8	0:0	4	c
op	223:9	0:0	4	->
water	223:11	0:0	4	status
op	223:17	0:0	4	[
water	223:18	0:0	4	0
op	223:19	0:0	4	]
op	223:20	0:0	4	.
water	223:21	0:0	4	predictor
op	223:32	0:0	4	=
water	223:34	0:0	4	(
water	223:35	0:0	4	int16_t
water	223:42	0:0	4	)
call	223:43	223:59	4	AV_RL16
arg	223:51	223:59	5	src+10
water	223:51	0:0	6	src
op	223:55	0:0	6	+
water	223:57	0:0	6	10
water	223:60	0:0	4	;
water	224:8	0:0	4	c
op	224:9	0:0	4	->
water	224:11	0:0	4	status
op	224:17	0:0	4	[
water	224:18	0:0	4	1
op	224:19	0:0	4	]
op	224:20	0:0	4	.
water	224:21	0:0	4	predictor
op	224:32	0:0	4	=
water	224:34	0:0	4	(
water	224:35	0:0	4	int16_t
water	224:42	0:0	4	)
call	224:43	224:59	4	AV_RL16
arg	224:51	224:59	5	src+12
water	224:51	0:0	6	src
op	224:55	0:0	6	+
water	224:57	0:0	6	12
water	224:60	0:0	4	;
water	225:8	0:0	4	c
op	225:9	0:0	4	->
water	225:11	0:0	4	status
op	225:17	0:0	4	[
water	225:18	0:0	4	0
op	225:19	0:0	4	]
op	225:20	0:0	4	.
water	225:21	0:0	4	step_index
op	225:32	0:0	4	=
water	225:34	0:0	4	src
op	225:37	0:0	4	[
water	225:38	0:0	4	14
op	225:40	0:0	4	]
water	225:41	0:0	4	;
water	226:8	0:0	4	c
op	226:9	0:0	4	->
water	226:11	0:0	4	status
op	226:17	0:0	4	[
water	226:18	0:0	4	1
op	226:19	0:0	4	]
op	226:20	0:0	4	.
water	226:21	0:0	4	step_index
op	226:32	0:0	4	=
water	226:34	0:0	4	src
op	226:37	0:0	4	[
water	226:38	0:0	4	15
op	226:40	0:0	4	]
water	226:41	0:0	4	;
water	228:8	0:0	4	src
op	228:12	0:0	4	+=
water	228:15	0:0	4	16
water	228:17	0:0	4	;
water	229:8	0:0	4	diff_channel
op	229:21	0:0	4	=
water	229:23	0:0	4	c
op	229:24	0:0	4	->
water	229:26	0:0	4	status
op	229:32	0:0	4	[
water	229:33	0:0	4	1
op	229:34	0:0	4	]
op	229:35	0:0	4	.
water	229:36	0:0	4	predictor
water	229:45	0:0	4	;
while	233:8	259:8	4	(1)
cond	233:15	233:15	5	1
water	233:15	0:0	6	1
stmts	233:18	259:8	5	
water	233:18	0:0	6	{
call	239:12	239:32	6	DK3_GET_NEXT_NIBBLE
water	239:33	0:0	6	;
call	240:12	240:60	6	adpcm_ima_expand_nibble
arg	240:36	240:49	7	&c->status[0]
op	240:36	0:0	8	&
water	240:37	0:0	8	c
op	240:38	0:0	8	->
water	240:40	0:0	8	status
op	240:46	0:0	8	[
water	240:47	0:0	8	0
op	240:48	0:0	8	]
arg	240:51	240:57	7	nibble
water	240:51	0:0	8	nibble
arg	240:59	240:60	7	3
water	240:59	0:0	8	3
water	240:61	0:0	6	;
call	243:12	243:32	6	DK3_GET_NEXT_NIBBLE
water	243:33	0:0	6	;
call	244:12	244:60	6	adpcm_ima_expand_nibble
arg	244:36	244:49	7	&c->status[1]
op	244:36	0:0	8	&
water	244:37	0:0	8	c
op	244:38	0:0	8	->
water	244:40	0:0	8	status
op	244:46	0:0	8	[
water	244:47	0:0	8	1
op	244:48	0:0	8	]
arg	244:51	244:57	7	nibble
water	244:51	0:0	8	nibble
arg	244:59	244:60	7	3
water	244:59	0:0	8	3
water	244:61	0:0	6	;
water	247:12	0:0	6	diff_channel
op	247:25	0:0	6	=
water	247:27	0:0	6	(
water	247:28	0:0	6	diff_channel
op	247:41	0:0	6	+
water	247:43	0:0	6	c
op	247:44	0:0	6	->
water	247:46	0:0	6	status
op	247:52	0:0	6	[
water	247:53	0:0	6	1
op	247:54	0:0	6	]
op	247:55	0:0	6	.
water	247:56	0:0	6	predictor
water	247:65	0:0	6	)
op	247:67	0:0	6	/
water	247:69	0:0	6	2
water	247:70	0:0	6	;
op	248:12	0:0	6	*
water	248:13	0:0	6	samples
op	248:20	0:0	6	++
op	248:23	0:0	6	=
water	248:25	0:0	6	c
op	248:26	0:0	6	->
water	248:28	0:0	6	status
op	248:34	0:0	6	[
water	248:35	0:0	6	0
op	248:36	0:0	6	]
op	248:37	0:0	6	.
water	248:38	0:0	6	predictor
op	248:48	0:0	6	+
water	248:50	0:0	6	c
op	248:51	0:0	6	->
water	248:53	0:0	6	status
op	248:59	0:0	6	[
water	248:60	0:0	6	1
op	248:61	0:0	6	]
op	248:62	0:0	6	.
water	248:63	0:0	6	predictor
water	248:72	0:0	6	;
op	249:12	0:0	6	*
water	249:13	0:0	6	samples
op	249:20	0:0	6	++
op	249:23	0:0	6	=
water	249:25	0:0	6	c
op	249:26	0:0	6	->
water	249:28	0:0	6	status
op	249:34	0:0	6	[
water	249:35	0:0	6	0
op	249:36	0:0	6	]
op	249:37	0:0	6	.
water	249:38	0:0	6	predictor
op	249:48	0:0	6	-
water	249:50	0:0	6	c
op	249:51	0:0	6	->
water	249:53	0:0	6	status
op	249:59	0:0	6	[
water	249:60	0:0	6	1
op	249:61	0:0	6	]
op	249:62	0:0	6	.
water	249:63	0:0	6	predictor
water	249:72	0:0	6	;
call	252:12	252:32	6	DK3_GET_NEXT_NIBBLE
water	252:33	0:0	6	;
call	253:12	253:60	6	adpcm_ima_expand_nibble
arg	253:36	253:49	7	&c->status[0]
op	253:36	0:0	8	&
water	253:37	0:0	8	c
op	253:38	0:0	8	->
water	253:40	0:0	8	status
op	253:46	0:0	8	[
water	253:47	0:0	8	0
op	253:48	0:0	8	]
arg	253:51	253:57	7	nibble
water	253:51	0:0	8	nibble
arg	253:59	253:60	7	3
water	253:59	0:0	8	3
water	253:61	0:0	6	;
water	256:12	0:0	6	diff_channel
op	256:25	0:0	6	=
water	256:27	0:0	6	(
water	256:28	0:0	6	diff_channel
op	256:41	0:0	6	+
water	256:43	0:0	6	c
op	256:44	0:0	6	->
water	256:46	0:0	6	status
op	256:52	0:0	6	[
water	256:53	0:0	6	1
op	256:54	0:0	6	]
op	256:55	0:0	6	.
water	256:56	0:0	6	predictor
water	256:65	0:0	6	)
op	256:67	0:0	6	/
water	256:69	0:0	6	2
water	256:70	0:0	6	;
op	257:12	0:0	6	*
water	257:13	0:0	6	samples
op	257:20	0:0	6	++
op	257:23	0:0	6	=
water	257:25	0:0	6	c
op	257:26	0:0	6	->
water	257:28	0:0	6	status
op	257:34	0:0	6	[
water	257:35	0:0	6	0
op	257:36	0:0	6	]
op	257:37	0:0	6	.
water	257:38	0:0	6	predictor
op	257:48	0:0	6	+
water	257:50	0:0	6	c
op	257:51	0:0	6	->
water	257:53	0:0	6	status
op	257:59	0:0	6	[
water	257:60	0:0	6	1
op	257:61	0:0	6	]
op	257:62	0:0	6	.
water	257:63	0:0	6	predictor
water	257:72	0:0	6	;
op	258:12	0:0	6	*
water	258:13	0:0	6	samples
op	258:20	0:0	6	++
op	258:23	0:0	6	=
water	258:25	0:0	6	c
op	258:26	0:0	6	->
water	258:28	0:0	6	status
op	258:34	0:0	6	[
water	258:35	0:0	6	0
op	258:36	0:0	6	]
op	258:37	0:0	6	.
water	258:38	0:0	6	predictor
op	258:48	0:0	6	-
water	258:50	0:0	6	c
op	258:51	0:0	6	->
water	258:53	0:0	6	status
op	258:59	0:0	6	[
water	258:60	0:0	6	1
op	258:61	0:0	6	]
op	258:62	0:0	6	.
water	258:63	0:0	6	predictor
water	258:72	0:0	6	;
water	259:8	0:0	6	}
break	260:8	260:13	4	
label	261:4	261:31	4	case CODEC_ID_ADPCM_IMA_ISS :
water	262:8	0:0	4	c
op	262:9	0:0	4	->
water	262:11	0:0	4	status
op	262:17	0:0	4	[
water	262:18	0:0	4	0
op	262:19	0:0	4	]
op	262:20	0:0	4	.
water	262:21	0:0	4	predictor
op	262:32	0:0	4	=
water	262:34	0:0	4	(
water	262:35	0:0	4	int16_t
water	262:42	0:0	4	)
call	262:43	262:58	4	AV_RL16
arg	262:51	262:58	5	src+0
water	262:51	0:0	6	src
op	262:55	0:0	6	+
water	262:57	0:0	6	0
water	262:59	0:0	4	;
water	263:8	0:0	4	c
op	263:9	0:0	4	->
water	263:11	0:0	4	status
op	263:17	0:0	4	[
water	263:18	0:0	4	0
op	263:19	0:0	4	]
op	263:20	0:0	4	.
water	263:21	0:0	4	step_index
op	263:32	0:0	4	=
water	263:34	0:0	4	src
op	263:37	0:0	4	[
water	263:38	0:0	4	2
op	263:39	0:0	4	]
water	263:40	0:0	4	;
water	264:8	0:0	4	src
op	264:12	0:0	4	+=
water	264:15	0:0	4	4
water	264:16	0:0	4	;
if	265:8	269:8	4	(st)
cond	265:11	265:11	5	st
water	265:11	0:0	6	st
stmts	265:15	269:8	5	
water	265:15	0:0	6	{
water	266:12	0:0	6	c
op	266:13	0:0	6	->
water	266:15	0:0	6	status
op	266:21	0:0	6	[
water	266:22	0:0	6	1
op	266:23	0:0	6	]
op	266:24	0:0	6	.
water	266:25	0:0	6	predictor
op	266:36	0:0	6	=
water	266:38	0:0	6	(
water	266:39	0:0	6	int16_t
water	266:46	0:0	6	)
call	266:47	266:62	6	AV_RL16
arg	266:55	266:62	7	src+0
water	266:55	0:0	8	src
op	266:59	0:0	8	+
water	266:61	0:0	8	0
water	266:63	0:0	6	;
water	267:12	0:0	6	c
op	267:13	0:0	6	->
water	267:15	0:0	6	status
op	267:21	0:0	6	[
water	267:22	0:0	6	1
op	267:23	0:0	6	]
op	267:24	0:0	6	.
water	267:25	0:0	6	step_index
op	267:36	0:0	6	=
water	267:38	0:0	6	src
op	267:41	0:0	6	[
water	267:42	0:0	6	2
op	267:43	0:0	6	]
water	267:44	0:0	6	;
water	268:12	0:0	6	src
op	268:16	0:0	6	+=
water	268:19	0:0	6	4
water	268:20	0:0	6	;
water	269:8	0:0	6	}
while	271:8	286:8	4	(src < buf + buf_size)
cond	271:15	271:27	5	src < buf + buf_size
water	271:15	0:0	6	src
op	271:19	0:0	6	<
water	271:21	0:0	6	buf
op	271:25	0:0	6	+
water	271:27	0:0	6	buf_size
stmts	271:37	286:8	5	
water	271:37	0:0	6	{
if	273:12	278:12	6	(st)
cond	273:16	273:16	7	st
water	273:16	0:0	8	st
stmts	273:20	278:12	7	
water	273:20	0:0	8	{
op	274:16	0:0	8	*
water	274:17	0:0	8	samples
op	274:24	0:0	8	++
op	274:27	0:0	8	=
call	274:29	275:36	8	adpcm_ima_expand_nibble
arg	274:53	274:66	9	&c->status[0]
op	274:53	0:0	10	&
water	274:54	0:0	10	c
op	274:55	0:0	10	->
water	274:57	0:0	10	status
op	274:63	0:0	10	[
water	274:64	0:0	10	0
op	274:65	0:0	10	]
arg	275:20	275:33	9	src[0]>>4
water	275:20	0:0	10	src
op	275:23	0:0	10	[
water	275:24	0:0	10	0
op	275:25	0:0	10	]
op	275:27	0:0	10	>>
water	275:30	0:0	10	4
arg	275:35	275:36	9	3
water	275:35	0:0	10	3
water	275:37	0:0	8	;
op	276:16	0:0	8	*
water	276:17	0:0	8	samples
op	276:24	0:0	8	++
op	276:27	0:0	8	=
call	276:29	277:36	8	adpcm_ima_expand_nibble
arg	276:53	276:66	9	&c->status[1]
op	276:53	0:0	10	&
water	276:54	0:0	10	c
op	276:55	0:0	10	->
water	276:57	0:0	10	status
op	276:63	0:0	10	[
water	276:64	0:0	10	1
op	276:65	0:0	10	]
arg	277:20	277:33	9	src[0]&0x0F
water	277:20	0:0	10	src
op	277:23	0:0	10	[
water	277:24	0:0	10	0
op	277:25	0:0	10	]
op	277:27	0:0	10	&
water	277:29	0:0	10	0
water	277:30	0:0	10	x0F
arg	277:35	277:36	9	3
water	277:35	0:0	10	3
water	277:37	0:0	8	;
water	278:12	0:0	8	}
else	278:14	283:12	6
stmts	278:19	283:12	7	
water	278:19	0:0	8	{
op	279:16	0:0	8	*
water	279:17	0:0	8	samples
op	279:24	0:0	8	++
op	279:27	0:0	8	=
call	279:29	280:36	8	adpcm_ima_expand_nibble
arg	279:53	279:66	9	&c->status[0]
op	279:53	0:0	10	&
water	279:54	0:0	10	c
op	279:55	0:0	10	->
water	279:57	0:0	10	status
op	279:63	0:0	10	[
water	279:64	0:0	10	0
op	279:65	0:0	10	]
arg	280:20	280:33	9	src[0]&0x0F
water	280:20	0:0	10	src
op	280:23	0:0	10	[
water	280:24	0:0	10	0
op	280:25	0:0	10	]
op	280:27	0:0	10	&
water	280:29	0:0	10	0
water	280:30	0:0	10	x0F
arg	280:35	280:36	9	3
water	280:35	0:0	10	3
water	280:37	0:0	8	;
op	281:16	0:0	8	*
water	281:17	0:0	8	samples
op	281:24	0:0	8	++
op	281:27	0:0	8	=
call	281:29	282:36	8	adpcm_ima_expand_nibble
arg	281:53	281:66	9	&c->status[0]
op	281:53	0:0	10	&
water	281:54	0:0	10	c
op	281:55	0:0	10	->
water	281:57	0:0	10	status
op	281:63	0:0	10	[
water	281:64	0:0	10	0
op	281:65	0:0	10	]
arg	282:20	282:33	9	src[0]>>4
water	282:20	0:0	10	src
op	282:23	0:0	10	[
water	282:24	0:0	10	0
op	282:25	0:0	10	]
op	282:27	0:0	10	>>
water	282:30	0:0	10	4
arg	282:35	282:36	9	3
water	282:35	0:0	10	3
water	282:37	0:0	8	;
water	283:12	0:0	8	}
water	285:12	0:0	6	src
op	285:15	0:0	6	++
water	285:17	0:0	6	;
water	286:8	0:0	6	}
break	287:8	287:13	4	
label	288:4	288:30	4	case CODEC_ID_ADPCM_IMA_WS :
while	290:8	305:8	4	(src < buf + buf_size)
cond	290:15	290:27	5	src < buf + buf_size
water	290:15	0:0	6	src
op	290:19	0:0	6	<
water	290:21	0:0	6	buf
op	290:25	0:0	6	+
water	290:27	0:0	6	buf_size
stmts	290:37	305:8	5	
water	290:37	0:0	6	{
if	292:12	297:12	6	(st)
cond	292:16	292:16	7	st
water	292:16	0:0	8	st
stmts	292:20	297:12	7	
water	292:20	0:0	8	{
op	293:16	0:0	8	*
water	293:17	0:0	8	samples
op	293:24	0:0	8	++
op	293:27	0:0	8	=
call	293:29	294:36	8	adpcm_ima_expand_nibble
arg	293:53	293:66	9	&c->status[0]
op	293:53	0:0	10	&
water	293:54	0:0	10	c
op	293:55	0:0	10	->
water	293:57	0:0	10	status
op	293:63	0:0	10	[
water	293:64	0:0	10	0
op	293:65	0:0	10	]
arg	294:20	294:33	9	src[0]>>4
water	294:20	0:0	10	src
op	294:23	0:0	10	[
water	294:24	0:0	10	0
op	294:25	0:0	10	]
op	294:27	0:0	10	>>
water	294:30	0:0	10	4
arg	294:35	294:36	9	3
water	294:35	0:0	10	3
water	294:37	0:0	8	;
op	295:16	0:0	8	*
water	295:17	0:0	8	samples
op	295:24	0:0	8	++
op	295:27	0:0	8	=
call	295:29	296:36	8	adpcm_ima_expand_nibble
arg	295:53	295:66	9	&c->status[1]
op	295:53	0:0	10	&
water	295:54	0:0	10	c
op	295:55	0:0	10	->
water	295:57	0:0	10	status
op	295:63	0:0	10	[
water	295:64	0:0	10	1
op	295:65	0:0	10	]
arg	296:20	296:33	9	src[0]&0x0F
water	296:20	0:0	10	src
op	296:23	0:0	10	[
water	296:24	0:0	10	0
op	296:25	0:0	10	]
op	296:27	0:0	10	&
water	296:29	0:0	10	0
water	296:30	0:0	10	x0F
arg	296:35	296:36	9	3
water	296:35	0:0	10	3
water	296:37	0:0	8	;
water	297:12	0:0	8	}
else	297:14	302:12	6
stmts	297:19	302:12	7	
water	297:19	0:0	8	{
op	298:16	0:0	8	*
water	298:17	0:0	8	samples
op	298:24	0:0	8	++
op	298:27	0:0	8	=
call	298:29	299:36	8	adpcm_ima_expand_nibble
arg	298:53	298:66	9	&c->status[0]
op	298:53	0:0	10	&
water	298:54	0:0	10	c
op	298:55	0:0	10	->
water	298:57	0:0	10	status
op	298:63	0:0	10	[
water	298:64	0:0	10	0
op	298:65	0:0	10	]
arg	299:20	299:33	9	src[0]>>4
water	299:20	0:0	10	src
op	299:23	0:0	10	[
water	299:24	0:0	10	0
op	299:25	0:0	10	]
op	299:27	0:0	10	>>
water	299:30	0:0	10	4
arg	299:35	299:36	9	3
water	299:35	0:0	10	3
water	299:37	0:0	8	;
op	300:16	0:0	8	*
water	300:17	0:0	8	samples
op	300:24	0:0	8	++
op	300:27	0:0	8	=
call	300:29	301:36	8	adpcm_ima_expand_nibble
arg	300:53	300:66	9	&c->status[0]
op	300:53	0:0	10	&
water	300:54	0:0	10	c
op	300:55	0:0	10	->
water	300:57	0:0	10	status
op	300:63	0:0	10	[
water	300:64	0:0	10	0
op	300:65	0:0	10	]
arg	301:20	301:33	9	src[0]&0x0F
water	301:20	0:0	10	src
op	301:23	0:0	10	[
water	301:24	0:0	10	0
op	301:25	0:0	10	]
op	301:27	0:0	10	&
water	301:29	0:0	10	0
water	301:30	0:0	10	x0F
arg	301:35	301:36	9	3
water	301:35	0:0	10	3
water	301:37	0:0	8	;
water	302:12	0:0	8	}
water	304:12	0:0	6	src
op	304:15	0:0	6	++
water	304:17	0:0	6	;
water	305:8	0:0	6	}
break	306:8	306:13	4	
label	307:4	307:26	4	case CODEC_ID_ADPCM_XA :
while	308:8	314:8	4	(buf_size >= 128)
cond	308:15	308:27	5	buf_size >= 128
water	308:15	0:0	6	buf_size
op	308:24	0:0	6	>=
water	308:27	0:0	6	128
stmts	308:32	314:8	5	
water	308:32	0:0	6	{
call	309:12	310:31	6	xa_decode
arg	309:22	309:29	7	samples
water	309:22	0:0	8	samples
arg	309:31	309:34	7	src
water	309:31	0:0	8	src
arg	309:36	309:49	7	&c->status[0]
op	309:36	0:0	8	&
water	309:37	0:0	8	c
op	309:38	0:0	8	->
water	309:40	0:0	8	status
op	309:46	0:0	8	[
water	309:47	0:0	8	0
op	309:48	0:0	8	]
arg	309:51	309:64	7	&c->status[1]
op	309:51	0:0	8	&
water	309:52	0:0	8	c
op	309:53	0:0	8	->
water	309:55	0:0	8	status
op	309:61	0:0	8	[
water	309:62	0:0	8	1
op	309:63	0:0	8	]
arg	310:16	310:31	7	avctx->channels
water	310:16	0:0	8	avctx
op	310:21	0:0	8	->
water	310:23	0:0	8	channels
water	310:32	0:0	6	;
water	311:12	0:0	6	src
op	311:16	0:0	6	+=
water	311:19	0:0	6	128
water	311:22	0:0	6	;
water	312:12	0:0	6	samples
op	312:20	0:0	6	+=
water	312:23	0:0	6	28
op	312:26	0:0	6	*
water	312:28	0:0	6	8
water	312:29	0:0	6	;
water	313:12	0:0	6	buf_size
op	313:21	0:0	6	-=
water	313:24	0:0	6	128
water	313:27	0:0	6	;
water	314:8	0:0	6	}
break	315:8	315:13	4	
label	316:4	316:35	4	case CODEC_ID_ADPCM_IMA_EA_EACS :
water	316:37	0:0	4	{
water	317:8	0:0	4	unsigned
water	317:17	0:0	4	header_size
op	317:29	0:0	4	=
water	317:31	0:0	4	4
op	317:33	0:0	4	+
water	317:35	0:0	4	(
water	317:36	0:0	4	8
op	317:37	0:0	4	<<
water	317:39	0:0	4	st
water	317:41	0:0	4	)
water	317:42	0:0	4	;
water	318:8	0:0	4	samples_in_chunk
op	318:25	0:0	4	=
call	318:27	318:51	4	bytestream_get_le32
arg	318:47	318:51	5	&src
op	318:47	0:0	6	&
water	318:48	0:0	6	src
op	318:53	0:0	4	>>
water	318:56	0:0	4	(
water	318:57	0:0	4	1
op	318:58	0:0	4	-
water	318:59	0:0	4	st
water	318:61	0:0	4	)
water	318:62	0:0	4	;
if	320:8	323:8	4	(buf_size < header_size || samples_in_chunk > buf_size - header_size)
cond	320:12	320:68	5	buf_size < header_size || samples_in_chunk > buf_size - header_size
water	320:12	0:0	6	buf_size
op	320:21	0:0	6	<
water	320:23	0:0	6	header_size
op	320:35	0:0	6	||
water	320:38	0:0	6	samples_in_chunk
op	320:55	0:0	6	>
water	320:57	0:0	6	buf_size
op	320:66	0:0	6	-
water	320:68	0:0	6	header_size
stmts	320:81	323:8	5	
water	320:81	0:0	6	{
water	321:12	0:0	6	src
op	321:16	0:0	6	+=
water	321:19	0:0	6	buf_size
op	321:28	0:0	6	-
water	321:30	0:0	6	4
water	321:31	0:0	6	;
break	322:12	322:17	6	
water	323:8	0:0	6	}
for	325:8	326:63	4	(i = 0 ;i <= st;i ++)
forinit	325:13	325:16	5	i = 0 ;
water	325:13	0:0	6	i
op	325:14	0:0	6	=
water	325:15	0:0	6	0
water	325:16	0:0	6	;
cond	325:18	325:21	5	i <= st
water	325:18	0:0	6	i
op	325:19	0:0	6	<=
water	325:21	0:0	6	st
forexpr	325:25	325:26	5	i ++
water	325:25	0:0	6	i
op	325:26	0:0	6	++
stmts	326:12	326:63	5	
water	326:12	0:0	6	c
op	326:13	0:0	6	->
water	326:15	0:0	6	status
op	326:21	0:0	6	[
water	326:22	0:0	6	i
op	326:23	0:0	6	]
op	326:24	0:0	6	.
water	326:25	0:0	6	step_index
op	326:36	0:0	6	=
call	326:38	326:62	6	bytestream_get_le32
arg	326:58	326:62	7	&src
op	326:58	0:0	8	&
water	326:59	0:0	8	src
water	326:63	0:0	6	;
for	327:8	328:63	4	(i = 0 ;i <= st;i ++)
forinit	327:13	327:16	5	i = 0 ;
water	327:13	0:0	6	i
op	327:14	0:0	6	=
water	327:15	0:0	6	0
water	327:16	0:0	6	;
cond	327:18	327:21	5	i <= st
water	327:18	0:0	6	i
op	327:19	0:0	6	<=
water	327:21	0:0	6	st
forexpr	327:25	327:26	5	i ++
water	327:25	0:0	6	i
op	327:26	0:0	6	++
stmts	328:12	328:63	5	
water	328:12	0:0	6	c
op	328:13	0:0	6	->
water	328:15	0:0	6	status
op	328:21	0:0	6	[
water	328:22	0:0	6	i
op	328:23	0:0	6	]
op	328:24	0:0	6	.
water	328:25	0:0	6	predictor
op	328:36	0:0	6	=
call	328:38	328:62	6	bytestream_get_le32
arg	328:58	328:62	7	&src
op	328:58	0:0	8	&
water	328:59	0:0	8	src
water	328:63	0:0	6	;
for	330:8	333:8	4	(;samples_in_chunk;samples_in_chunk -- , src ++)
forinit	330:13	330:13	5	;
water	330:13	0:0	6	;
cond	330:15	330:15	5	samples_in_chunk
water	330:15	0:0	6	samples_in_chunk
forexpr	330:33	330:56	5	samples_in_chunk -- , src ++
water	330:33	0:0	6	samples_in_chunk
op	330:49	0:0	6	--
water	330:51	0:0	6	,
water	330:53	0:0	6	src
op	330:56	0:0	6	++
stmts	330:60	333:8	5	
water	330:60	0:0	6	{
op	331:12	0:0	6	*
water	331:13	0:0	6	samples
op	331:20	0:0	6	++
op	331:23	0:0	6	=
call	331:25	331:77	6	adpcm_ima_expand_nibble
arg	331:49	331:62	7	&c->status[0]
op	331:49	0:0	8	&
water	331:50	0:0	8	c
op	331:51	0:0	8	->
water	331:53	0:0	8	status
op	331:59	0:0	8	[
water	331:60	0:0	8	0
op	331:61	0:0	8	]
arg	331:65	331:72	7	*src>>4
op	331:65	0:0	8	*
water	331:66	0:0	8	src
op	331:69	0:0	8	>>
water	331:71	0:0	8	4
arg	331:76	331:77	7	3
water	331:76	0:0	8	3
water	331:78	0:0	6	;
op	332:12	0:0	6	*
water	332:13	0:0	6	samples
op	332:20	0:0	6	++
op	332:23	0:0	6	=
call	332:25	332:77	6	adpcm_ima_expand_nibble
arg	332:49	332:63	7	&c->status[st]
op	332:49	0:0	8	&
water	332:50	0:0	8	c
op	332:51	0:0	8	->
water	332:53	0:0	8	status
op	332:59	0:0	8	[
water	332:60	0:0	8	st
op	332:62	0:0	8	]
arg	332:65	332:74	7	*src&0x0F
op	332:65	0:0	8	*
water	332:66	0:0	8	src
op	332:69	0:0	8	&
water	332:70	0:0	8	0
water	332:71	0:0	8	x0F
arg	332:76	332:77	7	3
water	332:76	0:0	8	3
water	332:78	0:0	6	;
water	333:8	0:0	6	}
break	334:8	334:13	4	
water	335:4	0:0	4	}
label	336:4	336:35	4	case CODEC_ID_ADPCM_IMA_EA_SEAD :
for	337:8	340:8	4	(;src < buf + buf_size;src ++)
forinit	337:13	337:13	5	;
water	337:13	0:0	6	;
cond	337:15	337:25	5	src < buf + buf_size
water	337:15	0:0	6	src
op	337:19	0:0	6	<
water	337:21	0:0	6	buf
op	337:24	0:0	6	+
water	337:25	0:0	6	buf_size
forexpr	337:35	337:38	5	src ++
water	337:35	0:0	6	src
op	337:38	0:0	6	++
stmts	337:42	340:8	5	
water	337:42	0:0	6	{
op	338:12	0:0	6	*
water	338:13	0:0	6	samples
op	338:20	0:0	6	++
op	338:23	0:0	6	=
call	338:25	338:78	6	adpcm_ima_expand_nibble
arg	338:49	338:62	7	&c->status[0]
op	338:49	0:0	8	&
water	338:50	0:0	8	c
op	338:51	0:0	8	->
water	338:53	0:0	8	status
op	338:59	0:0	8	[
water	338:60	0:0	8	0
op	338:61	0:0	8	]
arg	338:64	338:75	7	src[0]>>4
water	338:64	0:0	8	src
op	338:67	0:0	8	[
water	338:68	0:0	8	0
op	338:69	0:0	8	]
op	338:71	0:0	8	>>
water	338:74	0:0	8	4
arg	338:77	338:78	7	6
water	338:77	0:0	8	6
water	338:79	0:0	6	;
op	339:12	0:0	6	*
water	339:13	0:0	6	samples
op	339:20	0:0	6	++
op	339:23	0:0	6	=
call	339:25	339:78	6	adpcm_ima_expand_nibble
arg	339:49	339:63	7	&c->status[st]
op	339:49	0:0	8	&
water	339:50	0:0	8	c
op	339:51	0:0	8	->
water	339:53	0:0	8	status
op	339:59	0:0	8	[
water	339:60	0:0	8	st
op	339:62	0:0	8	]
arg	339:64	339:75	7	src[0]&0x0F
water	339:64	0:0	8	src
op	339:67	0:0	8	[
water	339:68	0:0	8	0
op	339:69	0:0	8	]
op	339:70	0:0	8	&
water	339:71	0:0	8	0
water	339:72	0:0	8	x0F
arg	339:77	339:78	7	6
water	339:77	0:0	8	6
water	339:79	0:0	6	;
water	340:8	0:0	6	}
break	341:8	341:13	4	
label	342:4	342:26	4	case CODEC_ID_ADPCM_EA :
if	343:8	346:8	4	(buf_size< 12 || AV_RL32 ( src ) >(buf_size - 12 ) / 30 * 28)
cond	343:12	343:63	5	buf_size< 12 || AV_RL32 ( src ) >(buf_size - 12 ) / 30 * 28
call	343:12	343:58	6	buf_size
arg	343:45	343:58	7	buf_size-12
water	343:45	0:0	8	buf_size
op	343:54	0:0	8	-
water	343:56	0:0	8	12
op	343:59	0:0	6	/
water	343:60	0:0	6	30
op	343:62	0:0	6	*
water	343:63	0:0	6	28
stmts	343:67	346:8	5	
water	343:67	0:0	6	{
water	344:12	0:0	6	src
op	344:16	0:0	6	+=
water	344:19	0:0	6	buf_size
water	344:27	0:0	6	;
break	345:12	345:17	6	
water	346:8	0:0	6	}
water	347:8	0:0	4	samples_in_chunk
op	347:25	0:0	4	=
call	347:27	347:38	4	AV_RL32
arg	347:35	347:38	5	src
water	347:35	0:0	6	src
water	347:39	0:0	4	;
water	348:8	0:0	4	src
op	348:12	0:0	4	+=
water	348:15	0:0	4	4
water	348:16	0:0	4	;
water	349:8	0:0	4	current_left_sample
op	349:30	0:0	4	=
water	349:32	0:0	4	(
water	349:33	0:0	4	int16_t
water	349:40	0:0	4	)
call	349:41	349:65	4	bytestream_get_le16
arg	349:61	349:65	5	&src
op	349:61	0:0	6	&
water	349:62	0:0	6	src
water	349:66	0:0	4	;
water	350:8	0:0	4	previous_left_sample
op	350:30	0:0	4	=
water	350:32	0:0	4	(
water	350:33	0:0	4	int16_t
water	350:40	0:0	4	)
call	350:41	350:65	4	bytestream_get_le16
arg	350:61	350:65	5	&src
op	350:61	0:0	6	&
water	350:62	0:0	6	src
water	350:66	0:0	4	;
water	351:8	0:0	4	current_right_sample
op	351:30	0:0	4	=
water	351:32	0:0	4	(
water	351:33	0:0	4	int16_t
water	351:40	0:0	4	)
call	351:41	351:65	4	bytestream_get_le16
arg	351:61	351:65	5	&src
op	351:61	0:0	6	&
water	351:62	0:0	6	src
water	351:66	0:0	4	;
water	352:8	0:0	4	previous_right_sample
op	352:30	0:0	4	=
water	352:32	0:0	4	(
water	352:33	0:0	4	int16_t
water	352:40	0:0	4	)
call	352:41	352:65	4	bytestream_get_le16
arg	352:61	352:65	5	&src
op	352:61	0:0	6	&
water	352:62	0:0	6	src
water	352:66	0:0	4	;
for	354:8	384:8	4	(count1 = 0 ;count1 < samples_in_chunk / 28;count1 ++)
forinit	354:13	354:23	5	count1 = 0 ;
water	354:13	0:0	6	count1
op	354:20	0:0	6	=
water	354:22	0:0	6	0
water	354:23	0:0	6	;
cond	354:25	354:51	5	count1 < samples_in_chunk / 28
water	354:25	0:0	6	count1
op	354:32	0:0	6	<
water	354:34	0:0	6	samples_in_chunk
op	354:50	0:0	6	/
water	354:51	0:0	6	28
forexpr	354:54	354:60	5	count1 ++
water	354:54	0:0	6	count1
op	354:60	0:0	6	++
stmts	354:64	384:8	5	
water	354:64	0:0	6	{
water	355:12	0:0	6	coeff1l
op	355:20	0:0	6	=
water	355:22	0:0	6	ea_adpcm_table
op	355:36	0:0	6	[
op	355:38	0:0	6	*
water	355:39	0:0	6	src
op	355:43	0:0	6	>>
water	355:46	0:0	6	4
op	355:54	0:0	6	]
water	355:55	0:0	6	;
water	356:12	0:0	6	coeff2l
op	356:20	0:0	6	=
water	356:22	0:0	6	ea_adpcm_table
op	356:36	0:0	6	[
water	356:37	0:0	6	(
op	356:38	0:0	6	*
water	356:39	0:0	6	src
op	356:43	0:0	6	>>
water	356:46	0:0	6	4
water	356:49	0:0	6	)
op	356:51	0:0	6	+
water	356:53	0:0	6	4
op	356:54	0:0	6	]
water	356:55	0:0	6	;
water	357:12	0:0	6	coeff1r
op	357:20	0:0	6	=
water	357:22	0:0	6	ea_adpcm_table
op	357:36	0:0	6	[
op	357:37	0:0	6	*
water	357:38	0:0	6	src
op	357:42	0:0	6	&
water	357:44	0:0	6	0
water	357:45	0:0	6	x0F
op	357:48	0:0	6	]
water	357:49	0:0	6	;
water	358:12	0:0	6	coeff2r
op	358:20	0:0	6	=
water	358:22	0:0	6	ea_adpcm_table
op	358:36	0:0	6	[
water	358:37	0:0	6	(
op	358:38	0:0	6	*
water	358:39	0:0	6	src
op	358:43	0:0	6	&
water	358:45	0:0	6	0
water	358:46	0:0	6	x0F
water	358:49	0:0	6	)
op	358:51	0:0	6	+
water	358:53	0:0	6	4
op	358:54	0:0	6	]
water	358:55	0:0	6	;
water	359:12	0:0	6	src
op	359:15	0:0	6	++
water	359:17	0:0	6	;
water	361:12	0:0	6	shift_left
op	361:24	0:0	6	=
water	361:26	0:0	6	(
op	361:27	0:0	6	*
water	361:28	0:0	6	src
op	361:32	0:0	6	>>
water	361:35	0:0	6	4
water	361:38	0:0	6	)
op	361:40	0:0	6	+
water	361:42	0:0	6	8
water	361:43	0:0	6	;
water	362:12	0:0	6	shift_right
op	362:24	0:0	6	=
water	362:26	0:0	6	(
op	362:27	0:0	6	*
water	362:28	0:0	6	src
op	362:32	0:0	6	&
water	362:34	0:0	6	0
water	362:35	0:0	6	x0F
water	362:38	0:0	6	)
op	362:40	0:0	6	+
water	362:42	0:0	6	8
water	362:43	0:0	6	;
water	363:12	0:0	6	src
op	363:15	0:0	6	++
water	363:17	0:0	6	;
for	365:12	383:12	6	(count2 = 0 ;count2 < 28;count2 ++)
forinit	365:17	365:27	7	count2 = 0 ;
water	365:17	0:0	8	count2
op	365:24	0:0	8	=
water	365:26	0:0	8	0
water	365:27	0:0	8	;
cond	365:29	365:38	7	count2 < 28
water	365:29	0:0	8	count2
op	365:36	0:0	8	<
water	365:38	0:0	8	28
forexpr	365:42	365:48	7	count2 ++
water	365:42	0:0	8	count2
op	365:48	0:0	8	++
stmts	365:52	383:12	7	
water	365:52	0:0	8	{
water	366:16	0:0	8	next_left_sample
op	366:34	0:0	8	=
call	366:36	366:65	8	(int32_t)
arg	366:46	366:65	9	(*src&0xF0)<<24
water	366:46	0:0	10	(
op	366:47	0:0	10	*
water	366:48	0:0	10	src
op	366:52	0:0	10	&
water	366:54	0:0	10	0
water	366:55	0:0	10	xF0
water	366:58	0:0	10	)
op	366:60	0:0	10	<<
water	366:63	0:0	10	24
op	366:67	0:0	8	>>
water	366:70	0:0	8	shift_left
water	366:80	0:0	8	;
water	367:16	0:0	8	next_right_sample
op	367:34	0:0	8	=
call	367:36	367:65	8	(int32_t)
arg	367:46	367:65	9	(*src&0x0F)<<28
water	367:46	0:0	10	(
op	367:47	0:0	10	*
water	367:48	0:0	10	src
op	367:52	0:0	10	&
water	367:54	0:0	10	0
water	367:55	0:0	10	x0F
water	367:58	0:0	10	)
op	367:60	0:0	10	<<
water	367:63	0:0	10	28
op	367:67	0:0	8	>>
water	367:70	0:0	8	shift_right
water	367:81	0:0	8	;
water	368:16	0:0	8	src
op	368:19	0:0	8	++
water	368:21	0:0	8	;
water	370:16	0:0	8	next_left_sample
op	370:33	0:0	8	=
water	370:35	0:0	8	(
water	370:36	0:0	8	next_left_sample
op	370:53	0:0	8	+
water	371:20	0:0	8	(
water	371:21	0:0	8	current_left_sample
op	371:41	0:0	8	*
water	371:43	0:0	8	coeff1l
water	371:50	0:0	8	)
op	371:52	0:0	8	+
water	372:20	0:0	8	(
water	372:21	0:0	8	previous_left_sample
op	372:42	0:0	8	*
water	372:44	0:0	8	coeff2l
water	372:51	0:0	8	)
op	372:53	0:0	8	+
water	372:55	0:0	8	0
water	372:56	0:0	8	x80
water	372:59	0:0	8	)
op	372:61	0:0	8	>>
water	372:64	0:0	8	8
water	372:65	0:0	8	;
water	373:16	0:0	8	next_right_sample
op	373:34	0:0	8	=
water	373:36	0:0	8	(
water	373:37	0:0	8	next_right_sample
op	373:55	0:0	8	+
water	374:20	0:0	8	(
water	374:21	0:0	8	current_right_sample
op	374:42	0:0	8	*
water	374:44	0:0	8	coeff1r
water	374:51	0:0	8	)
op	374:53	0:0	8	+
water	375:20	0:0	8	(
water	375:21	0:0	8	previous_right_sample
op	375:43	0:0	8	*
water	375:45	0:0	8	coeff2r
water	375:52	0:0	8	)
op	375:54	0:0	8	+
water	375:56	0:0	8	0
water	375:57	0:0	8	x80
water	375:60	0:0	8	)
op	375:62	0:0	8	>>
water	375:65	0:0	8	8
water	375:66	0:0	8	;
water	377:16	0:0	8	previous_left_sample
op	377:37	0:0	8	=
water	377:39	0:0	8	current_left_sample
water	377:58	0:0	8	;
water	378:16	0:0	8	current_left_sample
op	378:36	0:0	8	=
call	378:38	378:68	8	av_clip_int16
arg	378:52	378:68	9	next_left_sample
water	378:52	0:0	10	next_left_sample
water	378:69	0:0	8	;
water	379:16	0:0	8	previous_right_sample
op	379:38	0:0	8	=
water	379:40	0:0	8	current_right_sample
water	379:60	0:0	8	;
water	380:16	0:0	8	current_right_sample
op	380:37	0:0	8	=
call	380:39	380:70	8	av_clip_int16
arg	380:53	380:70	9	next_right_sample
water	380:53	0:0	10	next_right_sample
water	380:71	0:0	8	;
op	381:16	0:0	8	*
water	381:17	0:0	8	samples
op	381:24	0:0	8	++
op	381:27	0:0	8	=
water	381:29	0:0	8	(
water	381:30	0:0	8	unsigned
water	381:39	0:0	8	short
water	381:44	0:0	8	)
water	381:45	0:0	8	current_left_sample
water	381:64	0:0	8	;
op	382:16	0:0	8	*
water	382:17	0:0	8	samples
op	382:24	0:0	8	++
op	382:27	0:0	8	=
water	382:29	0:0	8	(
water	382:30	0:0	8	unsigned
water	382:39	0:0	8	short
water	382:44	0:0	8	)
water	382:45	0:0	8	current_right_sample
water	382:65	0:0	8	;
water	383:12	0:0	8	}
water	384:8	0:0	6	}
if	386:8	387:20	4	(src - buf == buf_size - 2)
cond	386:12	386:36	5	src - buf == buf_size - 2
water	386:12	0:0	6	src
op	386:16	0:0	6	-
water	386:18	0:0	6	buf
op	386:22	0:0	6	==
water	386:25	0:0	6	buf_size
op	386:34	0:0	6	-
water	386:36	0:0	6	2
stmts	387:12	387:20	5	
water	387:12	0:0	6	src
op	387:16	0:0	6	+=
water	387:19	0:0	6	2
water	387:20	0:0	6	;
break	389:8	389:13	4	
label	390:4	390:35	4	case CODEC_ID_ADPCM_EA_MAXIS_XA :
for	391:8	396:8	4	(channel = 0 ;channel < avctx -> channels;channel ++)
forinit	391:12	391:23	5	channel = 0 ;
water	391:12	0:0	6	channel
op	391:20	0:0	6	=
water	391:22	0:0	6	0
water	391:23	0:0	6	;
cond	391:25	391:42	5	channel < avctx -> channels
water	391:25	0:0	6	channel
op	391:33	0:0	6	<
water	391:35	0:0	6	avctx
op	391:40	0:0	6	->
water	391:42	0:0	6	channels
forexpr	391:52	391:59	5	channel ++
water	391:52	0:0	6	channel
op	391:59	0:0	6	++
stmts	391:63	396:8	5	
water	391:63	0:0	6	{
for	392:12	393:69	6	(i = 0 ;i < 2;i ++)
forinit	392:17	392:20	7	i = 0 ;
water	392:17	0:0	8	i
op	392:18	0:0	8	=
water	392:19	0:0	8	0
water	392:20	0:0	8	;
cond	392:22	392:24	7	i < 2
water	392:22	0:0	8	i
op	392:23	0:0	8	<
water	392:24	0:0	8	2
forexpr	392:27	392:28	7	i ++
water	392:27	0:0	8	i
op	392:28	0:0	8	++
stmts	393:16	393:69	7	
water	393:16	0:0	8	coeff
op	393:21	0:0	8	[
water	393:22	0:0	8	channel
op	393:29	0:0	8	]
op	393:30	0:0	8	[
water	393:31	0:0	8	i
op	393:32	0:0	8	]
op	393:34	0:0	8	=
water	393:36	0:0	8	ea_adpcm_table
op	393:50	0:0	8	[
water	393:51	0:0	8	(
op	393:52	0:0	8	*
water	393:53	0:0	8	src
op	393:57	0:0	8	>>
water	393:60	0:0	8	4
water	393:61	0:0	8	)
op	393:63	0:0	8	+
water	393:65	0:0	8	4
op	393:66	0:0	8	*
water	393:67	0:0	8	i
op	393:68	0:0	8	]
water	393:69	0:0	8	;
water	394:12	0:0	6	shift
op	394:17	0:0	6	[
water	394:18	0:0	6	channel
op	394:25	0:0	6	]
op	394:27	0:0	6	=
water	394:29	0:0	6	(
op	394:30	0:0	6	*
water	394:31	0:0	6	src
op	394:35	0:0	6	&
water	394:37	0:0	6	0
water	394:38	0:0	6	x0F
water	394:41	0:0	6	)
op	394:43	0:0	6	+
water	394:45	0:0	6	8
water	394:46	0:0	6	;
water	395:12	0:0	6	src
op	395:15	0:0	6	++
water	395:17	0:0	6	;
water	396:8	0:0	6	}
for	397:8	410:8	4	(count1 = 0 ;count1 < ( buf_size - avctx -> channels ) / avctx -> channels;count1 ++)
forinit	397:13	397:23	5	count1 = 0 ;
water	397:13	0:0	6	count1
op	397:20	0:0	6	=
water	397:22	0:0	6	0
water	397:23	0:0	6	;
cond	397:25	397:72	5	count1 < ( buf_size - avctx -> channels ) / avctx -> channels
water	397:25	0:0	6	count1
op	397:32	0:0	6	<
water	397:34	0:0	6	(
water	397:35	0:0	6	buf_size
op	397:44	0:0	6	-
water	397:46	0:0	6	avctx
op	397:51	0:0	6	->
water	397:53	0:0	6	channels
water	397:61	0:0	6	)
op	397:63	0:0	6	/
water	397:65	0:0	6	avctx
op	397:70	0:0	6	->
water	397:72	0:0	6	channels
forexpr	397:82	397:88	5	count1 ++
water	397:82	0:0	6	count1
op	397:88	0:0	6	++
stmts	397:92	410:8	5	
water	397:92	0:0	6	{
for	398:12	408:12	6	(i = 4 ;i >= 0;i -= 4)
forinit	398:16	398:21	7	i = 4 ;
water	398:16	0:0	8	i
op	398:18	0:0	8	=
water	398:20	0:0	8	4
water	398:21	0:0	8	;
cond	398:23	398:28	7	i >= 0
water	398:23	0:0	8	i
op	398:25	0:0	8	>=
water	398:28	0:0	8	0
forexpr	398:31	398:34	7	i -= 4
water	398:31	0:0	8	i
op	398:32	0:0	8	-=
water	398:34	0:0	8	4
stmts	398:37	408:12	7	
water	398:37	0:0	8	{
for	399:16	407:16	8	(channel = 0 ;channel < avctx -> channels;channel ++)
forinit	399:20	399:31	9	channel = 0 ;
water	399:20	0:0	10	channel
op	399:28	0:0	10	=
water	399:30	0:0	10	0
water	399:31	0:0	10	;
cond	399:33	399:50	9	channel < avctx -> channels
water	399:33	0:0	10	channel
op	399:41	0:0	10	<
water	399:43	0:0	10	avctx
op	399:48	0:0	10	->
water	399:50	0:0	10	channels
forexpr	399:60	399:67	9	channel ++
water	399:60	0:0	10	channel
op	399:67	0:0	10	++
stmts	399:71	407:16	9	
water	399:71	0:0	10	{
decl	400:20	400:104	10	int32_t	sample
op	400:35	0:0	10	=
call	400:37	400:85	11	(int32_t)
arg	400:47	400:85	12	((*(src+channel)>>i)&0x0F)<<0x1C
water	400:47	0:0	13	(
water	400:48	0:0	13	(
op	400:49	0:0	13	*
water	400:50	0:0	13	(
water	400:51	0:0	13	src
op	400:54	0:0	13	+
water	400:55	0:0	13	channel
water	400:62	0:0	13	)
op	400:64	0:0	13	>>
water	400:67	0:0	13	i
water	400:68	0:0	13	)
op	400:70	0:0	13	&
water	400:72	0:0	13	0
water	400:73	0:0	13	x0F
water	400:76	0:0	13	)
op	400:78	0:0	13	<<
water	400:81	0:0	13	0
water	400:82	0:0	13	x1C
op	400:87	0:0	10	>>
water	400:90	0:0	10	shift
op	400:95	0:0	10	[
water	400:96	0:0	10	channel
op	400:103	0:0	10	]
water	401:20	0:0	10	sample
op	401:27	0:0	10	=
water	401:29	0:0	10	(
water	401:30	0:0	10	sample
op	401:37	0:0	10	+
water	402:29	0:0	10	c
op	402:30	0:0	10	->
water	402:32	0:0	10	status
op	402:38	0:0	10	[
water	402:39	0:0	10	channel
op	402:46	0:0	10	]
op	402:47	0:0	10	.
water	402:48	0:0	10	sample1
op	402:56	0:0	10	*
water	402:58	0:0	10	coeff
op	402:63	0:0	10	[
water	402:64	0:0	10	channel
op	402:71	0:0	10	]
op	402:72	0:0	10	[
water	402:73	0:0	10	0
op	402:74	0:0	10	]
op	402:76	0:0	10	+
water	403:29	0:0	10	c
op	403:30	0:0	10	->
water	403:32	0:0	10	status
op	403:38	0:0	10	[
water	403:39	0:0	10	channel
op	403:46	0:0	10	]
op	403:47	0:0	10	.
water	403:48	0:0	10	sample2
op	403:56	0:0	10	*
water	403:58	0:0	10	coeff
op	403:63	0:0	10	[
water	403:64	0:0	10	channel
op	403:71	0:0	10	]
op	403:72	0:0	10	[
water	403:73	0:0	10	1
op	403:74	0:0	10	]
op	403:76	0:0	10	+
water	403:78	0:0	10	0
water	403:79	0:0	10	x80
water	403:82	0:0	10	)
op	403:84	0:0	10	>>
water	403:87	0:0	10	8
water	403:88	0:0	10	;
water	404:20	0:0	10	c
op	404:21	0:0	10	->
water	404:23	0:0	10	status
op	404:29	0:0	10	[
water	404:30	0:0	10	channel
op	404:37	0:0	10	]
op	404:38	0:0	10	.
water	404:39	0:0	10	sample2
op	404:47	0:0	10	=
water	404:49	0:0	10	c
op	404:50	0:0	10	->
water	404:52	0:0	10	status
op	404:58	0:0	10	[
water	404:59	0:0	10	channel
op	404:66	0:0	10	]
op	404:67	0:0	10	.
water	404:68	0:0	10	sample1
water	404:75	0:0	10	;
water	405:20	0:0	10	c
op	405:21	0:0	10	->
water	405:23	0:0	10	status
op	405:29	0:0	10	[
water	405:30	0:0	10	channel
op	405:37	0:0	10	]
op	405:38	0:0	10	.
water	405:39	0:0	10	sample1
op	405:47	0:0	10	=
call	405:49	405:69	10	av_clip_int16
arg	405:63	405:69	11	sample
water	405:63	0:0	12	sample
water	405:70	0:0	10	;
op	406:20	0:0	10	*
water	406:21	0:0	10	samples
op	406:28	0:0	10	++
op	406:31	0:0	10	=
water	406:33	0:0	10	c
op	406:34	0:0	10	->
water	406:36	0:0	10	status
op	406:42	0:0	10	[
water	406:43	0:0	10	channel
op	406:50	0:0	10	]
op	406:51	0:0	10	.
water	406:52	0:0	10	sample1
water	406:59	0:0	10	;
water	407:16	0:0	10	}
water	408:12	0:0	8	}
water	409:12	0:0	6	src
op	409:15	0:0	6	+=
water	409:17	0:0	6	avctx
op	409:22	0:0	6	->
water	409:24	0:0	6	channels
water	409:32	0:0	6	;
water	410:8	0:0	6	}
break	411:8	411:13	4	
label	412:4	412:29	4	case CODEC_ID_ADPCM_EA_R1 :
label	413:4	413:29	4	case CODEC_ID_ADPCM_EA_R2 :
label	414:4	414:29	4	case CODEC_ID_ADPCM_EA_R3 :
water	414:31	0:0	4	{
decl	419:8	419:71	4	const int	big_endian
op	419:29	0:0	4	=
water	419:31	0:0	4	avctx
op	419:36	0:0	4	->
water	419:38	0:0	4	codec
op	419:43	0:0	4	->
water	419:45	0:0	4	id
op	419:48	0:0	4	==
water	419:51	0:0	4	CODEC_ID_ADPCM_EA_R3
decl	420:8	420:60	4	int32_t	previous_sample
water	420:31	0:0	4	,
decl	420:8	420:60	4	int32_t	current_sample
water	420:47	0:0	4	,
decl	420:8	420:60	4	int32_t	next_sample
decl	421:8	421:30	4	int32_t	coeff1
water	421:22	0:0	4	,
decl	421:8	421:30	4	int32_t	coeff2
decl	422:8	422:21	4	uint8_t	shift
decl	423:8	423:28	4	unsigned int	channel
decl	424:8	424:26	4	uint16_t	*samplesC
decl	425:8	425:27	4	const uint8_t	*srcC
decl	426:8	426:47	4	const uint8_t	*src_end
op	426:31	0:0	4	=
water	426:33	0:0	4	buf
op	426:37	0:0	4	+
water	426:39	0:0	4	buf_size
water	428:8	0:0	4	samples_in_chunk
op	428:25	0:0	4	=
water	428:27	0:0	4	(
water	428:28	0:0	4	big_endian
water	428:39	0:0	4	?
call	428:41	428:65	4	bytestream_get_be32
arg	428:61	428:65	5	&src
op	428:61	0:0	6	&
water	428:62	0:0	6	src
water	429:39	0:0	4	:
call	429:41	429:65	4	bytestream_get_le32
arg	429:61	429:65	5	&src
op	429:61	0:0	6	&
water	429:62	0:0	6	src
water	429:66	0:0	4	)
op	429:68	0:0	4	/
water	429:70	0:0	4	28
water	429:72	0:0	4	;
if	430:8	434:8	4	(samples_in_chunk > UINT32_MAX / ( 28 * avctx -> channels ) || 28 * samples_in_chunk * avctx -> channels > samples_end - samples)
cond	430:12	431:62	5	samples_in_chunk > UINT32_MAX / ( 28 * avctx -> channels ) || 28 * samples_in_chunk * avctx -> channels > samples_end - samples
water	430:12	0:0	6	samples_in_chunk
op	430:29	0:0	6	>
water	430:31	0:0	6	UINT32_MAX
op	430:41	0:0	6	/
water	430:42	0:0	6	(
water	430:43	0:0	6	28
op	430:45	0:0	6	*
water	430:46	0:0	6	avctx
op	430:51	0:0	6	->
water	430:53	0:0	6	channels
water	430:61	0:0	6	)
op	430:63	0:0	6	||
water	431:12	0:0	6	28
op	431:14	0:0	6	*
water	431:15	0:0	6	samples_in_chunk
op	431:31	0:0	6	*
water	431:32	0:0	6	avctx
op	431:37	0:0	6	->
water	431:39	0:0	6	channels
op	431:48	0:0	6	>
water	431:50	0:0	6	samples_end
op	431:61	0:0	6	-
water	431:62	0:0	6	samples
stmts	431:71	434:8	5	
water	431:71	0:0	6	{
water	432:12	0:0	6	src
op	432:16	0:0	6	+=
water	432:19	0:0	6	buf_size
op	432:28	0:0	6	-
water	432:30	0:0	6	4
water	432:31	0:0	6	;
break	433:12	433:17	6	
water	434:8	0:0	6	}
for	436:8	492:8	4	(channel = 0 ;channel < avctx -> channels;channel ++)
forinit	436:13	436:22	5	channel = 0 ;
water	436:13	0:0	6	channel
op	436:20	0:0	6	=
water	436:21	0:0	6	0
water	436:22	0:0	6	;
cond	436:24	436:39	5	channel < avctx -> channels
water	436:24	0:0	6	channel
op	436:31	0:0	6	<
water	436:32	0:0	6	avctx
op	436:37	0:0	6	->
water	436:39	0:0	6	channels
forexpr	436:49	436:56	5	channel ++
water	436:49	0:0	6	channel
op	436:56	0:0	6	++
stmts	436:60	492:8	5	
water	436:60	0:0	6	{
decl	437:12	439:60	6	int32_t	offset
op	437:27	0:0	6	=
water	437:29	0:0	6	(
water	437:30	0:0	6	big_endian
water	437:41	0:0	6	?
call	437:43	437:67	7	bytestream_get_be32
arg	437:63	437:67	8	&src
op	437:63	0:0	9	&
water	437:64	0:0	9	src
water	438:41	0:0	6	:
call	438:43	438:67	7	bytestream_get_le32
arg	438:63	438:67	8	&src
op	438:63	0:0	9	&
water	438:64	0:0	9	src
water	438:68	0:0	6	)
op	439:27	0:0	6	+
water	439:29	0:0	6	(
water	439:30	0:0	6	avctx
op	439:35	0:0	6	->
water	439:37	0:0	6	channels
op	439:45	0:0	6	-
water	439:46	0:0	6	channel
op	439:53	0:0	6	-
water	439:54	0:0	6	1
water	439:55	0:0	6	)
op	439:57	0:0	6	*
water	439:59	0:0	6	4
if	441:12	441:68	6	(( offset < 0 ) || ( offset >= src_end - src - 4 ))
cond	441:16	441:60	7	( offset < 0 ) || ( offset >= src_end - src - 4 )
water	441:16	0:0	8	(
water	441:17	0:0	8	offset
op	441:24	0:0	8	<
water	441:26	0:0	8	0
water	441:27	0:0	8	)
op	441:29	0:0	8	||
water	441:32	0:0	8	(
water	441:33	0:0	8	offset
op	441:40	0:0	8	>=
water	441:43	0:0	8	src_end
op	441:51	0:0	8	-
water	441:53	0:0	8	src
op	441:57	0:0	8	-
water	441:59	0:0	8	4
water	441:60	0:0	8	)
stmts	441:63	441:68	7	
break	441:63	441:68	8	
water	442:12	0:0	6	srcC
op	442:18	0:0	6	=
water	442:20	0:0	6	src
op	442:24	0:0	6	+
water	442:26	0:0	6	offset
water	442:32	0:0	6	;
water	443:12	0:0	6	samplesC
op	443:21	0:0	6	=
water	443:23	0:0	6	samples
op	443:31	0:0	6	+
water	443:33	0:0	6	channel
water	443:40	0:0	6	;
if	445:12	448:12	6	(avctx -> codec -> id == CODEC_ID_ADPCM_EA_R1)
cond	445:16	445:36	7	avctx -> codec -> id == CODEC_ID_ADPCM_EA_R1
water	445:16	0:0	8	avctx
op	445:21	0:0	8	->
water	445:23	0:0	8	codec
op	445:28	0:0	8	->
water	445:30	0:0	8	id
op	445:33	0:0	8	==
water	445:36	0:0	8	CODEC_ID_ADPCM_EA_R1
stmts	445:58	448:12	7	
water	445:58	0:0	8	{
water	446:16	0:0	8	current_sample
op	446:32	0:0	8	=
water	446:34	0:0	8	(
water	446:35	0:0	8	int16_t
water	446:42	0:0	8	)
call	446:43	446:68	8	bytestream_get_le16
arg	446:63	446:68	9	&srcC
op	446:63	0:0	10	&
water	446:64	0:0	10	srcC
water	446:69	0:0	8	;
water	447:16	0:0	8	previous_sample
op	447:32	0:0	8	=
water	447:34	0:0	8	(
water	447:35	0:0	8	int16_t
water	447:42	0:0	8	)
call	447:43	447:68	8	bytestream_get_le16
arg	447:63	447:68	9	&srcC
op	447:63	0:0	10	&
water	447:64	0:0	10	srcC
water	447:69	0:0	8	;
water	448:12	0:0	8	}
else	448:14	451:12	6
stmts	448:19	451:12	7	
water	448:19	0:0	8	{
water	449:16	0:0	8	current_sample
op	449:32	0:0	8	=
water	449:34	0:0	8	c
op	449:35	0:0	8	->
water	449:37	0:0	8	status
op	449:43	0:0	8	[
water	449:44	0:0	8	channel
op	449:51	0:0	8	]
op	449:52	0:0	8	.
water	449:53	0:0	8	predictor
water	449:62	0:0	8	;
water	450:16	0:0	8	previous_sample
op	450:32	0:0	8	=
water	450:34	0:0	8	c
op	450:35	0:0	8	->
water	450:37	0:0	8	status
op	450:43	0:0	8	[
water	450:44	0:0	8	channel
op	450:51	0:0	8	]
op	450:52	0:0	8	.
water	450:53	0:0	8	prev_sample
water	450:64	0:0	8	;
water	451:12	0:0	8	}
for	453:12	486:12	6	(count1 = 0 ;count1 < samples_in_chunk;count1 ++)
forinit	453:17	453:25	7	count1 = 0 ;
water	453:17	0:0	8	count1
op	453:23	0:0	8	=
water	453:24	0:0	8	0
water	453:25	0:0	8	;
cond	453:27	453:34	7	count1 < samples_in_chunk
water	453:27	0:0	8	count1
op	453:33	0:0	8	<
water	453:34	0:0	8	samples_in_chunk
forexpr	453:52	453:58	7	count1 ++
water	453:52	0:0	8	count1
op	453:58	0:0	8	++
stmts	453:62	486:12	7	
water	453:62	0:0	8	{
if	454:16	464:16	8	(* srcC == 0 xEE)
cond	454:20	454:30	9	* srcC == 0 xEE
op	454:20	0:0	10	*
water	454:21	0:0	10	srcC
op	454:26	0:0	10	==
water	454:29	0:0	10	0
water	454:30	0:0	10	xEE
stmts	454:35	464:16	9	
water	454:35	0:0	10	{
water	455:20	0:0	10	srcC
op	455:24	0:0	10	++
water	455:26	0:0	10	;
if	456:20	456:52	10	(srcC > src_end - 30 * 2)
cond	456:24	456:44	11	srcC > src_end - 30 * 2
water	456:24	0:0	12	srcC
op	456:29	0:0	12	>
water	456:31	0:0	12	src_end
op	456:39	0:0	12	-
water	456:41	0:0	12	30
op	456:43	0:0	12	*
water	456:44	0:0	12	2
stmts	456:47	456:52	11	
break	456:47	456:52	12	
water	457:20	0:0	10	current_sample
op	457:36	0:0	10	=
water	457:38	0:0	10	(
water	457:39	0:0	10	int16_t
water	457:46	0:0	10	)
call	457:47	457:72	10	bytestream_get_be16
arg	457:67	457:72	11	&srcC
op	457:67	0:0	12	&
water	457:68	0:0	12	srcC
water	457:73	0:0	10	;
water	458:20	0:0	10	previous_sample
op	458:36	0:0	10	=
water	458:38	0:0	10	(
water	458:39	0:0	10	int16_t
water	458:46	0:0	10	)
call	458:47	458:72	10	bytestream_get_be16
arg	458:67	458:72	11	&srcC
op	458:67	0:0	12	&
water	458:68	0:0	12	srcC
water	458:73	0:0	10	;
for	460:20	463:20	10	(count2 = 0 ;count2 < 28;count2 ++)
forinit	460:25	460:33	11	count2 = 0 ;
water	460:25	0:0	12	count2
op	460:31	0:0	12	=
water	460:32	0:0	12	0
water	460:33	0:0	12	;
cond	460:35	460:42	11	count2 < 28
water	460:35	0:0	12	count2
op	460:41	0:0	12	<
water	460:42	0:0	12	28
forexpr	460:46	460:52	11	count2 ++
water	460:46	0:0	12	count2
op	460:52	0:0	12	++
stmts	460:56	463:20	11	
water	460:56	0:0	12	{
op	461:24	0:0	12	*
water	461:25	0:0	12	samplesC
op	461:34	0:0	12	=
water	461:36	0:0	12	(
water	461:37	0:0	12	int16_t
water	461:44	0:0	12	)
call	461:45	461:70	12	bytestream_get_be16
arg	461:65	461:70	13	&srcC
op	461:65	0:0	14	&
water	461:66	0:0	14	srcC
water	461:71	0:0	12	;
water	462:24	0:0	12	samplesC
op	462:33	0:0	12	+=
water	462:36	0:0	12	avctx
op	462:41	0:0	12	->
water	462:43	0:0	12	channels
water	462:51	0:0	12	;
water	463:20	0:0	12	}
water	464:16	0:0	10	}
else	464:18	485:16	8
stmts	464:23	485:16	9	
water	464:23	0:0	10	{
water	465:20	0:0	10	coeff1
op	465:27	0:0	10	=
water	465:29	0:0	10	ea_adpcm_table
op	465:43	0:0	10	[
op	465:45	0:0	10	*
water	465:46	0:0	10	srcC
op	465:50	0:0	10	>>
water	465:52	0:0	10	4
op	465:58	0:0	10	]
water	465:59	0:0	10	;
water	466:20	0:0	10	coeff2
op	466:27	0:0	10	=
water	466:29	0:0	10	ea_adpcm_table
op	466:43	0:0	10	[
water	466:44	0:0	10	(
op	466:45	0:0	10	*
water	466:46	0:0	10	srcC
op	466:50	0:0	10	>>
water	466:52	0:0	10	4
water	466:53	0:0	10	)
op	466:55	0:0	10	+
water	466:57	0:0	10	4
op	466:58	0:0	10	]
water	466:59	0:0	10	;
water	467:20	0:0	10	shift
op	467:26	0:0	10	=
water	467:28	0:0	10	(
op	467:29	0:0	10	*
water	467:30	0:0	10	srcC
op	467:34	0:0	10	++
op	467:37	0:0	10	&
water	467:39	0:0	10	0
water	467:40	0:0	10	x0F
water	467:43	0:0	10	)
op	467:45	0:0	10	+
water	467:47	0:0	10	8
water	467:48	0:0	10	;
if	469:20	469:50	10	(srcC > src_end - 14)
cond	469:24	469:41	11	srcC > src_end - 14
water	469:24	0:0	12	srcC
op	469:29	0:0	12	>
water	469:31	0:0	12	src_end
op	469:39	0:0	12	-
water	469:41	0:0	12	14
stmts	469:45	469:50	11	
break	469:45	469:50	12	
for	470:20	484:20	10	(count2 = 0 ;count2 < 28;count2 ++)
forinit	470:25	470:33	11	count2 = 0 ;
water	470:25	0:0	12	count2
op	470:31	0:0	12	=
water	470:32	0:0	12	0
water	470:33	0:0	12	;
cond	470:35	470:42	11	count2 < 28
water	470:35	0:0	12	count2
op	470:41	0:0	12	<
water	470:42	0:0	12	28
forexpr	470:46	470:52	11	count2 ++
water	470:46	0:0	12	count2
op	470:52	0:0	12	++
stmts	470:56	484:20	11	
water	470:56	0:0	12	{
if	471:24	472:84	12	(count2 & 1)
cond	471:28	471:37	13	count2 & 1
water	471:28	0:0	14	count2
op	471:35	0:0	14	&
water	471:37	0:0	14	1
stmts	472:28	472:84	13	
water	472:28	0:0	14	next_sample
op	472:40	0:0	14	=
call	472:42	472:74	14	(int32_t)
arg	472:52	472:74	15	(*srcC++&0x0F)<<28
water	472:52	0:0	16	(
op	472:53	0:0	16	*
water	472:54	0:0	16	srcC
op	472:58	0:0	16	++
op	472:61	0:0	16	&
water	472:63	0:0	16	0
water	472:64	0:0	16	x0F
water	472:67	0:0	16	)
op	472:69	0:0	16	<<
water	472:72	0:0	16	28
op	472:76	0:0	14	>>
water	472:79	0:0	14	shift
water	472:84	0:0	14	;
else	473:24	474:84	12
stmts	474:28	474:84	13	
water	474:28	0:0	14	next_sample
op	474:40	0:0	14	=
call	474:42	474:74	14	(int32_t)
arg	474:52	474:74	15	(*srcC&0xF0)<<24
water	474:52	0:0	16	(
op	474:53	0:0	16	*
water	474:54	0:0	16	srcC
op	474:61	0:0	16	&
water	474:63	0:0	16	0
water	474:64	0:0	16	xF0
water	474:67	0:0	16	)
op	474:69	0:0	16	<<
water	474:72	0:0	16	24
op	474:76	0:0	14	>>
water	474:79	0:0	14	shift
water	474:84	0:0	14	;
water	476:24	0:0	12	next_sample
op	476:36	0:0	12	+=
water	476:39	0:0	12	(
water	476:40	0:0	12	current_sample
op	476:56	0:0	12	*
water	476:58	0:0	12	coeff1
water	476:64	0:0	12	)
op	476:66	0:0	12	+
water	477:39	0:0	12	(
water	477:40	0:0	12	previous_sample
op	477:56	0:0	12	*
water	477:58	0:0	12	coeff2
water	477:64	0:0	12	)
water	477:65	0:0	12	;
water	478:24	0:0	12	next_sample
op	478:36	0:0	12	=
call	478:38	478:68	12	av_clip_int16
arg	478:52	478:68	13	next_sample>>8
water	478:52	0:0	14	next_sample
op	478:64	0:0	14	>>
water	478:67	0:0	14	8
water	478:69	0:0	12	;
water	480:24	0:0	12	previous_sample
op	480:40	0:0	12	=
water	480:42	0:0	12	current_sample
water	480:56	0:0	12	;
water	481:24	0:0	12	current_sample
op	481:40	0:0	12	=
water	481:42	0:0	12	next_sample
water	481:53	0:0	12	;
op	482:24	0:0	12	*
water	482:25	0:0	12	samplesC
op	482:34	0:0	12	=
water	482:36	0:0	12	current_sample
water	482:50	0:0	12	;
water	483:24	0:0	12	samplesC
op	483:33	0:0	12	+=
water	483:36	0:0	12	avctx
op	483:41	0:0	12	->
water	483:43	0:0	12	channels
water	483:51	0:0	12	;
water	484:20	0:0	12	}
water	485:16	0:0	10	}
water	486:12	0:0	8	}
if	488:12	491:12	6	(avctx -> codec -> id != CODEC_ID_ADPCM_EA_R1)
cond	488:16	488:36	7	avctx -> codec -> id != CODEC_ID_ADPCM_EA_R1
water	488:16	0:0	8	avctx
op	488:21	0:0	8	->
water	488:23	0:0	8	codec
op	488:28	0:0	8	->
water	488:30	0:0	8	id
op	488:33	0:0	8	!=
water	488:36	0:0	8	CODEC_ID_ADPCM_EA_R1
stmts	488:58	491:12	7	
water	488:58	0:0	8	{
water	489:16	0:0	8	c
op	489:17	0:0	8	->
water	489:19	0:0	8	status
op	489:25	0:0	8	[
water	489:26	0:0	8	channel
op	489:33	0:0	8	]
op	489:34	0:0	8	.
water	489:35	0:0	8	predictor
op	489:47	0:0	8	=
water	489:49	0:0	8	current_sample
water	489:63	0:0	8	;
water	490:16	0:0	8	c
op	490:17	0:0	8	->
water	490:19	0:0	8	status
op	490:25	0:0	8	[
water	490:26	0:0	8	channel
op	490:33	0:0	8	]
op	490:34	0:0	8	.
water	490:35	0:0	8	prev_sample
op	490:47	0:0	8	=
water	490:49	0:0	8	previous_sample
water	490:64	0:0	8	;
water	491:12	0:0	8	}
water	492:8	0:0	6	}
water	494:8	0:0	4	src
op	494:12	0:0	4	=
water	494:14	0:0	4	src
op	494:18	0:0	4	+
water	494:20	0:0	4	buf_size
op	494:29	0:0	4	-
water	494:31	0:0	4	(
water	494:32	0:0	4	4
op	494:34	0:0	4	+
water	494:36	0:0	4	4
op	494:37	0:0	4	*
water	494:38	0:0	4	avctx
op	494:43	0:0	4	->
water	494:45	0:0	4	channels
water	494:53	0:0	4	)
water	494:54	0:0	4	;
water	495:8	0:0	4	samples
op	495:16	0:0	4	+=
water	495:19	0:0	4	28
op	495:22	0:0	4	*
water	495:24	0:0	4	samples_in_chunk
op	495:41	0:0	4	*
water	495:43	0:0	4	avctx
op	495:48	0:0	4	->
water	495:50	0:0	4	channels
water	495:58	0:0	4	;
break	496:8	496:13	4	
water	497:4	0:0	4	}
label	498:4	498:30	4	case CODEC_ID_ADPCM_EA_XAS :
if	499:8	503:8	4	(samples_end - samples < 32 * 4 * avctx -> channels || buf_size < ( 4 + 15 ) * 4 * avctx -> channels)
cond	499:12	500:42	5	samples_end - samples < 32 * 4 * avctx -> channels || buf_size < ( 4 + 15 ) * 4 * avctx -> channels
water	499:12	0:0	6	samples_end
op	499:23	0:0	6	-
water	499:24	0:0	6	samples
op	499:32	0:0	6	<
water	499:34	0:0	6	32
op	499:36	0:0	6	*
water	499:37	0:0	6	4
op	499:38	0:0	6	*
water	499:39	0:0	6	avctx
op	499:44	0:0	6	->
water	499:46	0:0	6	channels
op	500:12	0:0	6	||
water	500:15	0:0	6	buf_size
op	500:24	0:0	6	<
water	500:26	0:0	6	(
water	500:27	0:0	6	4
op	500:28	0:0	6	+
water	500:29	0:0	6	15
water	500:31	0:0	6	)
op	500:32	0:0	6	*
water	500:33	0:0	6	4
op	500:34	0:0	6	*
water	500:35	0:0	6	avctx
op	500:40	0:0	6	->
water	500:42	0:0	6	channels
stmts	500:52	503:8	5	
water	500:52	0:0	6	{
water	501:12	0:0	6	src
op	501:16	0:0	6	+=
water	501:19	0:0	6	buf_size
water	501:27	0:0	6	;
break	502:12	502:17	6	
water	503:8	0:0	6	}
for	504:8	526:8	4	(channel = 0 ;channel < avctx -> channels;channel ++)
forinit	504:13	504:22	5	channel = 0 ;
water	504:13	0:0	6	channel
op	504:20	0:0	6	=
water	504:21	0:0	6	0
water	504:22	0:0	6	;
cond	504:24	504:39	5	channel < avctx -> channels
water	504:24	0:0	6	channel
op	504:31	0:0	6	<
water	504:32	0:0	6	avctx
op	504:37	0:0	6	->
water	504:39	0:0	6	channels
forexpr	504:49	504:56	5	channel ++
water	504:49	0:0	6	channel
op	504:56	0:0	6	++
stmts	504:60	526:8	5	
water	504:60	0:0	6	{
water	505:12	0:0	6	int
water	505:16	0:0	6	coeff
op	505:21	0:0	6	[
water	505:22	0:0	6	2
op	505:23	0:0	6	]
op	505:24	0:0	6	[
water	505:25	0:0	6	4
op	505:26	0:0	6	]
water	505:27	0:0	6	,
water	505:29	0:0	6	shift
op	505:34	0:0	6	[
water	505:35	0:0	6	4
op	505:36	0:0	6	]
water	505:37	0:0	6	;
decl	506:12	506:45	6	short	*s2
water	506:21	0:0	6	,
decl	506:12	506:45	6	short	*s
op	506:26	0:0	6	=
op	506:28	0:0	6	&
water	506:29	0:0	6	samples
op	506:36	0:0	6	[
water	506:37	0:0	6	channel
op	506:44	0:0	6	]
for	507:12	513:12	6	(n = 0 ;n < 4;n ++ , s += 32 * avctx -> channels)
forinit	507:17	507:20	7	n = 0 ;
water	507:17	0:0	8	n
op	507:18	0:0	8	=
water	507:19	0:0	8	0
water	507:20	0:0	8	;
cond	507:22	507:24	7	n < 4
water	507:22	0:0	8	n
op	507:23	0:0	8	<
water	507:24	0:0	8	4
forexpr	507:27	507:45	7	n ++ , s += 32 * avctx -> channels
water	507:27	0:0	8	n
op	507:28	0:0	8	++
water	507:30	0:0	8	,
water	507:32	0:0	8	s
op	507:33	0:0	8	+=
water	507:35	0:0	8	32
op	507:37	0:0	8	*
water	507:38	0:0	8	avctx
op	507:43	0:0	8	->
water	507:45	0:0	8	channels
stmts	507:55	513:12	7	
water	507:55	0:0	8	{
for	508:16	509:67	8	(i = 0 ;i < 2;i ++)
forinit	508:21	508:24	9	i = 0 ;
water	508:21	0:0	10	i
op	508:22	0:0	10	=
water	508:23	0:0	10	0
water	508:24	0:0	10	;
cond	508:26	508:28	9	i < 2
water	508:26	0:0	10	i
op	508:27	0:0	10	<
water	508:28	0:0	10	2
forexpr	508:31	508:32	9	i ++
water	508:31	0:0	10	i
op	508:32	0:0	10	++
stmts	509:20	509:67	9	
water	509:20	0:0	10	coeff
op	509:25	0:0	10	[
water	509:26	0:0	10	i
op	509:27	0:0	10	]
op	509:28	0:0	10	[
water	509:29	0:0	10	n
op	509:30	0:0	10	]
op	509:32	0:0	10	=
water	509:34	0:0	10	ea_adpcm_table
op	509:48	0:0	10	[
water	509:49	0:0	10	(
water	509:50	0:0	10	src
op	509:53	0:0	10	[
water	509:54	0:0	10	0
op	509:55	0:0	10	]
op	509:56	0:0	10	&
water	509:57	0:0	10	0
water	509:58	0:0	10	x0F
water	509:61	0:0	10	)
op	509:62	0:0	10	+
water	509:63	0:0	10	4
op	509:64	0:0	10	*
water	509:65	0:0	10	i
op	509:66	0:0	10	]
water	509:67	0:0	10	;
water	510:16	0:0	8	shift
op	510:21	0:0	8	[
water	510:22	0:0	8	n
op	510:23	0:0	8	]
op	510:25	0:0	8	=
water	510:27	0:0	8	(
water	510:28	0:0	8	src
op	510:31	0:0	8	[
water	510:32	0:0	8	2
op	510:33	0:0	8	]
op	510:34	0:0	8	&
water	510:35	0:0	8	0
water	510:36	0:0	8	x0F
water	510:39	0:0	8	)
op	510:41	0:0	8	+
water	510:43	0:0	8	8
water	510:44	0:0	8	;
for	511:16	512:55	8	(s2 = s , i = 0 ;i < 2;i ++ , src += 2 , s2 += avctx -> channels)
forinit	511:21	511:30	9	s2 = s , i = 0 ;
water	511:21	0:0	10	s2
op	511:23	0:0	10	=
water	511:24	0:0	10	s
water	511:25	0:0	10	,
water	511:27	0:0	10	i
op	511:28	0:0	10	=
water	511:29	0:0	10	0
water	511:30	0:0	10	;
cond	511:32	511:34	9	i < 2
water	511:32	0:0	10	i
op	511:33	0:0	10	<
water	511:34	0:0	10	2
forexpr	511:37	511:61	9	i ++ , src += 2 , s2 += avctx -> channels
water	511:37	0:0	10	i
op	511:38	0:0	10	++
water	511:40	0:0	10	,
water	511:42	0:0	10	src
op	511:45	0:0	10	+=
water	511:47	0:0	10	2
water	511:48	0:0	10	,
water	511:50	0:0	10	s2
op	511:52	0:0	10	+=
water	511:54	0:0	10	avctx
op	511:59	0:0	10	->
water	511:61	0:0	10	channels
stmts	512:20	512:55	9	
water	512:20	0:0	10	s2
op	512:22	0:0	10	[
water	512:23	0:0	10	0
op	512:24	0:0	10	]
op	512:26	0:0	10	=
water	512:28	0:0	10	(
water	512:29	0:0	10	src
op	512:32	0:0	10	[
water	512:33	0:0	10	0
op	512:34	0:0	10	]
op	512:35	0:0	10	&
water	512:36	0:0	10	0
water	512:37	0:0	10	xF0
water	512:40	0:0	10	)
op	512:42	0:0	10	+
water	512:44	0:0	10	(
water	512:45	0:0	10	src
op	512:48	0:0	10	[
water	512:49	0:0	10	1
op	512:50	0:0	10	]
op	512:51	0:0	10	<<
water	512:53	0:0	10	8
water	512:54	0:0	10	)
water	512:55	0:0	10	;
water	513:12	0:0	8	}
for	515:12	525:12	6	(m = 2 ;m < 32;m += 2)
forinit	515:17	515:20	7	m = 2 ;
water	515:17	0:0	8	m
op	515:18	0:0	8	=
water	515:19	0:0	8	2
water	515:20	0:0	8	;
cond	515:22	515:24	7	m < 32
water	515:22	0:0	8	m
op	515:23	0:0	8	<
water	515:24	0:0	8	32
forexpr	515:28	515:31	7	m += 2
water	515:28	0:0	8	m
op	515:29	0:0	8	+=
water	515:31	0:0	8	2
stmts	515:34	525:12	7	
water	515:34	0:0	8	{
water	516:16	0:0	8	s
op	516:18	0:0	8	=
op	516:20	0:0	8	&
water	516:21	0:0	8	samples
op	516:28	0:0	8	[
water	516:29	0:0	8	m
op	516:30	0:0	8	*
water	516:31	0:0	8	avctx
op	516:36	0:0	8	->
water	516:38	0:0	8	channels
op	516:47	0:0	8	+
water	516:49	0:0	8	channel
op	516:56	0:0	8	]
water	516:57	0:0	8	;
for	517:16	524:16	8	(n = 0 ;n < 4;n ++ , src ++ , s += 32 * avctx -> channels)
forinit	517:21	517:24	9	n = 0 ;
water	517:21	0:0	10	n
op	517:22	0:0	10	=
water	517:23	0:0	10	0
water	517:24	0:0	10	;
cond	517:26	517:28	9	n < 4
water	517:26	0:0	10	n
op	517:27	0:0	10	<
water	517:28	0:0	10	4
forexpr	517:31	517:56	9	n ++ , src ++ , s += 32 * avctx -> channels
water	517:31	0:0	10	n
op	517:32	0:0	10	++
water	517:34	0:0	10	,
water	517:36	0:0	10	src
op	517:39	0:0	10	++
water	517:41	0:0	10	,
water	517:43	0:0	10	s
op	517:44	0:0	10	+=
water	517:46	0:0	10	32
op	517:48	0:0	10	*
water	517:49	0:0	10	avctx
op	517:54	0:0	10	->
water	517:56	0:0	10	channels
stmts	517:66	524:16	9	
water	517:66	0:0	10	{
for	518:20	523:20	10	(s2 = s , i = 0 ;i < 8;i += 4 , s2 += avctx -> channels)
forinit	518:25	518:34	11	s2 = s , i = 0 ;
water	518:25	0:0	12	s2
op	518:27	0:0	12	=
water	518:28	0:0	12	s
water	518:29	0:0	12	,
water	518:31	0:0	12	i
op	518:32	0:0	12	=
water	518:33	0:0	12	0
water	518:34	0:0	12	;
cond	518:36	518:38	11	i < 8
water	518:36	0:0	12	i
op	518:37	0:0	12	<
water	518:38	0:0	12	8
forexpr	518:41	518:58	11	i += 4 , s2 += avctx -> channels
water	518:41	0:0	12	i
op	518:42	0:0	12	+=
water	518:44	0:0	12	4
water	518:45	0:0	12	,
water	518:47	0:0	12	s2
op	518:49	0:0	12	+=
water	518:51	0:0	12	avctx
op	518:56	0:0	12	->
water	518:58	0:0	12	channels
stmts	518:68	523:20	11	
water	518:68	0:0	12	{
decl	519:24	519:87	12	int	level
op	519:34	0:0	12	=
call	519:36	519:74	13	(int32_t)
arg	519:46	519:74	14	(*src&(0xF0>>i))<<(24+i)
water	519:46	0:0	15	(
op	519:47	0:0	15	*
water	519:48	0:0	15	src
op	519:52	0:0	15	&
water	519:54	0:0	15	(
water	519:55	0:0	15	0
water	519:56	0:0	15	xF0
op	519:59	0:0	15	>>
water	519:61	0:0	15	i
water	519:62	0:0	15	)
water	519:63	0:0	15	)
op	519:65	0:0	15	<<
water	519:68	0:0	15	(
water	519:69	0:0	15	24
op	519:71	0:0	15	+
water	519:72	0:0	15	i
water	519:73	0:0	15	)
op	519:76	0:0	12	>>
water	519:79	0:0	12	shift
op	519:84	0:0	12	[
water	519:85	0:0	12	n
op	519:86	0:0	12	]
decl	520:24	521:72	12	int	pred
op	520:34	0:0	12	=
water	520:36	0:0	12	s2
op	520:38	0:0	12	[
op	520:39	0:0	12	-
water	520:40	0:0	12	1
op	520:41	0:0	12	*
water	520:42	0:0	12	avctx
op	520:47	0:0	12	->
water	520:49	0:0	12	channels
op	520:57	0:0	12	]
op	520:59	0:0	12	*
water	520:61	0:0	12	coeff
op	520:66	0:0	12	[
water	520:67	0:0	12	0
op	520:68	0:0	12	]
op	520:69	0:0	12	[
water	520:70	0:0	12	n
op	520:71	0:0	12	]
op	521:34	0:0	12	+
water	521:36	0:0	12	s2
op	521:38	0:0	12	[
op	521:39	0:0	12	-
water	521:40	0:0	12	2
op	521:41	0:0	12	*
water	521:42	0:0	12	avctx
op	521:47	0:0	12	->
water	521:49	0:0	12	channels
op	521:57	0:0	12	]
op	521:59	0:0	12	*
water	521:61	0:0	12	coeff
op	521:66	0:0	12	[
water	521:67	0:0	12	1
op	521:68	0:0	12	]
op	521:69	0:0	12	[
water	521:70	0:0	12	n
op	521:71	0:0	12	]
water	522:24	0:0	12	s2
op	522:26	0:0	12	[
water	522:27	0:0	12	0
op	522:28	0:0	12	]
op	522:30	0:0	12	=
call	522:32	522:72	12	av_clip_int16
arg	522:46	522:72	13	(level+pred+0x80)>>8
water	522:46	0:0	14	(
water	522:47	0:0	14	level
op	522:53	0:0	14	+
water	522:55	0:0	14	pred
op	522:60	0:0	14	+
water	522:62	0:0	14	0
water	522:63	0:0	14	x80
water	522:66	0:0	14	)
op	522:68	0:0	14	>>
water	522:71	0:0	14	8
water	522:73	0:0	12	;
water	523:20	0:0	12	}
water	524:16	0:0	10	}
water	525:12	0:0	8	}
water	526:8	0:0	6	}
water	527:8	0:0	4	samples
op	527:16	0:0	4	+=
water	527:19	0:0	4	32
op	527:21	0:0	4	*
water	527:22	0:0	4	4
op	527:23	0:0	4	*
water	527:24	0:0	4	avctx
op	527:29	0:0	4	->
water	527:31	0:0	4	channels
water	527:39	0:0	4	;
break	528:8	528:13	4	
label	529:4	529:31	4	case CODEC_ID_ADPCM_IMA_AMV :
label	530:4	530:34	4	case CODEC_ID_ADPCM_IMA_SMJPEG :
water	531:8	0:0	4	c
op	531:9	0:0	4	->
water	531:11	0:0	4	status
op	531:17	0:0	4	[
water	531:18	0:0	4	0
op	531:19	0:0	4	]
op	531:20	0:0	4	.
water	531:21	0:0	4	predictor
op	531:31	0:0	4	=
water	531:33	0:0	4	(
water	531:34	0:0	4	int16_t
water	531:41	0:0	4	)
call	531:42	531:66	4	bytestream_get_le16
arg	531:62	531:66	5	&src
op	531:62	0:0	6	&
water	531:63	0:0	6	src
water	531:67	0:0	4	;
water	532:8	0:0	4	c
op	532:9	0:0	4	->
water	532:11	0:0	4	status
op	532:17	0:0	4	[
water	532:18	0:0	4	0
op	532:19	0:0	4	]
op	532:20	0:0	4	.
water	532:21	0:0	4	step_index
op	532:32	0:0	4	=
call	532:34	532:58	4	bytestream_get_le16
arg	532:54	532:58	5	&src
op	532:54	0:0	6	&
water	532:55	0:0	6	src
water	532:59	0:0	4	;
if	534:8	535:18	4	(avctx -> codec -> id == CODEC_ID_ADPCM_IMA_AMV)
cond	534:12	534:32	5	avctx -> codec -> id == CODEC_ID_ADPCM_IMA_AMV
water	534:12	0:0	6	avctx
op	534:17	0:0	6	->
water	534:19	0:0	6	codec
op	534:24	0:0	6	->
water	534:26	0:0	6	id
op	534:29	0:0	6	==
water	534:32	0:0	6	CODEC_ID_ADPCM_IMA_AMV
stmts	535:12	535:18	5	
water	535:12	0:0	6	src
op	535:15	0:0	6	+=
water	535:17	0:0	6	4
water	535:18	0:0	6	;
while	537:8	550:8	4	(src < buf + buf_size)
cond	537:15	537:27	5	src < buf + buf_size
water	537:15	0:0	6	src
op	537:19	0:0	6	<
water	537:21	0:0	6	buf
op	537:25	0:0	6	+
water	537:27	0:0	6	buf_size
stmts	537:37	550:8	5	
water	537:37	0:0	6	{
decl	538:12	538:23	6	char	hi
water	538:19	0:0	6	,
decl	538:12	538:23	6	char	lo
water	539:12	0:0	6	lo
op	539:15	0:0	6	=
op	539:17	0:0	6	*
water	539:18	0:0	6	src
op	539:22	0:0	6	&
water	539:24	0:0	6	0
water	539:25	0:0	6	x0F
water	539:28	0:0	6	;
water	540:12	0:0	6	hi
op	540:15	0:0	6	=
op	540:17	0:0	6	*
water	540:18	0:0	6	src
op	540:22	0:0	6	>>
water	540:25	0:0	6	4
water	540:26	0:0	6	;
if	542:12	543:36	6	(avctx -> codec -> id == CODEC_ID_ADPCM_IMA_AMV)
cond	542:16	542:36	7	avctx -> codec -> id == CODEC_ID_ADPCM_IMA_AMV
water	542:16	0:0	8	avctx
op	542:21	0:0	8	->
water	542:23	0:0	8	codec
op	542:28	0:0	8	->
water	542:30	0:0	8	id
op	542:33	0:0	8	==
water	542:36	0:0	8	CODEC_ID_ADPCM_IMA_AMV
stmts	543:16	543:36	7	
call	543:16	543:35	8	FFSWAP
arg	543:23	543:27	9	char
water	543:23	0:0	10	char
arg	543:29	543:31	9	hi
water	543:29	0:0	10	hi
arg	543:33	543:35	9	lo
water	543:33	0:0	10	lo
water	543:36	0:0	8	;
op	545:12	0:0	6	*
water	545:13	0:0	6	samples
op	545:20	0:0	6	++
op	545:23	0:0	6	=
call	545:25	546:21	6	adpcm_ima_expand_nibble
arg	545:49	545:62	7	&c->status[0]
op	545:49	0:0	8	&
water	545:50	0:0	8	c
op	545:51	0:0	8	->
water	545:53	0:0	8	status
op	545:59	0:0	8	[
water	545:60	0:0	8	0
op	545:61	0:0	8	]
arg	546:16	546:18	7	lo
water	546:16	0:0	8	lo
arg	546:20	546:21	7	3
water	546:20	0:0	8	3
water	546:22	0:0	6	;
op	547:12	0:0	6	*
water	547:13	0:0	6	samples
op	547:20	0:0	6	++
op	547:23	0:0	6	=
call	547:25	548:21	6	adpcm_ima_expand_nibble
arg	547:49	547:62	7	&c->status[0]
op	547:49	0:0	8	&
water	547:50	0:0	8	c
op	547:51	0:0	8	->
water	547:53	0:0	8	status
op	547:59	0:0	8	[
water	547:60	0:0	8	0
op	547:61	0:0	8	]
arg	548:16	548:18	7	hi
water	548:16	0:0	8	hi
arg	548:20	548:21	7	3
water	548:20	0:0	8	3
water	548:22	0:0	6	;
water	549:12	0:0	6	src
op	549:15	0:0	6	++
water	549:17	0:0	6	;
water	550:8	0:0	6	}
break	551:8	551:13	4	
label	552:4	552:26	4	case CODEC_ID_ADPCM_CT :
while	553:8	566:8	4	(src < buf + buf_size)
cond	553:15	553:27	5	src < buf + buf_size
water	553:15	0:0	6	src
op	553:19	0:0	6	<
water	553:21	0:0	6	buf
op	553:25	0:0	6	+
water	553:27	0:0	6	buf_size
stmts	553:37	566:8	5	
water	553:37	0:0	6	{
if	554:12	559:12	6	(st)
cond	554:16	554:16	7	st
water	554:16	0:0	8	st
stmts	554:20	559:12	7	
water	554:20	0:0	8	{
op	555:16	0:0	8	*
water	555:17	0:0	8	samples
op	555:24	0:0	8	++
op	555:27	0:0	8	=
call	555:29	556:31	8	adpcm_ct_expand_nibble
arg	555:52	555:65	9	&c->status[0]
op	555:52	0:0	10	&
water	555:53	0:0	10	c
op	555:54	0:0	10	->
water	555:56	0:0	10	status
op	555:62	0:0	10	[
water	555:63	0:0	10	0
op	555:64	0:0	10	]
arg	556:20	556:31	9	src[0]>>4
water	556:20	0:0	10	src
op	556:23	0:0	10	[
water	556:24	0:0	10	0
op	556:25	0:0	10	]
op	556:27	0:0	10	>>
water	556:30	0:0	10	4
water	556:32	0:0	8	;
op	557:16	0:0	8	*
water	557:17	0:0	8	samples
op	557:24	0:0	8	++
op	557:27	0:0	8	=
call	557:29	558:33	8	adpcm_ct_expand_nibble
arg	557:52	557:65	9	&c->status[1]
op	557:52	0:0	10	&
water	557:53	0:0	10	c
op	557:54	0:0	10	->
water	557:56	0:0	10	status
op	557:62	0:0	10	[
water	557:63	0:0	10	1
op	557:64	0:0	10	]
arg	558:20	558:33	9	src[0]&0x0F
water	558:20	0:0	10	src
op	558:23	0:0	10	[
water	558:24	0:0	10	0
op	558:25	0:0	10	]
op	558:27	0:0	10	&
water	558:29	0:0	10	0
water	558:30	0:0	10	x0F
water	558:34	0:0	8	;
water	559:12	0:0	8	}
else	559:14	564:12	6
stmts	559:19	564:12	7	
water	559:19	0:0	8	{
op	560:16	0:0	8	*
water	560:17	0:0	8	samples
op	560:24	0:0	8	++
op	560:27	0:0	8	=
call	560:29	561:31	8	adpcm_ct_expand_nibble
arg	560:52	560:65	9	&c->status[0]
op	560:52	0:0	10	&
water	560:53	0:0	10	c
op	560:54	0:0	10	->
water	560:56	0:0	10	status
op	560:62	0:0	10	[
water	560:63	0:0	10	0
op	560:64	0:0	10	]
arg	561:20	561:31	9	src[0]>>4
water	561:20	0:0	10	src
op	561:23	0:0	10	[
water	561:24	0:0	10	0
op	561:25	0:0	10	]
op	561:27	0:0	10	>>
water	561:30	0:0	10	4
water	561:32	0:0	8	;
op	562:16	0:0	8	*
water	562:17	0:0	8	samples
op	562:24	0:0	8	++
op	562:27	0:0	8	=
call	562:29	563:33	8	adpcm_ct_expand_nibble
arg	562:52	562:65	9	&c->status[0]
op	562:52	0:0	10	&
water	562:53	0:0	10	c
op	562:54	0:0	10	->
water	562:56	0:0	10	status
op	562:62	0:0	10	[
water	562:63	0:0	10	0
op	562:64	0:0	10	]
arg	563:20	563:33	9	src[0]&0x0F
water	563:20	0:0	10	src
op	563:23	0:0	10	[
water	563:24	0:0	10	0
op	563:25	0:0	10	]
op	563:27	0:0	10	&
water	563:29	0:0	10	0
water	563:30	0:0	10	x0F
water	563:34	0:0	8	;
water	564:12	0:0	8	}
water	565:12	0:0	6	src
op	565:15	0:0	6	++
water	565:17	0:0	6	;
water	566:8	0:0	6	}
break	567:8	567:13	4	
label	568:4	568:31	4	case CODEC_ID_ADPCM_SBPRO_4 :
label	569:4	569:31	4	case CODEC_ID_ADPCM_SBPRO_3 :
label	570:4	570:31	4	case CODEC_ID_ADPCM_SBPRO_2 :
if	571:8	577:8	4	(! c -> status [ 0 ] . step_index)
cond	571:12	571:26	5	! c -> status [ 0 ] . step_index
op	571:12	0:0	6	!
water	571:13	0:0	6	c
op	571:14	0:0	6	->
water	571:16	0:0	6	status
op	571:22	0:0	6	[
water	571:23	0:0	6	0
op	571:24	0:0	6	]
op	571:25	0:0	6	.
water	571:26	0:0	6	step_index
stmts	571:38	577:8	5	
water	571:38	0:0	6	{
op	573:12	0:0	6	*
water	573:13	0:0	6	samples
op	573:20	0:0	6	++
op	573:23	0:0	6	=
water	573:25	0:0	6	128
op	573:29	0:0	6	*
water	573:31	0:0	6	(
op	573:32	0:0	6	*
water	573:33	0:0	6	src
op	573:36	0:0	6	++
op	573:39	0:0	6	-
water	573:41	0:0	6	0
water	573:42	0:0	6	x80
water	573:45	0:0	6	)
water	573:46	0:0	6	;
if	574:12	575:48	6	(st)
cond	574:16	574:16	7	st
water	574:16	0:0	8	st
stmts	575:14	575:48	7	
op	575:14	0:0	8	*
water	575:15	0:0	8	samples
op	575:22	0:0	8	++
op	575:25	0:0	8	=
water	575:27	0:0	8	128
op	575:31	0:0	8	*
water	575:33	0:0	8	(
op	575:34	0:0	8	*
water	575:35	0:0	8	src
op	575:38	0:0	8	++
op	575:41	0:0	8	-
water	575:43	0:0	8	0
water	575:44	0:0	8	x80
water	575:47	0:0	8	)
water	575:48	0:0	8	;
water	576:12	0:0	6	c
op	576:13	0:0	6	->
water	576:15	0:0	6	status
op	576:21	0:0	6	[
water	576:22	0:0	6	0
op	576:23	0:0	6	]
op	576:24	0:0	6	.
water	576:25	0:0	6	step_index
op	576:36	0:0	6	=
water	576:38	0:0	6	1
water	576:39	0:0	6	;
water	577:8	0:0	6	}
if	578:8	586:8	4	(avctx -> codec -> id == CODEC_ID_ADPCM_SBPRO_4)
cond	578:12	578:32	5	avctx -> codec -> id == CODEC_ID_ADPCM_SBPRO_4
water	578:12	0:0	6	avctx
op	578:17	0:0	6	->
water	578:19	0:0	6	codec
op	578:24	0:0	6	->
water	578:26	0:0	6	id
op	578:29	0:0	6	==
water	578:32	0:0	6	CODEC_ID_ADPCM_SBPRO_4
stmts	578:56	586:8	5	
water	578:56	0:0	6	{
while	579:12	585:12	6	(src < buf + buf_size)
cond	579:19	579:31	7	src < buf + buf_size
water	579:19	0:0	8	src
op	579:23	0:0	8	<
water	579:25	0:0	8	buf
op	579:29	0:0	8	+
water	579:31	0:0	8	buf_size
stmts	579:41	585:12	7	
water	579:41	0:0	8	{
op	580:16	0:0	8	*
water	580:17	0:0	8	samples
op	580:24	0:0	8	++
op	580:27	0:0	8	=
call	580:29	581:37	8	adpcm_sbpro_expand_nibble
arg	580:55	580:68	9	&c->status[0]
op	580:55	0:0	10	&
water	580:56	0:0	10	c
op	580:57	0:0	10	->
water	580:59	0:0	10	status
op	580:65	0:0	10	[
water	580:66	0:0	10	0
op	580:67	0:0	10	]
arg	581:20	581:31	9	src[0]>>4
water	581:20	0:0	10	src
op	581:23	0:0	10	[
water	581:24	0:0	10	0
op	581:25	0:0	10	]
op	581:27	0:0	10	>>
water	581:30	0:0	10	4
arg	581:33	581:34	9	4
water	581:33	0:0	10	4
arg	581:36	581:37	9	0
water	581:36	0:0	10	0
water	581:38	0:0	8	;
op	582:16	0:0	8	*
water	582:17	0:0	8	samples
op	582:24	0:0	8	++
op	582:27	0:0	8	=
call	582:29	583:39	8	adpcm_sbpro_expand_nibble
arg	582:55	582:69	9	&c->status[st]
op	582:55	0:0	10	&
water	582:56	0:0	10	c
op	582:57	0:0	10	->
water	582:59	0:0	10	status
op	582:65	0:0	10	[
water	582:66	0:0	10	st
op	582:68	0:0	10	]
arg	583:20	583:33	9	src[0]&0x0F
water	583:20	0:0	10	src
op	583:23	0:0	10	[
water	583:24	0:0	10	0
op	583:25	0:0	10	]
op	583:27	0:0	10	&
water	583:29	0:0	10	0
water	583:30	0:0	10	x0F
arg	583:35	583:36	9	4
water	583:35	0:0	10	4
arg	583:38	583:39	9	0
water	583:38	0:0	10	0
water	583:40	0:0	8	;
water	584:16	0:0	8	src
op	584:19	0:0	8	++
water	584:21	0:0	8	;
water	585:12	0:0	8	}
water	586:8	0:0	6	}
else	586:10	596:8	4
stmts	586:15	596:8	5	
if	586:15	596:8	6	(avctx -> codec -> id == CODEC_ID_ADPCM_SBPRO_3)
cond	586:19	586:39	7	avctx -> codec -> id == CODEC_ID_ADPCM_SBPRO_3
water	586:19	0:0	8	avctx
op	586:24	0:0	8	->
water	586:26	0:0	8	codec
op	586:31	0:0	8	->
water	586:33	0:0	8	id
op	586:36	0:0	8	==
water	586:39	0:0	8	CODEC_ID_ADPCM_SBPRO_3
stmts	586:63	596:8	7	
water	586:63	0:0	8	{
while	587:12	595:12	8	(src < buf + buf_size && samples + 2 < samples_end)
cond	587:19	587:57	9	src < buf + buf_size && samples + 2 < samples_end
water	587:19	0:0	10	src
op	587:23	0:0	10	<
water	587:25	0:0	10	buf
op	587:29	0:0	10	+
water	587:31	0:0	10	buf_size
op	587:40	0:0	10	&&
water	587:43	0:0	10	samples
op	587:51	0:0	10	+
water	587:53	0:0	10	2
op	587:55	0:0	10	<
water	587:57	0:0	10	samples_end
stmts	587:70	595:12	9	
water	587:70	0:0	10	{
op	588:16	0:0	10	*
water	588:17	0:0	10	samples
op	588:24	0:0	10	++
op	588:27	0:0	10	=
call	588:29	589:46	10	adpcm_sbpro_expand_nibble
arg	588:55	588:68	11	&c->status[0]
op	588:55	0:0	12	&
water	588:56	0:0	12	c
op	588:57	0:0	12	->
water	588:59	0:0	12	status
op	588:65	0:0	12	[
water	588:66	0:0	12	0
op	588:67	0:0	12	]
arg	589:21	589:40	11	src[0]>>5
water	589:21	0:0	12	src
op	589:24	0:0	12	[
water	589:25	0:0	12	0
op	589:26	0:0	12	]
op	589:28	0:0	12	>>
water	589:31	0:0	12	5
arg	589:42	589:43	11	3
water	589:42	0:0	12	3
arg	589:45	589:46	11	0
water	589:45	0:0	12	0
water	589:47	0:0	10	;
op	590:16	0:0	10	*
water	590:17	0:0	10	samples
op	590:24	0:0	10	++
op	590:27	0:0	10	=
call	590:29	591:46	10	adpcm_sbpro_expand_nibble
arg	590:55	590:68	11	&c->status[0]
op	590:55	0:0	12	&
water	590:56	0:0	12	c
op	590:57	0:0	12	->
water	590:59	0:0	12	status
op	590:65	0:0	12	[
water	590:66	0:0	12	0
op	590:67	0:0	12	]
arg	591:20	591:40	11	(src[0]>>2)&0x07
water	591:20	0:0	12	(
water	591:21	0:0	12	src
op	591:24	0:0	12	[
water	591:25	0:0	12	0
op	591:26	0:0	12	]
op	591:28	0:0	12	>>
water	591:31	0:0	12	2
water	591:32	0:0	12	)
op	591:34	0:0	12	&
water	591:36	0:0	12	0
water	591:37	0:0	12	x07
arg	591:42	591:43	11	3
water	591:42	0:0	12	3
arg	591:45	591:46	11	0
water	591:45	0:0	12	0
water	591:47	0:0	10	;
op	592:16	0:0	10	*
water	592:17	0:0	10	samples
op	592:24	0:0	10	++
op	592:27	0:0	10	=
call	592:29	593:39	10	adpcm_sbpro_expand_nibble
arg	592:55	592:68	11	&c->status[0]
op	592:55	0:0	12	&
water	592:56	0:0	12	c
op	592:57	0:0	12	->
water	592:59	0:0	12	status
op	592:65	0:0	12	[
water	592:66	0:0	12	0
op	592:67	0:0	12	]
arg	593:20	593:33	11	src[0]&0x03
water	593:20	0:0	12	src
op	593:23	0:0	12	[
water	593:24	0:0	12	0
op	593:25	0:0	12	]
op	593:27	0:0	12	&
water	593:29	0:0	12	0
water	593:30	0:0	12	x03
arg	593:35	593:36	11	2
water	593:35	0:0	12	2
arg	593:38	593:39	11	0
water	593:38	0:0	12	0
water	593:40	0:0	10	;
water	594:16	0:0	10	src
op	594:19	0:0	10	++
water	594:21	0:0	10	;
water	595:12	0:0	10	}
water	596:8	0:0	8	}
else	596:10	608:8	4
stmts	596:15	608:8	5	
water	596:15	0:0	6	{
while	597:12	607:12	6	(src < buf + buf_size && samples + 3 < samples_end)
cond	597:19	597:57	7	src < buf + buf_size && samples + 3 < samples_end
water	597:19	0:0	8	src
op	597:23	0:0	8	<
water	597:25	0:0	8	buf
op	597:29	0:0	8	+
water	597:31	0:0	8	buf_size
op	597:40	0:0	8	&&
water	597:43	0:0	8	samples
op	597:51	0:0	8	+
water	597:53	0:0	8	3
op	597:55	0:0	8	<
water	597:57	0:0	8	samples_end
stmts	597:70	607:12	7	
water	597:70	0:0	8	{
op	598:16	0:0	8	*
water	598:17	0:0	8	samples
op	598:24	0:0	8	++
op	598:27	0:0	8	=
call	598:29	599:46	8	adpcm_sbpro_expand_nibble
arg	598:55	598:68	9	&c->status[0]
op	598:55	0:0	10	&
water	598:56	0:0	10	c
op	598:57	0:0	10	->
water	598:59	0:0	10	status
op	598:65	0:0	10	[
water	598:66	0:0	10	0
op	598:67	0:0	10	]
arg	599:21	599:40	9	src[0]>>6
water	599:21	0:0	10	src
op	599:24	0:0	10	[
water	599:25	0:0	10	0
op	599:26	0:0	10	]
op	599:28	0:0	10	>>
water	599:31	0:0	10	6
arg	599:42	599:43	9	2
water	599:42	0:0	10	2
arg	599:45	599:46	9	2
water	599:45	0:0	10	2
water	599:47	0:0	8	;
op	600:16	0:0	8	*
water	600:17	0:0	8	samples
op	600:24	0:0	8	++
op	600:27	0:0	8	=
call	600:29	601:46	8	adpcm_sbpro_expand_nibble
arg	600:55	600:69	9	&c->status[st]
op	600:55	0:0	10	&
water	600:56	0:0	10	c
op	600:57	0:0	10	->
water	600:59	0:0	10	status
op	600:65	0:0	10	[
water	600:66	0:0	10	st
op	600:68	0:0	10	]
arg	601:20	601:40	9	(src[0]>>4)&0x03
water	601:20	0:0	10	(
water	601:21	0:0	10	src
op	601:24	0:0	10	[
water	601:25	0:0	10	0
op	601:26	0:0	10	]
op	601:28	0:0	10	>>
water	601:31	0:0	10	4
water	601:32	0:0	10	)
op	601:34	0:0	10	&
water	601:36	0:0	10	0
water	601:37	0:0	10	x03
arg	601:42	601:43	9	2
water	601:42	0:0	10	2
arg	601:45	601:46	9	2
water	601:45	0:0	10	2
water	601:47	0:0	8	;
op	602:16	0:0	8	*
water	602:17	0:0	8	samples
op	602:24	0:0	8	++
op	602:27	0:0	8	=
call	602:29	603:46	8	adpcm_sbpro_expand_nibble
arg	602:55	602:68	9	&c->status[0]
op	602:55	0:0	10	&
water	602:56	0:0	10	c
op	602:57	0:0	10	->
water	602:59	0:0	10	status
op	602:65	0:0	10	[
water	602:66	0:0	10	0
op	602:67	0:0	10	]
arg	603:20	603:40	9	(src[0]>>2)&0x03
water	603:20	0:0	10	(
water	603:21	0:0	10	src
op	603:24	0:0	10	[
water	603:25	0:0	10	0
op	603:26	0:0	10	]
op	603:28	0:0	10	>>
water	603:31	0:0	10	2
water	603:32	0:0	10	)
op	603:34	0:0	10	&
water	603:36	0:0	10	0
water	603:37	0:0	10	x03
arg	603:42	603:43	9	2
water	603:42	0:0	10	2
arg	603:45	603:46	9	2
water	603:45	0:0	10	2
water	603:47	0:0	8	;
op	604:16	0:0	8	*
water	604:17	0:0	8	samples
op	604:24	0:0	8	++
op	604:27	0:0	8	=
call	604:29	605:39	8	adpcm_sbpro_expand_nibble
arg	604:55	604:69	9	&c->status[st]
op	604:55	0:0	10	&
water	604:56	0:0	10	c
op	604:57	0:0	10	->
water	604:59	0:0	10	status
op	604:65	0:0	10	[
water	604:66	0:0	10	st
op	604:68	0:0	10	]
arg	605:20	605:33	9	src[0]&0x03
water	605:20	0:0	10	src
op	605:23	0:0	10	[
water	605:24	0:0	10	0
op	605:25	0:0	10	]
op	605:27	0:0	10	&
water	605:29	0:0	10	0
water	605:30	0:0	10	x03
arg	605:35	605:36	9	2
water	605:35	0:0	10	2
arg	605:38	605:39	9	2
water	605:38	0:0	10	2
water	605:40	0:0	8	;
water	606:16	0:0	8	src
op	606:19	0:0	8	++
water	606:21	0:0	8	;
water	607:12	0:0	8	}
water	608:8	0:0	6	}
break	609:8	609:13	4	
label	610:4	610:27	4	case CODEC_ID_ADPCM_SWF :
water	611:4	0:0	4	{
decl	612:8	612:24	4	GetBitContext	gb
decl	613:8	613:24	4	const int	*table
decl	614:8	614:40	4	int	k0
water	614:14	0:0	4	,
decl	614:8	614:40	4	int	signmask
water	614:24	0:0	4	,
decl	614:8	614:40	4	int	nb_bits
water	614:33	0:0	4	,
decl	614:8	614:40	4	int	count
decl	615:8	615:29	4	int	size
op	615:17	0:0	4	=
water	615:19	0:0	4	buf_size
op	615:27	0:0	4	*
water	615:28	0:0	4	8
call	617:8	617:36	4	init_get_bits
arg	617:22	617:25	5	&gb
op	617:22	0:0	6	&
water	617:23	0:0	6	gb
arg	617:27	617:30	5	buf
water	617:27	0:0	6	buf
arg	617:32	617:36	5	size
water	617:32	0:0	6	size
water	617:37	0:0	4	;
water	620:8	0:0	4	nb_bits
op	620:16	0:0	4	=
call	620:18	620:33	4	get_bits
arg	620:27	620:30	5	&gb
op	620:27	0:0	6	&
water	620:28	0:0	6	gb
arg	620:32	620:33	5	2
water	620:32	0:0	6	2
op	620:34	0:0	4	+
water	620:35	0:0	4	2
water	620:36	0:0	4	;
water	622:8	0:0	4	table
op	622:14	0:0	4	=
water	622:16	0:0	4	swf_index_tables
op	622:32	0:0	4	[
water	622:33	0:0	4	nb_bits
op	622:40	0:0	4	-
water	622:41	0:0	4	2
op	622:42	0:0	4	]
water	622:43	0:0	4	;
water	623:8	0:0	4	k0
op	623:11	0:0	4	=
water	623:13	0:0	4	1
op	623:15	0:0	4	<<
water	623:18	0:0	4	(
water	623:19	0:0	4	nb_bits
op	623:26	0:0	4	-
water	623:27	0:0	4	2
water	623:28	0:0	4	)
water	623:29	0:0	4	;
water	624:8	0:0	4	signmask
op	624:17	0:0	4	=
water	624:19	0:0	4	1
op	624:21	0:0	4	<<
water	624:24	0:0	4	(
water	624:25	0:0	4	nb_bits
op	624:32	0:0	4	-
water	624:33	0:0	4	1
water	624:34	0:0	4	)
water	624:35	0:0	4	;
while	626:8	667:8	4	(get_bits_count (& gb ) <= size - 22 * avctx -> channels)
cond	626:15	626:55	5	get_bits_count (& gb ) <= size - 22 * avctx -> channels
call	626:15	626:33	6	get_bits_count
arg	626:30	626:33	7	&gb
op	626:30	0:0	8	&
water	626:31	0:0	8	gb
op	626:35	0:0	6	<=
water	626:38	0:0	6	size
op	626:43	0:0	6	-
water	626:45	0:0	6	22
op	626:47	0:0	6	*
water	626:48	0:0	6	avctx
op	626:53	0:0	6	->
water	626:55	0:0	6	channels
stmts	626:65	667:8	5	
water	626:65	0:0	6	{
for	627:12	630:12	6	(i = 0 ;i < avctx -> channels;i ++)
forinit	627:17	627:22	7	i = 0 ;
water	627:17	0:0	8	i
op	627:19	0:0	8	=
water	627:21	0:0	8	0
water	627:22	0:0	8	;
cond	627:24	627:35	7	i < avctx -> channels
water	627:24	0:0	8	i
op	627:26	0:0	8	<
water	627:28	0:0	8	avctx
op	627:33	0:0	8	->
water	627:35	0:0	8	channels
forexpr	627:45	627:46	7	i ++
water	627:45	0:0	8	i
op	627:46	0:0	8	++
stmts	627:50	630:12	7	
water	627:50	0:0	8	{
op	628:16	0:0	8	*
water	628:17	0:0	8	samples
op	628:24	0:0	8	++
op	628:27	0:0	8	=
water	628:29	0:0	8	c
op	628:30	0:0	8	->
water	628:32	0:0	8	status
op	628:38	0:0	8	[
water	628:39	0:0	8	i
op	628:40	0:0	8	]
op	628:41	0:0	8	.
water	628:42	0:0	8	predictor
op	628:52	0:0	8	=
call	628:54	628:71	8	get_sbits
arg	628:64	628:67	9	&gb
op	628:64	0:0	10	&
water	628:65	0:0	10	gb
arg	628:69	628:71	9	16
water	628:69	0:0	10	16
water	628:72	0:0	8	;
water	629:16	0:0	8	c
op	629:17	0:0	8	->
water	629:19	0:0	8	status
op	629:25	0:0	8	[
water	629:26	0:0	8	i
op	629:27	0:0	8	]
op	629:28	0:0	8	.
water	629:29	0:0	8	step_index
op	629:40	0:0	8	=
call	629:42	629:57	8	get_bits
arg	629:51	629:54	9	&gb
op	629:51	0:0	10	&
water	629:52	0:0	10	gb
arg	629:56	629:57	9	6
water	629:56	0:0	10	6
water	629:58	0:0	8	;
water	630:12	0:0	8	}
for	632:12	666:12	6	(count = 0 ;get_bits_count (& gb ) <= size - nb_bits * avctx -> channels && count < 4095;count ++)
forinit	632:17	632:26	7	count = 0 ;
water	632:17	0:0	8	count
op	632:23	0:0	8	=
water	632:25	0:0	8	0
water	632:26	0:0	8	;
cond	632:28	632:93	7	get_bits_count (& gb ) <= size - nb_bits * avctx -> channels && count < 4095
call	632:28	632:46	8	get_bits_count
arg	632:43	632:46	9	&gb
op	632:43	0:0	10	&
water	632:44	0:0	10	gb
op	632:48	0:0	8	<=
water	632:51	0:0	8	size
op	632:56	0:0	8	-
water	632:58	0:0	8	nb_bits
op	632:65	0:0	8	*
water	632:66	0:0	8	avctx
op	632:71	0:0	8	->
water	632:73	0:0	8	channels
op	632:82	0:0	8	&&
water	632:85	0:0	8	count
op	632:91	0:0	8	<
water	632:93	0:0	8	4095
forexpr	632:99	632:104	7	count ++
water	632:99	0:0	8	count
op	632:104	0:0	8	++
stmts	632:108	666:12	7	
water	632:108	0:0	8	{
decl	633:16	633:21	8	int	i
for	635:16	665:16	8	(i = 0 ;i < avctx -> channels;i ++)
forinit	635:21	635:26	9	i = 0 ;
water	635:21	0:0	10	i
op	635:23	0:0	10	=
water	635:25	0:0	10	0
water	635:26	0:0	10	;
cond	635:28	635:39	9	i < avctx -> channels
water	635:28	0:0	10	i
op	635:30	0:0	10	<
water	635:32	0:0	10	avctx
op	635:37	0:0	10	->
water	635:39	0:0	10	channels
forexpr	635:49	635:50	9	i ++
water	635:49	0:0	10	i
op	635:50	0:0	10	++
stmts	635:54	665:16	9	
water	635:54	0:0	10	{
decl	637:20	637:54	10	int	delta
op	637:30	0:0	10	=
call	637:32	637:53	11	get_bits
arg	637:41	637:44	12	&gb
op	637:41	0:0	13	&
water	637:42	0:0	13	gb
arg	637:46	637:53	12	nb_bits
water	637:46	0:0	13	nb_bits
decl	638:20	638:66	10	int	step
op	638:29	0:0	10	=
water	638:31	0:0	10	step_table
op	638:41	0:0	10	[
water	638:42	0:0	10	c
op	638:43	0:0	10	->
water	638:45	0:0	10	status
op	638:51	0:0	10	[
water	638:52	0:0	10	i
op	638:53	0:0	10	]
op	638:54	0:0	10	.
water	638:55	0:0	10	step_index
op	638:65	0:0	10	]
decl	639:20	639:35	10	long	vpdiff
op	639:32	0:0	10	=
water	639:34	0:0	10	0
decl	640:20	640:30	10	int	k
op	640:26	0:0	10	=
water	640:28	0:0	10	k0
do	642:20	647:20	10	(k)
cond	647:28	647:28	11	k
water	647:28	0:0	12	k
stmts	642:23	647:20	11	
water	642:23	0:0	12	{
if	643:24	644:42	12	(delta & k)
cond	643:28	643:36	13	delta & k
water	643:28	0:0	14	delta
op	643:34	0:0	14	&
water	643:36	0:0	14	k
stmts	644:28	644:42	13	
water	644:28	0:0	14	vpdiff
op	644:35	0:0	14	+=
water	644:38	0:0	14	step
water	644:42	0:0	14	;
water	645:24	0:0	12	step
op	645:29	0:0	12	>>=
water	645:33	0:0	12	1
water	645:34	0:0	12	;
water	646:24	0:0	12	k
op	646:26	0:0	12	>>=
water	646:30	0:0	12	1
water	646:31	0:0	12	;
water	647:20	0:0	12	}
water	647:30	0:0	10	;
water	648:20	0:0	10	vpdiff
op	648:27	0:0	10	+=
water	648:30	0:0	10	step
water	648:34	0:0	10	;
if	650:20	651:56	10	(delta & signmask)
cond	650:24	650:32	11	delta & signmask
water	650:24	0:0	12	delta
op	650:30	0:0	12	&
water	650:32	0:0	12	signmask
stmts	651:24	651:56	11	
water	651:24	0:0	12	c
op	651:25	0:0	12	->
water	651:27	0:0	12	status
op	651:33	0:0	12	[
water	651:34	0:0	12	i
op	651:35	0:0	12	]
op	651:36	0:0	12	.
water	651:37	0:0	12	predictor
op	651:47	0:0	12	-=
water	651:50	0:0	12	vpdiff
water	651:56	0:0	12	;
else	652:20	653:56	10
stmts	653:24	653:56	11	
water	653:24	0:0	12	c
op	653:25	0:0	12	->
water	653:27	0:0	12	status
op	653:33	0:0	12	[
water	653:34	0:0	12	i
op	653:35	0:0	12	]
op	653:36	0:0	12	.
water	653:37	0:0	12	predictor
op	653:47	0:0	12	+=
water	653:50	0:0	12	vpdiff
water	653:56	0:0	12	;
water	655:20	0:0	10	c
op	655:21	0:0	10	->
water	655:23	0:0	10	status
op	655:29	0:0	10	[
water	655:30	0:0	10	i
op	655:31	0:0	10	]
op	655:32	0:0	10	.
water	655:33	0:0	10	step_index
op	655:44	0:0	10	+=
water	655:47	0:0	10	table
op	655:52	0:0	10	[
water	655:53	0:0	10	delta
op	655:59	0:0	10	&
water	655:61	0:0	10	(
water	655:62	0:0	10	~signmask
water	655:71	0:0	10	)
op	655:72	0:0	10	]
water	655:73	0:0	10	;
water	657:20	0:0	10	c
op	657:21	0:0	10	->
water	657:23	0:0	10	status
op	657:29	0:0	10	[
water	657:30	0:0	10	i
op	657:31	0:0	10	]
op	657:32	0:0	10	.
water	657:33	0:0	10	step_index
op	657:44	0:0	10	=
call	657:46	657:84	10	av_clip
arg	657:54	657:77	11	c->status[i].step_index
water	657:54	0:0	12	c
op	657:55	0:0	12	->
water	657:57	0:0	12	status
op	657:63	0:0	12	[
water	657:64	0:0	12	i
op	657:65	0:0	12	]
op	657:66	0:0	12	.
water	657:67	0:0	12	step_index
arg	657:79	657:80	11	0
water	657:79	0:0	12	0
arg	657:82	657:84	11	88
water	657:82	0:0	12	88
water	657:85	0:0	10	;
water	658:20	0:0	10	c
op	658:21	0:0	10	->
water	658:23	0:0	10	status
op	658:29	0:0	10	[
water	658:30	0:0	10	i
op	658:31	0:0	10	]
op	658:32	0:0	10	.
water	658:33	0:0	10	predictor
op	658:43	0:0	10	=
call	658:45	658:81	10	av_clip_int16
arg	658:59	658:81	11	c->status[i].predictor
water	658:59	0:0	12	c
op	658:60	0:0	12	->
water	658:62	0:0	12	status
op	658:68	0:0	12	[
water	658:69	0:0	12	i
op	658:70	0:0	12	]
op	658:71	0:0	12	.
water	658:72	0:0	12	predictor
water	658:82	0:0	10	;
op	660:20	0:0	10	*
water	660:21	0:0	10	samples
op	660:28	0:0	10	++
op	660:31	0:0	10	=
water	660:33	0:0	10	c
op	660:34	0:0	10	->
water	660:36	0:0	10	status
op	660:42	0:0	10	[
water	660:43	0:0	10	i
op	660:44	0:0	10	]
op	660:45	0:0	10	.
water	660:46	0:0	10	predictor
water	660:55	0:0	10	;
if	661:20	664:20	10	(samples >= samples_end)
cond	661:24	661:35	11	samples >= samples_end
water	661:24	0:0	12	samples
op	661:32	0:0	12	>=
water	661:35	0:0	12	samples_end
stmts	661:48	664:20	11	
water	661:48	0:0	12	{
call	662:24	662:92	12	av_log
arg	662:31	662:36	13	avctx
water	662:31	0:0	14	avctx
arg	662:38	662:50	13	AV_LOG_ERROR
water	662:38	0:0	14	AV_LOG_ERROR
arg	662:52	662:92	13	"allocated output buffer is too small\n"
water	662:52	0:0	14	"allocated output buffer is too small\n"
water	662:93	0:0	12	;
return	663:24	663:33	12	-1
op	663:31	0:0	13	-
water	663:32	0:0	13	1
water	664:20	0:0	12	}
water	665:16	0:0	10	}
water	666:12	0:0	8	}
water	667:8	0:0	6	}
water	668:8	0:0	4	src
op	668:12	0:0	4	+=
water	668:15	0:0	4	buf_size
water	668:23	0:0	4	;
break	669:8	669:13	4	
water	670:4	0:0	4	}
label	671:4	671:30	4	case CODEC_ID_ADPCM_YAMAHA :
while	672:8	685:8	4	(src < buf + buf_size)
cond	672:15	672:27	5	src < buf + buf_size
water	672:15	0:0	6	src
op	672:19	0:0	6	<
water	672:21	0:0	6	buf
op	672:25	0:0	6	+
water	672:27	0:0	6	buf_size
stmts	672:37	685:8	5	
water	672:37	0:0	6	{
if	673:12	678:12	6	(st)
cond	673:16	673:16	7	st
water	673:16	0:0	8	st
stmts	673:20	678:12	7	
water	673:20	0:0	8	{
op	674:16	0:0	8	*
water	674:17	0:0	8	samples
op	674:24	0:0	8	++
op	674:27	0:0	8	=
call	674:29	675:37	8	adpcm_yamaha_expand_nibble
arg	674:56	674:69	9	&c->status[0]
op	674:56	0:0	10	&
water	674:57	0:0	10	c
op	674:58	0:0	10	->
water	674:60	0:0	10	status
op	674:66	0:0	10	[
water	674:67	0:0	10	0
op	674:68	0:0	10	]
arg	675:24	675:37	9	src[0]&0x0F
water	675:24	0:0	10	src
op	675:27	0:0	10	[
water	675:28	0:0	10	0
op	675:29	0:0	10	]
op	675:31	0:0	10	&
water	675:33	0:0	10	0
water	675:34	0:0	10	x0F
water	675:38	0:0	8	;
op	676:16	0:0	8	*
water	676:17	0:0	8	samples
op	676:24	0:0	8	++
op	676:27	0:0	8	=
call	676:29	677:37	8	adpcm_yamaha_expand_nibble
arg	676:56	676:69	9	&c->status[1]
op	676:56	0:0	10	&
water	676:57	0:0	10	c
op	676:58	0:0	10	->
water	676:60	0:0	10	status
op	676:66	0:0	10	[
water	676:67	0:0	10	1
op	676:68	0:0	10	]
arg	677:24	677:37	9	src[0]>>4
water	677:24	0:0	10	src
op	677:27	0:0	10	[
water	677:28	0:0	10	0
op	677:29	0:0	10	]
op	677:31	0:0	10	>>
water	677:34	0:0	10	4
water	677:38	0:0	8	;
water	678:12	0:0	8	}
else	678:14	683:12	6
stmts	678:19	683:12	7	
water	678:19	0:0	8	{
op	679:16	0:0	8	*
water	679:17	0:0	8	samples
op	679:24	0:0	8	++
op	679:27	0:0	8	=
call	679:29	680:37	8	adpcm_yamaha_expand_nibble
arg	679:56	679:69	9	&c->status[0]
op	679:56	0:0	10	&
water	679:57	0:0	10	c
op	679:58	0:0	10	->
water	679:60	0:0	10	status
op	679:66	0:0	10	[
water	679:67	0:0	10	0
op	679:68	0:0	10	]
arg	680:24	680:37	9	src[0]&0x0F
water	680:24	0:0	10	src
op	680:27	0:0	10	[
water	680:28	0:0	10	0
op	680:29	0:0	10	]
op	680:31	0:0	10	&
water	680:33	0:0	10	0
water	680:34	0:0	10	x0F
water	680:38	0:0	8	;
op	681:16	0:0	8	*
water	681:17	0:0	8	samples
op	681:24	0:0	8	++
op	681:27	0:0	8	=
call	681:29	682:37	8	adpcm_yamaha_expand_nibble
arg	681:56	681:69	9	&c->status[0]
op	681:56	0:0	10	&
water	681:57	0:0	10	c
op	681:58	0:0	10	->
water	681:60	0:0	10	status
op	681:66	0:0	10	[
water	681:67	0:0	10	0
op	681:68	0:0	10	]
arg	682:24	682:37	9	src[0]>>4
water	682:24	0:0	10	src
op	682:27	0:0	10	[
water	682:28	0:0	10	0
op	682:29	0:0	10	]
op	682:31	0:0	10	>>
water	682:34	0:0	10	4
water	682:38	0:0	8	;
water	683:12	0:0	8	}
water	684:12	0:0	6	src
op	684:15	0:0	6	++
water	684:17	0:0	6	;
water	685:8	0:0	6	}
break	686:8	686:13	4	
label	687:4	687:27	4	case CODEC_ID_ADPCM_THP :
water	688:4	0:0	4	{
water	689:8	0:0	4	int
water	689:12	0:0	4	table
op	689:17	0:0	4	[
water	689:18	0:0	4	2
op	689:19	0:0	4	]
op	689:20	0:0	4	[
water	689:21	0:0	4	16
op	689:23	0:0	4	]
water	689:24	0:0	4	;
decl	690:8	690:30	4	unsigned int	samplecnt
water	691:8	0:0	4	int
water	691:12	0:0	4	prev
op	691:16	0:0	4	[
water	691:17	0:0	4	2
op	691:18	0:0	4	]
op	691:19	0:0	4	[
water	691:20	0:0	4	2
op	691:21	0:0	4	]
water	691:22	0:0	4	;
decl	692:8	692:14	4	int	ch
if	694:8	697:8	4	(buf_size < 80)
cond	694:12	694:23	5	buf_size < 80
water	694:12	0:0	6	buf_size
op	694:21	0:0	6	<
water	694:23	0:0	6	80
stmts	694:27	697:8	5	
water	694:27	0:0	6	{
call	695:12	695:59	6	av_log
arg	695:19	695:24	7	avctx
water	695:19	0:0	8	avctx
arg	695:26	695:38	7	AV_LOG_ERROR
water	695:26	0:0	8	AV_LOG_ERROR
arg	695:40	695:59	7	"frame too small\n"
water	695:40	0:0	8	"frame too small\n"
water	695:60	0:0	6	;
return	696:12	696:21	6	-1
op	696:19	0:0	7	-
water	696:20	0:0	7	1
water	697:8	0:0	6	}
water	699:8	0:0	4	src
op	699:11	0:0	4	+=
water	699:13	0:0	4	4
water	699:14	0:0	4	;
water	700:8	0:0	4	samplecnt
op	700:18	0:0	4	=
call	700:20	700:44	4	bytestream_get_be32
arg	700:40	700:44	5	&src
op	700:40	0:0	6	&
water	700:41	0:0	6	src
water	700:45	0:0	4	;
for	702:8	703:60	4	(i = 0 ;i < 32;i ++)
forinit	702:13	702:18	5	i = 0 ;
water	702:13	0:0	6	i
op	702:15	0:0	6	=
water	702:17	0:0	6	0
water	702:18	0:0	6	;
cond	702:20	702:24	5	i < 32
water	702:20	0:0	6	i
op	702:22	0:0	6	<
water	702:24	0:0	6	32
forexpr	702:28	702:29	5	i ++
water	702:28	0:0	6	i
op	702:29	0:0	6	++
stmts	703:12	703:60	5	
water	703:12	0:0	6	table
op	703:17	0:0	6	[
water	703:18	0:0	6	0
op	703:19	0:0	6	]
op	703:20	0:0	6	[
water	703:21	0:0	6	i
op	703:22	0:0	6	]
op	703:24	0:0	6	=
water	703:26	0:0	6	(
water	703:27	0:0	6	int16_t
water	703:34	0:0	6	)
call	703:35	703:59	6	bytestream_get_be16
arg	703:55	703:59	7	&src
op	703:55	0:0	8	&
water	703:56	0:0	8	src
water	703:60	0:0	6	;
for	706:8	707:59	4	(i = 0 ;i < 4;i ++)
forinit	706:13	706:18	5	i = 0 ;
water	706:13	0:0	6	i
op	706:15	0:0	6	=
water	706:17	0:0	6	0
water	706:18	0:0	6	;
cond	706:20	706:24	5	i < 4
water	706:20	0:0	6	i
op	706:22	0:0	6	<
water	706:24	0:0	6	4
forexpr	706:27	706:28	5	i ++
water	706:27	0:0	6	i
op	706:28	0:0	6	++
stmts	707:12	707:59	5	
water	707:12	0:0	6	prev
op	707:16	0:0	6	[
water	707:17	0:0	6	0
op	707:18	0:0	6	]
op	707:19	0:0	6	[
water	707:20	0:0	6	i
op	707:21	0:0	6	]
op	707:23	0:0	6	=
water	707:25	0:0	6	(
water	707:26	0:0	6	int16_t
water	707:33	0:0	6	)
call	707:34	707:58	6	bytestream_get_be16
arg	707:54	707:58	7	&src
op	707:54	0:0	8	&
water	707:55	0:0	8	src
water	707:59	0:0	6	;
if	709:8	712:8	4	(samplecnt >= ( samples_end - samples ) / ( st + 1 ))
cond	709:12	709:59	5	samplecnt >= ( samples_end - samples ) / ( st + 1 )
water	709:12	0:0	6	samplecnt
op	709:22	0:0	6	>=
water	709:25	0:0	6	(
water	709:26	0:0	6	samples_end
op	709:38	0:0	6	-
water	709:40	0:0	6	samples
water	709:47	0:0	6	)
op	709:49	0:0	6	/
water	709:52	0:0	6	(
water	709:53	0:0	6	st
op	709:56	0:0	6	+
water	709:58	0:0	6	1
water	709:59	0:0	6	)
stmts	709:62	712:8	5	
water	709:62	0:0	6	{
call	710:12	710:80	6	av_log
arg	710:19	710:24	7	avctx
water	710:19	0:0	8	avctx
arg	710:26	710:38	7	AV_LOG_ERROR
water	710:26	0:0	8	AV_LOG_ERROR
arg	710:40	710:80	7	"allocated output buffer is too small\n"
water	710:40	0:0	8	"allocated output buffer is too small\n"
water	710:81	0:0	6	;
return	711:12	711:21	6	-1
op	711:19	0:0	7	-
water	711:20	0:0	7	1
water	712:8	0:0	6	}
for	714:8	741:8	4	(ch = 0 ;ch <= st;ch ++)
forinit	714:13	714:19	5	ch = 0 ;
water	714:13	0:0	6	ch
op	714:16	0:0	6	=
water	714:18	0:0	6	0
water	714:19	0:0	6	;
cond	714:21	714:27	5	ch <= st
water	714:21	0:0	6	ch
op	714:24	0:0	6	<=
water	714:27	0:0	6	st
forexpr	714:31	714:33	5	ch ++
water	714:31	0:0	6	ch
op	714:33	0:0	6	++
stmts	714:37	741:8	5	
water	714:37	0:0	6	{
water	715:12	0:0	6	samples
op	715:20	0:0	6	=
water	715:22	0:0	6	(
water	715:23	0:0	6	unsigned
water	715:32	0:0	6	short
op	715:38	0:0	6	*
water	715:39	0:0	6	)
water	715:41	0:0	6	data
op	715:46	0:0	6	+
water	715:48	0:0	6	ch
water	715:50	0:0	6	;
for	718:12	740:12	6	(i = 0 ;i < samplecnt / 14;i ++)
forinit	718:17	718:22	7	i = 0 ;
water	718:17	0:0	8	i
op	718:19	0:0	8	=
water	718:21	0:0	8	0
water	718:22	0:0	8	;
cond	718:24	718:40	7	i < samplecnt / 14
water	718:24	0:0	8	i
op	718:26	0:0	8	<
water	718:28	0:0	8	samplecnt
op	718:38	0:0	8	/
water	718:40	0:0	8	14
forexpr	718:44	718:45	7	i ++
water	718:44	0:0	8	i
op	718:45	0:0	8	++
stmts	718:49	740:12	7	
water	718:49	0:0	8	{
decl	719:16	719:43	8	int	index
op	719:26	0:0	8	=
water	719:28	0:0	8	(
op	719:29	0:0	8	*
water	719:30	0:0	8	src
op	719:34	0:0	8	>>
water	719:37	0:0	8	4
water	719:38	0:0	8	)
op	719:40	0:0	8	&
water	719:42	0:0	8	7
decl	720:16	720:53	8	unsigned int	exp
op	720:33	0:0	8	=
water	720:35	0:0	8	28
op	720:38	0:0	8	-
water	720:40	0:0	8	(
op	720:41	0:0	8	*
water	720:42	0:0	8	src
op	720:45	0:0	8	++
op	720:48	0:0	8	&
water	720:50	0:0	8	15
water	720:52	0:0	8	)
decl	721:16	721:50	8	int	factor1
op	721:28	0:0	8	=
water	721:30	0:0	8	table
op	721:35	0:0	8	[
water	721:36	0:0	8	ch
op	721:38	0:0	8	]
op	721:39	0:0	8	[
water	721:40	0:0	8	index
op	721:46	0:0	8	*
water	721:48	0:0	8	2
op	721:49	0:0	8	]
decl	722:16	722:54	8	int	factor2
op	722:28	0:0	8	=
water	722:30	0:0	8	table
op	722:35	0:0	8	[
water	722:36	0:0	8	ch
op	722:38	0:0	8	]
op	722:39	0:0	8	[
water	722:40	0:0	8	index
op	722:46	0:0	8	*
water	722:48	0:0	8	2
op	722:50	0:0	8	+
water	722:52	0:0	8	1
op	722:53	0:0	8	]
for	725:16	739:16	8	(n = 0 ;n < 14;n ++)
forinit	725:21	725:26	9	n = 0 ;
water	725:21	0:0	10	n
op	725:23	0:0	10	=
water	725:25	0:0	10	0
water	725:26	0:0	10	;
cond	725:28	725:32	9	n < 14
water	725:28	0:0	10	n
op	725:30	0:0	10	<
water	725:32	0:0	10	14
forexpr	725:36	725:37	9	n ++
water	725:36	0:0	10	n
op	725:37	0:0	10	++
stmts	725:41	739:16	9	
water	725:41	0:0	10	{
decl	726:20	726:37	10	int32_t	sampledat
if	727:20	727:54	10	(n & 1)
cond	727:23	727:25	11	n & 1
water	727:23	0:0	12	n
op	727:24	0:0	12	&
water	727:25	0:0	12	1
stmts	727:28	727:54	11	
water	727:28	0:0	12	sampledat
op	727:37	0:0	12	=
op	727:40	0:0	12	*
water	727:41	0:0	12	src
op	727:44	0:0	12	++
op	727:50	0:0	12	<<
water	727:52	0:0	12	28
water	727:54	0:0	12	;
else	728:20	728:54	10
stmts	728:28	728:54	11	
water	728:28	0:0	12	sampledat
op	728:37	0:0	12	=
water	728:39	0:0	12	(
op	728:40	0:0	12	*
water	728:41	0:0	12	src
op	728:44	0:0	12	&
water	728:45	0:0	12	0
water	728:46	0:0	12	xF0
water	728:49	0:0	12	)
op	728:50	0:0	12	<<
water	728:52	0:0	12	24
water	728:54	0:0	12	;
water	730:20	0:0	10	sampledat
op	730:30	0:0	10	=
water	730:32	0:0	10	(
water	730:33	0:0	10	(
water	730:34	0:0	10	prev
op	730:38	0:0	10	[
water	730:39	0:0	10	ch
op	730:41	0:0	10	]
op	730:42	0:0	10	[
water	730:43	0:0	10	0
op	730:44	0:0	10	]
op	730:45	0:0	10	*
water	730:46	0:0	10	factor1
op	731:32	0:0	10	+
water	731:34	0:0	10	prev
op	731:38	0:0	10	[
water	731:39	0:0	10	ch
op	731:41	0:0	10	]
op	731:42	0:0	10	[
water	731:43	0:0	10	1
op	731:44	0:0	10	]
op	731:45	0:0	10	*
water	731:46	0:0	10	factor2
water	731:53	0:0	10	)
op	731:55	0:0	10	>>
water	731:58	0:0	10	11
water	731:60	0:0	10	)
op	731:62	0:0	10	+
water	731:64	0:0	10	(
water	731:65	0:0	10	sampledat
op	731:74	0:0	10	>>
water	731:76	0:0	10	exp
water	731:79	0:0	10	)
water	731:80	0:0	10	;
op	732:20	0:0	10	*
water	732:21	0:0	10	samples
op	732:29	0:0	10	=
call	732:31	732:54	10	av_clip_int16
arg	732:45	732:54	11	sampledat
water	732:45	0:0	12	sampledat
water	732:55	0:0	10	;
water	733:20	0:0	10	prev
op	733:24	0:0	10	[
water	733:25	0:0	10	ch
op	733:27	0:0	10	]
op	733:28	0:0	10	[
water	733:29	0:0	10	1
op	733:30	0:0	10	]
op	733:32	0:0	10	=
water	733:34	0:0	10	prev
op	733:38	0:0	10	[
water	733:39	0:0	10	ch
op	733:41	0:0	10	]
op	733:42	0:0	10	[
water	733:43	0:0	10	0
op	733:44	0:0	10	]
water	733:45	0:0	10	;
water	734:20	0:0	10	prev
op	734:24	0:0	10	[
water	734:25	0:0	10	ch
op	734:27	0:0	10	]
op	734:28	0:0	10	[
water	734:29	0:0	10	0
op	734:30	0:0	10	]
op	734:32	0:0	10	=
op	734:34	0:0	10	*
water	734:35	0:0	10	samples
op	734:42	0:0	10	++
water	734:44	0:0	10	;
water	738:20	0:0	10	samples
op	738:28	0:0	10	+=
water	738:31	0:0	10	st
water	738:33	0:0	10	;
water	739:16	0:0	10	}
water	740:12	0:0	8	}
water	741:8	0:0	6	}
water	745:8	0:0	4	samples
op	745:16	0:0	4	-=
water	745:19	0:0	4	st
water	745:21	0:0	4	;
break	746:8	746:13	4	
water	747:4	0:0	4	}
label	749:4	749:11	4	default :
return	750:8	750:17	4	-1
op	750:15	0:0	5	-
water	750:16	0:0	5	1
water	751:4	0:0	4	}
op	752:4	0:0	2	*
water	752:5	0:0	2	data_size
op	752:15	0:0	2	=
water	752:17	0:0	2	(
water	752:18	0:0	2	uint8_t
op	752:26	0:0	2	*
water	752:27	0:0	2	)
water	752:28	0:0	2	samples
op	752:36	0:0	2	-
water	752:38	0:0	2	(
water	752:39	0:0	2	uint8_t
op	752:47	0:0	2	*
water	752:48	0:0	2	)
water	752:49	0:0	2	data
water	752:53	0:0	2	;
return	753:4	753:20	2	src-buf
water	753:11	0:0	3	src
op	753:15	0:0	3	-
water	753:17	0:0	3	buf
