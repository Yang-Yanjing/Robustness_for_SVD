func	2:0	79:0	0	static int	wavpack_decode_frame
params	2:31	0:0	1	
param	2:32	2:53	2	AVCodecContext *	avctx
param	2:55	2:65	2	void *	data
param	3:32	3:50	2	int *	got_frame_ptr
param	3:52	3:67	2	AVPacket *	avpkt
stmnts	0:0	78:22	1	
decl	5:4	5:40	2	WavpackContext	*s
op	5:22	0:0	2	=
water	5:24	0:0	2	avctx
op	5:29	0:0	2	->
water	5:31	0:0	2	priv_data
decl	6:4	6:36	2	const uint8_t	*buf
op	6:23	0:0	2	=
water	6:25	0:0	2	avpkt
op	6:30	0:0	2	->
water	6:32	0:0	2	data
decl	7:4	7:30	2	int	buf_size
op	7:17	0:0	2	=
water	7:19	0:0	2	avpkt
op	7:24	0:0	2	->
water	7:26	0:0	2	size
decl	8:4	8:36	2	int	frame_size
water	8:18	0:0	2	,
decl	8:4	8:36	2	int	ret
water	8:23	0:0	2	,
decl	8:4	8:36	2	int	frame_flags
decl	9:4	9:23	2	int	samplecount
op	9:20	0:0	2	=
water	9:22	0:0	2	0
water	11:4	0:0	2	s
op	11:5	0:0	2	->
water	11:7	0:0	2	block
op	11:13	0:0	2	=
water	11:15	0:0	2	0
water	11:16	0:0	2	;
water	12:4	0:0	2	s
op	12:5	0:0	2	->
water	12:7	0:0	2	ch_offset
op	12:17	0:0	2	=
water	12:19	0:0	2	0
water	12:20	0:0	2	;
if	15:4	18:4	2	(s -> mkv_mode)
cond	15:7	15:10	3	s -> mkv_mode
water	15:7	0:0	4	s
op	15:8	0:0	4	->
water	15:10	0:0	4	mkv_mode
stmts	15:19	18:4	3	
water	15:19	0:0	4	{
water	16:8	0:0	4	s
op	16:9	0:0	4	->
water	16:11	0:0	4	samples
op	16:20	0:0	4	=
call	16:22	16:33	4	AV_RL32
arg	16:30	16:33	5	buf
water	16:30	0:0	6	buf
water	16:34	0:0	4	;
water	16:36	0:0	4	buf
op	16:40	0:0	4	+=
water	16:43	0:0	4	4
water	16:44	0:0	4	;
water	17:8	0:0	4	frame_flags
op	17:20	0:0	4	=
call	17:22	17:33	4	AV_RL32
arg	17:30	17:33	5	buf
water	17:30	0:0	6	buf
water	17:34	0:0	4	;
water	18:4	0:0	4	}
else	18:6	26:4	2
stmts	18:11	26:4	3	
water	18:11	0:0	4	{
if	19:8	22:8	4	(s -> multichannel)
cond	19:12	19:15	5	s -> multichannel
water	19:12	0:0	6	s
op	19:13	0:0	6	->
water	19:15	0:0	6	multichannel
stmts	19:29	22:8	5	
water	19:29	0:0	6	{
water	20:12	0:0	6	s
op	20:13	0:0	6	->
water	20:15	0:0	6	samples
op	20:24	0:0	6	=
call	20:26	20:41	6	AV_RL32
arg	20:34	20:41	7	buf+4
water	20:34	0:0	8	buf
op	20:38	0:0	8	+
water	20:40	0:0	8	4
water	20:42	0:0	6	;
water	21:12	0:0	6	frame_flags
op	21:24	0:0	6	=
call	21:26	21:41	6	AV_RL32
arg	21:34	21:41	7	buf+8
water	21:34	0:0	8	buf
op	21:38	0:0	8	+
water	21:40	0:0	8	8
water	21:42	0:0	6	;
water	22:8	0:0	6	}
else	22:10	25:8	4
stmts	22:15	25:8	5	
water	22:15	0:0	6	{
water	23:12	0:0	6	s
op	23:13	0:0	6	->
water	23:15	0:0	6	samples
op	23:24	0:0	6	=
call	23:26	23:37	6	AV_RL32
arg	23:34	23:37	7	buf
water	23:34	0:0	8	buf
water	23:38	0:0	6	;
water	24:12	0:0	6	frame_flags
op	24:24	0:0	6	=
call	24:26	24:41	6	AV_RL32
arg	24:34	24:41	7	buf+4
water	24:34	0:0	8	buf
op	24:38	0:0	8	+
water	24:40	0:0	8	4
water	24:42	0:0	6	;
water	25:8	0:0	6	}
water	26:4	0:0	4	}
if	27:4	31:4	2	(s -> samples <= 0)
cond	27:8	27:22	3	s -> samples <= 0
water	27:8	0:0	4	s
op	27:9	0:0	4	->
water	27:11	0:0	4	samples
op	27:19	0:0	4	<=
water	27:22	0:0	4	0
stmts	27:25	31:4	3	
water	27:25	0:0	4	{
call	28:8	29:25	4	av_log
arg	28:15	28:20	5	avctx
water	28:15	0:0	6	avctx
arg	28:22	28:34	5	AV_LOG_ERROR
water	28:22	0:0	6	AV_LOG_ERROR
arg	28:36	28:69	5	"Invalid number of samples: %d\n"
water	28:36	0:0	6	"Invalid number of samples: %d\n"
arg	29:15	29:25	5	s->samples
water	29:15	0:0	6	s
op	29:16	0:0	6	->
water	29:18	0:0	6	samples
water	29:26	0:0	4	;
return	30:8	30:30	4	AVERROR(EINVAL)
call	30:15	30:29	5	AVERROR
arg	30:23	30:29	6	EINVAL
water	30:23	0:0	7	EINVAL
water	31:4	0:0	4	}
if	33:4	35:4	2	(frame_flags & 0 x80)
cond	33:8	33:23	3	frame_flags & 0 x80
water	33:8	0:0	4	frame_flags
op	33:20	0:0	4	&
water	33:22	0:0	4	0
water	33:23	0:0	4	x80
stmts	33:28	35:4	3	
water	33:28	0:0	4	{
water	34:8	0:0	4	avctx
op	34:13	0:0	4	->
water	34:15	0:0	4	sample_fmt
op	34:26	0:0	4	=
water	34:28	0:0	4	AV_SAMPLE_FMT_FLT
water	34:45	0:0	4	;
water	35:4	0:0	4	}
else	35:6	37:4	2
stmts	35:11	37:4	3	
if	35:11	37:4	4	(( frame_flags & 0 x03 ) <= 1)
cond	35:15	35:39	5	( frame_flags & 0 x03 ) <= 1
water	35:15	0:0	6	(
water	35:16	0:0	6	frame_flags
op	35:28	0:0	6	&
water	35:30	0:0	6	0
water	35:31	0:0	6	x03
water	35:34	0:0	6	)
op	35:36	0:0	6	<=
water	35:39	0:0	6	1
stmts	35:42	37:4	5	
water	35:42	0:0	6	{
water	36:8	0:0	6	avctx
op	36:13	0:0	6	->
water	36:15	0:0	6	sample_fmt
op	36:26	0:0	6	=
water	36:28	0:0	6	AV_SAMPLE_FMT_S16
water	36:45	0:0	6	;
water	37:4	0:0	6	}
else	37:6	39:4	2
stmts	37:11	39:4	3	
water	37:11	0:0	4	{
water	38:8	0:0	4	avctx
op	38:13	0:0	4	->
water	38:15	0:0	4	sample_fmt
op	38:26	0:0	4	=
water	38:28	0:0	4	AV_SAMPLE_FMT_S32
water	38:45	0:0	4	;
water	39:4	0:0	4	}
water	42:4	0:0	2	s
op	42:5	0:0	2	->
water	42:7	0:0	2	frame
op	42:12	0:0	2	.
water	42:13	0:0	2	nb_samples
op	42:24	0:0	2	=
water	42:26	0:0	2	s
op	42:27	0:0	2	->
water	42:29	0:0	2	samples
water	42:36	0:0	2	;
if	43:4	46:4	2	(( ret =avctx -> get_buffer (avctx ,& s -> frame ) ) < 0)
cond	43:8	43:54	3	( ret =avctx -> get_buffer (avctx ,& s -> frame ) ) < 0
water	43:8	0:0	4	(
water	43:9	0:0	4	ret
op	43:13	0:0	4	=
call	43:15	43:49	4	avctx->get_buffer
arg	43:33	43:38	5	avctx
water	43:33	0:0	6	avctx
arg	43:40	43:49	5	&s->frame
op	43:40	0:0	6	&
water	43:41	0:0	6	s
op	43:42	0:0	6	->
water	43:44	0:0	6	frame
water	43:50	0:0	4	)
op	43:52	0:0	4	<
water	43:54	0:0	4	0
stmts	43:57	46:4	3	
water	43:57	0:0	4	{
call	44:8	44:59	4	av_log
arg	44:15	44:20	5	avctx
water	44:15	0:0	6	avctx
arg	44:22	44:34	5	AV_LOG_ERROR
water	44:22	0:0	6	AV_LOG_ERROR
arg	44:36	44:59	5	"get_buffer() failed\n"
water	44:36	0:0	6	"get_buffer() failed\n"
water	44:60	0:0	4	;
return	45:8	45:18	4	ret
water	45:15	0:0	5	ret
water	46:4	0:0	4	}
while	48:4	73:4	2	(buf_size > 0)
cond	48:10	48:21	3	buf_size > 0
water	48:10	0:0	4	buf_size
op	48:19	0:0	4	>
water	48:21	0:0	4	0
stmts	48:23	73:4	3	
water	48:23	0:0	4	{
if	49:8	51:8	4	(! s -> multichannel)
cond	49:11	49:15	5	! s -> multichannel
op	49:11	0:0	6	!
water	49:12	0:0	6	s
op	49:13	0:0	6	->
water	49:15	0:0	6	multichannel
stmts	49:28	51:8	5	
water	49:28	0:0	6	{
water	50:12	0:0	6	frame_size
op	50:23	0:0	6	=
water	50:25	0:0	6	buf_size
water	50:33	0:0	6	;
water	51:8	0:0	6	}
else	51:9	59:8	4
stmts	51:13	59:8	5	
water	51:13	0:0	6	{
if	52:12	54:12	6	(! s -> mkv_mode)
cond	52:15	52:19	7	! s -> mkv_mode
op	52:15	0:0	8	!
water	52:16	0:0	8	s
op	52:17	0:0	8	->
water	52:19	0:0	8	mkv_mode
stmts	52:28	54:12	7	
water	52:28	0:0	8	{
water	53:16	0:0	8	frame_size
op	53:27	0:0	8	=
call	53:29	53:40	8	AV_RL32
arg	53:37	53:40	9	buf
water	53:37	0:0	10	buf
op	53:42	0:0	8	-
water	53:44	0:0	8	12
water	53:46	0:0	8	;
water	53:48	0:0	8	buf
op	53:52	0:0	8	+=
water	53:55	0:0	8	4
water	53:56	0:0	8	;
water	53:58	0:0	8	buf_size
op	53:67	0:0	8	-=
water	53:70	0:0	8	4
water	53:71	0:0	8	;
water	54:12	0:0	8	}
else	54:13	58:12	6
stmts	54:17	58:12	7	
water	54:17	0:0	8	{
if	55:16	56:25	8	(buf_size < 12)
cond	55:19	55:30	9	buf_size < 12
water	55:19	0:0	10	buf_size
op	55:28	0:0	10	<
water	55:30	0:0	10	12
stmts	56:20	56:25	9	
break	56:20	56:25	10	
water	57:16	0:0	8	frame_size
op	57:27	0:0	8	=
call	57:29	57:44	8	AV_RL32
arg	57:37	57:44	9	buf+8
water	57:37	0:0	10	buf
op	57:41	0:0	10	+
water	57:43	0:0	10	8
op	57:46	0:0	8	+
water	57:48	0:0	8	12
water	57:50	0:0	8	;
water	58:12	0:0	8	}
water	59:8	0:0	6	}
if	60:8	65:8	4	(frame_size < 0 || frame_size > buf_size)
cond	60:11	60:42	5	frame_size < 0 || frame_size > buf_size
water	60:11	0:0	6	frame_size
op	60:22	0:0	6	<
water	60:24	0:0	6	0
op	60:26	0:0	6	||
water	60:29	0:0	6	frame_size
op	60:40	0:0	6	>
water	60:42	0:0	6	buf_size
stmts	60:51	65:8	5	
water	60:51	0:0	6	{
call	61:12	62:49	6	av_log
arg	61:19	61:24	7	avctx
water	61:19	0:0	8	avctx
arg	61:26	61:38	7	AV_LOG_ERROR
water	61:26	0:0	8	AV_LOG_ERROR
arg	61:40	61:97	7	"Block %d has invalid size (size %d vs. %d bytes left)\n"
water	61:40	0:0	8	"Block %d has invalid size (size %d vs. %d bytes left)\n"
arg	62:19	62:27	7	s->block
water	62:19	0:0	8	s
op	62:20	0:0	8	->
water	62:22	0:0	8	block
arg	62:29	62:39	7	frame_size
water	62:29	0:0	8	frame_size
arg	62:41	62:49	7	buf_size
water	62:41	0:0	8	buf_size
water	62:50	0:0	6	;
call	63:12	63:38	6	wavpack_decode_flush
arg	63:33	63:38	7	avctx
water	63:33	0:0	8	avctx
water	63:39	0:0	6	;
return	64:12	64:21	6	-1
op	64:19	0:0	7	-
water	64:20	0:0	7	1
water	65:8	0:0	6	}
if	66:8	70:8	4	(( samplecount =wavpack_decode_block (avctx ,s -> block ,s -> frame . data [ 0 ] ,got_frame_ptr ,buf ,frame_size ) ) < 0)
cond	66:11	67:82	5	( samplecount =wavpack_decode_block (avctx ,s -> block ,s -> frame . data [ 0 ] ,got_frame_ptr ,buf ,frame_size ) ) < 0
water	66:11	0:0	6	(
water	66:12	0:0	6	samplecount
op	66:24	0:0	6	=
call	66:26	67:77	6	wavpack_decode_block
arg	66:47	66:52	7	avctx
water	66:47	0:0	8	avctx
arg	66:54	66:62	7	s->block
water	66:54	0:0	8	s
op	66:55	0:0	8	->
water	66:57	0:0	8	block
arg	66:64	66:80	7	s->frame.data[0]
water	66:64	0:0	8	s
op	66:65	0:0	8	->
water	66:67	0:0	8	frame
op	66:72	0:0	8	.
water	66:73	0:0	8	data
op	66:77	0:0	8	[
water	66:78	0:0	8	0
op	66:79	0:0	8	]
arg	67:47	67:60	7	got_frame_ptr
water	67:47	0:0	8	got_frame_ptr
arg	67:62	67:65	7	buf
water	67:62	0:0	8	buf
arg	67:67	67:77	7	frame_size
water	67:67	0:0	8	frame_size
water	67:78	0:0	6	)
op	67:80	0:0	6	<
water	67:82	0:0	6	0
stmts	67:85	70:8	5	
water	67:85	0:0	6	{
call	68:12	68:38	6	wavpack_decode_flush
arg	68:33	68:38	7	avctx
water	68:33	0:0	8	avctx
water	68:39	0:0	6	;
return	69:12	69:21	6	-1
op	69:19	0:0	7	-
water	69:20	0:0	7	1
water	70:8	0:0	6	}
water	71:8	0:0	4	s
op	71:9	0:0	4	->
water	71:11	0:0	4	block
op	71:16	0:0	4	++
water	71:18	0:0	4	;
water	72:8	0:0	4	buf
op	72:12	0:0	4	+=
water	72:15	0:0	4	frame_size
water	72:25	0:0	4	;
water	72:27	0:0	4	buf_size
op	72:36	0:0	4	-=
water	72:39	0:0	4	frame_size
water	72:49	0:0	4	;
water	73:4	0:0	4	}
if	75:4	76:35	2	(* got_frame_ptr)
cond	75:8	75:9	3	* got_frame_ptr
op	75:8	0:0	4	*
water	75:9	0:0	4	got_frame_ptr
stmts	76:8	76:35	3	
op	76:8	0:0	4	*
water	76:9	0:0	4	(
water	76:10	0:0	4	AVFrame
op	76:18	0:0	4	*
water	76:19	0:0	4	)
water	76:20	0:0	4	data
op	76:25	0:0	4	=
water	76:27	0:0	4	s
op	76:28	0:0	4	->
water	76:30	0:0	4	frame
water	76:35	0:0	4	;
return	78:4	78:22	2	avpkt->size
water	78:11	0:0	3	avpkt
op	78:16	0:0	3	->
water	78:18	0:0	3	size
