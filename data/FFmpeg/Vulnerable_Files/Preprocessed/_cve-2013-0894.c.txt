func	2:0	173:0	0	static int	vorbis_parse_setup_hdr_floors
params	2:40	0:0	1	
param	2:41	2:59	2	vorbis_context *	vc
stmnts	0:0	172:12	1	
decl	4:4	4:31	2	GetBitContext	*gb
op	4:22	0:0	2	=
op	4:24	0:0	2	&
water	4:25	0:0	2	vc
op	4:27	0:0	2	->
water	4:29	0:0	2	gb
decl	5:4	5:13	2	int	i
water	5:9	0:0	2	,
decl	5:4	5:13	2	int	j
water	5:11	0:0	2	,
decl	5:4	5:13	2	int	k
water	7:4	0:0	2	vc
op	7:6	0:0	2	->
water	7:8	0:0	2	floor_count
op	7:20	0:0	2	=
call	7:22	7:36	2	get_bits
arg	7:31	7:33	3	gb
water	7:31	0:0	4	gb
arg	7:35	7:36	3	6
water	7:35	0:0	4	6
op	7:38	0:0	2	+
water	7:40	0:0	2	1
water	7:41	0:0	2	;
water	9:4	0:0	2	vc
op	9:6	0:0	2	->
water	9:8	0:0	2	floors
op	9:15	0:0	2	=
call	9:17	9:65	2	av_mallocz
arg	9:28	9:65	3	vc->floor_count*sizeof(*vc->floors)
water	9:28	0:0	4	vc
op	9:30	0:0	4	->
water	9:32	0:0	4	floor_count
op	9:44	0:0	4	*
op	9:46	0:0	4	sizeof
water	9:52	0:0	4	(
op	9:53	0:0	4	*
water	9:54	0:0	4	vc
op	9:56	0:0	4	->
water	9:58	0:0	4	floors
water	9:64	0:0	4	)
water	9:66	0:0	2	;
for	11:4	171:4	2	(i = 0 ;i < vc -> floor_count;++ i)
forinit	11:9	11:14	3	i = 0 ;
water	11:9	0:0	4	i
op	11:11	0:0	4	=
water	11:13	0:0	4	0
water	11:14	0:0	4	;
cond	11:16	11:24	3	i < vc -> floor_count
water	11:16	0:0	4	i
op	11:18	0:0	4	<
water	11:20	0:0	4	vc
op	11:22	0:0	4	->
water	11:24	0:0	4	floor_count
forexpr	11:37	11:39	3	++ i
op	11:37	0:0	4	++
water	11:39	0:0	4	i
stmts	11:42	171:4	3	
water	11:42	0:0	4	{
decl	12:8	12:50	4	vorbis_floor	*floor_setup
op	12:34	0:0	4	=
op	12:36	0:0	4	&
water	12:37	0:0	4	vc
op	12:39	0:0	4	->
water	12:41	0:0	4	floors
op	12:47	0:0	4	[
water	12:48	0:0	4	i
op	12:49	0:0	4	]
water	14:8	0:0	4	floor_setup
op	14:19	0:0	4	->
water	14:21	0:0	4	floor_type
op	14:32	0:0	4	=
call	14:34	14:49	4	get_bits
arg	14:43	14:45	5	gb
water	14:43	0:0	6	gb
arg	14:47	14:49	5	16
water	14:47	0:0	6	16
water	14:50	0:0	4	;
call	16:8	16:73	4	av_dlog
arg	16:16	16:20	5	NULL
water	16:16	0:0	6	NULL
arg	16:22	16:45	5	" %d. floor type %d \n"
water	16:22	0:0	6	" %d. floor type %d \n"
arg	16:47	16:48	5	i
water	16:47	0:0	6	i
arg	16:50	16:73	5	floor_setup->floor_type
water	16:50	0:0	6	floor_setup
op	16:61	0:0	6	->
water	16:63	0:0	6	floor_type
water	16:74	0:0	4	;
if	18:8	101:8	4	(floor_setup -> floor_type == 1)
cond	18:12	18:39	5	floor_setup -> floor_type == 1
water	18:12	0:0	6	floor_setup
op	18:23	0:0	6	->
water	18:25	0:0	6	floor_type
op	18:36	0:0	6	==
water	18:39	0:0	6	1
stmts	18:42	101:8	5	
water	18:42	0:0	6	{
decl	19:12	19:34	6	int	maximum_class
op	19:30	0:0	6	=
op	19:32	0:0	6	-
water	19:33	0:0	6	1
water	20:12	0:0	6	unsigned
water	20:21	0:0	6	rangebits
water	20:30	0:0	6	,
water	20:32	0:0	6	rangemax
water	20:40	0:0	6	,
water	20:42	0:0	6	floor1_values
op	20:56	0:0	6	=
water	20:58	0:0	6	2
water	20:59	0:0	6	;
water	22:12	0:0	6	floor_setup
op	22:23	0:0	6	->
water	22:25	0:0	6	decode
op	22:32	0:0	6	=
water	22:34	0:0	6	vorbis_floor1_decode
water	22:54	0:0	6	;
water	24:12	0:0	6	floor_setup
op	24:23	0:0	6	->
water	24:25	0:0	6	data
op	24:29	0:0	6	.
water	24:30	0:0	6	t1
op	24:32	0:0	6	.
water	24:33	0:0	6	partitions
op	24:44	0:0	6	=
call	24:46	24:60	6	get_bits
arg	24:55	24:57	7	gb
water	24:55	0:0	8	gb
arg	24:59	24:60	7	5
water	24:59	0:0	8	5
water	24:61	0:0	6	;
call	26:12	27:54	6	av_dlog
arg	26:20	26:24	7	NULL
water	26:20	0:0	8	NULL
arg	26:26	26:55	7	" %d.floor: %d partitions \n"
water	26:26	0:0	8	" %d.floor: %d partitions \n"
arg	27:20	27:21	7	i
water	27:20	0:0	8	i
arg	27:23	27:54	7	floor_setup->data.t1.partitions
water	27:23	0:0	8	floor_setup
op	27:34	0:0	8	->
water	27:36	0:0	8	data
op	27:40	0:0	8	.
water	27:41	0:0	8	t1
op	27:43	0:0	8	.
water	27:44	0:0	8	partitions
water	27:55	0:0	6	;
for	29:12	37:12	6	(j = 0 ;j < floor_setup -> data . t1 . partitions;++ j)
forinit	29:17	29:22	7	j = 0 ;
water	29:17	0:0	8	j
op	29:19	0:0	8	=
water	29:21	0:0	8	0
water	29:22	0:0	8	;
cond	29:24	29:49	7	j < floor_setup -> data . t1 . partitions
water	29:24	0:0	8	j
op	29:26	0:0	8	<
water	29:28	0:0	8	floor_setup
op	29:39	0:0	8	->
water	29:41	0:0	8	data
op	29:45	0:0	8	.
water	29:46	0:0	8	t1
op	29:48	0:0	8	.
water	29:49	0:0	8	partitions
forexpr	29:61	29:63	7	++ j
op	29:61	0:0	8	++
water	29:63	0:0	8	j
stmts	29:66	37:12	7	
water	29:66	0:0	8	{
water	30:16	0:0	8	floor_setup
op	30:27	0:0	8	->
water	30:29	0:0	8	data
op	30:33	0:0	8	.
water	30:34	0:0	8	t1
op	30:36	0:0	8	.
water	30:37	0:0	8	partition_class
op	30:52	0:0	8	[
water	30:53	0:0	8	j
op	30:54	0:0	8	]
op	30:56	0:0	8	=
call	30:58	30:72	8	get_bits
arg	30:67	30:69	9	gb
water	30:67	0:0	10	gb
arg	30:71	30:72	9	4
water	30:71	0:0	10	4
water	30:73	0:0	8	;
if	31:16	32:75	8	(floor_setup -> data . t1 . partition_class [ j ] > maximum_class)
cond	31:20	31:62	9	floor_setup -> data . t1 . partition_class [ j ] > maximum_class
water	31:20	0:0	10	floor_setup
op	31:31	0:0	10	->
water	31:33	0:0	10	data
op	31:37	0:0	10	.
water	31:38	0:0	10	t1
op	31:40	0:0	10	.
water	31:41	0:0	10	partition_class
op	31:56	0:0	10	[
water	31:57	0:0	10	j
op	31:58	0:0	10	]
op	31:60	0:0	10	>
water	31:62	0:0	10	maximum_class
stmts	32:20	32:75	9	
water	32:20	0:0	10	maximum_class
op	32:34	0:0	10	=
water	32:36	0:0	10	floor_setup
op	32:47	0:0	10	->
water	32:49	0:0	10	data
op	32:53	0:0	10	.
water	32:54	0:0	10	t1
op	32:56	0:0	10	.
water	32:57	0:0	10	partition_class
op	32:72	0:0	10	[
water	32:73	0:0	10	j
op	32:74	0:0	10	]
water	32:75	0:0	10	;
call	34:16	35:69	8	av_dlog
arg	34:24	34:28	9	NULL
water	34:24	0:0	10	NULL
arg	34:30	34:67	9	" %d. floor %d partition class %d \n"
water	34:30	0:0	10	" %d. floor %d partition class %d \n"
arg	35:24	35:25	9	i
water	35:24	0:0	10	i
arg	35:27	35:28	9	j
water	35:27	0:0	10	j
arg	35:30	35:69	9	floor_setup->data.t1.partition_class[j]
water	35:30	0:0	10	floor_setup
op	35:41	0:0	10	->
water	35:43	0:0	10	data
op	35:47	0:0	10	.
water	35:48	0:0	10	t1
op	35:50	0:0	10	.
water	35:51	0:0	10	partition_class
op	35:66	0:0	10	[
water	35:67	0:0	10	j
op	35:68	0:0	10	]
water	35:70	0:0	8	;
water	37:12	0:0	8	}
call	39:12	39:63	6	av_dlog
arg	39:20	39:24	7	NULL
water	39:20	0:0	8	NULL
arg	39:26	39:48	7	" maximum class %d \n"
water	39:26	0:0	8	" maximum class %d \n"
arg	39:50	39:63	7	maximum_class
water	39:50	0:0	8	maximum_class
water	39:64	0:0	6	;
for	41:12	63:12	6	(j = 0 ;j <= maximum_class;++ j)
forinit	41:17	41:22	7	j = 0 ;
water	41:17	0:0	8	j
op	41:19	0:0	8	=
water	41:21	0:0	8	0
water	41:22	0:0	8	;
cond	41:24	41:29	7	j <= maximum_class
water	41:24	0:0	8	j
op	41:26	0:0	8	<=
water	41:29	0:0	8	maximum_class
forexpr	41:44	41:46	7	++ j
op	41:44	0:0	8	++
water	41:46	0:0	8	j
stmts	41:49	63:12	7	
water	41:49	0:0	8	{
water	42:16	0:0	8	floor_setup
op	42:27	0:0	8	->
water	42:29	0:0	8	data
op	42:33	0:0	8	.
water	42:34	0:0	8	t1
op	42:36	0:0	8	.
water	42:37	0:0	8	class_dimensions
op	42:53	0:0	8	[
water	42:54	0:0	8	j
op	42:55	0:0	8	]
op	42:57	0:0	8	=
call	42:59	42:73	8	get_bits
arg	42:68	42:70	9	gb
water	42:68	0:0	10	gb
arg	42:72	42:73	9	3
water	42:72	0:0	10	3
op	42:75	0:0	8	+
water	42:77	0:0	8	1
water	42:78	0:0	8	;
water	43:16	0:0	8	floor_setup
op	43:27	0:0	8	->
water	43:29	0:0	8	data
op	43:33	0:0	8	.
water	43:34	0:0	8	t1
op	43:36	0:0	8	.
water	43:37	0:0	8	class_subclasses
op	43:53	0:0	8	[
water	43:54	0:0	8	j
op	43:55	0:0	8	]
op	43:57	0:0	8	=
call	43:59	43:73	8	get_bits
arg	43:68	43:70	9	gb
water	43:68	0:0	10	gb
arg	43:72	43:73	9	2
water	43:72	0:0	10	2
water	43:74	0:0	8	;
call	45:16	47:64	8	av_dlog
arg	45:24	45:28	9	NULL
water	45:24	0:0	10	NULL
arg	45:30	45:75	9	" %d floor %d class dim: %d subclasses %d \n"
water	45:30	0:0	10	" %d floor %d class dim: %d subclasses %d \n"
arg	45:77	45:78	9	i
water	45:77	0:0	10	i
arg	45:80	45:81	9	j
water	45:80	0:0	10	j
arg	46:24	46:64	9	floor_setup->data.t1.class_dimensions[j]
water	46:24	0:0	10	floor_setup
op	46:35	0:0	10	->
water	46:37	0:0	10	data
op	46:41	0:0	10	.
water	46:42	0:0	10	t1
op	46:44	0:0	10	.
water	46:45	0:0	10	class_dimensions
op	46:61	0:0	10	[
water	46:62	0:0	10	j
op	46:63	0:0	10	]
arg	47:24	47:64	9	floor_setup->data.t1.class_subclasses[j]
water	47:24	0:0	10	floor_setup
op	47:35	0:0	10	->
water	47:37	0:0	10	data
op	47:41	0:0	10	.
water	47:42	0:0	10	t1
op	47:44	0:0	10	.
water	47:45	0:0	10	class_subclasses
op	47:61	0:0	10	[
water	47:62	0:0	10	j
op	47:63	0:0	10	]
water	47:65	0:0	8	;
if	49:16	53:16	8	(floor_setup -> data . t1 . class_subclasses [ j ])
cond	49:20	49:59	9	floor_setup -> data . t1 . class_subclasses [ j ]
water	49:20	0:0	10	floor_setup
op	49:31	0:0	10	->
water	49:33	0:0	10	data
op	49:37	0:0	10	.
water	49:38	0:0	10	t1
op	49:40	0:0	10	.
water	49:41	0:0	10	class_subclasses
op	49:57	0:0	10	[
water	49:58	0:0	10	j
op	49:59	0:0	10	]
stmts	49:62	53:16	9	
water	49:62	0:0	10	{
call	50:20	50:103	10	GET_VALIDATED_INDEX
arg	50:40	50:80	11	floor_setup->data.t1.class_masterbook[j]
water	50:40	0:0	12	floor_setup
op	50:51	0:0	12	->
water	50:53	0:0	12	data
op	50:57	0:0	12	.
water	50:58	0:0	12	t1
op	50:60	0:0	12	.
water	50:61	0:0	12	class_masterbook
op	50:77	0:0	12	[
water	50:78	0:0	12	j
op	50:79	0:0	12	]
arg	50:82	50:83	11	8
water	50:82	0:0	12	8
arg	50:85	50:103	11	vc->codebook_count
water	50:85	0:0	12	vc
op	50:87	0:0	12	->
water	50:89	0:0	12	codebook_count
call	52:20	52:98	10	av_dlog
arg	52:28	52:32	11	NULL
water	52:28	0:0	12	NULL
arg	52:34	52:56	11	"   masterbook: %d \n"
water	52:34	0:0	12	"   masterbook: %d \n"
arg	52:58	52:98	11	floor_setup->data.t1.class_masterbook[j]
water	52:58	0:0	12	floor_setup
op	52:69	0:0	12	->
water	52:71	0:0	12	data
op	52:75	0:0	12	.
water	52:76	0:0	12	t1
op	52:78	0:0	12	.
water	52:79	0:0	12	class_masterbook
op	52:95	0:0	12	[
water	52:96	0:0	12	j
op	52:97	0:0	12	]
water	52:99	0:0	10	;
water	53:16	0:0	10	}
for	55:16	62:16	8	(k = 0 ;k < ( 1 << floor_setup -> data . t1 . class_subclasses [ j ] );++ k)
forinit	55:21	55:26	9	k = 0 ;
water	55:21	0:0	10	k
op	55:23	0:0	10	=
water	55:25	0:0	10	0
water	55:26	0:0	10	;
cond	55:28	55:78	9	k < ( 1 << floor_setup -> data . t1 . class_subclasses [ j ] )
water	55:28	0:0	10	k
op	55:30	0:0	10	<
water	55:32	0:0	10	(
water	55:33	0:0	10	1
op	55:35	0:0	10	<<
water	55:38	0:0	10	floor_setup
op	55:49	0:0	10	->
water	55:51	0:0	10	data
op	55:55	0:0	10	.
water	55:56	0:0	10	t1
op	55:58	0:0	10	.
water	55:59	0:0	10	class_subclasses
op	55:75	0:0	10	[
water	55:76	0:0	10	j
op	55:77	0:0	10	]
water	55:78	0:0	10	)
forexpr	55:81	55:83	9	++ k
op	55:81	0:0	10	++
water	55:83	0:0	10	k
stmts	55:86	62:16	9	
water	55:86	0:0	10	{
decl	56:20	56:54	10	int16_t	bits
op	56:33	0:0	10	=
call	56:35	56:49	11	get_bits
arg	56:44	56:46	12	gb
water	56:44	0:0	13	gb
arg	56:48	56:49	12	8
water	56:48	0:0	13	8
op	56:51	0:0	10	-
water	56:53	0:0	10	1
if	57:20	59:68	10	(bits != - 1)
cond	57:24	57:33	11	bits != - 1
water	57:24	0:0	12	bits
op	57:29	0:0	12	!=
op	57:32	0:0	12	-
water	57:33	0:0	12	1
stmts	58:24	59:68	11	
call	58:24	58:63	12	VALIDATE_INDEX
arg	58:39	58:43	13	bits
water	58:39	0:0	14	bits
arg	58:45	58:63	13	vc->codebook_count
water	58:45	0:0	14	vc
op	58:47	0:0	14	->
water	58:49	0:0	14	codebook_count
water	59:20	0:0	12	floor_setup
op	59:31	0:0	12	->
water	59:33	0:0	12	data
op	59:37	0:0	12	.
water	59:38	0:0	12	t1
op	59:40	0:0	12	.
water	59:41	0:0	12	subclass_books
op	59:55	0:0	12	[
water	59:56	0:0	12	j
op	59:57	0:0	12	]
op	59:58	0:0	12	[
water	59:59	0:0	12	k
op	59:60	0:0	12	]
op	59:62	0:0	12	=
water	59:64	0:0	12	bits
water	59:68	0:0	12	;
call	61:20	61:102	10	av_dlog
arg	61:28	61:32	11	NULL
water	61:28	0:0	12	NULL
arg	61:34	61:56	11	"    book %d. : %d \n"
water	61:34	0:0	12	"    book %d. : %d \n"
arg	61:58	61:59	11	k
water	61:58	0:0	12	k
arg	61:61	61:102	11	floor_setup->data.t1.subclass_books[j][k]
water	61:61	0:0	12	floor_setup
op	61:72	0:0	12	->
water	61:74	0:0	12	data
op	61:78	0:0	12	.
water	61:79	0:0	12	t1
op	61:81	0:0	12	.
water	61:82	0:0	12	subclass_books
op	61:96	0:0	12	[
water	61:97	0:0	12	j
op	61:98	0:0	12	]
op	61:99	0:0	12	[
water	61:100	0:0	12	k
op	61:101	0:0	12	]
water	61:103	0:0	10	;
water	62:16	0:0	10	}
water	63:12	0:0	8	}
water	65:12	0:0	6	floor_setup
op	65:23	0:0	6	->
water	65:25	0:0	6	data
op	65:29	0:0	6	.
water	65:30	0:0	6	t1
op	65:32	0:0	6	.
water	65:33	0:0	6	multiplier
op	65:44	0:0	6	=
call	65:46	65:60	6	get_bits
arg	65:55	65:57	7	gb
water	65:55	0:0	8	gb
arg	65:59	65:60	7	2
water	65:59	0:0	8	2
op	65:62	0:0	6	+
water	65:64	0:0	6	1
water	65:65	0:0	6	;
water	66:12	0:0	6	floor_setup
op	66:23	0:0	6	->
water	66:25	0:0	6	data
op	66:29	0:0	6	.
water	66:30	0:0	6	t1
op	66:32	0:0	6	.
water	66:33	0:0	6	x_list_dim
op	66:44	0:0	6	=
water	66:46	0:0	6	2
water	66:47	0:0	6	;
for	68:12	69:127	6	(j = 0 ;j < floor_setup -> data . t1 . partitions;++ j)
forinit	68:17	68:22	7	j = 0 ;
water	68:17	0:0	8	j
op	68:19	0:0	8	=
water	68:21	0:0	8	0
water	68:22	0:0	8	;
cond	68:24	68:49	7	j < floor_setup -> data . t1 . partitions
water	68:24	0:0	8	j
op	68:26	0:0	8	<
water	68:28	0:0	8	floor_setup
op	68:39	0:0	8	->
water	68:41	0:0	8	data
op	68:45	0:0	8	.
water	68:46	0:0	8	t1
op	68:48	0:0	8	.
water	68:49	0:0	8	partitions
forexpr	68:61	68:63	7	++ j
op	68:61	0:0	8	++
water	68:63	0:0	8	j
stmts	69:16	69:127	7	
water	69:16	0:0	8	floor_setup
op	69:27	0:0	8	->
water	69:29	0:0	8	data
op	69:33	0:0	8	.
water	69:34	0:0	8	t1
op	69:36	0:0	8	.
water	69:37	0:0	8	x_list_dim
op	69:47	0:0	8	+=
water	69:49	0:0	8	floor_setup
op	69:60	0:0	8	->
water	69:62	0:0	8	data
op	69:66	0:0	8	.
water	69:67	0:0	8	t1
op	69:69	0:0	8	.
water	69:70	0:0	8	class_dimensions
op	69:86	0:0	8	[
water	69:87	0:0	8	floor_setup
op	69:98	0:0	8	->
water	69:100	0:0	8	data
op	69:104	0:0	8	.
water	69:105	0:0	8	t1
op	69:107	0:0	8	.
water	69:108	0:0	8	partition_class
op	69:123	0:0	8	[
water	69:124	0:0	8	j
op	69:125	0:0	8	]
op	69:126	0:0	8	]
water	69:127	0:0	8	;
water	71:12	0:0	6	floor_setup
op	71:23	0:0	6	->
water	71:25	0:0	6	data
op	71:29	0:0	6	.
water	71:30	0:0	6	t1
op	71:32	0:0	6	.
water	71:33	0:0	6	list
op	71:38	0:0	6	=
call	71:40	72:85	6	av_mallocz
arg	71:51	72:85	7	floor_setup->data.t1.x_list_dim*sizeof(*floor_setup->data.t1.list)
water	71:51	0:0	8	floor_setup
op	71:62	0:0	8	->
water	71:64	0:0	8	data
op	71:68	0:0	8	.
water	71:69	0:0	8	t1
op	71:71	0:0	8	.
water	71:72	0:0	8	x_list_dim
op	71:83	0:0	8	*
op	72:51	0:0	8	sizeof
water	72:57	0:0	8	(
op	72:58	0:0	8	*
water	72:59	0:0	8	floor_setup
op	72:70	0:0	8	->
water	72:72	0:0	8	data
op	72:76	0:0	8	.
water	72:77	0:0	8	t1
op	72:79	0:0	8	.
water	72:80	0:0	8	list
water	72:84	0:0	8	)
water	72:86	0:0	6	;
water	75:12	0:0	6	rangebits
op	75:22	0:0	6	=
call	75:24	75:38	6	get_bits
arg	75:33	75:35	7	gb
water	75:33	0:0	8	gb
arg	75:37	75:38	7	4
water	75:37	0:0	8	4
water	75:39	0:0	6	;
water	76:12	0:0	6	rangemax
op	76:21	0:0	6	=
water	76:23	0:0	6	(
water	76:24	0:0	6	1
op	76:26	0:0	6	<<
water	76:29	0:0	6	rangebits
water	76:38	0:0	6	)
water	76:39	0:0	6	;
if	77:12	82:12	6	(rangemax > vc -> blocksize [ 1 ] / 2)
cond	77:16	77:46	7	rangemax > vc -> blocksize [ 1 ] / 2
water	77:16	0:0	8	rangemax
op	77:25	0:0	8	>
water	77:27	0:0	8	vc
op	77:29	0:0	8	->
water	77:31	0:0	8	blocksize
op	77:40	0:0	8	[
water	77:41	0:0	8	1
op	77:42	0:0	8	]
op	77:44	0:0	8	/
water	77:46	0:0	8	2
stmts	77:49	82:12	7	
water	77:49	0:0	8	{
call	78:16	80:53	8	av_log
arg	78:23	78:37	9	vc->avccontext
water	78:23	0:0	10	vc
op	78:25	0:0	10	->
water	78:27	0:0	10	avccontext
arg	78:39	78:51	9	AV_LOG_ERROR
water	78:39	0:0	10	AV_LOG_ERROR
arg	79:23	79:81	9	"Floor value is too large for blocksize: %u (%"PRIu32")\n"
water	79:23	0:0	10	"Floor value is too large for blocksize: %u (%"
water	79:70	0:0	10	PRIu32
water	79:76	0:0	10	")\n"
arg	80:23	80:31	9	rangemax
water	80:23	0:0	10	rangemax
arg	80:33	80:53	9	vc->blocksize[1]/2
water	80:33	0:0	10	vc
op	80:35	0:0	10	->
water	80:37	0:0	10	blocksize
op	80:46	0:0	10	[
water	80:47	0:0	10	1
op	80:48	0:0	10	]
op	80:50	0:0	10	/
water	80:52	0:0	10	2
water	80:54	0:0	8	;
return	81:16	81:42	8	AVERROR_INVALIDDATA
water	81:23	0:0	9	AVERROR_INVALIDDATA
water	82:12	0:0	8	}
water	83:12	0:0	6	floor_setup
op	83:23	0:0	6	->
water	83:25	0:0	6	data
op	83:29	0:0	6	.
water	83:30	0:0	6	t1
op	83:32	0:0	6	.
water	83:33	0:0	6	list
op	83:37	0:0	6	[
water	83:38	0:0	6	0
op	83:39	0:0	6	]
op	83:40	0:0	6	.
water	83:41	0:0	6	x
op	83:43	0:0	6	=
water	83:45	0:0	6	0
water	83:46	0:0	6	;
water	84:12	0:0	6	floor_setup
op	84:23	0:0	6	->
water	84:25	0:0	6	data
op	84:29	0:0	6	.
water	84:30	0:0	6	t1
op	84:32	0:0	6	.
water	84:33	0:0	6	list
op	84:37	0:0	6	[
water	84:38	0:0	6	1
op	84:39	0:0	6	]
op	84:40	0:0	6	.
water	84:41	0:0	6	x
op	84:43	0:0	6	=
water	84:45	0:0	6	rangemax
water	84:53	0:0	6	;
for	86:12	93:12	6	(j = 0 ;j < floor_setup -> data . t1 . partitions;++ j)
forinit	86:17	86:22	7	j = 0 ;
water	86:17	0:0	8	j
op	86:19	0:0	8	=
water	86:21	0:0	8	0
water	86:22	0:0	8	;
cond	86:24	86:49	7	j < floor_setup -> data . t1 . partitions
water	86:24	0:0	8	j
op	86:26	0:0	8	<
water	86:28	0:0	8	floor_setup
op	86:39	0:0	8	->
water	86:41	0:0	8	data
op	86:45	0:0	8	.
water	86:46	0:0	8	t1
op	86:48	0:0	8	.
water	86:49	0:0	8	partitions
forexpr	86:61	86:63	7	++ j
op	86:61	0:0	8	++
water	86:63	0:0	8	j
stmts	86:66	93:12	7	
water	86:66	0:0	8	{
for	87:16	92:16	8	(k = 0 ;k < floor_setup -> data . t1 . class_dimensions [ floor_setup -> data . t1 . partition_class [ j ] ];++ k , ++ floor1_values)
forinit	87:21	87:26	9	k = 0 ;
water	87:21	0:0	10	k
op	87:23	0:0	10	=
water	87:25	0:0	10	0
water	87:26	0:0	10	;
cond	87:28	87:109	9	k < floor_setup -> data . t1 . class_dimensions [ floor_setup -> data . t1 . partition_class [ j ] ]
water	87:28	0:0	10	k
op	87:30	0:0	10	<
water	87:32	0:0	10	floor_setup
op	87:43	0:0	10	->
water	87:45	0:0	10	data
op	87:49	0:0	10	.
water	87:50	0:0	10	t1
op	87:52	0:0	10	.
water	87:53	0:0	10	class_dimensions
op	87:69	0:0	10	[
water	87:70	0:0	10	floor_setup
op	87:81	0:0	10	->
water	87:83	0:0	10	data
op	87:87	0:0	10	.
water	87:88	0:0	10	t1
op	87:90	0:0	10	.
water	87:91	0:0	10	partition_class
op	87:106	0:0	10	[
water	87:107	0:0	10	j
op	87:108	0:0	10	]
op	87:109	0:0	10	]
forexpr	87:112	87:119	9	++ k , ++ floor1_values
op	87:112	0:0	10	++
water	87:114	0:0	10	k
water	87:115	0:0	10	,
op	87:117	0:0	10	++
water	87:119	0:0	10	floor1_values
stmts	87:134	92:16	9	
water	87:134	0:0	10	{
water	88:20	0:0	10	floor_setup
op	88:31	0:0	10	->
water	88:33	0:0	10	data
op	88:37	0:0	10	.
water	88:38	0:0	10	t1
op	88:40	0:0	10	.
water	88:41	0:0	10	list
op	88:45	0:0	10	[
water	88:46	0:0	10	floor1_values
op	88:59	0:0	10	]
op	88:60	0:0	10	.
water	88:61	0:0	10	x
op	88:63	0:0	10	=
call	88:65	88:87	10	get_bits
arg	88:74	88:76	11	gb
water	88:74	0:0	12	gb
arg	88:78	88:87	11	rangebits
water	88:78	0:0	12	rangebits
water	88:88	0:0	10	;
call	90:20	91:70	10	av_dlog
arg	90:28	90:32	11	NULL
water	90:28	0:0	12	NULL
arg	90:34	90:61	11	" %u. floor1 Y coord. %d\n"
water	90:34	0:0	12	" %u. floor1 Y coord. %d\n"
arg	90:63	90:76	11	floor1_values
water	90:63	0:0	12	floor1_values
arg	91:28	91:70	11	floor_setup->data.t1.list[floor1_values].x
water	91:28	0:0	12	floor_setup
op	91:39	0:0	12	->
water	91:41	0:0	12	data
op	91:45	0:0	12	.
water	91:46	0:0	12	t1
op	91:48	0:0	12	.
water	91:49	0:0	12	list
op	91:53	0:0	12	[
water	91:54	0:0	12	floor1_values
op	91:67	0:0	12	]
op	91:68	0:0	12	.
water	91:69	0:0	12	x
water	91:71	0:0	10	;
water	92:16	0:0	10	}
water	93:12	0:0	8	}
if	96:12	100:12	6	(ff_vorbis_ready_floor1_list (vc -> avccontext ,floor_setup -> data . t1 . list ,floor_setup -> data . t1 . x_list_dim ))
cond	96:16	98:75	7	ff_vorbis_ready_floor1_list (vc -> avccontext ,floor_setup -> data . t1 . list ,floor_setup -> data . t1 . x_list_dim )
call	96:16	98:75	8	ff_vorbis_ready_floor1_list
arg	96:44	96:58	9	vc->avccontext
water	96:44	0:0	10	vc
op	96:46	0:0	10	->
water	96:48	0:0	10	avccontext
arg	97:44	97:69	9	floor_setup->data.t1.list
water	97:44	0:0	10	floor_setup
op	97:55	0:0	10	->
water	97:57	0:0	10	data
op	97:61	0:0	10	.
water	97:62	0:0	10	t1
op	97:64	0:0	10	.
water	97:65	0:0	10	list
arg	98:44	98:75	9	floor_setup->data.t1.x_list_dim
water	98:44	0:0	10	floor_setup
op	98:55	0:0	10	->
water	98:57	0:0	10	data
op	98:61	0:0	10	.
water	98:62	0:0	10	t1
op	98:64	0:0	10	.
water	98:65	0:0	10	x_list_dim
stmts	98:78	100:12	7	
water	98:78	0:0	8	{
return	99:16	99:42	8	AVERROR_INVALIDDATA
water	99:23	0:0	9	AVERROR_INVALIDDATA
water	100:12	0:0	8	}
water	101:8	0:0	6	}
else	101:10	167:8	4
stmts	101:15	167:8	5	
if	101:15	167:8	6	(floor_setup -> floor_type == 0)
cond	101:19	101:46	7	floor_setup -> floor_type == 0
water	101:19	0:0	8	floor_setup
op	101:30	0:0	8	->
water	101:32	0:0	8	floor_type
op	101:43	0:0	8	==
water	101:46	0:0	8	0
stmts	101:49	167:8	7	
water	101:49	0:0	8	{
water	102:12	0:0	8	unsigned
water	102:21	0:0	8	max_codebook_dim
op	102:38	0:0	8	=
water	102:40	0:0	8	0
water	102:41	0:0	8	;
water	104:12	0:0	8	floor_setup
op	104:23	0:0	8	->
water	104:25	0:0	8	decode
op	104:32	0:0	8	=
water	104:34	0:0	8	vorbis_floor0_decode
water	104:54	0:0	8	;
water	106:12	0:0	8	floor_setup
op	106:23	0:0	8	->
water	106:25	0:0	8	data
op	106:29	0:0	8	.
water	106:30	0:0	8	t0
op	106:32	0:0	8	.
water	106:33	0:0	8	order
op	106:48	0:0	8	=
call	106:50	106:65	8	get_bits
arg	106:59	106:61	9	gb
water	106:59	0:0	10	gb
arg	106:64	106:65	9	8
water	106:64	0:0	10	8
water	106:66	0:0	8	;
water	107:12	0:0	8	floor_setup
op	107:23	0:0	8	->
water	107:25	0:0	8	data
op	107:29	0:0	8	.
water	107:30	0:0	8	t0
op	107:32	0:0	8	.
water	107:33	0:0	8	rate
op	107:48	0:0	8	=
call	107:50	107:65	8	get_bits
arg	107:59	107:61	9	gb
water	107:59	0:0	10	gb
arg	107:63	107:65	9	16
water	107:63	0:0	10	16
water	107:66	0:0	8	;
water	108:12	0:0	8	floor_setup
op	108:23	0:0	8	->
water	108:25	0:0	8	data
op	108:29	0:0	8	.
water	108:30	0:0	8	t0
op	108:32	0:0	8	.
water	108:33	0:0	8	bark_map_size
op	108:48	0:0	8	=
call	108:50	108:65	8	get_bits
arg	108:59	108:61	9	gb
water	108:59	0:0	10	gb
arg	108:63	108:65	9	16
water	108:63	0:0	10	16
water	108:66	0:0	8	;
water	109:12	0:0	8	floor_setup
op	109:23	0:0	8	->
water	109:25	0:0	8	data
op	109:29	0:0	8	.
water	109:30	0:0	8	t0
op	109:32	0:0	8	.
water	109:33	0:0	8	amplitude_bits
op	109:48	0:0	8	=
call	109:50	109:65	8	get_bits
arg	109:59	109:61	9	gb
water	109:59	0:0	10	gb
arg	109:64	109:65	9	6
water	109:64	0:0	10	6
water	109:66	0:0	8	;
if	112:12	116:12	8	(floor_setup -> data . t0 . amplitude_bits == 0)
cond	112:16	112:55	9	floor_setup -> data . t0 . amplitude_bits == 0
water	112:16	0:0	10	floor_setup
op	112:27	0:0	10	->
water	112:29	0:0	10	data
op	112:33	0:0	10	.
water	112:34	0:0	10	t0
op	112:36	0:0	10	.
water	112:37	0:0	10	amplitude_bits
op	112:52	0:0	10	==
water	112:55	0:0	10	0
stmts	112:58	116:12	9	
water	112:58	0:0	10	{
call	113:16	114:55	10	av_log
arg	113:23	113:37	11	vc->avccontext
water	113:23	0:0	12	vc
op	113:25	0:0	12	->
water	113:27	0:0	12	avccontext
arg	113:39	113:51	11	AV_LOG_ERROR
water	113:39	0:0	12	AV_LOG_ERROR
arg	114:23	114:55	11	"Floor 0 amplitude bits is 0.\n"
water	114:23	0:0	12	"Floor 0 amplitude bits is 0.\n"
water	114:56	0:0	10	;
return	115:16	115:42	10	AVERROR_INVALIDDATA
water	115:23	0:0	11	AVERROR_INVALIDDATA
water	116:12	0:0	10	}
water	117:12	0:0	8	floor_setup
op	117:23	0:0	8	->
water	117:25	0:0	8	data
op	117:29	0:0	8	.
water	117:30	0:0	8	t0
op	117:32	0:0	8	.
water	117:33	0:0	8	amplitude_offset
op	117:50	0:0	8	=
call	117:52	117:66	8	get_bits
arg	117:61	117:63	9	gb
water	117:61	0:0	10	gb
arg	117:65	117:66	9	8
water	117:65	0:0	10	8
water	117:67	0:0	8	;
water	118:12	0:0	8	floor_setup
op	118:23	0:0	8	->
water	118:25	0:0	8	data
op	118:29	0:0	8	.
water	118:30	0:0	8	t0
op	118:32	0:0	8	.
water	118:33	0:0	8	num_books
op	118:50	0:0	8	=
call	118:52	118:66	8	get_bits
arg	118:61	118:63	9	gb
water	118:61	0:0	10	gb
arg	118:65	118:66	9	4
water	118:65	0:0	10	4
op	118:68	0:0	8	+
water	118:70	0:0	8	1
water	118:71	0:0	8	;
water	121:12	0:0	8	floor_setup
op	121:23	0:0	8	->
water	121:25	0:0	8	data
op	121:29	0:0	8	.
water	121:30	0:0	8	t0
op	121:32	0:0	8	.
water	121:33	0:0	8	book_list
op	121:43	0:0	8	=
call	122:16	122:56	8	av_malloc
arg	122:26	122:56	9	floor_setup->data.t0.num_books
water	122:26	0:0	10	floor_setup
op	122:37	0:0	10	->
water	122:39	0:0	10	data
op	122:43	0:0	10	.
water	122:44	0:0	10	t0
op	122:46	0:0	10	.
water	122:47	0:0	10	num_books
water	122:57	0:0	8	;
if	123:12	124:38	8	(! floor_setup -> data . t0 . book_list)
cond	123:16	123:38	9	! floor_setup -> data . t0 . book_list
op	123:16	0:0	10	!
water	123:17	0:0	10	floor_setup
op	123:28	0:0	10	->
water	123:30	0:0	10	data
op	123:34	0:0	10	.
water	123:35	0:0	10	t0
op	123:37	0:0	10	.
water	123:38	0:0	10	book_list
stmts	124:16	124:38	9	
return	124:16	124:38	10	AVERROR(ENOMEM)
call	124:23	124:37	11	AVERROR
arg	124:31	124:37	12	ENOMEM
water	124:31	0:0	13	ENOMEM
water	126:12	0:0	8	{
decl	127:16	127:23	8	int	idx
water	128:16	0:0	8	unsigned
water	128:25	0:0	8	book_idx
water	128:33	0:0	8	;
for	129:16	134:16	8	(idx = 0 ;idx < floor_setup -> data . t0 . num_books;++ idx)
forinit	129:21	129:28	9	idx = 0 ;
water	129:21	0:0	10	idx
op	129:25	0:0	10	=
water	129:27	0:0	10	0
water	129:28	0:0	10	;
cond	129:30	129:57	9	idx < floor_setup -> data . t0 . num_books
water	129:30	0:0	10	idx
op	129:34	0:0	10	<
water	129:36	0:0	10	floor_setup
op	129:47	0:0	10	->
water	129:49	0:0	10	data
op	129:53	0:0	10	.
water	129:54	0:0	10	t0
op	129:56	0:0	10	.
water	129:57	0:0	10	num_books
forexpr	129:68	129:70	9	++ idx
op	129:68	0:0	10	++
water	129:70	0:0	10	idx
stmts	129:75	134:16	9	
water	129:75	0:0	10	{
call	130:20	130:71	10	GET_VALIDATED_INDEX
arg	130:40	130:48	11	book_idx
water	130:40	0:0	12	book_idx
arg	130:50	130:51	11	8
water	130:50	0:0	12	8
arg	130:53	130:71	11	vc->codebook_count
water	130:53	0:0	12	vc
op	130:55	0:0	12	->
water	130:57	0:0	12	codebook_count
water	131:20	0:0	10	floor_setup
op	131:31	0:0	10	->
water	131:33	0:0	10	data
op	131:37	0:0	10	.
water	131:38	0:0	10	t0
op	131:40	0:0	10	.
water	131:41	0:0	10	book_list
op	131:50	0:0	10	[
water	131:51	0:0	10	idx
op	131:54	0:0	10	]
op	131:56	0:0	10	=
water	131:58	0:0	10	book_idx
water	131:66	0:0	10	;
if	132:20	133:77	10	(vc -> codebooks [ book_idx ] . dimensions > max_codebook_dim)
cond	132:24	132:61	11	vc -> codebooks [ book_idx ] . dimensions > max_codebook_dim
water	132:24	0:0	12	vc
op	132:26	0:0	12	->
water	132:28	0:0	12	codebooks
op	132:37	0:0	12	[
water	132:38	0:0	12	book_idx
op	132:46	0:0	12	]
op	132:47	0:0	12	.
water	132:48	0:0	12	dimensions
op	132:59	0:0	12	>
water	132:61	0:0	12	max_codebook_dim
stmts	133:24	133:77	11	
water	133:24	0:0	12	max_codebook_dim
op	133:41	0:0	12	=
water	133:43	0:0	12	vc
op	133:45	0:0	12	->
water	133:47	0:0	12	codebooks
op	133:56	0:0	12	[
water	133:57	0:0	12	book_idx
op	133:65	0:0	12	]
op	133:66	0:0	12	.
water	133:67	0:0	12	dimensions
water	133:77	0:0	12	;
water	134:16	0:0	10	}
water	135:12	0:0	8	}
call	137:12	137:28	8	create_map
arg	137:23	137:25	9	vc
water	137:23	0:0	10	vc
arg	137:27	137:28	9	i
water	137:27	0:0	10	i
water	137:29	0:0	8	;
water	141:12	0:0	8	floor_setup
op	141:23	0:0	8	->
water	141:25	0:0	8	data
op	141:29	0:0	8	.
water	141:30	0:0	8	t0
op	141:32	0:0	8	.
water	141:33	0:0	8	lsp
op	141:37	0:0	8	=
call	142:16	143:61	8	av_malloc
arg	142:26	143:61	9	(floor_setup->data.t0.order+1+max_codebook_dim)*sizeof(*floor_setup->data.t0.lsp)
water	142:26	0:0	10	(
water	142:27	0:0	10	floor_setup
op	142:38	0:0	10	->
water	142:40	0:0	10	data
op	142:44	0:0	10	.
water	142:45	0:0	10	t0
op	142:47	0:0	10	.
water	142:48	0:0	10	order
op	142:54	0:0	10	+
water	142:56	0:0	10	1
op	142:58	0:0	10	+
water	142:60	0:0	10	max_codebook_dim
water	142:76	0:0	10	)
op	143:26	0:0	10	*
op	143:28	0:0	10	sizeof
water	143:34	0:0	10	(
op	143:35	0:0	10	*
water	143:36	0:0	10	floor_setup
op	143:47	0:0	10	->
water	143:49	0:0	10	data
op	143:53	0:0	10	.
water	143:54	0:0	10	t0
op	143:56	0:0	10	.
water	143:57	0:0	10	lsp
water	143:60	0:0	10	)
water	143:62	0:0	8	;
if	144:12	145:38	8	(! floor_setup -> data . t0 . lsp)
cond	144:16	144:38	9	! floor_setup -> data . t0 . lsp
op	144:16	0:0	10	!
water	144:17	0:0	10	floor_setup
op	144:28	0:0	10	->
water	144:30	0:0	10	data
op	144:34	0:0	10	.
water	144:35	0:0	10	t0
op	144:37	0:0	10	.
water	144:38	0:0	10	lsp
stmts	145:16	145:38	9	
return	145:16	145:38	10	AVERROR(ENOMEM)
call	145:23	145:37	11	AVERROR
arg	145:31	145:37	12	ENOMEM
water	145:31	0:0	13	ENOMEM
call	148:12	148:74	8	av_dlog
arg	148:20	148:24	9	NULL
water	148:20	0:0	10	NULL
arg	148:26	148:46	9	"floor0 order: %u\n"
water	148:26	0:0	10	"floor0 order: %u\n"
arg	148:48	148:74	9	floor_setup->data.t0.order
water	148:48	0:0	10	floor_setup
op	148:59	0:0	10	->
water	148:61	0:0	10	data
op	148:65	0:0	10	.
water	148:66	0:0	10	t0
op	148:68	0:0	10	.
water	148:69	0:0	10	order
water	148:75	0:0	8	;
call	149:12	149:72	8	av_dlog
arg	149:20	149:24	9	NULL
water	149:20	0:0	10	NULL
arg	149:26	149:45	9	"floor0 rate: %u\n"
water	149:26	0:0	10	"floor0 rate: %u\n"
arg	149:47	149:72	9	floor_setup->data.t0.rate
water	149:47	0:0	10	floor_setup
op	149:58	0:0	10	->
water	149:60	0:0	10	data
op	149:64	0:0	10	.
water	149:65	0:0	10	t0
op	149:67	0:0	10	.
water	149:68	0:0	10	rate
water	149:73	0:0	8	;
call	150:12	151:54	8	av_dlog
arg	150:20	150:24	9	NULL
water	150:20	0:0	10	NULL
arg	150:26	150:54	9	"floor0 bark map size: %u\n"
water	150:26	0:0	10	"floor0 bark map size: %u\n"
arg	151:20	151:54	9	floor_setup->data.t0.bark_map_size
water	151:20	0:0	10	floor_setup
op	151:31	0:0	10	->
water	151:33	0:0	10	data
op	151:37	0:0	10	.
water	151:38	0:0	10	t0
op	151:40	0:0	10	.
water	151:41	0:0	10	bark_map_size
water	151:55	0:0	8	;
call	152:12	153:55	8	av_dlog
arg	152:20	152:24	9	NULL
water	152:20	0:0	10	NULL
arg	152:26	152:55	9	"floor0 amplitude bits: %u\n"
water	152:26	0:0	10	"floor0 amplitude bits: %u\n"
arg	153:20	153:55	9	floor_setup->data.t0.amplitude_bits
water	153:20	0:0	10	floor_setup
op	153:31	0:0	10	->
water	153:33	0:0	10	data
op	153:37	0:0	10	.
water	153:38	0:0	10	t0
op	153:40	0:0	10	.
water	153:41	0:0	10	amplitude_bits
water	153:56	0:0	8	;
call	154:12	155:57	8	av_dlog
arg	154:20	154:24	9	NULL
water	154:20	0:0	10	NULL
arg	154:26	154:57	9	"floor0 amplitude offset: %u\n"
water	154:26	0:0	10	"floor0 amplitude offset: %u\n"
arg	155:20	155:57	9	floor_setup->data.t0.amplitude_offset
water	155:20	0:0	10	floor_setup
op	155:31	0:0	10	->
water	155:33	0:0	10	data
op	155:37	0:0	10	.
water	155:38	0:0	10	t0
op	155:40	0:0	10	.
water	155:41	0:0	10	amplitude_offset
water	155:58	0:0	8	;
call	156:12	157:50	8	av_dlog
arg	156:20	156:24	9	NULL
water	156:20	0:0	10	NULL
arg	156:26	156:56	9	"floor0 number of books: %u\n"
water	156:26	0:0	10	"floor0 number of books: %u\n"
arg	157:20	157:50	9	floor_setup->data.t0.num_books
water	157:20	0:0	10	floor_setup
op	157:31	0:0	10	->
water	157:33	0:0	10	data
op	157:37	0:0	10	.
water	157:38	0:0	10	t0
op	157:40	0:0	10	.
water	157:41	0:0	10	num_books
water	157:51	0:0	8	;
call	158:12	159:50	8	av_dlog
arg	158:20	158:24	9	NULL
water	158:20	0:0	10	NULL
arg	158:26	158:58	9	"floor0 book list pointer: %p\n"
water	158:26	0:0	10	"floor0 book list pointer: %p\n"
arg	159:20	159:50	9	floor_setup->data.t0.book_list
water	159:20	0:0	10	floor_setup
op	159:31	0:0	10	->
water	159:33	0:0	10	data
op	159:37	0:0	10	.
water	159:38	0:0	10	t0
op	159:40	0:0	10	.
water	159:41	0:0	10	book_list
water	159:51	0:0	8	;
water	160:12	0:0	8	{
decl	161:16	161:23	8	int	idx
for	162:16	165:16	8	(idx = 0 ;idx < floor_setup -> data . t0 . num_books;++ idx)
forinit	162:21	162:28	9	idx = 0 ;
water	162:21	0:0	10	idx
op	162:25	0:0	10	=
water	162:27	0:0	10	0
water	162:28	0:0	10	;
cond	162:30	162:57	9	idx < floor_setup -> data . t0 . num_books
water	162:30	0:0	10	idx
op	162:34	0:0	10	<
water	162:36	0:0	10	floor_setup
op	162:47	0:0	10	->
water	162:49	0:0	10	data
op	162:53	0:0	10	.
water	162:54	0:0	10	t0
op	162:56	0:0	10	.
water	162:57	0:0	10	num_books
forexpr	162:68	162:70	9	++ idx
op	162:68	0:0	10	++
water	162:70	0:0	10	idx
stmts	162:75	165:16	9	
water	162:75	0:0	10	{
call	163:20	164:63	10	av_dlog
arg	163:28	163:32	11	NULL
water	163:28	0:0	12	NULL
arg	163:34	163:51	11	"  Book %d: %u\n"
water	163:34	0:0	12	"  Book %d: %u\n"
arg	163:53	163:60	11	idx+1
water	163:53	0:0	12	idx
op	163:57	0:0	12	+
water	163:59	0:0	12	1
arg	164:28	164:63	11	floor_setup->data.t0.book_list[idx]
water	164:28	0:0	12	floor_setup
op	164:39	0:0	12	->
water	164:41	0:0	12	data
op	164:45	0:0	12	.
water	164:46	0:0	12	t0
op	164:48	0:0	12	.
water	164:49	0:0	12	book_list
op	164:58	0:0	12	[
water	164:59	0:0	12	idx
op	164:62	0:0	12	]
water	164:64	0:0	10	;
water	165:16	0:0	10	}
water	166:12	0:0	8	}
water	167:8	0:0	8	}
else	167:10	170:8	4
stmts	167:15	170:8	5	
water	167:15	0:0	6	{
call	168:12	168:72	6	av_log
arg	168:19	168:33	7	vc->avccontext
water	168:19	0:0	8	vc
op	168:21	0:0	8	->
water	168:23	0:0	8	avccontext
arg	168:35	168:47	7	AV_LOG_ERROR
water	168:35	0:0	8	AV_LOG_ERROR
arg	168:49	168:72	7	"Invalid floor type!\n"
water	168:49	0:0	8	"Invalid floor type!\n"
water	168:73	0:0	6	;
return	169:12	169:38	6	AVERROR_INVALIDDATA
water	169:19	0:0	7	AVERROR_INVALIDDATA
water	170:8	0:0	6	}
water	171:4	0:0	4	}
return	172:4	172:12	2	0
water	172:11	0:0	3	0
