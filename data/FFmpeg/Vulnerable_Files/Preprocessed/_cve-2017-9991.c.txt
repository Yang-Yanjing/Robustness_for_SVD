func	2:0	215:0	0	static int	xwd_decode_frame
params	2:27	0:0	1	
param	2:28	2:49	2	AVCodecContext *	avctx
param	2:51	2:61	2	void *	data
param	3:28	3:42	2	int *	got_frame
param	3:44	3:59	2	AVPacket *	avpkt
stmnts	0:0	214:19	1	
decl	5:4	5:21	2	AVFrame	*p
op	5:15	0:0	2	=
water	5:17	0:0	2	data
decl	6:4	6:36	2	const uint8_t	*buf
op	6:23	0:0	2	=
water	6:25	0:0	2	avpkt
op	6:30	0:0	2	->
water	6:32	0:0	2	data
decl	7:4	7:38	2	int	i
water	7:9	0:0	2	,
decl	7:4	7:38	2	int	ret
water	7:14	0:0	2	,
decl	7:4	7:38	2	int	buf_size
op	7:25	0:0	2	=
water	7:27	0:0	2	avpkt
op	7:32	0:0	2	->
water	7:34	0:0	2	size
decl	8:4	8:50	2	uint32_t	version
water	8:20	0:0	2	,
decl	8:4	8:50	2	uint32_t	header_size
water	8:33	0:0	2	,
decl	8:4	8:50	2	uint32_t	vclass
water	8:41	0:0	2	,
decl	8:4	8:50	2	uint32_t	ncolors
decl	9:4	9:43	2	uint32_t	xoffset
water	9:20	0:0	2	,
decl	9:4	9:43	2	uint32_t	be
water	9:24	0:0	2	,
decl	9:4	9:43	2	uint32_t	bpp
water	9:29	0:0	2	,
decl	9:4	9:43	2	uint32_t	lsize
water	9:36	0:0	2	,
decl	9:4	9:43	2	uint32_t	rsize
decl	10:4	10:55	2	uint32_t	pixformat
water	10:22	0:0	2	,
decl	10:4	10:55	2	uint32_t	pixdepth
water	10:32	0:0	2	,
decl	10:4	10:55	2	uint32_t	bunit
water	10:39	0:0	2	,
decl	10:4	10:55	2	uint32_t	bitorder
water	10:49	0:0	2	,
decl	10:4	10:55	2	uint32_t	bpad
decl	11:4	11:19	2	uint32_t	rgb[3]
decl	12:4	12:16	2	uint8_t	*ptr
decl	13:4	13:21	2	GetByteContext	gb
if	15:4	16:34	2	(buf_size < XWD_HEADER_SIZE)
cond	15:8	15:19	3	buf_size < XWD_HEADER_SIZE
water	15:8	0:0	4	buf_size
op	15:17	0:0	4	<
water	15:19	0:0	4	XWD_HEADER_SIZE
stmts	16:8	16:34	3	
return	16:8	16:34	4	AVERROR_INVALIDDATA
water	16:15	0:0	5	AVERROR_INVALIDDATA
call	18:4	18:39	2	bytestream2_init
arg	18:21	18:24	3	&gb
op	18:21	0:0	4	&
water	18:22	0:0	4	gb
arg	18:26	18:29	3	buf
water	18:26	0:0	4	buf
arg	18:31	18:39	3	buf_size
water	18:31	0:0	4	buf_size
water	18:40	0:0	2	;
water	19:4	0:0	2	header_size
op	19:16	0:0	2	=
call	19:18	19:43	2	bytestream2_get_be32u
arg	19:40	19:43	3	&gb
op	19:40	0:0	4	&
water	19:41	0:0	4	gb
water	19:44	0:0	2	;
water	21:4	0:0	2	version
op	21:12	0:0	2	=
call	21:14	21:39	2	bytestream2_get_be32u
arg	21:36	21:39	3	&gb
op	21:36	0:0	4	&
water	21:37	0:0	4	gb
water	21:40	0:0	2	;
if	22:4	25:4	2	(version != XWD_VERSION)
cond	22:8	22:19	3	version != XWD_VERSION
water	22:8	0:0	4	version
op	22:16	0:0	4	!=
water	22:19	0:0	4	XWD_VERSION
stmts	22:32	25:4	3	
water	22:32	0:0	4	{
call	23:8	23:59	4	av_log
arg	23:15	23:20	5	avctx
water	23:15	0:0	6	avctx
arg	23:22	23:34	5	AV_LOG_ERROR
water	23:22	0:0	6	AV_LOG_ERROR
arg	23:36	23:59	5	"unsupported version\n"
water	23:36	0:0	6	"unsupported version\n"
water	23:60	0:0	4	;
return	24:8	24:34	4	AVERROR_INVALIDDATA
water	24:15	0:0	5	AVERROR_INVALIDDATA
water	25:4	0:0	4	}
if	27:4	30:4	2	(buf_size < header_size || header_size < XWD_HEADER_SIZE)
cond	27:8	27:48	3	buf_size < header_size || header_size < XWD_HEADER_SIZE
water	27:8	0:0	4	buf_size
op	27:17	0:0	4	<
water	27:19	0:0	4	header_size
op	27:31	0:0	4	||
water	27:34	0:0	4	header_size
op	27:46	0:0	4	<
water	27:48	0:0	4	XWD_HEADER_SIZE
stmts	27:65	30:4	3	
water	27:65	0:0	4	{
call	28:8	28:59	4	av_log
arg	28:15	28:20	5	avctx
water	28:15	0:0	6	avctx
arg	28:22	28:34	5	AV_LOG_ERROR
water	28:22	0:0	6	AV_LOG_ERROR
arg	28:36	28:59	5	"invalid header size\n"
water	28:36	0:0	6	"invalid header size\n"
water	28:60	0:0	4	;
return	29:8	29:34	4	AVERROR_INVALIDDATA
water	29:15	0:0	5	AVERROR_INVALIDDATA
water	30:4	0:0	4	}
water	32:4	0:0	2	pixformat
op	32:18	0:0	2	=
call	32:20	32:45	2	bytestream2_get_be32u
arg	32:42	32:45	3	&gb
op	32:42	0:0	4	&
water	32:43	0:0	4	gb
water	32:46	0:0	2	;
water	33:4	0:0	2	pixdepth
op	33:18	0:0	2	=
call	33:20	33:45	2	bytestream2_get_be32u
arg	33:42	33:45	3	&gb
op	33:42	0:0	4	&
water	33:43	0:0	4	gb
water	33:46	0:0	2	;
water	34:4	0:0	2	avctx
op	34:9	0:0	2	->
water	34:11	0:0	2	width
op	34:18	0:0	2	=
call	34:20	34:45	2	bytestream2_get_be32u
arg	34:42	34:45	3	&gb
op	34:42	0:0	4	&
water	34:43	0:0	4	gb
water	34:46	0:0	2	;
water	35:4	0:0	2	avctx
op	35:9	0:0	2	->
water	35:11	0:0	2	height
op	35:18	0:0	2	=
call	35:20	35:45	2	bytestream2_get_be32u
arg	35:42	35:45	3	&gb
op	35:42	0:0	4	&
water	35:43	0:0	4	gb
water	35:46	0:0	2	;
water	36:4	0:0	2	xoffset
op	36:18	0:0	2	=
call	36:20	36:45	2	bytestream2_get_be32u
arg	36:42	36:45	3	&gb
op	36:42	0:0	4	&
water	36:43	0:0	4	gb
water	36:46	0:0	2	;
water	37:4	0:0	2	be
op	37:18	0:0	2	=
call	37:20	37:45	2	bytestream2_get_be32u
arg	37:42	37:45	3	&gb
op	37:42	0:0	4	&
water	37:43	0:0	4	gb
water	37:46	0:0	2	;
water	38:4	0:0	2	bunit
op	38:18	0:0	2	=
call	38:20	38:45	2	bytestream2_get_be32u
arg	38:42	38:45	3	&gb
op	38:42	0:0	4	&
water	38:43	0:0	4	gb
water	38:46	0:0	2	;
water	39:4	0:0	2	bitorder
op	39:18	0:0	2	=
call	39:20	39:45	2	bytestream2_get_be32u
arg	39:42	39:45	3	&gb
op	39:42	0:0	4	&
water	39:43	0:0	4	gb
water	39:46	0:0	2	;
water	40:4	0:0	2	bpad
op	40:18	0:0	2	=
call	40:20	40:45	2	bytestream2_get_be32u
arg	40:42	40:45	3	&gb
op	40:42	0:0	4	&
water	40:43	0:0	4	gb
water	40:46	0:0	2	;
water	41:4	0:0	2	bpp
op	41:18	0:0	2	=
call	41:20	41:45	2	bytestream2_get_be32u
arg	41:42	41:45	3	&gb
op	41:42	0:0	4	&
water	41:43	0:0	4	gb
water	41:46	0:0	2	;
water	42:4	0:0	2	lsize
op	42:18	0:0	2	=
call	42:20	42:45	2	bytestream2_get_be32u
arg	42:42	42:45	3	&gb
op	42:42	0:0	4	&
water	42:43	0:0	4	gb
water	42:46	0:0	2	;
water	43:4	0:0	2	vclass
op	43:18	0:0	2	=
call	43:20	43:45	2	bytestream2_get_be32u
arg	43:42	43:45	3	&gb
op	43:42	0:0	4	&
water	43:43	0:0	4	gb
water	43:46	0:0	2	;
water	44:4	0:0	2	rgb
op	44:7	0:0	2	[
water	44:8	0:0	2	0
op	44:9	0:0	2	]
op	44:18	0:0	2	=
call	44:20	44:45	2	bytestream2_get_be32u
arg	44:42	44:45	3	&gb
op	44:42	0:0	4	&
water	44:43	0:0	4	gb
water	44:46	0:0	2	;
water	45:4	0:0	2	rgb
op	45:7	0:0	2	[
water	45:8	0:0	2	1
op	45:9	0:0	2	]
op	45:18	0:0	2	=
call	45:20	45:45	2	bytestream2_get_be32u
arg	45:42	45:45	3	&gb
op	45:42	0:0	4	&
water	45:43	0:0	4	gb
water	45:46	0:0	2	;
water	46:4	0:0	2	rgb
op	46:7	0:0	2	[
water	46:8	0:0	2	2
op	46:9	0:0	2	]
op	46:18	0:0	2	=
call	46:20	46:45	2	bytestream2_get_be32u
arg	46:42	46:45	3	&gb
op	46:42	0:0	4	&
water	46:43	0:0	4	gb
water	46:46	0:0	2	;
call	47:4	47:28	2	bytestream2_skipu
arg	47:22	47:25	3	&gb
op	47:22	0:0	4	&
water	47:23	0:0	4	gb
arg	47:27	47:28	3	8
water	47:27	0:0	4	8
water	47:29	0:0	2	;
water	48:4	0:0	2	ncolors
op	48:18	0:0	2	=
call	48:20	48:45	2	bytestream2_get_be32u
arg	48:42	48:45	3	&gb
op	48:42	0:0	4	&
water	48:43	0:0	4	gb
water	48:46	0:0	2	;
call	49:4	49:63	2	bytestream2_skipu
arg	49:22	49:25	3	&gb
op	49:22	0:0	4	&
water	49:23	0:0	4	gb
arg	49:27	49:63	3	header_size-(XWD_HEADER_SIZE-20)
water	49:27	0:0	4	header_size
op	49:39	0:0	4	-
water	49:41	0:0	4	(
water	49:42	0:0	4	XWD_HEADER_SIZE
op	49:58	0:0	4	-
water	49:60	0:0	4	20
water	49:62	0:0	4	)
water	49:64	0:0	2	;
call	51:4	53:53	2	av_log
arg	51:11	51:16	3	avctx
water	51:11	0:0	4	avctx
arg	51:18	51:30	3	AV_LOG_DEBUG
water	51:18	0:0	4	AV_LOG_DEBUG
arg	52:11	52:107	3	"pixformat %"PRIu32", pixdepth %"PRIu32", bunit %"PRIu32", bitorder %"PRIu32", bpad %"PRIu32"\n"
water	52:11	0:0	4	"pixformat %"
water	52:24	0:0	4	PRIu32
water	52:30	0:0	4	", pixdepth %"
water	52:44	0:0	4	PRIu32
water	52:50	0:0	4	", bunit %"
water	52:61	0:0	4	PRIu32
water	52:67	0:0	4	", bitorder %"
water	52:81	0:0	4	PRIu32
water	52:87	0:0	4	", bpad %"
water	52:97	0:0	4	PRIu32
water	52:103	0:0	4	"\n"
arg	53:11	53:20	3	pixformat
water	53:11	0:0	4	pixformat
arg	53:22	53:30	3	pixdepth
water	53:22	0:0	4	pixdepth
arg	53:32	53:37	3	bunit
water	53:32	0:0	4	bunit
arg	53:39	53:47	3	bitorder
water	53:39	0:0	4	bitorder
arg	53:49	53:53	3	bpad
water	53:49	0:0	4	bpad
water	53:54	0:0	2	;
call	54:4	56:51	2	av_log
arg	54:11	54:16	3	avctx
water	54:11	0:0	4	avctx
arg	54:18	54:30	3	AV_LOG_DEBUG
water	54:18	0:0	4	AV_LOG_DEBUG
arg	55:11	55:115	3	"vclass %"PRIu32", ncolors %"PRIu32", bpp %"PRIu32", be %"PRIu32", lsize %"PRIu32", xoffset %"PRIu32"\n"
water	55:11	0:0	4	"vclass %"
water	55:21	0:0	4	PRIu32
water	55:27	0:0	4	", ncolors %"
water	55:40	0:0	4	PRIu32
water	55:46	0:0	4	", bpp %"
water	55:55	0:0	4	PRIu32
water	55:61	0:0	4	", be %"
water	55:69	0:0	4	PRIu32
water	55:75	0:0	4	", lsize %"
water	55:86	0:0	4	PRIu32
water	55:92	0:0	4	", xoffset %"
water	55:105	0:0	4	PRIu32
water	55:111	0:0	4	"\n"
arg	56:11	56:17	3	vclass
water	56:11	0:0	4	vclass
arg	56:19	56:26	3	ncolors
water	56:19	0:0	4	ncolors
arg	56:28	56:31	3	bpp
water	56:28	0:0	4	bpp
arg	56:33	56:35	3	be
water	56:33	0:0	4	be
arg	56:37	56:42	3	lsize
water	56:37	0:0	4	lsize
arg	56:44	56:51	3	xoffset
water	56:44	0:0	4	xoffset
water	56:52	0:0	2	;
call	57:4	59:33	2	av_log
arg	57:11	57:16	3	avctx
water	57:11	0:0	4	avctx
arg	57:18	57:30	3	AV_LOG_DEBUG
water	57:18	0:0	4	AV_LOG_DEBUG
arg	58:11	58:64	3	"red %0"PRIx32", green %0"PRIx32", blue %0"PRIx32"\n"
water	58:11	0:0	4	"red %0"
water	58:19	0:0	4	PRIx32
water	58:25	0:0	4	", green %0"
water	58:37	0:0	4	PRIx32
water	58:43	0:0	4	", blue %0"
water	58:54	0:0	4	PRIx32
water	58:60	0:0	4	"\n"
arg	59:11	59:17	3	rgb[0]
water	59:11	0:0	4	rgb
op	59:14	0:0	4	[
water	59:15	0:0	4	0
op	59:16	0:0	4	]
arg	59:19	59:25	3	rgb[1]
water	59:19	0:0	4	rgb
op	59:22	0:0	4	[
water	59:23	0:0	4	1
op	59:24	0:0	4	]
arg	59:27	59:33	3	rgb[2]
water	59:27	0:0	4	rgb
op	59:30	0:0	4	[
water	59:31	0:0	4	2
op	59:32	0:0	4	]
water	59:34	0:0	2	;
if	61:4	64:4	2	(pixformat > XWD_Z_PIXMAP)
cond	61:8	61:20	3	pixformat > XWD_Z_PIXMAP
water	61:8	0:0	4	pixformat
op	61:18	0:0	4	>
water	61:20	0:0	4	XWD_Z_PIXMAP
stmts	61:34	64:4	3	
water	61:34	0:0	4	{
call	62:8	62:61	4	av_log
arg	62:15	62:20	5	avctx
water	62:15	0:0	6	avctx
arg	62:22	62:34	5	AV_LOG_ERROR
water	62:22	0:0	6	AV_LOG_ERROR
arg	62:36	62:61	5	"invalid pixmap format\n"
water	62:36	0:0	6	"invalid pixmap format\n"
water	62:62	0:0	4	;
return	63:8	63:34	4	AVERROR_INVALIDDATA
water	63:15	0:0	5	AVERROR_INVALIDDATA
water	64:4	0:0	4	}
if	66:4	69:4	2	(pixdepth == 0 || pixdepth > 32)
cond	66:8	66:36	3	pixdepth == 0 || pixdepth > 32
water	66:8	0:0	4	pixdepth
op	66:17	0:0	4	==
water	66:20	0:0	4	0
op	66:22	0:0	4	||
water	66:25	0:0	4	pixdepth
op	66:34	0:0	4	>
water	66:36	0:0	4	32
stmts	66:40	69:4	3	
water	66:40	0:0	4	{
call	67:8	67:60	4	av_log
arg	67:15	67:20	5	avctx
water	67:15	0:0	6	avctx
arg	67:22	67:34	5	AV_LOG_ERROR
water	67:22	0:0	6	AV_LOG_ERROR
arg	67:36	67:60	5	"invalid pixmap depth\n"
water	67:36	0:0	6	"invalid pixmap depth\n"
water	67:61	0:0	4	;
return	68:8	68:34	4	AVERROR_INVALIDDATA
water	68:15	0:0	5	AVERROR_INVALIDDATA
water	69:4	0:0	4	}
if	71:4	74:4	2	(xoffset)
cond	71:8	71:8	3	xoffset
water	71:8	0:0	4	xoffset
stmts	71:17	74:4	3	
water	71:17	0:0	4	{
call	72:8	72:65	4	avpriv_request_sample
arg	72:30	72:35	5	avctx
water	72:30	0:0	6	avctx
arg	72:37	72:56	5	"xoffset %"PRIu32""
water	72:37	0:0	6	"xoffset %"
water	72:48	0:0	6	PRIu32
water	72:54	0:0	6	""
arg	72:58	72:65	5	xoffset
water	72:58	0:0	6	xoffset
water	72:66	0:0	4	;
return	73:8	73:35	4	AVERROR_PATCHWELCOME
water	73:15	0:0	5	AVERROR_PATCHWELCOME
water	74:4	0:0	4	}
if	76:4	79:4	2	(be > 1)
cond	76:8	76:13	3	be > 1
water	76:8	0:0	4	be
op	76:11	0:0	4	>
water	76:13	0:0	4	1
stmts	76:16	79:4	3	
water	76:16	0:0	4	{
call	77:8	77:58	4	av_log
arg	77:15	77:20	5	avctx
water	77:15	0:0	6	avctx
arg	77:22	77:34	5	AV_LOG_ERROR
water	77:22	0:0	6	AV_LOG_ERROR
arg	77:36	77:58	5	"invalid byte order\n"
water	77:36	0:0	6	"invalid byte order\n"
water	77:59	0:0	4	;
return	78:8	78:34	4	AVERROR_INVALIDDATA
water	78:15	0:0	5	AVERROR_INVALIDDATA
water	79:4	0:0	4	}
if	81:4	84:4	2	(bitorder > 1)
cond	81:8	81:19	3	bitorder > 1
water	81:8	0:0	4	bitorder
op	81:17	0:0	4	>
water	81:19	0:0	4	1
stmts	81:22	84:4	3	
water	81:22	0:0	4	{
call	82:8	82:64	4	av_log
arg	82:15	82:20	5	avctx
water	82:15	0:0	6	avctx
arg	82:22	82:34	5	AV_LOG_ERROR
water	82:22	0:0	6	AV_LOG_ERROR
arg	82:36	82:64	5	"invalid bitmap bit order\n"
water	82:36	0:0	6	"invalid bitmap bit order\n"
water	82:65	0:0	4	;
return	83:8	83:34	4	AVERROR_INVALIDDATA
water	83:15	0:0	5	AVERROR_INVALIDDATA
water	84:4	0:0	4	}
if	86:4	89:4	2	(bunit != 8 && bunit != 16 && bunit != 32)
cond	86:8	86:46	3	bunit != 8 && bunit != 16 && bunit != 32
water	86:8	0:0	4	bunit
op	86:14	0:0	4	!=
water	86:17	0:0	4	8
op	86:19	0:0	4	&&
water	86:22	0:0	4	bunit
op	86:28	0:0	4	!=
water	86:31	0:0	4	16
op	86:34	0:0	4	&&
water	86:37	0:0	4	bunit
op	86:43	0:0	4	!=
water	86:46	0:0	4	32
stmts	86:50	89:4	3	
water	86:50	0:0	4	{
call	87:8	87:59	4	av_log
arg	87:15	87:20	5	avctx
water	87:15	0:0	6	avctx
arg	87:22	87:34	5	AV_LOG_ERROR
water	87:22	0:0	6	AV_LOG_ERROR
arg	87:36	87:59	5	"invalid bitmap unit\n"
water	87:36	0:0	6	"invalid bitmap unit\n"
water	87:60	0:0	4	;
return	88:8	88:34	4	AVERROR_INVALIDDATA
water	88:15	0:0	5	AVERROR_INVALIDDATA
water	89:4	0:0	4	}
if	91:4	94:4	2	(bpad != 8 && bpad != 16 && bpad != 32)
cond	91:8	91:43	3	bpad != 8 && bpad != 16 && bpad != 32
water	91:8	0:0	4	bpad
op	91:13	0:0	4	!=
water	91:16	0:0	4	8
op	91:18	0:0	4	&&
water	91:21	0:0	4	bpad
op	91:26	0:0	4	!=
water	91:29	0:0	4	16
op	91:32	0:0	4	&&
water	91:35	0:0	4	bpad
op	91:40	0:0	4	!=
water	91:43	0:0	4	32
stmts	91:47	94:4	3	
water	91:47	0:0	4	{
call	92:8	92:68	4	av_log
arg	92:15	92:20	5	avctx
water	92:15	0:0	6	avctx
arg	92:22	92:34	5	AV_LOG_ERROR
water	92:22	0:0	6	AV_LOG_ERROR
arg	92:36	92:68	5	"invalid bitmap scan-line pad\n"
water	92:36	0:0	6	"invalid bitmap scan-line pad\n"
water	92:69	0:0	4	;
return	93:8	93:34	4	AVERROR_INVALIDDATA
water	93:15	0:0	5	AVERROR_INVALIDDATA
water	94:4	0:0	4	}
if	96:4	99:4	2	(bpp == 0 || bpp > 32)
cond	96:8	96:26	3	bpp == 0 || bpp > 32
water	96:8	0:0	4	bpp
op	96:12	0:0	4	==
water	96:15	0:0	4	0
op	96:17	0:0	4	||
water	96:20	0:0	4	bpp
op	96:24	0:0	4	>
water	96:26	0:0	4	32
stmts	96:30	99:4	3	
water	96:30	0:0	4	{
call	97:8	97:62	4	av_log
arg	97:15	97:20	5	avctx
water	97:15	0:0	6	avctx
arg	97:22	97:34	5	AV_LOG_ERROR
water	97:22	0:0	6	AV_LOG_ERROR
arg	97:36	97:62	5	"invalid bits per pixel\n"
water	97:36	0:0	6	"invalid bits per pixel\n"
water	97:63	0:0	4	;
return	98:8	98:34	4	AVERROR_INVALIDDATA
water	98:15	0:0	5	AVERROR_INVALIDDATA
water	99:4	0:0	4	}
if	101:4	104:4	2	(ncolors > 256)
cond	101:8	101:18	3	ncolors > 256
water	101:8	0:0	4	ncolors
op	101:16	0:0	4	>
water	101:18	0:0	4	256
stmts	101:23	104:4	3	
water	101:23	0:0	4	{
call	102:8	102:77	4	av_log
arg	102:15	102:20	5	avctx
water	102:15	0:0	6	avctx
arg	102:22	102:34	5	AV_LOG_ERROR
water	102:22	0:0	6	AV_LOG_ERROR
arg	102:36	102:77	5	"invalid number of entries in colormap\n"
water	102:36	0:0	6	"invalid number of entries in colormap\n"
water	102:78	0:0	4	;
return	103:8	103:34	4	AVERROR_INVALIDDATA
water	103:15	0:0	5	AVERROR_INVALIDDATA
water	104:4	0:0	4	}
if	106:4	107:18	2	(( ret =av_image_check_size (avctx -> width ,avctx -> height ,0 ,NULL ) ) < 0)
cond	106:8	106:76	3	( ret =av_image_check_size (avctx -> width ,avctx -> height ,0 ,NULL ) ) < 0
water	106:8	0:0	4	(
water	106:9	0:0	4	ret
op	106:13	0:0	4	=
call	106:15	106:71	4	av_image_check_size
arg	106:35	106:47	5	avctx->width
water	106:35	0:0	6	avctx
op	106:40	0:0	6	->
water	106:42	0:0	6	width
arg	106:49	106:62	5	avctx->height
water	106:49	0:0	6	avctx
op	106:54	0:0	6	->
water	106:56	0:0	6	height
arg	106:64	106:65	5	0
water	106:64	0:0	6	0
arg	106:67	106:71	5	NULL
water	106:67	0:0	6	NULL
water	106:72	0:0	4	)
op	106:74	0:0	4	<
water	106:76	0:0	4	0
stmts	107:8	107:18	3	
return	107:8	107:18	4	ret
water	107:15	0:0	5	ret
water	109:4	0:0	2	rsize
op	109:10	0:0	2	=
call	109:12	109:44	2	FFALIGN
arg	109:20	109:38	3	avctx->width*bpp
water	109:20	0:0	4	avctx
op	109:25	0:0	4	->
water	109:27	0:0	4	width
op	109:33	0:0	4	*
water	109:35	0:0	4	bpp
arg	109:40	109:44	3	bpad
water	109:40	0:0	4	bpad
op	109:46	0:0	2	/
water	109:48	0:0	2	8
water	109:49	0:0	2	;
if	110:4	113:4	2	(lsize < rsize)
cond	110:8	110:16	3	lsize < rsize
water	110:8	0:0	4	lsize
op	110:14	0:0	4	<
water	110:16	0:0	4	rsize
stmts	110:23	113:4	3	
water	110:23	0:0	4	{
call	111:8	111:67	4	av_log
arg	111:15	111:20	5	avctx
water	111:15	0:0	6	avctx
arg	111:22	111:34	5	AV_LOG_ERROR
water	111:22	0:0	6	AV_LOG_ERROR
arg	111:36	111:67	5	"invalid bytes per scan-line\n"
water	111:36	0:0	6	"invalid bytes per scan-line\n"
water	111:68	0:0	4	;
return	112:8	112:34	4	AVERROR_INVALIDDATA
water	112:15	0:0	5	AVERROR_INVALIDDATA
water	113:4	0:0	4	}
if	115:4	118:4	2	(bytestream2_get_bytes_left (& gb ) < ncolors * XWD_CMAP_SIZE + ( uint64_t ) avctx -> height * lsize)
cond	115:8	115:94	3	bytestream2_get_bytes_left (& gb ) < ncolors * XWD_CMAP_SIZE + ( uint64_t ) avctx -> height * lsize
call	115:8	115:38	4	bytestream2_get_bytes_left
arg	115:35	115:38	5	&gb
op	115:35	0:0	6	&
water	115:36	0:0	6	gb
op	115:40	0:0	4	<
water	115:42	0:0	4	ncolors
op	115:50	0:0	4	*
water	115:52	0:0	4	XWD_CMAP_SIZE
op	115:66	0:0	4	+
water	115:68	0:0	4	(
water	115:69	0:0	4	uint64_t
water	115:77	0:0	4	)
water	115:78	0:0	4	avctx
op	115:83	0:0	4	->
water	115:85	0:0	4	height
op	115:92	0:0	4	*
water	115:94	0:0	4	lsize
stmts	115:101	118:4	3	
water	115:101	0:0	4	{
call	116:8	116:62	4	av_log
arg	116:15	116:20	5	avctx
water	116:15	0:0	6	avctx
arg	116:22	116:34	5	AV_LOG_ERROR
water	116:22	0:0	6	AV_LOG_ERROR
arg	116:36	116:62	5	"input buffer too small\n"
water	116:36	0:0	6	"input buffer too small\n"
water	116:63	0:0	4	;
return	117:8	117:34	4	AVERROR_INVALIDDATA
water	117:15	0:0	5	AVERROR_INVALIDDATA
water	118:4	0:0	4	}
if	120:4	123:4	2	(pixformat != XWD_Z_PIXMAP)
cond	120:8	120:21	3	pixformat != XWD_Z_PIXMAP
water	120:8	0:0	4	pixformat
op	120:18	0:0	4	!=
water	120:21	0:0	4	XWD_Z_PIXMAP
stmts	120:35	123:4	3	
water	120:35	0:0	4	{
call	121:8	121:79	4	avpriv_report_missing_feature
arg	121:38	121:43	5	avctx
water	121:38	0:0	6	avctx
arg	121:45	121:68	5	"Pixmap format %"PRIu32
water	121:45	0:0	6	"Pixmap format %"
water	121:62	0:0	6	PRIu32
arg	121:70	121:79	5	pixformat
water	121:70	0:0	6	pixformat
water	121:80	0:0	4	;
return	122:8	122:35	4	AVERROR_PATCHWELCOME
water	122:15	0:0	5	AVERROR_PATCHWELCOME
water	123:4	0:0	4	}
water	125:4	0:0	2	avctx
op	125:9	0:0	2	->
water	125:11	0:0	2	pix_fmt
op	125:19	0:0	2	=
water	125:21	0:0	2	AV_PIX_FMT_NONE
water	125:36	0:0	2	;
switch	126:4	172:4	2	(vclass)
cond	126:12	126:12	3	vclass
water	126:12	0:0	4	vclass
stmts	126:20	172:4	3	
water	126:20	0:0	4	{
label	127:4	127:24	4	case XWD_STATIC_GRAY :
label	128:4	128:23	4	case XWD_GRAY_SCALE :
if	129:8	130:38	4	(bpp != 1 && bpp != 8)
cond	129:12	129:31	5	bpp != 1 && bpp != 8
water	129:12	0:0	6	bpp
op	129:16	0:0	6	!=
water	129:19	0:0	6	1
op	129:21	0:0	6	&&
water	129:24	0:0	6	bpp
op	129:28	0:0	6	!=
water	129:31	0:0	6	8
stmts	130:12	130:38	5	
return	130:12	130:38	6	AVERROR_INVALIDDATA
water	130:19	0:0	7	AVERROR_INVALIDDATA
if	131:8	133:8	4	(pixdepth == 1)
cond	131:12	131:24	5	pixdepth == 1
water	131:12	0:0	6	pixdepth
op	131:21	0:0	6	==
water	131:24	0:0	6	1
stmts	131:27	133:8	5	
water	131:27	0:0	6	{
water	132:12	0:0	6	avctx
op	132:17	0:0	6	->
water	132:19	0:0	6	pix_fmt
op	132:27	0:0	6	=
water	132:29	0:0	6	AV_PIX_FMT_MONOWHITE
water	132:49	0:0	6	;
water	133:8	0:0	6	}
else	133:10	135:8	4
stmts	133:15	135:8	5	
if	133:15	135:8	6	(pixdepth == 8)
cond	133:19	133:31	7	pixdepth == 8
water	133:19	0:0	8	pixdepth
op	133:28	0:0	8	==
water	133:31	0:0	8	8
stmts	133:34	135:8	7	
water	133:34	0:0	8	{
water	134:12	0:0	8	avctx
op	134:17	0:0	8	->
water	134:19	0:0	8	pix_fmt
op	134:27	0:0	8	=
water	134:29	0:0	8	AV_PIX_FMT_GRAY8
water	134:45	0:0	8	;
water	135:8	0:0	8	}
break	136:8	136:13	4	
label	137:4	137:25	4	case XWD_STATIC_COLOR :
label	138:4	138:25	4	case XWD_PSEUDO_COLOR :
if	139:8	140:44	4	(bpp == 8)
cond	139:12	139:19	5	bpp == 8
water	139:12	0:0	6	bpp
op	139:16	0:0	6	==
water	139:19	0:0	6	8
stmts	140:12	140:44	5	
water	140:12	0:0	6	avctx
op	140:17	0:0	6	->
water	140:19	0:0	6	pix_fmt
op	140:27	0:0	6	=
water	140:29	0:0	6	AV_PIX_FMT_PAL8
water	140:44	0:0	6	;
break	141:8	141:13	4	
label	142:4	142:23	4	case XWD_TRUE_COLOR :
label	143:4	143:25	4	case XWD_DIRECT_COLOR :
if	144:8	145:38	4	(bpp != 16 && bpp != 24 && bpp != 32)
cond	144:12	144:45	5	bpp != 16 && bpp != 24 && bpp != 32
water	144:12	0:0	6	bpp
op	144:16	0:0	6	!=
water	144:19	0:0	6	16
op	144:22	0:0	6	&&
water	144:25	0:0	6	bpp
op	144:29	0:0	6	!=
water	144:32	0:0	6	24
op	144:35	0:0	6	&&
water	144:38	0:0	6	bpp
op	144:42	0:0	6	!=
water	144:45	0:0	6	32
stmts	145:12	145:38	5	
return	145:12	145:38	6	AVERROR_INVALIDDATA
water	145:19	0:0	7	AVERROR_INVALIDDATA
if	146:8	151:8	4	(bpp == 16 && pixdepth == 15)
cond	146:12	146:37	5	bpp == 16 && pixdepth == 15
water	146:12	0:0	6	bpp
op	146:16	0:0	6	==
water	146:19	0:0	6	16
op	146:22	0:0	6	&&
water	146:25	0:0	6	pixdepth
op	146:34	0:0	6	==
water	146:37	0:0	6	15
stmts	146:41	151:8	5	
water	146:41	0:0	6	{
if	147:12	148:79	6	(rgb [ 0 ] == 0 x7C00 && rgb [ 1 ] == 0 x3E0 && rgb [ 2 ] == 0 x1F)
cond	147:16	147:66	7	rgb [ 0 ] == 0 x7C00 && rgb [ 1 ] == 0 x3E0 && rgb [ 2 ] == 0 x1F
water	147:16	0:0	8	rgb
op	147:19	0:0	8	[
water	147:20	0:0	8	0
op	147:21	0:0	8	]
op	147:23	0:0	8	==
water	147:26	0:0	8	0
water	147:27	0:0	8	x7C00
op	147:33	0:0	8	&&
water	147:36	0:0	8	rgb
op	147:39	0:0	8	[
water	147:40	0:0	8	1
op	147:41	0:0	8	]
op	147:43	0:0	8	==
water	147:46	0:0	8	0
water	147:47	0:0	8	x3E0
op	147:52	0:0	8	&&
water	147:55	0:0	8	rgb
op	147:58	0:0	8	[
water	147:59	0:0	8	2
op	147:60	0:0	8	]
op	147:62	0:0	8	==
water	147:65	0:0	8	0
water	147:66	0:0	8	x1F
stmts	148:16	148:79	7	
water	148:16	0:0	8	avctx
op	148:21	0:0	8	->
water	148:23	0:0	8	pix_fmt
op	148:31	0:0	8	=
water	148:33	0:0	8	be
water	148:36	0:0	8	?
water	148:38	0:0	8	AV_PIX_FMT_RGB555BE
water	148:58	0:0	8	:
water	148:60	0:0	8	AV_PIX_FMT_RGB555LE
water	148:79	0:0	8	;
else	149:12	150:79	6
stmts	149:17	150:79	7	
if	149:17	150:79	8	(rgb [ 0 ] == 0 x1F && rgb [ 1 ] == 0 x3E0 && rgb [ 2 ] == 0 x7C00)
cond	149:21	149:69	9	rgb [ 0 ] == 0 x1F && rgb [ 1 ] == 0 x3E0 && rgb [ 2 ] == 0 x7C00
water	149:21	0:0	10	rgb
op	149:24	0:0	10	[
water	149:25	0:0	10	0
op	149:26	0:0	10	]
op	149:28	0:0	10	==
water	149:31	0:0	10	0
water	149:32	0:0	10	x1F
op	149:36	0:0	10	&&
water	149:39	0:0	10	rgb
op	149:42	0:0	10	[
water	149:43	0:0	10	1
op	149:44	0:0	10	]
op	149:46	0:0	10	==
water	149:49	0:0	10	0
water	149:50	0:0	10	x3E0
op	149:55	0:0	10	&&
water	149:58	0:0	10	rgb
op	149:61	0:0	10	[
water	149:62	0:0	10	2
op	149:63	0:0	10	]
op	149:65	0:0	10	==
water	149:68	0:0	10	0
water	149:69	0:0	10	x7C00
stmts	150:16	150:79	9	
water	150:16	0:0	10	avctx
op	150:21	0:0	10	->
water	150:23	0:0	10	pix_fmt
op	150:31	0:0	10	=
water	150:33	0:0	10	be
water	150:36	0:0	10	?
water	150:38	0:0	10	AV_PIX_FMT_BGR555BE
water	150:58	0:0	10	:
water	150:60	0:0	10	AV_PIX_FMT_BGR555LE
water	150:79	0:0	10	;
water	151:8	0:0	6	}
else	151:10	156:8	4
stmts	151:15	156:8	5	
if	151:15	156:8	6	(bpp == 16 && pixdepth == 16)
cond	151:19	151:44	7	bpp == 16 && pixdepth == 16
water	151:19	0:0	8	bpp
op	151:23	0:0	8	==
water	151:26	0:0	8	16
op	151:29	0:0	8	&&
water	151:32	0:0	8	pixdepth
op	151:41	0:0	8	==
water	151:44	0:0	8	16
stmts	151:48	156:8	7	
water	151:48	0:0	8	{
if	152:12	153:79	8	(rgb [ 0 ] == 0 xF800 && rgb [ 1 ] == 0 x7E0 && rgb [ 2 ] == 0 x1F)
cond	152:16	152:66	9	rgb [ 0 ] == 0 xF800 && rgb [ 1 ] == 0 x7E0 && rgb [ 2 ] == 0 x1F
water	152:16	0:0	10	rgb
op	152:19	0:0	10	[
water	152:20	0:0	10	0
op	152:21	0:0	10	]
op	152:23	0:0	10	==
water	152:26	0:0	10	0
water	152:27	0:0	10	xF800
op	152:33	0:0	10	&&
water	152:36	0:0	10	rgb
op	152:39	0:0	10	[
water	152:40	0:0	10	1
op	152:41	0:0	10	]
op	152:43	0:0	10	==
water	152:46	0:0	10	0
water	152:47	0:0	10	x7E0
op	152:52	0:0	10	&&
water	152:55	0:0	10	rgb
op	152:58	0:0	10	[
water	152:59	0:0	10	2
op	152:60	0:0	10	]
op	152:62	0:0	10	==
water	152:65	0:0	10	0
water	152:66	0:0	10	x1F
stmts	153:16	153:79	9	
water	153:16	0:0	10	avctx
op	153:21	0:0	10	->
water	153:23	0:0	10	pix_fmt
op	153:31	0:0	10	=
water	153:33	0:0	10	be
water	153:36	0:0	10	?
water	153:38	0:0	10	AV_PIX_FMT_RGB565BE
water	153:58	0:0	10	:
water	153:60	0:0	10	AV_PIX_FMT_RGB565LE
water	153:79	0:0	10	;
else	154:12	155:79	8
stmts	154:17	155:79	9	
if	154:17	155:79	10	(rgb [ 0 ] == 0 x1F && rgb [ 1 ] == 0 x7E0 && rgb [ 2 ] == 0 xF800)
cond	154:21	154:69	11	rgb [ 0 ] == 0 x1F && rgb [ 1 ] == 0 x7E0 && rgb [ 2 ] == 0 xF800
water	154:21	0:0	12	rgb
op	154:24	0:0	12	[
water	154:25	0:0	12	0
op	154:26	0:0	12	]
op	154:28	0:0	12	==
water	154:31	0:0	12	0
water	154:32	0:0	12	x1F
op	154:36	0:0	12	&&
water	154:39	0:0	12	rgb
op	154:42	0:0	12	[
water	154:43	0:0	12	1
op	154:44	0:0	12	]
op	154:46	0:0	12	==
water	154:49	0:0	12	0
water	154:50	0:0	12	x7E0
op	154:55	0:0	12	&&
water	154:58	0:0	12	rgb
op	154:61	0:0	12	[
water	154:62	0:0	12	2
op	154:63	0:0	12	]
op	154:65	0:0	12	==
water	154:68	0:0	12	0
water	154:69	0:0	12	xF800
stmts	155:16	155:79	11	
water	155:16	0:0	12	avctx
op	155:21	0:0	12	->
water	155:23	0:0	12	pix_fmt
op	155:31	0:0	12	=
water	155:33	0:0	12	be
water	155:36	0:0	12	?
water	155:38	0:0	12	AV_PIX_FMT_BGR565BE
water	155:58	0:0	12	:
water	155:60	0:0	12	AV_PIX_FMT_BGR565LE
water	155:79	0:0	12	;
water	156:8	0:0	8	}
else	156:10	161:8	4
stmts	156:15	161:8	5	
if	156:15	161:8	6	(bpp == 24)
cond	156:19	156:26	7	bpp == 24
water	156:19	0:0	8	bpp
op	156:23	0:0	8	==
water	156:26	0:0	8	24
stmts	156:30	161:8	7	
water	156:30	0:0	8	{
if	157:12	158:73	8	(rgb [ 0 ] == 0 xFF0000 && rgb [ 1 ] == 0 xFF00 && rgb [ 2 ] == 0 xFF)
cond	157:16	157:69	9	rgb [ 0 ] == 0 xFF0000 && rgb [ 1 ] == 0 xFF00 && rgb [ 2 ] == 0 xFF
water	157:16	0:0	10	rgb
op	157:19	0:0	10	[
water	157:20	0:0	10	0
op	157:21	0:0	10	]
op	157:23	0:0	10	==
water	157:26	0:0	10	0
water	157:27	0:0	10	xFF0000
op	157:35	0:0	10	&&
water	157:38	0:0	10	rgb
op	157:41	0:0	10	[
water	157:42	0:0	10	1
op	157:43	0:0	10	]
op	157:45	0:0	10	==
water	157:48	0:0	10	0
water	157:49	0:0	10	xFF00
op	157:55	0:0	10	&&
water	157:58	0:0	10	rgb
op	157:61	0:0	10	[
water	157:62	0:0	10	2
op	157:63	0:0	10	]
op	157:65	0:0	10	==
water	157:68	0:0	10	0
water	157:69	0:0	10	xFF
stmts	158:16	158:73	9	
water	158:16	0:0	10	avctx
op	158:21	0:0	10	->
water	158:23	0:0	10	pix_fmt
op	158:31	0:0	10	=
water	158:33	0:0	10	be
water	158:36	0:0	10	?
water	158:38	0:0	10	AV_PIX_FMT_RGB24
water	158:55	0:0	10	:
water	158:57	0:0	10	AV_PIX_FMT_BGR24
water	158:73	0:0	10	;
else	159:12	160:73	8
stmts	159:17	160:73	9	
if	159:17	160:73	10	(rgb [ 0 ] == 0 xFF && rgb [ 1 ] == 0 xFF00 && rgb [ 2 ] == 0 xFF0000)
cond	159:21	159:70	11	rgb [ 0 ] == 0 xFF && rgb [ 1 ] == 0 xFF00 && rgb [ 2 ] == 0 xFF0000
water	159:21	0:0	12	rgb
op	159:24	0:0	12	[
water	159:25	0:0	12	0
op	159:26	0:0	12	]
op	159:28	0:0	12	==
water	159:31	0:0	12	0
water	159:32	0:0	12	xFF
op	159:36	0:0	12	&&
water	159:39	0:0	12	rgb
op	159:42	0:0	12	[
water	159:43	0:0	12	1
op	159:44	0:0	12	]
op	159:46	0:0	12	==
water	159:49	0:0	12	0
water	159:50	0:0	12	xFF00
op	159:56	0:0	12	&&
water	159:59	0:0	12	rgb
op	159:62	0:0	12	[
water	159:63	0:0	12	2
op	159:64	0:0	12	]
op	159:66	0:0	12	==
water	159:69	0:0	12	0
water	159:70	0:0	12	xFF0000
stmts	160:16	160:73	11	
water	160:16	0:0	12	avctx
op	160:21	0:0	12	->
water	160:23	0:0	12	pix_fmt
op	160:31	0:0	12	=
water	160:33	0:0	12	be
water	160:36	0:0	12	?
water	160:38	0:0	12	AV_PIX_FMT_BGR24
water	160:55	0:0	12	:
water	160:57	0:0	12	AV_PIX_FMT_RGB24
water	160:73	0:0	12	;
water	161:8	0:0	8	}
else	161:10	166:8	4
stmts	161:15	166:8	5	
if	161:15	166:8	6	(bpp == 32)
cond	161:19	161:26	7	bpp == 32
water	161:19	0:0	8	bpp
op	161:23	0:0	8	==
water	161:26	0:0	8	32
stmts	161:30	166:8	7	
water	161:30	0:0	8	{
if	162:12	163:71	8	(rgb [ 0 ] == 0 xFF0000 && rgb [ 1 ] == 0 xFF00 && rgb [ 2 ] == 0 xFF)
cond	162:16	162:69	9	rgb [ 0 ] == 0 xFF0000 && rgb [ 1 ] == 0 xFF00 && rgb [ 2 ] == 0 xFF
water	162:16	0:0	10	rgb
op	162:19	0:0	10	[
water	162:20	0:0	10	0
op	162:21	0:0	10	]
op	162:23	0:0	10	==
water	162:26	0:0	10	0
water	162:27	0:0	10	xFF0000
op	162:35	0:0	10	&&
water	162:38	0:0	10	rgb
op	162:41	0:0	10	[
water	162:42	0:0	10	1
op	162:43	0:0	10	]
op	162:45	0:0	10	==
water	162:48	0:0	10	0
water	162:49	0:0	10	xFF00
op	162:55	0:0	10	&&
water	162:58	0:0	10	rgb
op	162:61	0:0	10	[
water	162:62	0:0	10	2
op	162:63	0:0	10	]
op	162:65	0:0	10	==
water	162:68	0:0	10	0
water	162:69	0:0	10	xFF
stmts	163:16	163:71	9	
water	163:16	0:0	10	avctx
op	163:21	0:0	10	->
water	163:23	0:0	10	pix_fmt
op	163:31	0:0	10	=
water	163:33	0:0	10	be
water	163:36	0:0	10	?
water	163:38	0:0	10	AV_PIX_FMT_ARGB
water	163:54	0:0	10	:
water	163:56	0:0	10	AV_PIX_FMT_BGRA
water	163:71	0:0	10	;
else	164:12	165:71	8
stmts	164:17	165:71	9	
if	164:17	165:71	10	(rgb [ 0 ] == 0 xFF && rgb [ 1 ] == 0 xFF00 && rgb [ 2 ] == 0 xFF0000)
cond	164:21	164:70	11	rgb [ 0 ] == 0 xFF && rgb [ 1 ] == 0 xFF00 && rgb [ 2 ] == 0 xFF0000
water	164:21	0:0	12	rgb
op	164:24	0:0	12	[
water	164:25	0:0	12	0
op	164:26	0:0	12	]
op	164:28	0:0	12	==
water	164:31	0:0	12	0
water	164:32	0:0	12	xFF
op	164:36	0:0	12	&&
water	164:39	0:0	12	rgb
op	164:42	0:0	12	[
water	164:43	0:0	12	1
op	164:44	0:0	12	]
op	164:46	0:0	12	==
water	164:49	0:0	12	0
water	164:50	0:0	12	xFF00
op	164:56	0:0	12	&&
water	164:59	0:0	12	rgb
op	164:62	0:0	12	[
water	164:63	0:0	12	2
op	164:64	0:0	12	]
op	164:66	0:0	12	==
water	164:69	0:0	12	0
water	164:70	0:0	12	xFF0000
stmts	165:16	165:71	11	
water	165:16	0:0	12	avctx
op	165:21	0:0	12	->
water	165:23	0:0	12	pix_fmt
op	165:31	0:0	12	=
water	165:33	0:0	12	be
water	165:36	0:0	12	?
water	165:38	0:0	12	AV_PIX_FMT_ABGR
water	165:54	0:0	12	:
water	165:56	0:0	12	AV_PIX_FMT_RGBA
water	165:71	0:0	12	;
water	166:8	0:0	8	}
call	167:8	167:54	4	bytestream2_skipu
arg	167:26	167:29	5	&gb
op	167:26	0:0	6	&
water	167:27	0:0	6	gb
arg	167:31	167:54	5	ncolors*XWD_CMAP_SIZE
water	167:31	0:0	6	ncolors
op	167:39	0:0	6	*
water	167:41	0:0	6	XWD_CMAP_SIZE
water	167:55	0:0	4	;
break	168:8	168:13	4	
label	169:4	169:11	4	default :
call	170:8	170:60	4	av_log
arg	170:15	170:20	5	avctx
water	170:15	0:0	6	avctx
arg	170:22	170:34	5	AV_LOG_ERROR
water	170:22	0:0	6	AV_LOG_ERROR
arg	170:36	170:60	5	"invalid visual class\n"
water	170:36	0:0	6	"invalid visual class\n"
water	170:61	0:0	4	;
return	171:8	171:34	4	AVERROR_INVALIDDATA
water	171:15	0:0	5	AVERROR_INVALIDDATA
water	172:4	0:0	4	}
if	174:4	179:4	2	(avctx -> pix_fmt == AV_PIX_FMT_NONE)
cond	174:8	174:26	3	avctx -> pix_fmt == AV_PIX_FMT_NONE
water	174:8	0:0	4	avctx
op	174:13	0:0	4	->
water	174:15	0:0	4	pix_fmt
op	174:23	0:0	4	==
water	174:26	0:0	4	AV_PIX_FMT_NONE
stmts	174:43	179:4	3	
water	174:43	0:0	4	{
call	175:8	177:51	4	avpriv_request_sample
arg	175:30	175:35	5	avctx
water	175:30	0:0	6	avctx
arg	176:30	176:97	5	"Unknown file: bpp %"PRIu32", pixdepth %"PRIu32", vclass %"PRIu32""
water	176:30	0:0	6	"Unknown file: bpp %"
water	176:51	0:0	6	PRIu32
water	176:57	0:0	6	", pixdepth %"
water	176:71	0:0	6	PRIu32
water	176:77	0:0	6	", vclass %"
water	176:89	0:0	6	PRIu32
water	176:95	0:0	6	""
arg	177:30	177:33	5	bpp
water	177:30	0:0	6	bpp
arg	177:35	177:43	5	pixdepth
water	177:35	0:0	6	pixdepth
arg	177:45	177:51	5	vclass
water	177:45	0:0	6	vclass
water	177:52	0:0	4	;
return	178:8	178:35	4	AVERROR_PATCHWELCOME
water	178:15	0:0	5	AVERROR_PATCHWELCOME
water	179:4	0:0	4	}
if	181:4	182:18	2	(( ret =ff_get_buffer (avctx ,p ,0 ) ) < 0)
cond	181:8	181:45	3	( ret =ff_get_buffer (avctx ,p ,0 ) ) < 0
water	181:8	0:0	4	(
water	181:9	0:0	4	ret
op	181:13	0:0	4	=
call	181:15	181:40	4	ff_get_buffer
arg	181:29	181:34	5	avctx
water	181:29	0:0	6	avctx
arg	181:36	181:37	5	p
water	181:36	0:0	6	p
arg	181:39	181:40	5	0
water	181:39	0:0	6	0
water	181:41	0:0	4	)
op	181:43	0:0	4	<
water	181:45	0:0	4	0
stmts	182:8	182:18	3	
return	182:8	182:18	4	ret
water	182:15	0:0	5	ret
water	184:4	0:0	2	p
op	184:5	0:0	2	->
water	184:7	0:0	2	key_frame
op	184:17	0:0	2	=
water	184:19	0:0	2	1
water	184:20	0:0	2	;
water	185:4	0:0	2	p
op	185:5	0:0	2	->
water	185:7	0:0	2	pict_type
op	185:17	0:0	2	=
water	185:19	0:0	2	AV_PICTURE_TYPE_I
water	185:36	0:0	2	;
if	187:4	203:4	2	(avctx -> pix_fmt == AV_PIX_FMT_PAL8)
cond	187:8	187:26	3	avctx -> pix_fmt == AV_PIX_FMT_PAL8
water	187:8	0:0	4	avctx
op	187:13	0:0	4	->
water	187:15	0:0	4	pix_fmt
op	187:23	0:0	4	==
water	187:26	0:0	4	AV_PIX_FMT_PAL8
stmts	187:43	203:4	3	
water	187:43	0:0	4	{
decl	188:8	188:46	4	uint32_t	*dst
op	188:22	0:0	4	=
water	188:24	0:0	4	(
water	188:25	0:0	4	uint32_t
op	188:34	0:0	4	*
water	188:35	0:0	4	)
water	188:36	0:0	4	p
op	188:37	0:0	4	->
water	188:39	0:0	4	data
op	188:43	0:0	4	[
water	188:44	0:0	4	1
op	188:45	0:0	4	]
decl	189:8	189:32	4	uint8_t	red
water	189:19	0:0	4	,
decl	189:8	189:32	4	uint8_t	green
water	189:26	0:0	4	,
decl	189:8	189:32	4	uint8_t	blue
for	191:8	202:8	4	(i = 0 ;i < ncolors;i ++)
forinit	191:13	191:18	5	i = 0 ;
water	191:13	0:0	6	i
op	191:15	0:0	6	=
water	191:17	0:0	6	0
water	191:18	0:0	6	;
cond	191:20	191:24	5	i < ncolors
water	191:20	0:0	6	i
op	191:22	0:0	6	<
water	191:24	0:0	6	ncolors
forexpr	191:33	191:34	5	i ++
water	191:33	0:0	6	i
op	191:34	0:0	6	++
stmts	191:38	202:8	5	
water	191:38	0:0	6	{
call	193:12	193:36	6	bytestream2_skipu
arg	193:30	193:33	7	&gb
op	193:30	0:0	8	&
water	193:31	0:0	8	gb
arg	193:35	193:36	7	4
water	193:35	0:0	8	4
water	193:37	0:0	6	;
water	194:12	0:0	6	red
op	194:19	0:0	6	=
call	194:21	194:46	6	bytestream2_get_byteu
arg	194:43	194:46	7	&gb
op	194:43	0:0	8	&
water	194:44	0:0	8	gb
water	194:47	0:0	6	;
call	195:12	195:36	6	bytestream2_skipu
arg	195:30	195:33	7	&gb
op	195:30	0:0	8	&
water	195:31	0:0	8	gb
arg	195:35	195:36	7	1
water	195:35	0:0	8	1
water	195:37	0:0	6	;
water	196:12	0:0	6	green
op	196:19	0:0	6	=
call	196:21	196:46	6	bytestream2_get_byteu
arg	196:43	196:46	7	&gb
op	196:43	0:0	8	&
water	196:44	0:0	8	gb
water	196:47	0:0	6	;
call	197:12	197:36	6	bytestream2_skipu
arg	197:30	197:33	7	&gb
op	197:30	0:0	8	&
water	197:31	0:0	8	gb
arg	197:35	197:36	7	1
water	197:35	0:0	8	1
water	197:37	0:0	6	;
water	198:12	0:0	6	blue
op	198:19	0:0	6	=
call	198:21	198:46	6	bytestream2_get_byteu
arg	198:43	198:46	7	&gb
op	198:43	0:0	8	&
water	198:44	0:0	8	gb
water	198:47	0:0	6	;
call	199:12	199:36	6	bytestream2_skipu
arg	199:30	199:33	7	&gb
op	199:30	0:0	8	&
water	199:31	0:0	8	gb
arg	199:35	199:36	7	3
water	199:35	0:0	8	3
water	199:37	0:0	6	;
water	201:12	0:0	6	dst
op	201:15	0:0	6	[
water	201:16	0:0	6	i
op	201:17	0:0	6	]
op	201:19	0:0	6	=
water	201:21	0:0	6	red
op	201:25	0:0	6	<<
water	201:28	0:0	6	16
op	201:31	0:0	6	|
water	201:33	0:0	6	green
op	201:39	0:0	6	<<
water	201:42	0:0	6	8
op	201:44	0:0	6	|
water	201:46	0:0	6	blue
water	201:50	0:0	6	;
water	202:8	0:0	6	}
water	203:4	0:0	4	}
water	205:4	0:0	2	ptr
op	205:8	0:0	2	=
water	205:10	0:0	2	p
op	205:11	0:0	2	->
water	205:13	0:0	2	data
op	205:17	0:0	2	[
water	205:18	0:0	2	0
op	205:19	0:0	2	]
water	205:20	0:0	2	;
for	206:4	210:4	2	(i = 0 ;i < avctx -> height;i ++)
forinit	206:9	206:14	3	i = 0 ;
water	206:9	0:0	4	i
op	206:11	0:0	4	=
water	206:13	0:0	4	0
water	206:14	0:0	4	;
cond	206:16	206:27	3	i < avctx -> height
water	206:16	0:0	4	i
op	206:18	0:0	4	<
water	206:20	0:0	4	avctx
op	206:25	0:0	4	->
water	206:27	0:0	4	height
forexpr	206:35	206:36	3	i ++
water	206:35	0:0	4	i
op	206:36	0:0	4	++
stmts	206:40	210:4	3	
water	206:40	0:0	4	{
call	207:8	207:47	4	bytestream2_get_bufferu
arg	207:32	207:35	5	&gb
op	207:32	0:0	6	&
water	207:33	0:0	6	gb
arg	207:37	207:40	5	ptr
water	207:37	0:0	6	ptr
arg	207:42	207:47	5	rsize
water	207:42	0:0	6	rsize
water	207:48	0:0	4	;
call	208:8	208:44	4	bytestream2_skipu
arg	208:26	208:29	5	&gb
op	208:26	0:0	6	&
water	208:27	0:0	6	gb
arg	208:31	208:44	5	lsize-rsize
water	208:31	0:0	6	lsize
op	208:37	0:0	6	-
water	208:39	0:0	6	rsize
water	208:45	0:0	4	;
water	209:8	0:0	4	ptr
op	209:12	0:0	4	+=
water	209:15	0:0	4	p
op	209:16	0:0	4	->
water	209:18	0:0	4	linesize
op	209:26	0:0	4	[
water	209:27	0:0	4	0
op	209:28	0:0	4	]
water	209:29	0:0	4	;
water	210:4	0:0	4	}
op	212:4	0:0	2	*
water	212:5	0:0	2	got_frame
op	212:21	0:0	2	=
water	212:23	0:0	2	1
water	212:24	0:0	2	;
return	214:4	214:19	2	buf_size
water	214:11	0:0	3	buf_size
