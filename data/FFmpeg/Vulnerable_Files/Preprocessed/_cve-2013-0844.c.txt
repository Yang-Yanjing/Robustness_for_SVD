func	2:0	689:0	0	static int	adpcm_decode_frame
params	2:29	0:0	1	
param	2:30	2:51	2	AVCodecContext *	avctx
param	2:53	2:63	2	void *	data
param	3:30	3:48	2	int *	got_frame_ptr
param	3:50	3:65	2	AVPacket *	avpkt
stmnts	0:0	688:20	1	
decl	5:4	5:36	2	const uint8_t	*buf
op	5:23	0:0	2	=
water	5:25	0:0	2	avpkt
op	5:30	0:0	2	->
water	5:32	0:0	2	data
decl	6:4	6:30	2	int	buf_size
op	6:17	0:0	2	=
water	6:19	0:0	2	avpkt
op	6:24	0:0	2	->
water	6:26	0:0	2	size
decl	7:4	7:44	2	ADPCMDecodeContext	*c
op	7:26	0:0	2	=
water	7:28	0:0	2	avctx
op	7:33	0:0	2	->
water	7:35	0:0	2	priv_data
decl	8:4	8:26	2	ADPCMChannelStatus	*cs
decl	9:4	9:24	2	int	n
water	9:9	0:0	2	,
decl	9:4	9:24	2	int	m
water	9:12	0:0	2	,
decl	9:4	9:24	2	int	channel
water	9:21	0:0	2	,
decl	9:4	9:24	2	int	i
decl	10:4	10:18	2	short	*samples
decl	11:4	11:22	2	const uint8_t	*src
decl	12:4	12:10	2	int	st
decl	13:4	13:22	2	int	count1
water	13:14	0:0	2	,
decl	13:4	13:22	2	int	count2
decl	14:4	14:38	2	int	nb_samples
water	14:18	0:0	2	,
decl	14:4	14:38	2	int	coded_samples
water	14:33	0:0	2	,
decl	14:4	14:38	2	int	ret
water	16:4	0:0	2	nb_samples
op	16:15	0:0	2	=
call	16:17	16:68	2	get_nb_samples
arg	16:32	16:37	3	avctx
water	16:32	0:0	4	avctx
arg	16:39	16:42	3	buf
water	16:39	0:0	4	buf
arg	16:44	16:52	3	buf_size
water	16:44	0:0	4	buf_size
arg	16:54	16:68	3	&coded_samples
op	16:54	0:0	4	&
water	16:55	0:0	4	coded_samples
water	16:69	0:0	2	;
if	17:4	20:4	2	(nb_samples <= 0)
cond	17:8	17:22	3	nb_samples <= 0
water	17:8	0:0	4	nb_samples
op	17:19	0:0	4	<=
water	17:22	0:0	4	0
stmts	17:25	20:4	3	
water	17:25	0:0	4	{
call	18:8	18:75	4	av_log
arg	18:15	18:20	5	avctx
water	18:15	0:0	6	avctx
arg	18:22	18:34	5	AV_LOG_ERROR
water	18:22	0:0	6	AV_LOG_ERROR
arg	18:36	18:75	5	"invalid number of samples in packet\n"
water	18:36	0:0	6	"invalid number of samples in packet\n"
water	18:76	0:0	4	;
return	19:8	19:34	4	AVERROR_INVALIDDATA
water	19:15	0:0	5	AVERROR_INVALIDDATA
water	20:4	0:0	4	}
water	23:4	0:0	2	c
op	23:5	0:0	2	->
water	23:7	0:0	2	frame
op	23:12	0:0	2	.
water	23:13	0:0	2	nb_samples
op	23:24	0:0	2	=
water	23:26	0:0	2	nb_samples
water	23:36	0:0	2	;
if	24:4	27:4	2	(( ret =avctx -> get_buffer (avctx ,& c -> frame ) ) < 0)
cond	24:8	24:54	3	( ret =avctx -> get_buffer (avctx ,& c -> frame ) ) < 0
water	24:8	0:0	4	(
water	24:9	0:0	4	ret
op	24:13	0:0	4	=
call	24:15	24:49	4	avctx->get_buffer
arg	24:33	24:38	5	avctx
water	24:33	0:0	6	avctx
arg	24:40	24:49	5	&c->frame
op	24:40	0:0	6	&
water	24:41	0:0	6	c
op	24:42	0:0	6	->
water	24:44	0:0	6	frame
water	24:50	0:0	4	)
op	24:52	0:0	4	<
water	24:54	0:0	4	0
stmts	24:57	27:4	3	
water	24:57	0:0	4	{
call	25:8	25:59	4	av_log
arg	25:15	25:20	5	avctx
water	25:15	0:0	6	avctx
arg	25:22	25:34	5	AV_LOG_ERROR
water	25:22	0:0	6	AV_LOG_ERROR
arg	25:36	25:59	5	"get_buffer() failed\n"
water	25:36	0:0	6	"get_buffer() failed\n"
water	25:60	0:0	4	;
return	26:8	26:18	4	ret
water	26:15	0:0	5	ret
water	27:4	0:0	4	}
water	28:4	0:0	2	samples
op	28:12	0:0	2	=
water	28:14	0:0	2	(
water	28:15	0:0	2	short
op	28:21	0:0	2	*
water	28:22	0:0	2	)
water	28:23	0:0	2	c
op	28:24	0:0	2	->
water	28:26	0:0	2	frame
op	28:31	0:0	2	.
water	28:32	0:0	2	data
op	28:36	0:0	2	[
water	28:37	0:0	2	0
op	28:38	0:0	2	]
water	28:39	0:0	2	;
if	32:4	36:4	2	(coded_samples)
cond	32:8	32:8	3	coded_samples
water	32:8	0:0	4	coded_samples
stmts	32:23	36:4	3	
water	32:23	0:0	4	{
if	33:8	34:77	4	(coded_samples != nb_samples)
cond	33:12	33:29	5	coded_samples != nb_samples
water	33:12	0:0	6	coded_samples
op	33:26	0:0	6	!=
water	33:29	0:0	6	nb_samples
stmts	34:12	34:77	5	
call	34:12	34:76	6	av_log
arg	34:19	34:24	7	avctx
water	34:19	0:0	8	avctx
arg	34:26	34:40	7	AV_LOG_WARNING
water	34:26	0:0	8	AV_LOG_WARNING
arg	34:42	34:76	7	"mismatch in coded sample count\n"
water	34:42	0:0	8	"mismatch in coded sample count\n"
water	34:77	0:0	6	;
water	35:8	0:0	4	c
op	35:9	0:0	4	->
water	35:11	0:0	4	frame
op	35:16	0:0	4	.
water	35:17	0:0	4	nb_samples
op	35:28	0:0	4	=
water	35:30	0:0	4	nb_samples
op	35:41	0:0	4	=
water	35:43	0:0	4	coded_samples
water	35:56	0:0	4	;
water	36:4	0:0	4	}
water	38:4	0:0	2	src
op	38:8	0:0	2	=
water	38:10	0:0	2	buf
water	38:13	0:0	2	;
water	40:4	0:0	2	st
op	40:7	0:0	2	=
water	40:9	0:0	2	avctx
op	40:14	0:0	2	->
water	40:16	0:0	2	channels
op	40:25	0:0	2	==
water	40:28	0:0	2	2
water	40:30	0:0	2	?
water	40:32	0:0	2	1
water	40:34	0:0	2	:
water	40:36	0:0	2	0
water	40:37	0:0	2	;
switch	42:4	683:4	2	(avctx -> codec -> id)
cond	42:11	42:25	3	avctx -> codec -> id
water	42:11	0:0	4	avctx
op	42:16	0:0	4	->
water	42:18	0:0	4	codec
op	42:23	0:0	4	->
water	42:25	0:0	4	id
stmts	42:29	683:4	3	
water	42:29	0:0	4	{
label	43:4	43:30	4	case CODEC_ID_ADPCM_IMA_QT :
for	46:8	85:8	4	(channel = 0 ;channel < avctx -> channels;channel ++)
forinit	46:13	46:24	5	channel = 0 ;
water	46:13	0:0	6	channel
op	46:21	0:0	6	=
water	46:23	0:0	6	0
water	46:24	0:0	6	;
cond	46:26	46:43	5	channel < avctx -> channels
water	46:26	0:0	6	channel
op	46:34	0:0	6	<
water	46:36	0:0	6	avctx
op	46:41	0:0	6	->
water	46:43	0:0	6	channels
forexpr	46:53	46:60	5	channel ++
water	46:53	0:0	6	channel
op	46:60	0:0	6	++
stmts	46:64	85:8	5	
water	46:64	0:0	6	{
decl	47:12	47:29	6	int16_t	predictor
decl	48:12	48:26	6	int	step_index
water	49:12	0:0	6	cs
op	49:15	0:0	6	=
op	49:17	0:0	6	&
water	49:18	0:0	6	(
water	49:19	0:0	6	c
op	49:20	0:0	6	->
water	49:22	0:0	6	status
op	49:28	0:0	6	[
water	49:29	0:0	6	channel
op	49:36	0:0	6	]
water	49:37	0:0	6	)
water	49:38	0:0	6	;
water	53:12	0:0	6	predictor
op	53:22	0:0	6	=
call	53:24	53:35	6	AV_RB16
arg	53:32	53:35	7	src
water	53:32	0:0	8	src
water	53:36	0:0	6	;
water	54:12	0:0	6	step_index
op	54:23	0:0	6	=
water	54:25	0:0	6	predictor
op	54:35	0:0	6	&
water	54:37	0:0	6	0
water	54:38	0:0	6	x7F
water	54:41	0:0	6	;
water	55:12	0:0	6	predictor
op	55:22	0:0	6	&=
water	55:25	0:0	6	0
water	55:26	0:0	6	xFF80
water	55:31	0:0	6	;
water	57:12	0:0	6	src
op	57:16	0:0	6	+=
water	57:19	0:0	6	2
water	57:20	0:0	6	;
if	59:12	65:12	6	(cs -> step_index == step_index)
cond	59:16	59:34	7	cs -> step_index == step_index
water	59:16	0:0	8	cs
op	59:18	0:0	8	->
water	59:20	0:0	8	step_index
op	59:31	0:0	8	==
water	59:34	0:0	8	step_index
stmts	59:46	65:12	7	
water	59:46	0:0	8	{
decl	60:16	60:57	8	int	diff
op	60:25	0:0	8	=
water	60:27	0:0	8	(
water	60:28	0:0	8	int
water	60:31	0:0	8	)
water	60:32	0:0	8	predictor
op	60:42	0:0	8	-
water	60:44	0:0	8	cs
op	60:46	0:0	8	->
water	60:48	0:0	8	predictor
if	61:16	62:33	8	(diff < 0)
cond	61:20	61:27	9	diff < 0
water	61:20	0:0	10	diff
op	61:25	0:0	10	<
water	61:27	0:0	10	0
stmts	62:20	62:33	9	
water	62:20	0:0	10	diff
op	62:25	0:0	10	=
op	62:27	0:0	10	-
water	62:29	0:0	10	diff
water	62:33	0:0	10	;
if	63:16	64:31	8	(diff > 0 x7f)
cond	63:20	63:28	9	diff > 0 x7f
water	63:20	0:0	10	diff
op	63:25	0:0	10	>
water	63:27	0:0	10	0
water	63:28	0:0	10	x7f
stmts	64:20	64:31	9	
goto	64:20	64:31	10	update
water	64:25	0:0	11	update
water	65:12	0:0	8	}
else	65:14	69:12	6
stmts	65:19	69:12	7	
water	65:19	0:0	8	{
label	66:12	66:18	8	update :
water	67:16	0:0	8	cs
op	67:18	0:0	8	->
water	67:20	0:0	8	step_index
op	67:31	0:0	8	=
water	67:33	0:0	8	step_index
water	67:43	0:0	8	;
water	68:16	0:0	8	cs
op	68:18	0:0	8	->
water	68:20	0:0	8	predictor
op	68:30	0:0	8	=
water	68:32	0:0	8	predictor
water	68:41	0:0	8	;
water	69:12	0:0	8	}
if	71:12	74:12	6	(cs -> step_index > 88)
cond	71:16	71:33	7	cs -> step_index > 88
water	71:16	0:0	8	cs
op	71:18	0:0	8	->
water	71:20	0:0	8	step_index
op	71:31	0:0	8	>
water	71:33	0:0	8	88
stmts	71:36	74:12	7	
water	71:36	0:0	8	{
call	72:16	72:86	8	av_log
arg	72:23	72:28	9	avctx
water	72:23	0:0	10	avctx
arg	72:30	72:42	9	AV_LOG_ERROR
water	72:30	0:0	10	AV_LOG_ERROR
arg	72:44	72:70	9	"ERROR: step_index = %i\n"
water	72:44	0:0	10	"ERROR: step_index = %i\n"
arg	72:72	72:86	9	cs->step_index
water	72:72	0:0	10	cs
op	72:74	0:0	10	->
water	72:76	0:0	10	step_index
water	72:87	0:0	8	;
water	73:16	0:0	8	cs
op	73:18	0:0	8	->
water	73:20	0:0	8	step_index
op	73:31	0:0	8	=
water	73:33	0:0	8	88
water	73:35	0:0	8	;
water	74:12	0:0	8	}
water	76:12	0:0	6	samples
op	76:20	0:0	6	=
water	76:22	0:0	6	(
water	76:23	0:0	6	short
op	76:29	0:0	6	*
water	76:30	0:0	6	)
water	76:31	0:0	6	c
op	76:32	0:0	6	->
water	76:34	0:0	6	frame
op	76:39	0:0	6	.
water	76:40	0:0	6	data
op	76:44	0:0	6	[
water	76:45	0:0	6	0
op	76:46	0:0	6	]
op	76:48	0:0	6	+
water	76:50	0:0	6	channel
water	76:57	0:0	6	;
for	78:12	84:12	6	(m = 0 ;m < 32;m ++)
forinit	78:17	78:22	7	m = 0 ;
water	78:17	0:0	8	m
op	78:19	0:0	8	=
water	78:21	0:0	8	0
water	78:22	0:0	8	;
cond	78:24	78:28	7	m < 32
water	78:24	0:0	8	m
op	78:26	0:0	8	<
water	78:28	0:0	8	32
forexpr	78:32	78:33	7	m ++
water	78:32	0:0	8	m
op	78:33	0:0	8	++
stmts	78:37	84:12	7	
water	78:37	0:0	8	{
op	79:16	0:0	8	*
water	79:17	0:0	8	samples
op	79:25	0:0	8	=
call	79:27	79:74	8	adpcm_ima_qt_expand_nibble
arg	79:54	79:56	9	cs
water	79:54	0:0	10	cs
arg	79:58	79:71	9	src[0]&0x0F
water	79:58	0:0	10	src
op	79:61	0:0	10	[
water	79:62	0:0	10	0
op	79:63	0:0	10	]
op	79:65	0:0	10	&
water	79:67	0:0	10	0
water	79:68	0:0	10	x0F
arg	79:73	79:74	9	3
water	79:73	0:0	10	3
water	79:75	0:0	8	;
water	80:16	0:0	8	samples
op	80:24	0:0	8	+=
water	80:27	0:0	8	avctx
op	80:32	0:0	8	->
water	80:34	0:0	8	channels
water	80:42	0:0	8	;
op	81:16	0:0	8	*
water	81:17	0:0	8	samples
op	81:25	0:0	8	=
call	81:27	81:74	8	adpcm_ima_qt_expand_nibble
arg	81:54	81:56	9	cs
water	81:54	0:0	10	cs
arg	81:58	81:71	9	src[0]>>4
water	81:58	0:0	10	src
op	81:61	0:0	10	[
water	81:62	0:0	10	0
op	81:63	0:0	10	]
op	81:65	0:0	10	>>
water	81:68	0:0	10	4
arg	81:73	81:74	9	3
water	81:73	0:0	10	3
water	81:75	0:0	8	;
water	82:16	0:0	8	samples
op	82:24	0:0	8	+=
water	82:27	0:0	8	avctx
op	82:32	0:0	8	->
water	82:34	0:0	8	channels
water	82:42	0:0	8	;
water	83:16	0:0	8	src
op	83:20	0:0	8	++
water	83:22	0:0	8	;
water	84:12	0:0	8	}
water	85:8	0:0	6	}
break	86:8	86:13	4	
label	87:4	87:31	4	case CODEC_ID_ADPCM_IMA_WAV :
if	88:8	89:41	4	(avctx -> block_align != 0 && buf_size > avctx -> block_align)
cond	88:12	88:57	5	avctx -> block_align != 0 && buf_size > avctx -> block_align
water	88:12	0:0	6	avctx
op	88:17	0:0	6	->
water	88:19	0:0	6	block_align
op	88:31	0:0	6	!=
water	88:34	0:0	6	0
op	88:36	0:0	6	&&
water	88:39	0:0	6	buf_size
op	88:48	0:0	6	>
water	88:50	0:0	6	avctx
op	88:55	0:0	6	->
water	88:57	0:0	6	block_align
stmts	89:12	89:41	5	
water	89:12	0:0	6	buf_size
op	89:21	0:0	6	=
water	89:23	0:0	6	avctx
op	89:28	0:0	6	->
water	89:30	0:0	6	block_align
water	89:41	0:0	6	;
for	91:8	101:8	4	(i = 0 ;i < avctx -> channels;i ++)
forinit	91:12	91:15	5	i = 0 ;
water	91:12	0:0	6	i
op	91:13	0:0	6	=
water	91:14	0:0	6	0
water	91:15	0:0	6	;
cond	91:17	91:26	5	i < avctx -> channels
water	91:17	0:0	6	i
op	91:18	0:0	6	<
water	91:19	0:0	6	avctx
op	91:24	0:0	6	->
water	91:26	0:0	6	channels
forexpr	91:36	91:37	5	i ++
water	91:36	0:0	6	i
op	91:37	0:0	6	++
stmts	91:40	101:8	5	
water	91:40	0:0	6	{
water	92:12	0:0	6	cs
op	92:15	0:0	6	=
op	92:17	0:0	6	&
water	92:18	0:0	6	(
water	92:19	0:0	6	c
op	92:20	0:0	6	->
water	92:22	0:0	6	status
op	92:28	0:0	6	[
water	92:29	0:0	6	i
op	92:30	0:0	6	]
water	92:31	0:0	6	)
water	92:32	0:0	6	;
water	93:12	0:0	6	cs
op	93:14	0:0	6	->
water	93:16	0:0	6	predictor
op	93:26	0:0	6	=
op	93:28	0:0	6	*
water	93:29	0:0	6	samples
op	93:36	0:0	6	++
op	93:39	0:0	6	=
water	93:41	0:0	6	(
water	93:42	0:0	6	int16_t
water	93:49	0:0	6	)
call	93:50	93:74	6	bytestream_get_le16
arg	93:70	93:74	7	&src
op	93:70	0:0	8	&
water	93:71	0:0	8	src
water	93:75	0:0	6	;
water	95:12	0:0	6	cs
op	95:14	0:0	6	->
water	95:16	0:0	6	step_index
op	95:27	0:0	6	=
op	95:29	0:0	6	*
water	95:30	0:0	6	src
op	95:33	0:0	6	++
water	95:35	0:0	6	;
if	96:12	99:12	6	(cs -> step_index > 88)
cond	96:16	96:33	7	cs -> step_index > 88
water	96:16	0:0	8	cs
op	96:18	0:0	8	->
water	96:20	0:0	8	step_index
op	96:31	0:0	8	>
water	96:33	0:0	8	88
stmts	96:36	99:12	7	
water	96:36	0:0	8	{
call	97:16	97:86	8	av_log
arg	97:23	97:28	9	avctx
water	97:23	0:0	10	avctx
arg	97:30	97:42	9	AV_LOG_ERROR
water	97:30	0:0	10	AV_LOG_ERROR
arg	97:44	97:70	9	"ERROR: step_index = %i\n"
water	97:44	0:0	10	"ERROR: step_index = %i\n"
arg	97:72	97:86	9	cs->step_index
water	97:72	0:0	10	cs
op	97:74	0:0	10	->
water	97:76	0:0	10	step_index
water	97:87	0:0	8	;
water	98:16	0:0	8	cs
op	98:18	0:0	8	->
water	98:20	0:0	8	step_index
op	98:31	0:0	8	=
water	98:33	0:0	8	88
water	98:35	0:0	8	;
water	99:12	0:0	8	}
if	100:12	100:104	6	(* src ++)
cond	100:16	100:20	7	* src ++
op	100:16	0:0	8	*
water	100:17	0:0	8	src
op	100:20	0:0	8	++
stmts	100:24	100:104	7	
call	100:24	100:103	8	av_log
arg	100:31	100:36	9	avctx
water	100:31	0:0	10	avctx
arg	100:38	100:50	9	AV_LOG_ERROR
water	100:38	0:0	10	AV_LOG_ERROR
arg	100:52	100:94	9	"unused byte should be null but is %d!!\n"
water	100:52	0:0	10	"unused byte should be null but is %d!!\n"
arg	100:96	100:103	9	src[-1]
water	100:96	0:0	10	src
op	100:99	0:0	10	[
op	100:100	0:0	10	-
water	100:101	0:0	10	1
op	100:102	0:0	10	]
water	100:104	0:0	8	;
water	101:8	0:0	6	}
for	103:8	116:8	4	(n = ( nb_samples - 1 ) / 8 ;n > 0;n --)
forinit	103:13	103:37	5	n = ( nb_samples - 1 ) / 8 ;
water	103:13	0:0	6	n
op	103:15	0:0	6	=
water	103:17	0:0	6	(
water	103:18	0:0	6	nb_samples
op	103:29	0:0	6	-
water	103:31	0:0	6	1
water	103:32	0:0	6	)
op	103:34	0:0	6	/
water	103:36	0:0	6	8
water	103:37	0:0	6	;
cond	103:39	103:43	5	n > 0
water	103:39	0:0	6	n
op	103:41	0:0	6	>
water	103:43	0:0	6	0
forexpr	103:46	103:47	5	n --
water	103:46	0:0	6	n
op	103:47	0:0	6	--
stmts	103:51	116:8	5	
water	103:51	0:0	6	{
for	104:12	114:12	6	(i = 0 ;i < avctx -> channels;i ++)
forinit	104:17	104:22	7	i = 0 ;
water	104:17	0:0	8	i
op	104:19	0:0	8	=
water	104:21	0:0	8	0
water	104:22	0:0	8	;
cond	104:24	104:35	7	i < avctx -> channels
water	104:24	0:0	8	i
op	104:26	0:0	8	<
water	104:28	0:0	8	avctx
op	104:33	0:0	8	->
water	104:35	0:0	8	channels
forexpr	104:45	104:46	7	i ++
water	104:45	0:0	8	i
op	104:46	0:0	8	++
stmts	104:50	114:12	7	
water	104:50	0:0	8	{
water	105:16	0:0	8	cs
op	105:19	0:0	8	=
op	105:21	0:0	8	&
water	105:22	0:0	8	c
op	105:23	0:0	8	->
water	105:25	0:0	8	status
op	105:31	0:0	8	[
water	105:32	0:0	8	i
op	105:33	0:0	8	]
water	105:34	0:0	8	;
for	106:16	112:16	8	(m = 0 ;m < 4;m ++)
forinit	106:21	106:26	9	m = 0 ;
water	106:21	0:0	10	m
op	106:23	0:0	10	=
water	106:25	0:0	10	0
water	106:26	0:0	10	;
cond	106:28	106:32	9	m < 4
water	106:28	0:0	10	m
op	106:30	0:0	10	<
water	106:32	0:0	10	4
forexpr	106:35	106:36	9	m ++
water	106:35	0:0	10	m
op	106:36	0:0	10	++
stmts	106:40	112:16	9	
water	106:40	0:0	10	{
decl	107:20	107:38	10	uint8_t	v
op	107:30	0:0	10	=
op	107:32	0:0	10	*
water	107:33	0:0	10	src
op	107:36	0:0	10	++
op	108:20	0:0	10	*
water	108:21	0:0	10	samples
op	108:29	0:0	10	=
call	108:31	108:70	10	adpcm_ima_expand_nibble
arg	108:55	108:57	11	cs
water	108:55	0:0	12	cs
arg	108:59	108:67	11	v&0x0F
water	108:59	0:0	12	v
op	108:61	0:0	12	&
water	108:63	0:0	12	0
water	108:64	0:0	12	x0F
arg	108:69	108:70	11	3
water	108:69	0:0	12	3
water	108:71	0:0	10	;
water	109:20	0:0	10	samples
op	109:28	0:0	10	+=
water	109:31	0:0	10	avctx
op	109:36	0:0	10	->
water	109:38	0:0	10	channels
water	109:46	0:0	10	;
op	110:20	0:0	10	*
water	110:21	0:0	10	samples
op	110:29	0:0	10	=
call	110:31	110:70	10	adpcm_ima_expand_nibble
arg	110:55	110:57	11	cs
water	110:55	0:0	12	cs
arg	110:59	110:67	11	v>>4
water	110:59	0:0	12	v
op	110:61	0:0	12	>>
water	110:64	0:0	12	4
arg	110:69	110:70	11	3
water	110:69	0:0	12	3
water	110:71	0:0	10	;
water	111:20	0:0	10	samples
op	111:28	0:0	10	+=
water	111:31	0:0	10	avctx
op	111:36	0:0	10	->
water	111:38	0:0	10	channels
water	111:46	0:0	10	;
water	112:16	0:0	10	}
water	113:16	0:0	8	samples
op	113:24	0:0	8	-=
water	113:27	0:0	8	8
op	113:29	0:0	8	*
water	113:31	0:0	8	avctx
op	113:36	0:0	8	->
water	113:38	0:0	8	channels
op	113:47	0:0	8	-
water	113:49	0:0	8	1
water	113:50	0:0	8	;
water	114:12	0:0	8	}
water	115:12	0:0	6	samples
op	115:20	0:0	6	+=
water	115:23	0:0	6	7
op	115:25	0:0	6	*
water	115:27	0:0	6	avctx
op	115:32	0:0	6	->
water	115:34	0:0	6	channels
water	115:42	0:0	6	;
water	116:8	0:0	6	}
break	117:8	117:13	4	
label	118:4	118:27	4	case CODEC_ID_ADPCM_4XM :
for	119:8	120:70	4	(i = 0 ;i < avctx -> channels;i ++)
forinit	119:13	119:18	5	i = 0 ;
water	119:13	0:0	6	i
op	119:15	0:0	6	=
water	119:17	0:0	6	0
water	119:18	0:0	6	;
cond	119:20	119:31	5	i < avctx -> channels
water	119:20	0:0	6	i
op	119:22	0:0	6	<
water	119:24	0:0	6	avctx
op	119:29	0:0	6	->
water	119:31	0:0	6	channels
forexpr	119:41	119:42	5	i ++
water	119:41	0:0	6	i
op	119:42	0:0	6	++
stmts	120:12	120:70	5	
water	120:12	0:0	6	c
op	120:13	0:0	6	->
water	120:15	0:0	6	status
op	120:21	0:0	6	[
water	120:22	0:0	6	i
op	120:23	0:0	6	]
op	120:24	0:0	6	.
water	120:25	0:0	6	predictor
op	120:34	0:0	6	=
water	120:36	0:0	6	(
water	120:37	0:0	6	int16_t
water	120:44	0:0	6	)
call	120:45	120:69	6	bytestream_get_le16
arg	120:65	120:69	7	&src
op	120:65	0:0	8	&
water	120:66	0:0	8	src
water	120:70	0:0	6	;
for	122:8	125:8	4	(i = 0 ;i < avctx -> channels;i ++)
forinit	122:13	122:18	5	i = 0 ;
water	122:13	0:0	6	i
op	122:15	0:0	6	=
water	122:17	0:0	6	0
water	122:18	0:0	6	;
cond	122:20	122:31	5	i < avctx -> channels
water	122:20	0:0	6	i
op	122:22	0:0	6	<
water	122:24	0:0	6	avctx
op	122:29	0:0	6	->
water	122:31	0:0	6	channels
forexpr	122:41	122:42	5	i ++
water	122:41	0:0	6	i
op	122:42	0:0	6	++
stmts	122:46	125:8	5	
water	122:46	0:0	6	{
water	123:12	0:0	6	c
op	123:13	0:0	6	->
water	123:15	0:0	6	status
op	123:21	0:0	6	[
water	123:22	0:0	6	i
op	123:23	0:0	6	]
op	123:24	0:0	6	.
water	123:25	0:0	6	step_index
op	123:35	0:0	6	=
water	123:37	0:0	6	(
water	123:38	0:0	6	int16_t
water	123:45	0:0	6	)
call	123:46	123:70	6	bytestream_get_le16
arg	123:66	123:70	7	&src
op	123:66	0:0	8	&
water	123:67	0:0	8	src
water	123:71	0:0	6	;
water	124:12	0:0	6	c
op	124:13	0:0	6	->
water	124:15	0:0	6	status
op	124:21	0:0	6	[
water	124:22	0:0	6	i
op	124:23	0:0	6	]
op	124:24	0:0	6	.
water	124:25	0:0	6	step_index
op	124:36	0:0	6	=
call	124:38	124:76	6	av_clip
arg	124:46	124:69	7	c->status[i].step_index
water	124:46	0:0	8	c
op	124:47	0:0	8	->
water	124:49	0:0	8	status
op	124:55	0:0	8	[
water	124:56	0:0	8	i
op	124:57	0:0	8	]
op	124:58	0:0	8	.
water	124:59	0:0	8	step_index
arg	124:71	124:72	7	0
water	124:71	0:0	8	0
arg	124:74	124:76	7	88
water	124:74	0:0	8	88
water	124:77	0:0	6	;
water	125:8	0:0	6	}
for	127:8	137:8	4	(i = 0 ;i < avctx -> channels;i ++)
forinit	127:13	127:18	5	i = 0 ;
water	127:13	0:0	6	i
op	127:15	0:0	6	=
water	127:17	0:0	6	0
water	127:18	0:0	6	;
cond	127:20	127:31	5	i < avctx -> channels
water	127:20	0:0	6	i
op	127:22	0:0	6	<
water	127:24	0:0	6	avctx
op	127:29	0:0	6	->
water	127:31	0:0	6	channels
forexpr	127:41	127:42	5	i ++
water	127:41	0:0	6	i
op	127:42	0:0	6	++
stmts	127:46	137:8	5	
water	127:46	0:0	6	{
water	128:12	0:0	6	samples
op	128:20	0:0	6	=
water	128:22	0:0	6	(
water	128:23	0:0	6	short
op	128:29	0:0	6	*
water	128:30	0:0	6	)
water	128:31	0:0	6	c
op	128:32	0:0	6	->
water	128:34	0:0	6	frame
op	128:39	0:0	6	.
water	128:40	0:0	6	data
op	128:44	0:0	6	[
water	128:45	0:0	6	0
op	128:46	0:0	6	]
op	128:48	0:0	6	+
water	128:50	0:0	6	i
water	128:51	0:0	6	;
water	129:12	0:0	6	cs
op	129:15	0:0	6	=
op	129:17	0:0	6	&
water	129:18	0:0	6	c
op	129:19	0:0	6	->
water	129:21	0:0	6	status
op	129:27	0:0	6	[
water	129:28	0:0	6	i
op	129:29	0:0	6	]
water	129:30	0:0	6	;
for	130:12	136:12	6	(n = nb_samples >> 1 ;n > 0;n -- , src ++)
forinit	130:17	130:36	7	n = nb_samples >> 1 ;
water	130:17	0:0	8	n
op	130:19	0:0	8	=
water	130:21	0:0	8	nb_samples
op	130:32	0:0	8	>>
water	130:35	0:0	8	1
water	130:36	0:0	8	;
cond	130:38	130:42	7	n > 0
water	130:38	0:0	8	n
op	130:40	0:0	8	>
water	130:42	0:0	8	0
forexpr	130:45	130:53	7	n -- , src ++
water	130:45	0:0	8	n
op	130:46	0:0	8	--
water	130:48	0:0	8	,
water	130:50	0:0	8	src
op	130:53	0:0	8	++
stmts	130:57	136:12	7	
water	130:57	0:0	8	{
decl	131:16	131:32	8	uint8_t	v
op	131:26	0:0	8	=
op	131:28	0:0	8	*
water	131:29	0:0	8	src
op	132:16	0:0	8	*
water	132:17	0:0	8	samples
op	132:25	0:0	8	=
call	132:27	132:66	8	adpcm_ima_expand_nibble
arg	132:51	132:53	9	cs
water	132:51	0:0	10	cs
arg	132:55	132:63	9	v&0x0F
water	132:55	0:0	10	v
op	132:57	0:0	10	&
water	132:59	0:0	10	0
water	132:60	0:0	10	x0F
arg	132:65	132:66	9	4
water	132:65	0:0	10	4
water	132:67	0:0	8	;
water	133:16	0:0	8	samples
op	133:24	0:0	8	+=
water	133:27	0:0	8	avctx
op	133:32	0:0	8	->
water	133:34	0:0	8	channels
water	133:42	0:0	8	;
op	134:16	0:0	8	*
water	134:17	0:0	8	samples
op	134:25	0:0	8	=
call	134:27	134:66	8	adpcm_ima_expand_nibble
arg	134:51	134:53	9	cs
water	134:51	0:0	10	cs
arg	134:55	134:63	9	v>>4
water	134:55	0:0	10	v
op	134:57	0:0	10	>>
water	134:60	0:0	10	4
arg	134:65	134:66	9	4
water	134:65	0:0	10	4
water	134:67	0:0	8	;
water	135:16	0:0	8	samples
op	135:24	0:0	8	+=
water	135:27	0:0	8	avctx
op	135:32	0:0	8	->
water	135:34	0:0	8	channels
water	135:42	0:0	8	;
water	136:12	0:0	8	}
water	137:8	0:0	6	}
break	138:8	138:13	4	
label	139:4	139:26	4	case CODEC_ID_ADPCM_MS :
water	140:4	0:0	4	{
decl	141:8	141:27	4	int	block_predictor
if	143:8	144:41	4	(avctx -> block_align != 0 && buf_size > avctx -> block_align)
cond	143:12	143:57	5	avctx -> block_align != 0 && buf_size > avctx -> block_align
water	143:12	0:0	6	avctx
op	143:17	0:0	6	->
water	143:19	0:0	6	block_align
op	143:31	0:0	6	!=
water	143:34	0:0	6	0
op	143:36	0:0	6	&&
water	143:39	0:0	6	buf_size
op	143:48	0:0	6	>
water	143:50	0:0	6	avctx
op	143:55	0:0	6	->
water	143:57	0:0	6	block_align
stmts	144:12	144:41	5	
water	144:12	0:0	6	buf_size
op	144:21	0:0	6	=
water	144:23	0:0	6	avctx
op	144:28	0:0	6	->
water	144:30	0:0	6	block_align
water	144:41	0:0	6	;
water	146:8	0:0	4	block_predictor
op	146:24	0:0	4	=
call	146:26	146:46	4	av_clip
arg	146:34	146:40	5	*src++
op	146:34	0:0	6	*
water	146:35	0:0	6	src
op	146:38	0:0	6	++
arg	146:42	146:43	5	0
water	146:42	0:0	6	0
arg	146:45	146:46	5	6
water	146:45	0:0	6	6
water	146:47	0:0	4	;
water	147:8	0:0	4	c
op	147:9	0:0	4	->
water	147:11	0:0	4	status
op	147:17	0:0	4	[
water	147:18	0:0	4	0
op	147:19	0:0	4	]
op	147:20	0:0	4	.
water	147:21	0:0	4	coeff1
op	147:28	0:0	4	=
water	147:30	0:0	4	ff_adpcm_AdaptCoeff1
op	147:50	0:0	4	[
water	147:51	0:0	4	block_predictor
op	147:66	0:0	4	]
water	147:67	0:0	4	;
water	148:8	0:0	4	c
op	148:9	0:0	4	->
water	148:11	0:0	4	status
op	148:17	0:0	4	[
water	148:18	0:0	4	0
op	148:19	0:0	4	]
op	148:20	0:0	4	.
water	148:21	0:0	4	coeff2
op	148:28	0:0	4	=
water	148:30	0:0	4	ff_adpcm_AdaptCoeff2
op	148:50	0:0	4	[
water	148:51	0:0	4	block_predictor
op	148:66	0:0	4	]
water	148:67	0:0	4	;
if	149:8	153:8	4	(st)
cond	149:12	149:12	5	st
water	149:12	0:0	6	st
stmts	149:16	153:8	5	
water	149:16	0:0	6	{
water	150:12	0:0	6	block_predictor
op	150:28	0:0	6	=
call	150:30	150:50	6	av_clip
arg	150:38	150:44	7	*src++
op	150:38	0:0	8	*
water	150:39	0:0	8	src
op	150:42	0:0	8	++
arg	150:46	150:47	7	0
water	150:46	0:0	8	0
arg	150:49	150:50	7	6
water	150:49	0:0	8	6
water	150:51	0:0	6	;
water	151:12	0:0	6	c
op	151:13	0:0	6	->
water	151:15	0:0	6	status
op	151:21	0:0	6	[
water	151:22	0:0	6	1
op	151:23	0:0	6	]
op	151:24	0:0	6	.
water	151:25	0:0	6	coeff1
op	151:32	0:0	6	=
water	151:34	0:0	6	ff_adpcm_AdaptCoeff1
op	151:54	0:0	6	[
water	151:55	0:0	6	block_predictor
op	151:70	0:0	6	]
water	151:71	0:0	6	;
water	152:12	0:0	6	c
op	152:13	0:0	6	->
water	152:15	0:0	6	status
op	152:21	0:0	6	[
water	152:22	0:0	6	1
op	152:23	0:0	6	]
op	152:24	0:0	6	.
water	152:25	0:0	6	coeff2
op	152:32	0:0	6	=
water	152:34	0:0	6	ff_adpcm_AdaptCoeff2
op	152:54	0:0	6	[
water	152:55	0:0	6	block_predictor
op	152:70	0:0	6	]
water	152:71	0:0	6	;
water	153:8	0:0	6	}
water	154:8	0:0	4	c
op	154:9	0:0	4	->
water	154:11	0:0	4	status
op	154:17	0:0	4	[
water	154:18	0:0	4	0
op	154:19	0:0	4	]
op	154:20	0:0	4	.
water	154:21	0:0	4	idelta
op	154:28	0:0	4	=
water	154:30	0:0	4	(
water	154:31	0:0	4	int16_t
water	154:38	0:0	4	)
call	154:39	154:63	4	bytestream_get_le16
arg	154:59	154:63	5	&src
op	154:59	0:0	6	&
water	154:60	0:0	6	src
water	154:64	0:0	4	;
if	155:8	157:8	4	(st)
cond	155:12	155:12	5	st
water	155:12	0:0	6	st
stmts	155:15	157:8	5	
water	155:15	0:0	6	{
water	156:12	0:0	6	c
op	156:13	0:0	6	->
water	156:15	0:0	6	status
op	156:21	0:0	6	[
water	156:22	0:0	6	1
op	156:23	0:0	6	]
op	156:24	0:0	6	.
water	156:25	0:0	6	idelta
op	156:32	0:0	6	=
water	156:34	0:0	6	(
water	156:35	0:0	6	int16_t
water	156:42	0:0	6	)
call	156:43	156:67	6	bytestream_get_le16
arg	156:63	156:67	7	&src
op	156:63	0:0	8	&
water	156:64	0:0	8	src
water	156:68	0:0	6	;
water	157:8	0:0	6	}
water	159:8	0:0	4	c
op	159:9	0:0	4	->
water	159:11	0:0	4	status
op	159:17	0:0	4	[
water	159:18	0:0	4	0
op	159:19	0:0	4	]
op	159:20	0:0	4	.
water	159:21	0:0	4	sample1
op	159:29	0:0	4	=
call	159:31	159:55	4	bytestream_get_le16
arg	159:51	159:55	5	&src
op	159:51	0:0	6	&
water	159:52	0:0	6	src
water	159:56	0:0	4	;
if	160:8	160:64	4	(st)
cond	160:12	160:12	5	st
water	160:12	0:0	6	st
stmts	160:16	160:64	5	
water	160:16	0:0	6	c
op	160:17	0:0	6	->
water	160:19	0:0	6	status
op	160:25	0:0	6	[
water	160:26	0:0	6	1
op	160:27	0:0	6	]
op	160:28	0:0	6	.
water	160:29	0:0	6	sample1
op	160:37	0:0	6	=
call	160:39	160:63	6	bytestream_get_le16
arg	160:59	160:63	7	&src
op	160:59	0:0	8	&
water	160:60	0:0	8	src
water	160:64	0:0	6	;
water	161:8	0:0	4	c
op	161:9	0:0	4	->
water	161:11	0:0	4	status
op	161:17	0:0	4	[
water	161:18	0:0	4	0
op	161:19	0:0	4	]
op	161:20	0:0	4	.
water	161:21	0:0	4	sample2
op	161:29	0:0	4	=
call	161:31	161:55	4	bytestream_get_le16
arg	161:51	161:55	5	&src
op	161:51	0:0	6	&
water	161:52	0:0	6	src
water	161:56	0:0	4	;
if	162:8	162:64	4	(st)
cond	162:12	162:12	5	st
water	162:12	0:0	6	st
stmts	162:16	162:64	5	
water	162:16	0:0	6	c
op	162:17	0:0	6	->
water	162:19	0:0	6	status
op	162:25	0:0	6	[
water	162:26	0:0	6	1
op	162:27	0:0	6	]
op	162:28	0:0	6	.
water	162:29	0:0	6	sample2
op	162:37	0:0	6	=
call	162:39	162:63	6	bytestream_get_le16
arg	162:59	162:63	7	&src
op	162:59	0:0	8	&
water	162:60	0:0	8	src
water	162:64	0:0	6	;
op	164:8	0:0	4	*
water	164:9	0:0	4	samples
op	164:16	0:0	4	++
op	164:19	0:0	4	=
water	164:21	0:0	4	c
op	164:22	0:0	4	->
water	164:24	0:0	4	status
op	164:30	0:0	4	[
water	164:31	0:0	4	0
op	164:32	0:0	4	]
op	164:33	0:0	4	.
water	164:34	0:0	4	sample2
water	164:41	0:0	4	;
if	165:8	165:49	4	(st)
cond	165:12	165:12	5	st
water	165:12	0:0	6	st
stmts	165:16	165:49	5	
op	165:16	0:0	6	*
water	165:17	0:0	6	samples
op	165:24	0:0	6	++
op	165:27	0:0	6	=
water	165:29	0:0	6	c
op	165:30	0:0	6	->
water	165:32	0:0	6	status
op	165:38	0:0	6	[
water	165:39	0:0	6	1
op	165:40	0:0	6	]
op	165:41	0:0	6	.
water	165:42	0:0	6	sample2
water	165:49	0:0	6	;
op	166:8	0:0	4	*
water	166:9	0:0	4	samples
op	166:16	0:0	4	++
op	166:19	0:0	4	=
water	166:21	0:0	4	c
op	166:22	0:0	4	->
water	166:24	0:0	4	status
op	166:30	0:0	4	[
water	166:31	0:0	4	0
op	166:32	0:0	4	]
op	166:33	0:0	4	.
water	166:34	0:0	4	sample1
water	166:41	0:0	4	;
if	167:8	167:49	4	(st)
cond	167:12	167:12	5	st
water	167:12	0:0	6	st
stmts	167:16	167:49	5	
op	167:16	0:0	6	*
water	167:17	0:0	6	samples
op	167:24	0:0	6	++
op	167:27	0:0	6	=
water	167:29	0:0	6	c
op	167:30	0:0	6	->
water	167:32	0:0	6	status
op	167:38	0:0	6	[
water	167:39	0:0	6	1
op	167:40	0:0	6	]
op	167:41	0:0	6	.
water	167:42	0:0	6	sample1
water	167:49	0:0	6	;
for	168:8	171:8	4	(n = ( nb_samples - 2 ) >> ( 1 - st ) ;n > 0;n -- , src ++)
forinit	168:12	168:44	5	n = ( nb_samples - 2 ) >> ( 1 - st ) ;
water	168:12	0:0	6	n
op	168:14	0:0	6	=
water	168:16	0:0	6	(
water	168:17	0:0	6	nb_samples
op	168:28	0:0	6	-
water	168:30	0:0	6	2
water	168:31	0:0	6	)
op	168:33	0:0	6	>>
water	168:36	0:0	6	(
water	168:37	0:0	6	1
op	168:39	0:0	6	-
water	168:41	0:0	6	st
water	168:43	0:0	6	)
water	168:44	0:0	6	;
cond	168:46	168:50	5	n > 0
water	168:46	0:0	6	n
op	168:48	0:0	6	>
water	168:50	0:0	6	0
forexpr	168:53	168:61	5	n -- , src ++
water	168:53	0:0	6	n
op	168:54	0:0	6	--
water	168:56	0:0	6	,
water	168:58	0:0	6	src
op	168:61	0:0	6	++
stmts	168:65	171:8	5	
water	168:65	0:0	6	{
op	169:12	0:0	6	*
water	169:13	0:0	6	samples
op	169:20	0:0	6	++
op	169:23	0:0	6	=
call	169:25	169:77	6	adpcm_ms_expand_nibble
arg	169:48	169:62	7	&c->status[0]
op	169:48	0:0	8	&
water	169:49	0:0	8	c
op	169:50	0:0	8	->
water	169:52	0:0	8	status
op	169:58	0:0	8	[
water	169:59	0:0	8	0
op	169:61	0:0	8	]
arg	169:64	169:77	7	src[0]>>4
water	169:64	0:0	8	src
op	169:67	0:0	8	[
water	169:68	0:0	8	0
op	169:69	0:0	8	]
op	169:71	0:0	8	>>
water	169:74	0:0	8	4
water	169:78	0:0	6	;
op	170:12	0:0	6	*
water	170:13	0:0	6	samples
op	170:20	0:0	6	++
op	170:23	0:0	6	=
call	170:25	170:77	6	adpcm_ms_expand_nibble
arg	170:48	170:62	7	&c->status[st]
op	170:48	0:0	8	&
water	170:49	0:0	8	c
op	170:50	0:0	8	->
water	170:52	0:0	8	status
op	170:58	0:0	8	[
water	170:59	0:0	8	st
op	170:61	0:0	8	]
arg	170:64	170:77	7	src[0]&0x0F
water	170:64	0:0	8	src
op	170:67	0:0	8	[
water	170:68	0:0	8	0
op	170:69	0:0	8	]
op	170:71	0:0	8	&
water	170:73	0:0	8	0
water	170:74	0:0	8	x0F
water	170:78	0:0	6	;
water	171:8	0:0	6	}
break	172:8	172:13	4	
water	173:4	0:0	4	}
label	174:4	174:31	4	case CODEC_ID_ADPCM_IMA_DK4 :
if	175:8	176:41	4	(avctx -> block_align != 0 && buf_size > avctx -> block_align)
cond	175:12	175:57	5	avctx -> block_align != 0 && buf_size > avctx -> block_align
water	175:12	0:0	6	avctx
op	175:17	0:0	6	->
water	175:19	0:0	6	block_align
op	175:31	0:0	6	!=
water	175:34	0:0	6	0
op	175:36	0:0	6	&&
water	175:39	0:0	6	buf_size
op	175:48	0:0	6	>
water	175:50	0:0	6	avctx
op	175:55	0:0	6	->
water	175:57	0:0	6	block_align
stmts	176:12	176:41	5	
water	176:12	0:0	6	buf_size
op	176:21	0:0	6	=
water	176:23	0:0	6	avctx
op	176:28	0:0	6	->
water	176:30	0:0	6	block_align
water	176:41	0:0	6	;
for	178:8	184:8	4	(channel = 0 ;channel < avctx -> channels;channel ++)
forinit	178:13	178:24	5	channel = 0 ;
water	178:13	0:0	6	channel
op	178:21	0:0	6	=
water	178:23	0:0	6	0
water	178:24	0:0	6	;
cond	178:26	178:43	5	channel < avctx -> channels
water	178:26	0:0	6	channel
op	178:34	0:0	6	<
water	178:36	0:0	6	avctx
op	178:41	0:0	6	->
water	178:43	0:0	6	channels
forexpr	178:53	178:60	5	channel ++
water	178:53	0:0	6	channel
op	178:60	0:0	6	++
stmts	178:64	184:8	5	
water	178:64	0:0	6	{
water	179:12	0:0	6	cs
op	179:15	0:0	6	=
op	179:17	0:0	6	&
water	179:18	0:0	6	c
op	179:19	0:0	6	->
water	179:21	0:0	6	status
op	179:27	0:0	6	[
water	179:28	0:0	6	channel
op	179:35	0:0	6	]
water	179:36	0:0	6	;
water	180:12	0:0	6	cs
op	180:14	0:0	6	->
water	180:16	0:0	6	predictor
op	180:27	0:0	6	=
water	180:29	0:0	6	(
water	180:30	0:0	6	int16_t
water	180:37	0:0	6	)
call	180:38	180:62	6	bytestream_get_le16
arg	180:58	180:62	7	&src
op	180:58	0:0	8	&
water	180:59	0:0	8	src
water	180:63	0:0	6	;
water	181:12	0:0	6	cs
op	181:14	0:0	6	->
water	181:16	0:0	6	step_index
op	181:27	0:0	6	=
op	181:29	0:0	6	*
water	181:30	0:0	6	src
op	181:33	0:0	6	++
water	181:35	0:0	6	;
water	182:12	0:0	6	src
op	182:15	0:0	6	++
water	182:17	0:0	6	;
op	183:12	0:0	6	*
water	183:13	0:0	6	samples
op	183:20	0:0	6	++
op	183:23	0:0	6	=
water	183:25	0:0	6	cs
op	183:27	0:0	6	->
water	183:29	0:0	6	predictor
water	183:38	0:0	6	;
water	184:8	0:0	6	}
for	185:8	189:8	4	(n = nb_samples >> ( 1 - st ) ;n > 0;n -- , src ++)
forinit	185:13	185:39	5	n = nb_samples >> ( 1 - st ) ;
water	185:13	0:0	6	n
op	185:15	0:0	6	=
water	185:17	0:0	6	nb_samples
op	185:28	0:0	6	>>
water	185:31	0:0	6	(
water	185:32	0:0	6	1
op	185:34	0:0	6	-
water	185:36	0:0	6	st
water	185:38	0:0	6	)
water	185:39	0:0	6	;
cond	185:41	185:45	5	n > 0
water	185:41	0:0	6	n
op	185:43	0:0	6	>
water	185:45	0:0	6	0
forexpr	185:48	185:56	5	n -- , src ++
water	185:48	0:0	6	n
op	185:49	0:0	6	--
water	185:51	0:0	6	,
water	185:53	0:0	6	src
op	185:56	0:0	6	++
stmts	185:60	189:8	5	
water	185:60	0:0	6	{
decl	186:12	186:28	6	uint8_t	v
op	186:22	0:0	6	=
op	186:24	0:0	6	*
water	186:25	0:0	6	src
op	187:12	0:0	6	*
water	187:13	0:0	6	samples
op	187:20	0:0	6	++
op	187:23	0:0	6	=
call	187:25	187:76	6	adpcm_ima_expand_nibble
arg	187:49	187:63	7	&c->status[0]
op	187:49	0:0	8	&
water	187:50	0:0	8	c
op	187:51	0:0	8	->
water	187:53	0:0	8	status
op	187:59	0:0	8	[
water	187:60	0:0	8	0
op	187:62	0:0	8	]
arg	187:65	187:73	7	v>>4
water	187:65	0:0	8	v
op	187:67	0:0	8	>>
water	187:70	0:0	8	4
arg	187:75	187:76	7	3
water	187:75	0:0	8	3
water	187:77	0:0	6	;
op	188:12	0:0	6	*
water	188:13	0:0	6	samples
op	188:20	0:0	6	++
op	188:23	0:0	6	=
call	188:25	188:76	6	adpcm_ima_expand_nibble
arg	188:49	188:63	7	&c->status[st]
op	188:49	0:0	8	&
water	188:50	0:0	8	c
op	188:51	0:0	8	->
water	188:53	0:0	8	status
op	188:59	0:0	8	[
water	188:60	0:0	8	st
op	188:62	0:0	8	]
arg	188:65	188:73	7	v&0x0F
water	188:65	0:0	8	v
op	188:67	0:0	8	&
water	188:69	0:0	8	0
water	188:70	0:0	8	x0F
arg	188:75	188:76	7	3
water	188:75	0:0	8	3
water	188:77	0:0	6	;
water	189:8	0:0	6	}
break	190:8	190:13	4	
label	191:4	191:31	4	case CODEC_ID_ADPCM_IMA_DK3 :
water	192:4	0:0	4	{
decl	193:8	193:35	4	unsigned char	last_byte
op	193:32	0:0	4	=
water	193:34	0:0	4	0
decl	194:8	194:28	4	unsigned char	nibble
decl	195:8	195:38	4	int	decode_top_nibble_next
op	195:35	0:0	4	=
water	195:37	0:0	4	0
decl	196:8	196:29	4	int	end_of_packet
op	196:26	0:0	4	=
water	196:28	0:0	4	0
decl	197:8	197:24	4	int	diff_channel
if	199:8	200:41	4	(avctx -> block_align != 0 && buf_size > avctx -> block_align)
cond	199:12	199:57	5	avctx -> block_align != 0 && buf_size > avctx -> block_align
water	199:12	0:0	6	avctx
op	199:17	0:0	6	->
water	199:19	0:0	6	block_align
op	199:31	0:0	6	!=
water	199:34	0:0	6	0
op	199:36	0:0	6	&&
water	199:39	0:0	6	buf_size
op	199:48	0:0	6	>
water	199:50	0:0	6	avctx
op	199:55	0:0	6	->
water	199:57	0:0	6	block_align
stmts	200:12	200:41	5	
water	200:12	0:0	6	buf_size
op	200:21	0:0	6	=
water	200:23	0:0	6	avctx
op	200:28	0:0	6	->
water	200:30	0:0	6	block_align
water	200:41	0:0	6	;
water	202:8	0:0	4	c
op	202:9	0:0	4	->
water	202:11	0:0	4	status
op	202:17	0:0	4	[
water	202:18	0:0	4	0
op	202:19	0:0	4	]
op	202:20	0:0	4	.
water	202:21	0:0	4	predictor
op	202:32	0:0	4	=
water	202:34	0:0	4	(
water	202:35	0:0	4	int16_t
water	202:42	0:0	4	)
call	202:43	202:59	4	AV_RL16
arg	202:51	202:59	5	src+10
water	202:51	0:0	6	src
op	202:55	0:0	6	+
water	202:57	0:0	6	10
water	202:60	0:0	4	;
water	203:8	0:0	4	c
op	203:9	0:0	4	->
water	203:11	0:0	4	status
op	203:17	0:0	4	[
water	203:18	0:0	4	1
op	203:19	0:0	4	]
op	203:20	0:0	4	.
water	203:21	0:0	4	predictor
op	203:32	0:0	4	=
water	203:34	0:0	4	(
water	203:35	0:0	4	int16_t
water	203:42	0:0	4	)
call	203:43	203:59	4	AV_RL16
arg	203:51	203:59	5	src+12
water	203:51	0:0	6	src
op	203:55	0:0	6	+
water	203:57	0:0	6	12
water	203:60	0:0	4	;
water	204:8	0:0	4	c
op	204:9	0:0	4	->
water	204:11	0:0	4	status
op	204:17	0:0	4	[
water	204:18	0:0	4	0
op	204:19	0:0	4	]
op	204:20	0:0	4	.
water	204:21	0:0	4	step_index
op	204:32	0:0	4	=
water	204:34	0:0	4	src
op	204:37	0:0	4	[
water	204:38	0:0	4	14
op	204:40	0:0	4	]
water	204:41	0:0	4	;
water	205:8	0:0	4	c
op	205:9	0:0	4	->
water	205:11	0:0	4	status
op	205:17	0:0	4	[
water	205:18	0:0	4	1
op	205:19	0:0	4	]
op	205:20	0:0	4	.
water	205:21	0:0	4	step_index
op	205:32	0:0	4	=
water	205:34	0:0	4	src
op	205:37	0:0	4	[
water	205:38	0:0	4	15
op	205:40	0:0	4	]
water	205:41	0:0	4	;
water	207:8	0:0	4	src
op	207:12	0:0	4	+=
water	207:15	0:0	4	16
water	207:17	0:0	4	;
water	208:8	0:0	4	diff_channel
op	208:21	0:0	4	=
water	208:23	0:0	4	c
op	208:24	0:0	4	->
water	208:26	0:0	4	status
op	208:32	0:0	4	[
water	208:33	0:0	4	1
op	208:34	0:0	4	]
op	208:35	0:0	4	.
water	208:36	0:0	4	predictor
water	208:45	0:0	4	;
while	212:8	238:8	4	(1)
cond	212:15	212:15	5	1
water	212:15	0:0	6	1
stmts	212:18	238:8	5	
water	212:18	0:0	6	{
call	218:12	218:32	6	DK3_GET_NEXT_NIBBLE
water	218:33	0:0	6	;
call	219:12	219:60	6	adpcm_ima_expand_nibble
arg	219:36	219:49	7	&c->status[0]
op	219:36	0:0	8	&
water	219:37	0:0	8	c
op	219:38	0:0	8	->
water	219:40	0:0	8	status
op	219:46	0:0	8	[
water	219:47	0:0	8	0
op	219:48	0:0	8	]
arg	219:51	219:57	7	nibble
water	219:51	0:0	8	nibble
arg	219:59	219:60	7	3
water	219:59	0:0	8	3
water	219:61	0:0	6	;
call	222:12	222:32	6	DK3_GET_NEXT_NIBBLE
water	222:33	0:0	6	;
call	223:12	223:60	6	adpcm_ima_expand_nibble
arg	223:36	223:49	7	&c->status[1]
op	223:36	0:0	8	&
water	223:37	0:0	8	c
op	223:38	0:0	8	->
water	223:40	0:0	8	status
op	223:46	0:0	8	[
water	223:47	0:0	8	1
op	223:48	0:0	8	]
arg	223:51	223:57	7	nibble
water	223:51	0:0	8	nibble
arg	223:59	223:60	7	3
water	223:59	0:0	8	3
water	223:61	0:0	6	;
water	226:12	0:0	6	diff_channel
op	226:25	0:0	6	=
water	226:27	0:0	6	(
water	226:28	0:0	6	diff_channel
op	226:41	0:0	6	+
water	226:43	0:0	6	c
op	226:44	0:0	6	->
water	226:46	0:0	6	status
op	226:52	0:0	6	[
water	226:53	0:0	6	1
op	226:54	0:0	6	]
op	226:55	0:0	6	.
water	226:56	0:0	6	predictor
water	226:65	0:0	6	)
op	226:67	0:0	6	/
water	226:69	0:0	6	2
water	226:70	0:0	6	;
op	227:12	0:0	6	*
water	227:13	0:0	6	samples
op	227:20	0:0	6	++
op	227:23	0:0	6	=
water	227:25	0:0	6	c
op	227:26	0:0	6	->
water	227:28	0:0	6	status
op	227:34	0:0	6	[
water	227:35	0:0	6	0
op	227:36	0:0	6	]
op	227:37	0:0	6	.
water	227:38	0:0	6	predictor
op	227:48	0:0	6	+
water	227:50	0:0	6	c
op	227:51	0:0	6	->
water	227:53	0:0	6	status
op	227:59	0:0	6	[
water	227:60	0:0	6	1
op	227:61	0:0	6	]
op	227:62	0:0	6	.
water	227:63	0:0	6	predictor
water	227:72	0:0	6	;
op	228:12	0:0	6	*
water	228:13	0:0	6	samples
op	228:20	0:0	6	++
op	228:23	0:0	6	=
water	228:25	0:0	6	c
op	228:26	0:0	6	->
water	228:28	0:0	6	status
op	228:34	0:0	6	[
water	228:35	0:0	6	0
op	228:36	0:0	6	]
op	228:37	0:0	6	.
water	228:38	0:0	6	predictor
op	228:48	0:0	6	-
water	228:50	0:0	6	c
op	228:51	0:0	6	->
water	228:53	0:0	6	status
op	228:59	0:0	6	[
water	228:60	0:0	6	1
op	228:61	0:0	6	]
op	228:62	0:0	6	.
water	228:63	0:0	6	predictor
water	228:72	0:0	6	;
call	231:12	231:32	6	DK3_GET_NEXT_NIBBLE
water	231:33	0:0	6	;
call	232:12	232:60	6	adpcm_ima_expand_nibble
arg	232:36	232:49	7	&c->status[0]
op	232:36	0:0	8	&
water	232:37	0:0	8	c
op	232:38	0:0	8	->
water	232:40	0:0	8	status
op	232:46	0:0	8	[
water	232:47	0:0	8	0
op	232:48	0:0	8	]
arg	232:51	232:57	7	nibble
water	232:51	0:0	8	nibble
arg	232:59	232:60	7	3
water	232:59	0:0	8	3
water	232:61	0:0	6	;
water	235:12	0:0	6	diff_channel
op	235:25	0:0	6	=
water	235:27	0:0	6	(
water	235:28	0:0	6	diff_channel
op	235:41	0:0	6	+
water	235:43	0:0	6	c
op	235:44	0:0	6	->
water	235:46	0:0	6	status
op	235:52	0:0	6	[
water	235:53	0:0	6	1
op	235:54	0:0	6	]
op	235:55	0:0	6	.
water	235:56	0:0	6	predictor
water	235:65	0:0	6	)
op	235:67	0:0	6	/
water	235:69	0:0	6	2
water	235:70	0:0	6	;
op	236:12	0:0	6	*
water	236:13	0:0	6	samples
op	236:20	0:0	6	++
op	236:23	0:0	6	=
water	236:25	0:0	6	c
op	236:26	0:0	6	->
water	236:28	0:0	6	status
op	236:34	0:0	6	[
water	236:35	0:0	6	0
op	236:36	0:0	6	]
op	236:37	0:0	6	.
water	236:38	0:0	6	predictor
op	236:48	0:0	6	+
water	236:50	0:0	6	c
op	236:51	0:0	6	->
water	236:53	0:0	6	status
op	236:59	0:0	6	[
water	236:60	0:0	6	1
op	236:61	0:0	6	]
op	236:62	0:0	6	.
water	236:63	0:0	6	predictor
water	236:72	0:0	6	;
op	237:12	0:0	6	*
water	237:13	0:0	6	samples
op	237:20	0:0	6	++
op	237:23	0:0	6	=
water	237:25	0:0	6	c
op	237:26	0:0	6	->
water	237:28	0:0	6	status
op	237:34	0:0	6	[
water	237:35	0:0	6	0
op	237:36	0:0	6	]
op	237:37	0:0	6	.
water	237:38	0:0	6	predictor
op	237:48	0:0	6	-
water	237:50	0:0	6	c
op	237:51	0:0	6	->
water	237:53	0:0	6	status
op	237:59	0:0	6	[
water	237:60	0:0	6	1
op	237:61	0:0	6	]
op	237:62	0:0	6	.
water	237:63	0:0	6	predictor
water	237:72	0:0	6	;
water	238:8	0:0	6	}
break	239:8	239:13	4	
water	240:4	0:0	4	}
label	241:4	241:31	4	case CODEC_ID_ADPCM_IMA_ISS :
for	242:8	247:8	4	(channel = 0 ;channel < avctx -> channels;channel ++)
forinit	242:13	242:24	5	channel = 0 ;
water	242:13	0:0	6	channel
op	242:21	0:0	6	=
water	242:23	0:0	6	0
water	242:24	0:0	6	;
cond	242:26	242:43	5	channel < avctx -> channels
water	242:26	0:0	6	channel
op	242:34	0:0	6	<
water	242:36	0:0	6	avctx
op	242:41	0:0	6	->
water	242:43	0:0	6	channels
forexpr	242:53	242:60	5	channel ++
water	242:53	0:0	6	channel
op	242:60	0:0	6	++
stmts	242:64	247:8	5	
water	242:64	0:0	6	{
water	243:12	0:0	6	cs
op	243:15	0:0	6	=
op	243:17	0:0	6	&
water	243:18	0:0	6	c
op	243:19	0:0	6	->
water	243:21	0:0	6	status
op	243:27	0:0	6	[
water	243:28	0:0	6	channel
op	243:35	0:0	6	]
water	243:36	0:0	6	;
water	244:12	0:0	6	cs
op	244:14	0:0	6	->
water	244:16	0:0	6	predictor
op	244:27	0:0	6	=
water	244:29	0:0	6	(
water	244:30	0:0	6	int16_t
water	244:37	0:0	6	)
call	244:38	244:62	6	bytestream_get_le16
arg	244:58	244:62	7	&src
op	244:58	0:0	8	&
water	244:59	0:0	8	src
water	244:63	0:0	6	;
water	245:12	0:0	6	cs
op	245:14	0:0	6	->
water	245:16	0:0	6	step_index
op	245:27	0:0	6	=
op	245:29	0:0	6	*
water	245:30	0:0	6	src
op	245:33	0:0	6	++
water	245:35	0:0	6	;
water	246:12	0:0	6	src
op	246:15	0:0	6	++
water	246:17	0:0	6	;
water	247:8	0:0	6	}
for	249:8	262:8	4	(n = nb_samples >> ( 1 - st ) ;n > 0;n -- , src ++)
forinit	249:13	249:39	5	n = nb_samples >> ( 1 - st ) ;
water	249:13	0:0	6	n
op	249:15	0:0	6	=
water	249:17	0:0	6	nb_samples
op	249:28	0:0	6	>>
water	249:31	0:0	6	(
water	249:32	0:0	6	1
op	249:34	0:0	6	-
water	249:36	0:0	6	st
water	249:38	0:0	6	)
water	249:39	0:0	6	;
cond	249:41	249:45	5	n > 0
water	249:41	0:0	6	n
op	249:43	0:0	6	>
water	249:45	0:0	6	0
forexpr	249:48	249:56	5	n -- , src ++
water	249:48	0:0	6	n
op	249:49	0:0	6	--
water	249:51	0:0	6	,
water	249:53	0:0	6	src
op	249:56	0:0	6	++
stmts	249:60	262:8	5	
water	249:60	0:0	6	{
decl	250:12	250:26	6	uint8_t	v1
water	250:22	0:0	6	,
decl	250:12	250:26	6	uint8_t	v2
decl	251:12	251:28	6	uint8_t	v
op	251:22	0:0	6	=
op	251:24	0:0	6	*
water	251:25	0:0	6	src
if	253:12	256:12	6	(st)
cond	253:16	253:16	7	st
water	253:16	0:0	8	st
stmts	253:20	256:12	7	
water	253:20	0:0	8	{
water	254:16	0:0	8	v1
op	254:19	0:0	8	=
water	254:21	0:0	8	v
op	254:23	0:0	8	>>
water	254:26	0:0	8	4
water	254:27	0:0	8	;
water	255:16	0:0	8	v2
op	255:19	0:0	8	=
water	255:21	0:0	8	v
op	255:23	0:0	8	&
water	255:25	0:0	8	0
water	255:26	0:0	8	x0F
water	255:29	0:0	8	;
water	256:12	0:0	8	}
else	256:14	259:12	6
stmts	256:19	259:12	7	
water	256:19	0:0	8	{
water	257:16	0:0	8	v2
op	257:19	0:0	8	=
water	257:21	0:0	8	v
op	257:23	0:0	8	>>
water	257:26	0:0	8	4
water	257:27	0:0	8	;
water	258:16	0:0	8	v1
op	258:19	0:0	8	=
water	258:21	0:0	8	v
op	258:23	0:0	8	&
water	258:25	0:0	8	0
water	258:26	0:0	8	x0F
water	258:29	0:0	8	;
water	259:12	0:0	8	}
op	260:12	0:0	6	*
water	260:13	0:0	6	samples
op	260:20	0:0	6	++
op	260:23	0:0	6	=
call	260:25	260:70	6	adpcm_ima_expand_nibble
arg	260:49	260:63	7	&c->status[0]
op	260:49	0:0	8	&
water	260:50	0:0	8	c
op	260:51	0:0	8	->
water	260:53	0:0	8	status
op	260:59	0:0	8	[
water	260:60	0:0	8	0
op	260:62	0:0	8	]
arg	260:65	260:67	7	v1
water	260:65	0:0	8	v1
arg	260:69	260:70	7	3
water	260:69	0:0	8	3
water	260:71	0:0	6	;
op	261:12	0:0	6	*
water	261:13	0:0	6	samples
op	261:20	0:0	6	++
op	261:23	0:0	6	=
call	261:25	261:70	6	adpcm_ima_expand_nibble
arg	261:49	261:63	7	&c->status[st]
op	261:49	0:0	8	&
water	261:50	0:0	8	c
op	261:51	0:0	8	->
water	261:53	0:0	8	status
op	261:59	0:0	8	[
water	261:60	0:0	8	st
op	261:62	0:0	8	]
arg	261:65	261:67	7	v2
water	261:65	0:0	8	v2
arg	261:69	261:70	7	3
water	261:69	0:0	8	3
water	261:71	0:0	6	;
water	262:8	0:0	6	}
break	263:8	263:13	4	
label	264:4	264:30	4	case CODEC_ID_ADPCM_IMA_WS :
while	265:8	269:8	4	(src < buf + buf_size)
cond	265:15	265:27	5	src < buf + buf_size
water	265:15	0:0	6	src
op	265:19	0:0	6	<
water	265:21	0:0	6	buf
op	265:25	0:0	6	+
water	265:27	0:0	6	buf_size
stmts	265:37	269:8	5	
water	265:37	0:0	6	{
decl	266:12	266:30	6	uint8_t	v
op	266:22	0:0	6	=
op	266:24	0:0	6	*
water	266:25	0:0	6	src
op	266:28	0:0	6	++
op	267:12	0:0	6	*
water	267:13	0:0	6	samples
op	267:20	0:0	6	++
op	267:23	0:0	6	=
call	267:25	267:76	6	adpcm_ima_expand_nibble
arg	267:49	267:62	7	&c->status[0]
op	267:49	0:0	8	&
water	267:50	0:0	8	c
op	267:51	0:0	8	->
water	267:53	0:0	8	status
op	267:59	0:0	8	[
water	267:60	0:0	8	0
op	267:61	0:0	8	]
arg	267:65	267:73	7	v>>4
water	267:65	0:0	8	v
op	267:67	0:0	8	>>
water	267:70	0:0	8	4
arg	267:75	267:76	7	3
water	267:75	0:0	8	3
water	267:77	0:0	6	;
op	268:12	0:0	6	*
water	268:13	0:0	6	samples
op	268:20	0:0	6	++
op	268:23	0:0	6	=
call	268:25	268:76	6	adpcm_ima_expand_nibble
arg	268:49	268:63	7	&c->status[st]
op	268:49	0:0	8	&
water	268:50	0:0	8	c
op	268:51	0:0	8	->
water	268:53	0:0	8	status
op	268:59	0:0	8	[
water	268:60	0:0	8	st
op	268:62	0:0	8	]
arg	268:65	268:73	7	v&0x0F
water	268:65	0:0	8	v
op	268:67	0:0	8	&
water	268:69	0:0	8	0
water	268:70	0:0	8	x0F
arg	268:75	268:76	7	3
water	268:75	0:0	8	3
water	268:77	0:0	6	;
water	269:8	0:0	6	}
break	270:8	270:13	4	
label	271:4	271:26	4	case CODEC_ID_ADPCM_XA :
while	272:8	278:8	4	(buf_size >= 128)
cond	272:15	272:27	5	buf_size >= 128
water	272:15	0:0	6	buf_size
op	272:24	0:0	6	>=
water	272:27	0:0	6	128
stmts	272:32	278:8	5	
water	272:32	0:0	6	{
call	273:12	274:31	6	xa_decode
arg	273:22	273:29	7	samples
water	273:22	0:0	8	samples
arg	273:31	273:34	7	src
water	273:31	0:0	8	src
arg	273:36	273:49	7	&c->status[0]
op	273:36	0:0	8	&
water	273:37	0:0	8	c
op	273:38	0:0	8	->
water	273:40	0:0	8	status
op	273:46	0:0	8	[
water	273:47	0:0	8	0
op	273:48	0:0	8	]
arg	273:51	273:64	7	&c->status[1]
op	273:51	0:0	8	&
water	273:52	0:0	8	c
op	273:53	0:0	8	->
water	273:55	0:0	8	status
op	273:61	0:0	8	[
water	273:62	0:0	8	1
op	273:63	0:0	8	]
arg	274:16	274:31	7	avctx->channels
water	274:16	0:0	8	avctx
op	274:21	0:0	8	->
water	274:23	0:0	8	channels
water	274:32	0:0	6	;
water	275:12	0:0	6	src
op	275:16	0:0	6	+=
water	275:19	0:0	6	128
water	275:22	0:0	6	;
water	276:12	0:0	6	samples
op	276:20	0:0	6	+=
water	276:23	0:0	6	28
op	276:26	0:0	6	*
water	276:28	0:0	6	8
water	276:29	0:0	6	;
water	277:12	0:0	6	buf_size
op	277:21	0:0	6	-=
water	277:24	0:0	6	128
water	277:27	0:0	6	;
water	278:8	0:0	6	}
break	279:8	279:13	4	
label	280:4	280:35	4	case CODEC_ID_ADPCM_IMA_EA_EACS :
water	281:8	0:0	4	src
op	281:12	0:0	4	+=
water	281:15	0:0	4	4
water	281:16	0:0	4	;
for	283:8	284:63	4	(i = 0 ;i <= st;i ++)
forinit	283:13	283:16	5	i = 0 ;
water	283:13	0:0	6	i
op	283:14	0:0	6	=
water	283:15	0:0	6	0
water	283:16	0:0	6	;
cond	283:18	283:21	5	i <= st
water	283:18	0:0	6	i
op	283:19	0:0	6	<=
water	283:21	0:0	6	st
forexpr	283:25	283:26	5	i ++
water	283:25	0:0	6	i
op	283:26	0:0	6	++
stmts	284:12	284:63	5	
water	284:12	0:0	6	c
op	284:13	0:0	6	->
water	284:15	0:0	6	status
op	284:21	0:0	6	[
water	284:22	0:0	6	i
op	284:23	0:0	6	]
op	284:24	0:0	6	.
water	284:25	0:0	6	step_index
op	284:36	0:0	6	=
call	284:38	284:62	6	bytestream_get_le32
arg	284:58	284:62	7	&src
op	284:58	0:0	8	&
water	284:59	0:0	8	src
water	284:63	0:0	6	;
for	285:8	286:63	4	(i = 0 ;i <= st;i ++)
forinit	285:13	285:16	5	i = 0 ;
water	285:13	0:0	6	i
op	285:14	0:0	6	=
water	285:15	0:0	6	0
water	285:16	0:0	6	;
cond	285:18	285:21	5	i <= st
water	285:18	0:0	6	i
op	285:19	0:0	6	<=
water	285:21	0:0	6	st
forexpr	285:25	285:26	5	i ++
water	285:25	0:0	6	i
op	285:26	0:0	6	++
stmts	286:12	286:63	5	
water	286:12	0:0	6	c
op	286:13	0:0	6	->
water	286:15	0:0	6	status
op	286:21	0:0	6	[
water	286:22	0:0	6	i
op	286:23	0:0	6	]
op	286:24	0:0	6	.
water	286:25	0:0	6	predictor
op	286:36	0:0	6	=
call	286:38	286:62	6	bytestream_get_le32
arg	286:58	286:62	7	&src
op	286:58	0:0	8	&
water	286:59	0:0	8	src
water	286:63	0:0	6	;
for	288:8	291:8	4	(n = nb_samples >> ( 1 - st ) ;n > 0;n -- , src ++)
forinit	288:13	288:39	5	n = nb_samples >> ( 1 - st ) ;
water	288:13	0:0	6	n
op	288:15	0:0	6	=
water	288:17	0:0	6	nb_samples
op	288:28	0:0	6	>>
water	288:31	0:0	6	(
water	288:32	0:0	6	1
op	288:34	0:0	6	-
water	288:36	0:0	6	st
water	288:38	0:0	6	)
water	288:39	0:0	6	;
cond	288:41	288:45	5	n > 0
water	288:41	0:0	6	n
op	288:43	0:0	6	>
water	288:45	0:0	6	0
forexpr	288:48	288:56	5	n -- , src ++
water	288:48	0:0	6	n
op	288:49	0:0	6	--
water	288:51	0:0	6	,
water	288:53	0:0	6	src
op	288:56	0:0	6	++
stmts	288:60	291:8	5	
water	288:60	0:0	6	{
op	289:12	0:0	6	*
water	289:13	0:0	6	samples
op	289:20	0:0	6	++
op	289:23	0:0	6	=
call	289:25	289:77	6	adpcm_ima_expand_nibble
arg	289:49	289:62	7	&c->status[0]
op	289:49	0:0	8	&
water	289:50	0:0	8	c
op	289:51	0:0	8	->
water	289:53	0:0	8	status
op	289:59	0:0	8	[
water	289:60	0:0	8	0
op	289:61	0:0	8	]
arg	289:65	289:72	7	*src>>4
op	289:65	0:0	8	*
water	289:66	0:0	8	src
op	289:69	0:0	8	>>
water	289:71	0:0	8	4
arg	289:76	289:77	7	3
water	289:76	0:0	8	3
water	289:78	0:0	6	;
op	290:12	0:0	6	*
water	290:13	0:0	6	samples
op	290:20	0:0	6	++
op	290:23	0:0	6	=
call	290:25	290:77	6	adpcm_ima_expand_nibble
arg	290:49	290:63	7	&c->status[st]
op	290:49	0:0	8	&
water	290:50	0:0	8	c
op	290:51	0:0	8	->
water	290:53	0:0	8	status
op	290:59	0:0	8	[
water	290:60	0:0	8	st
op	290:62	0:0	8	]
arg	290:65	290:74	7	*src&0x0F
op	290:65	0:0	8	*
water	290:66	0:0	8	src
op	290:69	0:0	8	&
water	290:70	0:0	8	0
water	290:71	0:0	8	x0F
arg	290:76	290:77	7	3
water	290:76	0:0	8	3
water	290:78	0:0	6	;
water	291:8	0:0	6	}
break	292:8	292:13	4	
label	293:4	293:35	4	case CODEC_ID_ADPCM_IMA_EA_SEAD :
for	294:8	297:8	4	(n = nb_samples >> ( 1 - st ) ;n > 0;n -- , src ++)
forinit	294:13	294:39	5	n = nb_samples >> ( 1 - st ) ;
water	294:13	0:0	6	n
op	294:15	0:0	6	=
water	294:17	0:0	6	nb_samples
op	294:28	0:0	6	>>
water	294:31	0:0	6	(
water	294:32	0:0	6	1
op	294:34	0:0	6	-
water	294:36	0:0	6	st
water	294:38	0:0	6	)
water	294:39	0:0	6	;
cond	294:41	294:45	5	n > 0
water	294:41	0:0	6	n
op	294:43	0:0	6	>
water	294:45	0:0	6	0
forexpr	294:48	294:56	5	n -- , src ++
water	294:48	0:0	6	n
op	294:49	0:0	6	--
water	294:51	0:0	6	,
water	294:53	0:0	6	src
op	294:56	0:0	6	++
stmts	294:60	297:8	5	
water	294:60	0:0	6	{
op	295:12	0:0	6	*
water	295:13	0:0	6	samples
op	295:20	0:0	6	++
op	295:23	0:0	6	=
call	295:25	295:78	6	adpcm_ima_expand_nibble
arg	295:49	295:62	7	&c->status[0]
op	295:49	0:0	8	&
water	295:50	0:0	8	c
op	295:51	0:0	8	->
water	295:53	0:0	8	status
op	295:59	0:0	8	[
water	295:60	0:0	8	0
op	295:61	0:0	8	]
arg	295:64	295:75	7	src[0]>>4
water	295:64	0:0	8	src
op	295:67	0:0	8	[
water	295:68	0:0	8	0
op	295:69	0:0	8	]
op	295:71	0:0	8	>>
water	295:74	0:0	8	4
arg	295:77	295:78	7	6
water	295:77	0:0	8	6
water	295:79	0:0	6	;
op	296:12	0:0	6	*
water	296:13	0:0	6	samples
op	296:20	0:0	6	++
op	296:23	0:0	6	=
call	296:25	296:78	6	adpcm_ima_expand_nibble
arg	296:49	296:63	7	&c->status[st]
op	296:49	0:0	8	&
water	296:50	0:0	8	c
op	296:51	0:0	8	->
water	296:53	0:0	8	status
op	296:59	0:0	8	[
water	296:60	0:0	8	st
op	296:62	0:0	8	]
arg	296:64	296:75	7	src[0]&0x0F
water	296:64	0:0	8	src
op	296:67	0:0	8	[
water	296:68	0:0	8	0
op	296:69	0:0	8	]
op	296:70	0:0	8	&
water	296:71	0:0	8	0
water	296:72	0:0	8	x0F
arg	296:77	296:78	7	6
water	296:77	0:0	8	6
water	296:79	0:0	6	;
water	297:8	0:0	6	}
break	298:8	298:13	4	
label	299:4	299:26	4	case CODEC_ID_ADPCM_EA :
water	300:4	0:0	4	{
decl	301:8	301:59	4	int32_t	previous_left_sample
water	301:36	0:0	4	,
decl	301:8	301:59	4	int32_t	previous_right_sample
decl	302:8	302:57	4	int32_t	current_left_sample
water	302:35	0:0	4	,
decl	302:8	302:57	4	int32_t	current_right_sample
decl	303:8	303:51	4	int32_t	next_left_sample
water	303:32	0:0	4	,
decl	303:8	303:51	4	int32_t	next_right_sample
decl	304:8	304:50	4	int32_t	coeff1l
water	304:23	0:0	4	,
decl	304:8	304:50	4	int32_t	coeff2l
water	304:32	0:0	4	,
decl	304:8	304:50	4	int32_t	coeff1r
water	304:41	0:0	4	,
decl	304:8	304:50	4	int32_t	coeff2r
decl	305:8	305:39	4	uint8_t	shift_left
water	305:26	0:0	4	,
decl	305:8	305:39	4	uint8_t	shift_right
if	310:8	311:38	4	(avctx -> channels != 2)
cond	310:11	310:30	5	avctx -> channels != 2
water	310:11	0:0	6	avctx
op	310:16	0:0	6	->
water	310:18	0:0	6	channels
op	310:27	0:0	6	!=
water	310:30	0:0	6	2
stmts	311:12	311:38	5	
return	311:12	311:38	6	AVERROR_INVALIDDATA
water	311:19	0:0	7	AVERROR_INVALIDDATA
water	313:8	0:0	4	src
op	313:12	0:0	4	+=
water	313:15	0:0	4	4
water	313:16	0:0	4	;
water	315:8	0:0	4	current_left_sample
op	315:30	0:0	4	=
water	315:32	0:0	4	(
water	315:33	0:0	4	int16_t
water	315:40	0:0	4	)
call	315:41	315:65	4	bytestream_get_le16
arg	315:61	315:65	5	&src
op	315:61	0:0	6	&
water	315:62	0:0	6	src
water	315:66	0:0	4	;
water	316:8	0:0	4	previous_left_sample
op	316:30	0:0	4	=
water	316:32	0:0	4	(
water	316:33	0:0	4	int16_t
water	316:40	0:0	4	)
call	316:41	316:65	4	bytestream_get_le16
arg	316:61	316:65	5	&src
op	316:61	0:0	6	&
water	316:62	0:0	6	src
water	316:66	0:0	4	;
water	317:8	0:0	4	current_right_sample
op	317:30	0:0	4	=
water	317:32	0:0	4	(
water	317:33	0:0	4	int16_t
water	317:40	0:0	4	)
call	317:41	317:65	4	bytestream_get_le16
arg	317:61	317:65	5	&src
op	317:61	0:0	6	&
water	317:62	0:0	6	src
water	317:66	0:0	4	;
water	318:8	0:0	4	previous_right_sample
op	318:30	0:0	4	=
water	318:32	0:0	4	(
water	318:33	0:0	4	int16_t
water	318:40	0:0	4	)
call	318:41	318:65	4	bytestream_get_le16
arg	318:61	318:65	5	&src
op	318:61	0:0	6	&
water	318:62	0:0	6	src
water	318:66	0:0	4	;
for	320:8	350:8	4	(count1 = 0 ;count1 < nb_samples / 28;count1 ++)
forinit	320:13	320:23	5	count1 = 0 ;
water	320:13	0:0	6	count1
op	320:20	0:0	6	=
water	320:22	0:0	6	0
water	320:23	0:0	6	;
cond	320:25	320:47	5	count1 < nb_samples / 28
water	320:25	0:0	6	count1
op	320:32	0:0	6	<
water	320:34	0:0	6	nb_samples
op	320:45	0:0	6	/
water	320:47	0:0	6	28
forexpr	320:51	320:57	5	count1 ++
water	320:51	0:0	6	count1
op	320:57	0:0	6	++
stmts	320:61	350:8	5	
water	320:61	0:0	6	{
water	321:12	0:0	6	coeff1l
op	321:20	0:0	6	=
water	321:22	0:0	6	ea_adpcm_table
op	321:36	0:0	6	[
op	321:38	0:0	6	*
water	321:39	0:0	6	src
op	321:43	0:0	6	>>
water	321:46	0:0	6	4
op	321:54	0:0	6	]
water	321:55	0:0	6	;
water	322:12	0:0	6	coeff2l
op	322:20	0:0	6	=
water	322:22	0:0	6	ea_adpcm_table
op	322:36	0:0	6	[
water	322:37	0:0	6	(
op	322:38	0:0	6	*
water	322:39	0:0	6	src
op	322:43	0:0	6	>>
water	322:46	0:0	6	4
water	322:49	0:0	6	)
op	322:51	0:0	6	+
water	322:53	0:0	6	4
op	322:54	0:0	6	]
water	322:55	0:0	6	;
water	323:12	0:0	6	coeff1r
op	323:20	0:0	6	=
water	323:22	0:0	6	ea_adpcm_table
op	323:36	0:0	6	[
op	323:37	0:0	6	*
water	323:38	0:0	6	src
op	323:42	0:0	6	&
water	323:44	0:0	6	0
water	323:45	0:0	6	x0F
op	323:48	0:0	6	]
water	323:49	0:0	6	;
water	324:12	0:0	6	coeff2r
op	324:20	0:0	6	=
water	324:22	0:0	6	ea_adpcm_table
op	324:36	0:0	6	[
water	324:37	0:0	6	(
op	324:38	0:0	6	*
water	324:39	0:0	6	src
op	324:43	0:0	6	&
water	324:45	0:0	6	0
water	324:46	0:0	6	x0F
water	324:49	0:0	6	)
op	324:51	0:0	6	+
water	324:53	0:0	6	4
op	324:54	0:0	6	]
water	324:55	0:0	6	;
water	325:12	0:0	6	src
op	325:15	0:0	6	++
water	325:17	0:0	6	;
water	327:12	0:0	6	shift_left
op	327:24	0:0	6	=
water	327:26	0:0	6	20
op	327:29	0:0	6	-
water	327:31	0:0	6	(
op	327:32	0:0	6	*
water	327:33	0:0	6	src
op	327:37	0:0	6	>>
water	327:40	0:0	6	4
water	327:41	0:0	6	)
water	327:42	0:0	6	;
water	328:12	0:0	6	shift_right
op	328:24	0:0	6	=
water	328:26	0:0	6	20
op	328:29	0:0	6	-
water	328:31	0:0	6	(
op	328:32	0:0	6	*
water	328:33	0:0	6	src
op	328:37	0:0	6	&
water	328:39	0:0	6	0
water	328:40	0:0	6	x0F
water	328:43	0:0	6	)
water	328:44	0:0	6	;
water	329:12	0:0	6	src
op	329:15	0:0	6	++
water	329:17	0:0	6	;
for	331:12	349:12	6	(count2 = 0 ;count2 < 28;count2 ++)
forinit	331:17	331:27	7	count2 = 0 ;
water	331:17	0:0	8	count2
op	331:24	0:0	8	=
water	331:26	0:0	8	0
water	331:27	0:0	8	;
cond	331:29	331:38	7	count2 < 28
water	331:29	0:0	8	count2
op	331:36	0:0	8	<
water	331:38	0:0	8	28
forexpr	331:42	331:48	7	count2 ++
water	331:42	0:0	8	count2
op	331:48	0:0	8	++
stmts	331:52	349:12	7	
water	331:52	0:0	8	{
water	332:16	0:0	8	next_left_sample
op	332:34	0:0	8	=
call	332:36	332:60	8	sign_extend
arg	332:48	332:57	9	*src>>4
op	332:48	0:0	10	*
water	332:49	0:0	10	src
op	332:53	0:0	10	>>
water	332:56	0:0	10	4
arg	332:59	332:60	9	4
water	332:59	0:0	10	4
op	332:62	0:0	8	<<
water	332:65	0:0	8	shift_left
water	332:75	0:0	8	;
water	333:16	0:0	8	next_right_sample
op	333:34	0:0	8	=
call	333:36	333:60	8	sign_extend
arg	333:48	333:52	9	*src
op	333:48	0:0	10	*
water	333:49	0:0	10	src
arg	333:59	333:60	9	4
water	333:59	0:0	10	4
op	333:62	0:0	8	<<
water	333:65	0:0	8	shift_right
water	333:76	0:0	8	;
water	334:16	0:0	8	src
op	334:19	0:0	8	++
water	334:21	0:0	8	;
water	336:16	0:0	8	next_left_sample
op	336:33	0:0	8	=
water	336:35	0:0	8	(
water	336:36	0:0	8	next_left_sample
op	336:53	0:0	8	+
water	337:20	0:0	8	(
water	337:21	0:0	8	current_left_sample
op	337:41	0:0	8	*
water	337:43	0:0	8	coeff1l
water	337:50	0:0	8	)
op	337:52	0:0	8	+
water	338:20	0:0	8	(
water	338:21	0:0	8	previous_left_sample
op	338:42	0:0	8	*
water	338:44	0:0	8	coeff2l
water	338:51	0:0	8	)
op	338:53	0:0	8	+
water	338:55	0:0	8	0
water	338:56	0:0	8	x80
water	338:59	0:0	8	)
op	338:61	0:0	8	>>
water	338:64	0:0	8	8
water	338:65	0:0	8	;
water	339:16	0:0	8	next_right_sample
op	339:34	0:0	8	=
water	339:36	0:0	8	(
water	339:37	0:0	8	next_right_sample
op	339:55	0:0	8	+
water	340:20	0:0	8	(
water	340:21	0:0	8	current_right_sample
op	340:42	0:0	8	*
water	340:44	0:0	8	coeff1r
water	340:51	0:0	8	)
op	340:53	0:0	8	+
water	341:20	0:0	8	(
water	341:21	0:0	8	previous_right_sample
op	341:43	0:0	8	*
water	341:45	0:0	8	coeff2r
water	341:52	0:0	8	)
op	341:54	0:0	8	+
water	341:56	0:0	8	0
water	341:57	0:0	8	x80
water	341:60	0:0	8	)
op	341:62	0:0	8	>>
water	341:65	0:0	8	8
water	341:66	0:0	8	;
water	343:16	0:0	8	previous_left_sample
op	343:37	0:0	8	=
water	343:39	0:0	8	current_left_sample
water	343:58	0:0	8	;
water	344:16	0:0	8	current_left_sample
op	344:36	0:0	8	=
call	344:38	344:68	8	av_clip_int16
arg	344:52	344:68	9	next_left_sample
water	344:52	0:0	10	next_left_sample
water	344:69	0:0	8	;
water	345:16	0:0	8	previous_right_sample
op	345:38	0:0	8	=
water	345:40	0:0	8	current_right_sample
water	345:60	0:0	8	;
water	346:16	0:0	8	current_right_sample
op	346:37	0:0	8	=
call	346:39	346:70	8	av_clip_int16
arg	346:53	346:70	9	next_right_sample
water	346:53	0:0	10	next_right_sample
water	346:71	0:0	8	;
op	347:16	0:0	8	*
water	347:17	0:0	8	samples
op	347:24	0:0	8	++
op	347:27	0:0	8	=
water	347:29	0:0	8	(
water	347:30	0:0	8	unsigned
water	347:39	0:0	8	short
water	347:44	0:0	8	)
water	347:45	0:0	8	current_left_sample
water	347:64	0:0	8	;
op	348:16	0:0	8	*
water	348:17	0:0	8	samples
op	348:24	0:0	8	++
op	348:27	0:0	8	=
water	348:29	0:0	8	(
water	348:30	0:0	8	unsigned
water	348:39	0:0	8	short
water	348:44	0:0	8	)
water	348:45	0:0	8	current_right_sample
water	348:65	0:0	8	;
water	349:12	0:0	8	}
water	350:8	0:0	6	}
if	352:8	353:20	4	(src - buf == buf_size - 2)
cond	352:12	352:36	5	src - buf == buf_size - 2
water	352:12	0:0	6	src
op	352:16	0:0	6	-
water	352:18	0:0	6	buf
op	352:22	0:0	6	==
water	352:25	0:0	6	buf_size
op	352:34	0:0	6	-
water	352:36	0:0	6	2
stmts	353:12	353:20	5	
water	353:12	0:0	6	src
op	353:16	0:0	6	+=
water	353:19	0:0	6	2
water	353:20	0:0	6	;
break	355:8	355:13	4	
water	356:4	0:0	4	}
label	357:4	357:35	4	case CODEC_ID_ADPCM_EA_MAXIS_XA :
water	358:4	0:0	4	{
water	359:8	0:0	4	int
water	359:12	0:0	4	coeff
op	359:17	0:0	4	[
water	359:18	0:0	4	2
op	359:19	0:0	4	]
op	359:20	0:0	4	[
water	359:21	0:0	4	2
op	359:22	0:0	4	]
water	359:23	0:0	4	,
water	359:25	0:0	4	shift
op	359:30	0:0	4	[
water	359:31	0:0	4	2
op	359:32	0:0	4	]
water	359:33	0:0	4	;
for	361:8	366:8	4	(channel = 0 ;channel < avctx -> channels;channel ++)
forinit	361:12	361:23	5	channel = 0 ;
water	361:12	0:0	6	channel
op	361:20	0:0	6	=
water	361:22	0:0	6	0
water	361:23	0:0	6	;
cond	361:25	361:42	5	channel < avctx -> channels
water	361:25	0:0	6	channel
op	361:33	0:0	6	<
water	361:35	0:0	6	avctx
op	361:40	0:0	6	->
water	361:42	0:0	6	channels
forexpr	361:52	361:59	5	channel ++
water	361:52	0:0	6	channel
op	361:59	0:0	6	++
stmts	361:63	366:8	5	
water	361:63	0:0	6	{
for	362:12	363:69	6	(i = 0 ;i < 2;i ++)
forinit	362:17	362:20	7	i = 0 ;
water	362:17	0:0	8	i
op	362:18	0:0	8	=
water	362:19	0:0	8	0
water	362:20	0:0	8	;
cond	362:22	362:24	7	i < 2
water	362:22	0:0	8	i
op	362:23	0:0	8	<
water	362:24	0:0	8	2
forexpr	362:27	362:28	7	i ++
water	362:27	0:0	8	i
op	362:28	0:0	8	++
stmts	363:16	363:69	7	
water	363:16	0:0	8	coeff
op	363:21	0:0	8	[
water	363:22	0:0	8	channel
op	363:29	0:0	8	]
op	363:30	0:0	8	[
water	363:31	0:0	8	i
op	363:32	0:0	8	]
op	363:34	0:0	8	=
water	363:36	0:0	8	ea_adpcm_table
op	363:50	0:0	8	[
water	363:51	0:0	8	(
op	363:52	0:0	8	*
water	363:53	0:0	8	src
op	363:57	0:0	8	>>
water	363:60	0:0	8	4
water	363:61	0:0	8	)
op	363:63	0:0	8	+
water	363:65	0:0	8	4
op	363:66	0:0	8	*
water	363:67	0:0	8	i
op	363:68	0:0	8	]
water	363:69	0:0	8	;
water	364:12	0:0	6	shift
op	364:17	0:0	6	[
water	364:18	0:0	6	channel
op	364:25	0:0	6	]
op	364:27	0:0	6	=
water	364:29	0:0	6	20
op	364:32	0:0	6	-
water	364:34	0:0	6	(
op	364:35	0:0	6	*
water	364:36	0:0	6	src
op	364:40	0:0	6	&
water	364:42	0:0	6	0
water	364:43	0:0	6	x0F
water	364:46	0:0	6	)
water	364:47	0:0	6	;
water	365:12	0:0	6	src
op	365:15	0:0	6	++
water	365:17	0:0	6	;
water	366:8	0:0	6	}
for	367:8	380:8	4	(count1 = 0 ;count1 < nb_samples / 2;count1 ++)
forinit	367:13	367:23	5	count1 = 0 ;
water	367:13	0:0	6	count1
op	367:20	0:0	6	=
water	367:22	0:0	6	0
water	367:23	0:0	6	;
cond	367:25	367:47	5	count1 < nb_samples / 2
water	367:25	0:0	6	count1
op	367:32	0:0	6	<
water	367:34	0:0	6	nb_samples
op	367:45	0:0	6	/
water	367:47	0:0	6	2
forexpr	367:50	367:56	5	count1 ++
water	367:50	0:0	6	count1
op	367:56	0:0	6	++
stmts	367:60	380:8	5	
water	367:60	0:0	6	{
for	368:12	378:12	6	(i = 4 ;i >= 0;i -= 4)
forinit	368:16	368:21	7	i = 4 ;
water	368:16	0:0	8	i
op	368:18	0:0	8	=
water	368:20	0:0	8	4
water	368:21	0:0	8	;
cond	368:23	368:28	7	i >= 0
water	368:23	0:0	8	i
op	368:25	0:0	8	>=
water	368:28	0:0	8	0
forexpr	368:31	368:34	7	i -= 4
water	368:31	0:0	8	i
op	368:32	0:0	8	-=
water	368:34	0:0	8	4
stmts	368:37	378:12	7	
water	368:37	0:0	8	{
for	369:16	377:16	8	(channel = 0 ;channel < avctx -> channels;channel ++)
forinit	369:20	369:31	9	channel = 0 ;
water	369:20	0:0	10	channel
op	369:28	0:0	10	=
water	369:30	0:0	10	0
water	369:31	0:0	10	;
cond	369:33	369:50	9	channel < avctx -> channels
water	369:33	0:0	10	channel
op	369:41	0:0	10	<
water	369:43	0:0	10	avctx
op	369:48	0:0	10	->
water	369:50	0:0	10	channels
forexpr	369:60	369:67	9	channel ++
water	369:60	0:0	10	channel
op	369:67	0:0	10	++
stmts	369:71	377:16	9	
water	369:71	0:0	10	{
decl	370:20	370:88	10	int32_t	sample
op	370:35	0:0	10	=
call	370:37	370:69	11	sign_extend
arg	370:49	370:66	12	src[channel]>>i
water	370:49	0:0	13	src
op	370:52	0:0	13	[
water	370:53	0:0	13	channel
op	370:60	0:0	13	]
op	370:62	0:0	13	>>
water	370:65	0:0	13	i
arg	370:68	370:69	12	4
water	370:68	0:0	13	4
op	370:71	0:0	10	<<
water	370:74	0:0	10	shift
op	370:79	0:0	10	[
water	370:80	0:0	10	channel
op	370:87	0:0	10	]
water	371:20	0:0	10	sample
op	371:27	0:0	10	=
water	371:29	0:0	10	(
water	371:30	0:0	10	sample
op	371:37	0:0	10	+
water	372:29	0:0	10	c
op	372:30	0:0	10	->
water	372:32	0:0	10	status
op	372:38	0:0	10	[
water	372:39	0:0	10	channel
op	372:46	0:0	10	]
op	372:47	0:0	10	.
water	372:48	0:0	10	sample1
op	372:56	0:0	10	*
water	372:58	0:0	10	coeff
op	372:63	0:0	10	[
water	372:64	0:0	10	channel
op	372:71	0:0	10	]
op	372:72	0:0	10	[
water	372:73	0:0	10	0
op	372:74	0:0	10	]
op	372:76	0:0	10	+
water	373:29	0:0	10	c
op	373:30	0:0	10	->
water	373:32	0:0	10	status
op	373:38	0:0	10	[
water	373:39	0:0	10	channel
op	373:46	0:0	10	]
op	373:47	0:0	10	.
water	373:48	0:0	10	sample2
op	373:56	0:0	10	*
water	373:58	0:0	10	coeff
op	373:63	0:0	10	[
water	373:64	0:0	10	channel
op	373:71	0:0	10	]
op	373:72	0:0	10	[
water	373:73	0:0	10	1
op	373:74	0:0	10	]
op	373:76	0:0	10	+
water	373:78	0:0	10	0
water	373:79	0:0	10	x80
water	373:82	0:0	10	)
op	373:84	0:0	10	>>
water	373:87	0:0	10	8
water	373:88	0:0	10	;
water	374:20	0:0	10	c
op	374:21	0:0	10	->
water	374:23	0:0	10	status
op	374:29	0:0	10	[
water	374:30	0:0	10	channel
op	374:37	0:0	10	]
op	374:38	0:0	10	.
water	374:39	0:0	10	sample2
op	374:47	0:0	10	=
water	374:49	0:0	10	c
op	374:50	0:0	10	->
water	374:52	0:0	10	status
op	374:58	0:0	10	[
water	374:59	0:0	10	channel
op	374:66	0:0	10	]
op	374:67	0:0	10	.
water	374:68	0:0	10	sample1
water	374:75	0:0	10	;
water	375:20	0:0	10	c
op	375:21	0:0	10	->
water	375:23	0:0	10	status
op	375:29	0:0	10	[
water	375:30	0:0	10	channel
op	375:37	0:0	10	]
op	375:38	0:0	10	.
water	375:39	0:0	10	sample1
op	375:47	0:0	10	=
call	375:49	375:69	10	av_clip_int16
arg	375:63	375:69	11	sample
water	375:63	0:0	12	sample
water	375:70	0:0	10	;
op	376:20	0:0	10	*
water	376:21	0:0	10	samples
op	376:28	0:0	10	++
op	376:31	0:0	10	=
water	376:33	0:0	10	c
op	376:34	0:0	10	->
water	376:36	0:0	10	status
op	376:42	0:0	10	[
water	376:43	0:0	10	channel
op	376:50	0:0	10	]
op	376:51	0:0	10	.
water	376:52	0:0	10	sample1
water	376:59	0:0	10	;
water	377:16	0:0	10	}
water	378:12	0:0	8	}
water	379:12	0:0	6	src
op	379:15	0:0	6	+=
water	379:17	0:0	6	avctx
op	379:22	0:0	6	->
water	379:24	0:0	6	channels
water	379:32	0:0	6	;
water	380:8	0:0	6	}
water	382:8	0:0	4	src
op	382:12	0:0	4	=
water	382:14	0:0	4	buf
op	382:18	0:0	4	+
water	382:20	0:0	4	buf_size
water	382:28	0:0	4	;
break	383:8	383:13	4	
water	384:4	0:0	4	}
label	385:4	385:29	4	case CODEC_ID_ADPCM_EA_R1 :
label	386:4	386:29	4	case CODEC_ID_ADPCM_EA_R2 :
label	387:4	387:29	4	case CODEC_ID_ADPCM_EA_R3 :
water	387:31	0:0	4	{
decl	392:8	392:71	4	const int	big_endian
op	392:29	0:0	4	=
water	392:31	0:0	4	avctx
op	392:36	0:0	4	->
water	392:38	0:0	4	codec
op	392:43	0:0	4	->
water	392:45	0:0	4	id
op	392:48	0:0	4	==
water	392:51	0:0	4	CODEC_ID_ADPCM_EA_R3
decl	393:8	393:60	4	int32_t	previous_sample
water	393:31	0:0	4	,
decl	393:8	393:60	4	int32_t	current_sample
water	393:47	0:0	4	,
decl	393:8	393:60	4	int32_t	next_sample
decl	394:8	394:30	4	int32_t	coeff1
water	394:22	0:0	4	,
decl	394:8	394:30	4	int32_t	coeff2
decl	395:8	395:21	4	uint8_t	shift
decl	396:8	396:28	4	unsigned int	channel
decl	397:8	397:26	4	uint16_t	*samplesC
decl	398:8	398:27	4	const uint8_t	*srcC
decl	399:8	399:47	4	const uint8_t	*src_end
op	399:31	0:0	4	=
water	399:33	0:0	4	buf
op	399:37	0:0	4	+
water	399:39	0:0	4	buf_size
decl	400:8	400:21	4	int	count
op	400:18	0:0	4	=
water	400:20	0:0	4	0
water	402:8	0:0	4	src
op	402:12	0:0	4	+=
water	402:15	0:0	4	4
water	402:16	0:0	4	;
for	404:8	466:8	4	(channel = 0 ;channel < avctx -> channels;channel ++)
forinit	404:13	404:22	5	channel = 0 ;
water	404:13	0:0	6	channel
op	404:20	0:0	6	=
water	404:21	0:0	6	0
water	404:22	0:0	6	;
cond	404:24	404:39	5	channel < avctx -> channels
water	404:24	0:0	6	channel
op	404:31	0:0	6	<
water	404:32	0:0	6	avctx
op	404:37	0:0	6	->
water	404:39	0:0	6	channels
forexpr	404:49	404:56	5	channel ++
water	404:49	0:0	6	channel
op	404:56	0:0	6	++
stmts	404:60	466:8	5	
water	404:60	0:0	6	{
decl	405:12	407:60	6	int32_t	offset
op	405:27	0:0	6	=
water	405:29	0:0	6	(
water	405:30	0:0	6	big_endian
water	405:41	0:0	6	?
call	405:43	405:67	7	bytestream_get_be32
arg	405:63	405:67	8	&src
op	405:63	0:0	9	&
water	405:64	0:0	9	src
water	406:41	0:0	6	:
call	406:43	406:67	7	bytestream_get_le32
arg	406:63	406:67	8	&src
op	406:63	0:0	9	&
water	406:64	0:0	9	src
water	406:68	0:0	6	)
op	407:27	0:0	6	+
water	407:29	0:0	6	(
water	407:30	0:0	6	avctx
op	407:35	0:0	6	->
water	407:37	0:0	6	channels
op	407:45	0:0	6	-
water	407:46	0:0	6	channel
op	407:53	0:0	6	-
water	407:54	0:0	6	1
water	407:55	0:0	6	)
op	407:57	0:0	6	*
water	407:59	0:0	6	4
if	409:12	409:68	6	(( offset < 0 ) || ( offset >= src_end - src - 4 ))
cond	409:16	409:60	7	( offset < 0 ) || ( offset >= src_end - src - 4 )
water	409:16	0:0	8	(
water	409:17	0:0	8	offset
op	409:24	0:0	8	<
water	409:26	0:0	8	0
water	409:27	0:0	8	)
op	409:29	0:0	8	||
water	409:32	0:0	8	(
water	409:33	0:0	8	offset
op	409:40	0:0	8	>=
water	409:43	0:0	8	src_end
op	409:51	0:0	8	-
water	409:53	0:0	8	src
op	409:57	0:0	8	-
water	409:59	0:0	8	4
water	409:60	0:0	8	)
stmts	409:63	409:68	7	
break	409:63	409:68	8	
water	410:12	0:0	6	srcC
op	410:18	0:0	6	=
water	410:20	0:0	6	src
op	410:24	0:0	6	+
water	410:26	0:0	6	offset
water	410:32	0:0	6	;
water	411:12	0:0	6	samplesC
op	411:21	0:0	6	=
water	411:23	0:0	6	samples
op	411:31	0:0	6	+
water	411:33	0:0	6	channel
water	411:40	0:0	6	;
if	413:12	416:12	6	(avctx -> codec -> id == CODEC_ID_ADPCM_EA_R1)
cond	413:16	413:36	7	avctx -> codec -> id == CODEC_ID_ADPCM_EA_R1
water	413:16	0:0	8	avctx
op	413:21	0:0	8	->
water	413:23	0:0	8	codec
op	413:28	0:0	8	->
water	413:30	0:0	8	id
op	413:33	0:0	8	==
water	413:36	0:0	8	CODEC_ID_ADPCM_EA_R1
stmts	413:58	416:12	7	
water	413:58	0:0	8	{
water	414:16	0:0	8	current_sample
op	414:32	0:0	8	=
water	414:34	0:0	8	(
water	414:35	0:0	8	int16_t
water	414:42	0:0	8	)
call	414:43	414:68	8	bytestream_get_le16
arg	414:63	414:68	9	&srcC
op	414:63	0:0	10	&
water	414:64	0:0	10	srcC
water	414:69	0:0	8	;
water	415:16	0:0	8	previous_sample
op	415:32	0:0	8	=
water	415:34	0:0	8	(
water	415:35	0:0	8	int16_t
water	415:42	0:0	8	)
call	415:43	415:68	8	bytestream_get_le16
arg	415:63	415:68	9	&srcC
op	415:63	0:0	10	&
water	415:64	0:0	10	srcC
water	415:69	0:0	8	;
water	416:12	0:0	8	}
else	416:14	419:12	6
stmts	416:19	419:12	7	
water	416:19	0:0	8	{
water	417:16	0:0	8	current_sample
op	417:32	0:0	8	=
water	417:34	0:0	8	c
op	417:35	0:0	8	->
water	417:37	0:0	8	status
op	417:43	0:0	8	[
water	417:44	0:0	8	channel
op	417:51	0:0	8	]
op	417:52	0:0	8	.
water	417:53	0:0	8	predictor
water	417:62	0:0	8	;
water	418:16	0:0	8	previous_sample
op	418:32	0:0	8	=
water	418:34	0:0	8	c
op	418:35	0:0	8	->
water	418:37	0:0	8	status
op	418:43	0:0	8	[
water	418:44	0:0	8	channel
op	418:51	0:0	8	]
op	418:52	0:0	8	.
water	418:53	0:0	8	prev_sample
water	418:64	0:0	8	;
water	419:12	0:0	8	}
for	421:12	454:12	6	(count1 = 0 ;count1 < nb_samples / 28;count1 ++)
forinit	421:17	421:27	7	count1 = 0 ;
water	421:17	0:0	8	count1
op	421:24	0:0	8	=
water	421:26	0:0	8	0
water	421:27	0:0	8	;
cond	421:29	421:51	7	count1 < nb_samples / 28
water	421:29	0:0	8	count1
op	421:36	0:0	8	<
water	421:38	0:0	8	nb_samples
op	421:49	0:0	8	/
water	421:51	0:0	8	28
forexpr	421:55	421:61	7	count1 ++
water	421:55	0:0	8	count1
op	421:61	0:0	8	++
stmts	421:65	454:12	7	
water	421:65	0:0	8	{
if	422:16	432:16	8	(* srcC == 0 xEE)
cond	422:20	422:30	9	* srcC == 0 xEE
op	422:20	0:0	10	*
water	422:21	0:0	10	srcC
op	422:26	0:0	10	==
water	422:29	0:0	10	0
water	422:30	0:0	10	xEE
stmts	422:35	432:16	9	
water	422:35	0:0	10	{
water	423:20	0:0	10	srcC
op	423:24	0:0	10	++
water	423:26	0:0	10	;
if	424:20	424:52	10	(srcC > src_end - 30 * 2)
cond	424:24	424:44	11	srcC > src_end - 30 * 2
water	424:24	0:0	12	srcC
op	424:29	0:0	12	>
water	424:31	0:0	12	src_end
op	424:39	0:0	12	-
water	424:41	0:0	12	30
op	424:43	0:0	12	*
water	424:44	0:0	12	2
stmts	424:47	424:52	11	
break	424:47	424:52	12	
water	425:20	0:0	10	current_sample
op	425:36	0:0	10	=
water	425:38	0:0	10	(
water	425:39	0:0	10	int16_t
water	425:46	0:0	10	)
call	425:47	425:72	10	bytestream_get_be16
arg	425:67	425:72	11	&srcC
op	425:67	0:0	12	&
water	425:68	0:0	12	srcC
water	425:73	0:0	10	;
water	426:20	0:0	10	previous_sample
op	426:36	0:0	10	=
water	426:38	0:0	10	(
water	426:39	0:0	10	int16_t
water	426:46	0:0	10	)
call	426:47	426:72	10	bytestream_get_be16
arg	426:67	426:72	11	&srcC
op	426:67	0:0	12	&
water	426:68	0:0	12	srcC
water	426:73	0:0	10	;
for	428:20	431:20	10	(count2 = 0 ;count2 < 28;count2 ++)
forinit	428:25	428:33	11	count2 = 0 ;
water	428:25	0:0	12	count2
op	428:31	0:0	12	=
water	428:32	0:0	12	0
water	428:33	0:0	12	;
cond	428:35	428:42	11	count2 < 28
water	428:35	0:0	12	count2
op	428:41	0:0	12	<
water	428:42	0:0	12	28
forexpr	428:46	428:52	11	count2 ++
water	428:46	0:0	12	count2
op	428:52	0:0	12	++
stmts	428:56	431:20	11	
water	428:56	0:0	12	{
op	429:24	0:0	12	*
water	429:25	0:0	12	samplesC
op	429:34	0:0	12	=
water	429:36	0:0	12	(
water	429:37	0:0	12	int16_t
water	429:44	0:0	12	)
call	429:45	429:70	12	bytestream_get_be16
arg	429:65	429:70	13	&srcC
op	429:65	0:0	14	&
water	429:66	0:0	14	srcC
water	429:71	0:0	12	;
water	430:24	0:0	12	samplesC
op	430:33	0:0	12	+=
water	430:36	0:0	12	avctx
op	430:41	0:0	12	->
water	430:43	0:0	12	channels
water	430:51	0:0	12	;
water	431:20	0:0	12	}
water	432:16	0:0	10	}
else	432:18	453:16	8
stmts	432:23	453:16	9	
water	432:23	0:0	10	{
water	433:20	0:0	10	coeff1
op	433:27	0:0	10	=
water	433:29	0:0	10	ea_adpcm_table
op	433:43	0:0	10	[
op	433:45	0:0	10	*
water	433:46	0:0	10	srcC
op	433:50	0:0	10	>>
water	433:52	0:0	10	4
op	433:58	0:0	10	]
water	433:59	0:0	10	;
water	434:20	0:0	10	coeff2
op	434:27	0:0	10	=
water	434:29	0:0	10	ea_adpcm_table
op	434:43	0:0	10	[
water	434:44	0:0	10	(
op	434:45	0:0	10	*
water	434:46	0:0	10	srcC
op	434:50	0:0	10	>>
water	434:52	0:0	10	4
water	434:53	0:0	10	)
op	434:55	0:0	10	+
water	434:57	0:0	10	4
op	434:58	0:0	10	]
water	434:59	0:0	10	;
water	435:20	0:0	10	shift
op	435:26	0:0	10	=
water	435:28	0:0	10	20
op	435:31	0:0	10	-
water	435:33	0:0	10	(
op	435:34	0:0	10	*
water	435:35	0:0	10	srcC
op	435:39	0:0	10	++
op	435:42	0:0	10	&
water	435:44	0:0	10	0
water	435:45	0:0	10	x0F
water	435:48	0:0	10	)
water	435:49	0:0	10	;
if	437:20	437:50	10	(srcC > src_end - 14)
cond	437:24	437:41	11	srcC > src_end - 14
water	437:24	0:0	12	srcC
op	437:29	0:0	12	>
water	437:31	0:0	12	src_end
op	437:39	0:0	12	-
water	437:41	0:0	12	14
stmts	437:45	437:50	11	
break	437:45	437:50	12	
for	438:20	452:20	10	(count2 = 0 ;count2 < 28;count2 ++)
forinit	438:25	438:33	11	count2 = 0 ;
water	438:25	0:0	12	count2
op	438:31	0:0	12	=
water	438:32	0:0	12	0
water	438:33	0:0	12	;
cond	438:35	438:42	11	count2 < 28
water	438:35	0:0	12	count2
op	438:41	0:0	12	<
water	438:42	0:0	12	28
forexpr	438:46	438:52	11	count2 ++
water	438:46	0:0	12	count2
op	438:52	0:0	12	++
stmts	438:56	452:20	11	
water	438:56	0:0	12	{
if	439:24	440:77	12	(count2 & 1)
cond	439:28	439:37	13	count2 & 1
water	439:28	0:0	14	count2
op	439:35	0:0	14	&
water	439:37	0:0	14	1
stmts	440:28	440:77	13	
water	440:28	0:0	14	next_sample
op	440:40	0:0	14	=
call	440:42	440:67	14	sign_extend
arg	440:54	440:61	15	*srcC++
op	440:54	0:0	16	*
water	440:55	0:0	16	srcC
op	440:59	0:0	16	++
arg	440:66	440:67	15	4
water	440:66	0:0	16	4
op	440:69	0:0	14	<<
water	440:72	0:0	14	shift
water	440:77	0:0	14	;
else	441:24	442:77	12
stmts	442:28	442:77	13	
water	442:28	0:0	14	next_sample
op	442:40	0:0	14	=
call	442:42	442:67	14	sign_extend
arg	442:54	442:64	15	*srcC>>4
op	442:54	0:0	16	*
water	442:55	0:0	16	srcC
op	442:60	0:0	16	>>
water	442:63	0:0	16	4
arg	442:66	442:67	15	4
water	442:66	0:0	16	4
op	442:69	0:0	14	<<
water	442:72	0:0	14	shift
water	442:77	0:0	14	;
water	444:24	0:0	12	next_sample
op	444:36	0:0	12	+=
water	444:39	0:0	12	(
water	444:40	0:0	12	current_sample
op	444:56	0:0	12	*
water	444:58	0:0	12	coeff1
water	444:64	0:0	12	)
op	444:66	0:0	12	+
water	445:39	0:0	12	(
water	445:40	0:0	12	previous_sample
op	445:56	0:0	12	*
water	445:58	0:0	12	coeff2
water	445:64	0:0	12	)
water	445:65	0:0	12	;
water	446:24	0:0	12	next_sample
op	446:36	0:0	12	=
call	446:38	446:68	12	av_clip_int16
arg	446:52	446:68	13	next_sample>>8
water	446:52	0:0	14	next_sample
op	446:64	0:0	14	>>
water	446:67	0:0	14	8
water	446:69	0:0	12	;
water	448:24	0:0	12	previous_sample
op	448:40	0:0	12	=
water	448:42	0:0	12	current_sample
water	448:56	0:0	12	;
water	449:24	0:0	12	current_sample
op	449:40	0:0	12	=
water	449:42	0:0	12	next_sample
water	449:53	0:0	12	;
op	450:24	0:0	12	*
water	450:25	0:0	12	samplesC
op	450:34	0:0	12	=
water	450:36	0:0	12	current_sample
water	450:50	0:0	12	;
water	451:24	0:0	12	samplesC
op	451:33	0:0	12	+=
water	451:36	0:0	12	avctx
op	451:41	0:0	12	->
water	451:43	0:0	12	channels
water	451:51	0:0	12	;
water	452:20	0:0	12	}
water	453:16	0:0	10	}
water	454:12	0:0	8	}
if	455:12	457:12	6	(! count)
cond	455:16	455:17	7	! count
op	455:16	0:0	8	!
water	455:17	0:0	8	count
stmts	455:24	457:12	7	
water	455:24	0:0	8	{
water	456:16	0:0	8	count
op	456:22	0:0	8	=
water	456:24	0:0	8	count1
water	456:30	0:0	8	;
water	457:12	0:0	8	}
else	457:14	460:12	6
stmts	457:19	460:12	7	
if	457:19	460:12	8	(count != count1)
cond	457:23	457:32	9	count != count1
water	457:23	0:0	10	count
op	457:29	0:0	10	!=
water	457:32	0:0	10	count1
stmts	457:40	460:12	9	
water	457:40	0:0	10	{
call	458:16	458:83	10	av_log
arg	458:23	458:28	11	avctx
water	458:23	0:0	12	avctx
arg	458:30	458:44	11	AV_LOG_WARNING
water	458:30	0:0	12	AV_LOG_WARNING
arg	458:46	458:83	11	"per-channel sample count mismatch\n"
water	458:46	0:0	12	"per-channel sample count mismatch\n"
water	458:84	0:0	10	;
water	459:16	0:0	10	count
op	459:22	0:0	10	=
call	459:24	459:43	10	FFMAX
arg	459:30	459:35	11	count
water	459:30	0:0	12	count
arg	459:37	459:43	11	count1
water	459:37	0:0	12	count1
water	459:44	0:0	10	;
water	460:12	0:0	10	}
if	462:12	465:12	6	(avctx -> codec -> id != CODEC_ID_ADPCM_EA_R1)
cond	462:16	462:36	7	avctx -> codec -> id != CODEC_ID_ADPCM_EA_R1
water	462:16	0:0	8	avctx
op	462:21	0:0	8	->
water	462:23	0:0	8	codec
op	462:28	0:0	8	->
water	462:30	0:0	8	id
op	462:33	0:0	8	!=
water	462:36	0:0	8	CODEC_ID_ADPCM_EA_R1
stmts	462:58	465:12	7	
water	462:58	0:0	8	{
water	463:16	0:0	8	c
op	463:17	0:0	8	->
water	463:19	0:0	8	status
op	463:25	0:0	8	[
water	463:26	0:0	8	channel
op	463:33	0:0	8	]
op	463:34	0:0	8	.
water	463:35	0:0	8	predictor
op	463:47	0:0	8	=
water	463:49	0:0	8	current_sample
water	463:63	0:0	8	;
water	464:16	0:0	8	c
op	464:17	0:0	8	->
water	464:19	0:0	8	status
op	464:25	0:0	8	[
water	464:26	0:0	8	channel
op	464:33	0:0	8	]
op	464:34	0:0	8	.
water	464:35	0:0	8	prev_sample
op	464:47	0:0	8	=
water	464:49	0:0	8	previous_sample
water	464:64	0:0	8	;
water	465:12	0:0	8	}
water	466:8	0:0	6	}
water	468:8	0:0	4	c
op	468:9	0:0	4	->
water	468:11	0:0	4	frame
op	468:16	0:0	4	.
water	468:17	0:0	4	nb_samples
op	468:28	0:0	4	=
water	468:30	0:0	4	count
op	468:36	0:0	4	*
water	468:38	0:0	4	28
water	468:40	0:0	4	;
water	469:8	0:0	4	src
op	469:12	0:0	4	=
water	469:14	0:0	4	src_end
water	469:21	0:0	4	;
break	470:8	470:13	4	
water	471:4	0:0	4	}
label	472:4	472:30	4	case CODEC_ID_ADPCM_EA_XAS :
for	473:8	495:8	4	(channel = 0 ;channel < avctx -> channels;channel ++)
forinit	473:13	473:22	5	channel = 0 ;
water	473:13	0:0	6	channel
op	473:20	0:0	6	=
water	473:21	0:0	6	0
water	473:22	0:0	6	;
cond	473:24	473:39	5	channel < avctx -> channels
water	473:24	0:0	6	channel
op	473:31	0:0	6	<
water	473:32	0:0	6	avctx
op	473:37	0:0	6	->
water	473:39	0:0	6	channels
forexpr	473:49	473:56	5	channel ++
water	473:49	0:0	6	channel
op	473:56	0:0	6	++
stmts	473:60	495:8	5	
water	473:60	0:0	6	{
water	474:12	0:0	6	int
water	474:16	0:0	6	coeff
op	474:21	0:0	6	[
water	474:22	0:0	6	2
op	474:23	0:0	6	]
op	474:24	0:0	6	[
water	474:25	0:0	6	4
op	474:26	0:0	6	]
water	474:27	0:0	6	,
water	474:29	0:0	6	shift
op	474:34	0:0	6	[
water	474:35	0:0	6	4
op	474:36	0:0	6	]
water	474:37	0:0	6	;
decl	475:12	475:45	6	short	*s2
water	475:21	0:0	6	,
decl	475:12	475:45	6	short	*s
op	475:26	0:0	6	=
op	475:28	0:0	6	&
water	475:29	0:0	6	samples
op	475:36	0:0	6	[
water	475:37	0:0	6	channel
op	475:44	0:0	6	]
for	476:12	482:12	6	(n = 0 ;n < 4;n ++ , s += 32 * avctx -> channels)
forinit	476:17	476:20	7	n = 0 ;
water	476:17	0:0	8	n
op	476:18	0:0	8	=
water	476:19	0:0	8	0
water	476:20	0:0	8	;
cond	476:22	476:24	7	n < 4
water	476:22	0:0	8	n
op	476:23	0:0	8	<
water	476:24	0:0	8	4
forexpr	476:27	476:45	7	n ++ , s += 32 * avctx -> channels
water	476:27	0:0	8	n
op	476:28	0:0	8	++
water	476:30	0:0	8	,
water	476:32	0:0	8	s
op	476:33	0:0	8	+=
water	476:35	0:0	8	32
op	476:37	0:0	8	*
water	476:38	0:0	8	avctx
op	476:43	0:0	8	->
water	476:45	0:0	8	channels
stmts	476:55	482:12	7	
water	476:55	0:0	8	{
for	477:16	478:67	8	(i = 0 ;i < 2;i ++)
forinit	477:21	477:24	9	i = 0 ;
water	477:21	0:0	10	i
op	477:22	0:0	10	=
water	477:23	0:0	10	0
water	477:24	0:0	10	;
cond	477:26	477:28	9	i < 2
water	477:26	0:0	10	i
op	477:27	0:0	10	<
water	477:28	0:0	10	2
forexpr	477:31	477:32	9	i ++
water	477:31	0:0	10	i
op	477:32	0:0	10	++
stmts	478:20	478:67	9	
water	478:20	0:0	10	coeff
op	478:25	0:0	10	[
water	478:26	0:0	10	i
op	478:27	0:0	10	]
op	478:28	0:0	10	[
water	478:29	0:0	10	n
op	478:30	0:0	10	]
op	478:32	0:0	10	=
water	478:34	0:0	10	ea_adpcm_table
op	478:48	0:0	10	[
water	478:49	0:0	10	(
water	478:50	0:0	10	src
op	478:53	0:0	10	[
water	478:54	0:0	10	0
op	478:55	0:0	10	]
op	478:56	0:0	10	&
water	478:57	0:0	10	0
water	478:58	0:0	10	x0F
water	478:61	0:0	10	)
op	478:62	0:0	10	+
water	478:63	0:0	10	4
op	478:64	0:0	10	*
water	478:65	0:0	10	i
op	478:66	0:0	10	]
water	478:67	0:0	10	;
water	479:16	0:0	8	shift
op	479:21	0:0	8	[
water	479:22	0:0	8	n
op	479:23	0:0	8	]
op	479:25	0:0	8	=
water	479:27	0:0	8	20
op	479:30	0:0	8	-
water	479:32	0:0	8	(
water	479:33	0:0	8	src
op	479:36	0:0	8	[
water	479:37	0:0	8	2
op	479:38	0:0	8	]
op	479:40	0:0	8	&
water	479:42	0:0	8	0
water	479:43	0:0	8	x0F
water	479:46	0:0	8	)
water	479:47	0:0	8	;
for	480:16	481:55	8	(s2 = s , i = 0 ;i < 2;i ++ , src += 2 , s2 += avctx -> channels)
forinit	480:21	480:30	9	s2 = s , i = 0 ;
water	480:21	0:0	10	s2
op	480:23	0:0	10	=
water	480:24	0:0	10	s
water	480:25	0:0	10	,
water	480:27	0:0	10	i
op	480:28	0:0	10	=
water	480:29	0:0	10	0
water	480:30	0:0	10	;
cond	480:32	480:34	9	i < 2
water	480:32	0:0	10	i
op	480:33	0:0	10	<
water	480:34	0:0	10	2
forexpr	480:37	480:61	9	i ++ , src += 2 , s2 += avctx -> channels
water	480:37	0:0	10	i
op	480:38	0:0	10	++
water	480:40	0:0	10	,
water	480:42	0:0	10	src
op	480:45	0:0	10	+=
water	480:47	0:0	10	2
water	480:48	0:0	10	,
water	480:50	0:0	10	s2
op	480:52	0:0	10	+=
water	480:54	0:0	10	avctx
op	480:59	0:0	10	->
water	480:61	0:0	10	channels
stmts	481:20	481:55	9	
water	481:20	0:0	10	s2
op	481:22	0:0	10	[
water	481:23	0:0	10	0
op	481:24	0:0	10	]
op	481:26	0:0	10	=
water	481:28	0:0	10	(
water	481:29	0:0	10	src
op	481:32	0:0	10	[
water	481:33	0:0	10	0
op	481:34	0:0	10	]
op	481:35	0:0	10	&
water	481:36	0:0	10	0
water	481:37	0:0	10	xF0
water	481:40	0:0	10	)
op	481:42	0:0	10	+
water	481:44	0:0	10	(
water	481:45	0:0	10	src
op	481:48	0:0	10	[
water	481:49	0:0	10	1
op	481:50	0:0	10	]
op	481:51	0:0	10	<<
water	481:53	0:0	10	8
water	481:54	0:0	10	)
water	481:55	0:0	10	;
water	482:12	0:0	8	}
for	484:12	494:12	6	(m = 2 ;m < 32;m += 2)
forinit	484:17	484:20	7	m = 2 ;
water	484:17	0:0	8	m
op	484:18	0:0	8	=
water	484:19	0:0	8	2
water	484:20	0:0	8	;
cond	484:22	484:24	7	m < 32
water	484:22	0:0	8	m
op	484:23	0:0	8	<
water	484:24	0:0	8	32
forexpr	484:28	484:31	7	m += 2
water	484:28	0:0	8	m
op	484:29	0:0	8	+=
water	484:31	0:0	8	2
stmts	484:34	494:12	7	
water	484:34	0:0	8	{
water	485:16	0:0	8	s
op	485:18	0:0	8	=
op	485:20	0:0	8	&
water	485:21	0:0	8	samples
op	485:28	0:0	8	[
water	485:29	0:0	8	m
op	485:30	0:0	8	*
water	485:31	0:0	8	avctx
op	485:36	0:0	8	->
water	485:38	0:0	8	channels
op	485:47	0:0	8	+
water	485:49	0:0	8	channel
op	485:56	0:0	8	]
water	485:57	0:0	8	;
for	486:16	493:16	8	(n = 0 ;n < 4;n ++ , src ++ , s += 32 * avctx -> channels)
forinit	486:21	486:24	9	n = 0 ;
water	486:21	0:0	10	n
op	486:22	0:0	10	=
water	486:23	0:0	10	0
water	486:24	0:0	10	;
cond	486:26	486:28	9	n < 4
water	486:26	0:0	10	n
op	486:27	0:0	10	<
water	486:28	0:0	10	4
forexpr	486:31	486:56	9	n ++ , src ++ , s += 32 * avctx -> channels
water	486:31	0:0	10	n
op	486:32	0:0	10	++
water	486:34	0:0	10	,
water	486:36	0:0	10	src
op	486:39	0:0	10	++
water	486:41	0:0	10	,
water	486:43	0:0	10	s
op	486:44	0:0	10	+=
water	486:46	0:0	10	32
op	486:48	0:0	10	*
water	486:49	0:0	10	avctx
op	486:54	0:0	10	->
water	486:56	0:0	10	channels
stmts	486:66	493:16	9	
water	486:66	0:0	10	{
for	487:20	492:20	10	(s2 = s , i = 0 ;i < 8;i += 4 , s2 += avctx -> channels)
forinit	487:25	487:34	11	s2 = s , i = 0 ;
water	487:25	0:0	12	s2
op	487:27	0:0	12	=
water	487:28	0:0	12	s
water	487:29	0:0	12	,
water	487:31	0:0	12	i
op	487:32	0:0	12	=
water	487:33	0:0	12	0
water	487:34	0:0	12	;
cond	487:36	487:38	11	i < 8
water	487:36	0:0	12	i
op	487:37	0:0	12	<
water	487:38	0:0	12	8
forexpr	487:41	487:58	11	i += 4 , s2 += avctx -> channels
water	487:41	0:0	12	i
op	487:42	0:0	12	+=
water	487:44	0:0	12	4
water	487:45	0:0	12	,
water	487:47	0:0	12	s2
op	487:49	0:0	12	+=
water	487:51	0:0	12	avctx
op	487:56	0:0	12	->
water	487:58	0:0	12	channels
stmts	487:68	492:20	11	
water	487:68	0:0	12	{
decl	488:24	488:79	12	int	level
op	488:34	0:0	12	=
call	488:36	488:66	13	sign_extend
arg	488:48	488:63	14	*src>>(4-i)
op	488:48	0:0	15	*
water	488:49	0:0	15	src
op	488:53	0:0	15	>>
water	488:56	0:0	15	(
water	488:57	0:0	15	4
op	488:59	0:0	15	-
water	488:61	0:0	15	i
water	488:62	0:0	15	)
arg	488:65	488:66	14	4
water	488:65	0:0	15	4
op	488:68	0:0	12	<<
water	488:71	0:0	12	shift
op	488:76	0:0	12	[
water	488:77	0:0	12	n
op	488:78	0:0	12	]
decl	489:24	490:72	12	int	pred
op	489:34	0:0	12	=
water	489:36	0:0	12	s2
op	489:38	0:0	12	[
op	489:39	0:0	12	-
water	489:40	0:0	12	1
op	489:41	0:0	12	*
water	489:42	0:0	12	avctx
op	489:47	0:0	12	->
water	489:49	0:0	12	channels
op	489:57	0:0	12	]
op	489:59	0:0	12	*
water	489:61	0:0	12	coeff
op	489:66	0:0	12	[
water	489:67	0:0	12	0
op	489:68	0:0	12	]
op	489:69	0:0	12	[
water	489:70	0:0	12	n
op	489:71	0:0	12	]
op	490:34	0:0	12	+
water	490:36	0:0	12	s2
op	490:38	0:0	12	[
op	490:39	0:0	12	-
water	490:40	0:0	12	2
op	490:41	0:0	12	*
water	490:42	0:0	12	avctx
op	490:47	0:0	12	->
water	490:49	0:0	12	channels
op	490:57	0:0	12	]
op	490:59	0:0	12	*
water	490:61	0:0	12	coeff
op	490:66	0:0	12	[
water	490:67	0:0	12	1
op	490:68	0:0	12	]
op	490:69	0:0	12	[
water	490:70	0:0	12	n
op	490:71	0:0	12	]
water	491:24	0:0	12	s2
op	491:26	0:0	12	[
water	491:27	0:0	12	0
op	491:28	0:0	12	]
op	491:30	0:0	12	=
call	491:32	491:72	12	av_clip_int16
arg	491:46	491:72	13	(level+pred+0x80)>>8
water	491:46	0:0	14	(
water	491:47	0:0	14	level
op	491:53	0:0	14	+
water	491:55	0:0	14	pred
op	491:60	0:0	14	+
water	491:62	0:0	14	0
water	491:63	0:0	14	x80
water	491:66	0:0	14	)
op	491:68	0:0	14	>>
water	491:71	0:0	14	8
water	491:73	0:0	12	;
water	492:20	0:0	12	}
water	493:16	0:0	10	}
water	494:12	0:0	8	}
water	495:8	0:0	6	}
break	496:8	496:13	4	
label	497:4	497:31	4	case CODEC_ID_ADPCM_IMA_AMV :
label	498:4	498:34	4	case CODEC_ID_ADPCM_IMA_SMJPEG :
if	499:8	503:8	4	(avctx -> codec -> id == CODEC_ID_ADPCM_IMA_AMV)
cond	499:12	499:32	5	avctx -> codec -> id == CODEC_ID_ADPCM_IMA_AMV
water	499:12	0:0	6	avctx
op	499:17	0:0	6	->
water	499:19	0:0	6	codec
op	499:24	0:0	6	->
water	499:26	0:0	6	id
op	499:29	0:0	6	==
water	499:32	0:0	6	CODEC_ID_ADPCM_IMA_AMV
stmts	499:56	503:8	5	
water	499:56	0:0	6	{
water	500:12	0:0	6	c
op	500:13	0:0	6	->
water	500:15	0:0	6	status
op	500:21	0:0	6	[
water	500:22	0:0	6	0
op	500:23	0:0	6	]
op	500:24	0:0	6	.
water	500:25	0:0	6	predictor
op	500:35	0:0	6	=
call	500:37	500:78	6	sign_extend
arg	500:49	500:74	7	bytestream_get_le16(&src)
call	500:49	500:73	8	bytestream_get_le16
arg	500:69	500:73	9	&src
op	500:69	0:0	10	&
water	500:70	0:0	10	src
arg	500:76	500:78	7	16
water	500:76	0:0	8	16
water	500:79	0:0	6	;
water	501:12	0:0	6	c
op	501:13	0:0	6	->
water	501:15	0:0	6	status
op	501:21	0:0	6	[
water	501:22	0:0	6	0
op	501:23	0:0	6	]
op	501:24	0:0	6	.
water	501:25	0:0	6	step_index
op	501:36	0:0	6	=
call	501:38	501:62	6	bytestream_get_le16
arg	501:58	501:62	7	&src
op	501:58	0:0	8	&
water	501:59	0:0	8	src
water	501:63	0:0	6	;
water	502:12	0:0	6	src
op	502:16	0:0	6	+=
water	502:19	0:0	6	4
water	502:20	0:0	6	;
water	503:8	0:0	6	}
else	503:10	507:8	4
stmts	503:15	507:8	5	
water	503:15	0:0	6	{
water	504:12	0:0	6	c
op	504:13	0:0	6	->
water	504:15	0:0	6	status
op	504:21	0:0	6	[
water	504:22	0:0	6	0
op	504:23	0:0	6	]
op	504:24	0:0	6	.
water	504:25	0:0	6	predictor
op	504:35	0:0	6	=
call	504:37	504:78	6	sign_extend
arg	504:49	504:74	7	bytestream_get_be16(&src)
call	504:49	504:73	8	bytestream_get_be16
arg	504:69	504:73	9	&src
op	504:69	0:0	10	&
water	504:70	0:0	10	src
arg	504:76	504:78	7	16
water	504:76	0:0	8	16
water	504:79	0:0	6	;
water	505:12	0:0	6	c
op	505:13	0:0	6	->
water	505:15	0:0	6	status
op	505:21	0:0	6	[
water	505:22	0:0	6	0
op	505:23	0:0	6	]
op	505:24	0:0	6	.
water	505:25	0:0	6	step_index
op	505:36	0:0	6	=
call	505:38	505:62	6	bytestream_get_byte
arg	505:58	505:62	7	&src
op	505:58	0:0	8	&
water	505:59	0:0	8	src
water	505:63	0:0	6	;
water	506:12	0:0	6	src
op	506:16	0:0	6	+=
water	506:19	0:0	6	1
water	506:20	0:0	6	;
water	507:8	0:0	6	}
for	509:8	521:8	4	(n = nb_samples >> ( 1 - st ) ;n > 0;n -- , src ++)
forinit	509:13	509:39	5	n = nb_samples >> ( 1 - st ) ;
water	509:13	0:0	6	n
op	509:15	0:0	6	=
water	509:17	0:0	6	nb_samples
op	509:28	0:0	6	>>
water	509:31	0:0	6	(
water	509:32	0:0	6	1
op	509:34	0:0	6	-
water	509:36	0:0	6	st
water	509:38	0:0	6	)
water	509:39	0:0	6	;
cond	509:41	509:45	5	n > 0
water	509:41	0:0	6	n
op	509:43	0:0	6	>
water	509:45	0:0	6	0
forexpr	509:48	509:56	5	n -- , src ++
water	509:48	0:0	6	n
op	509:49	0:0	6	--
water	509:51	0:0	6	,
water	509:53	0:0	6	src
op	509:56	0:0	6	++
stmts	509:60	521:8	5	
water	509:60	0:0	6	{
decl	510:12	510:23	6	char	hi
water	510:19	0:0	6	,
decl	510:12	510:23	6	char	lo
water	511:12	0:0	6	lo
op	511:15	0:0	6	=
op	511:17	0:0	6	*
water	511:18	0:0	6	src
op	511:22	0:0	6	&
water	511:24	0:0	6	0
water	511:25	0:0	6	x0F
water	511:28	0:0	6	;
water	512:12	0:0	6	hi
op	512:15	0:0	6	=
op	512:17	0:0	6	*
water	512:18	0:0	6	src
op	512:22	0:0	6	>>
water	512:25	0:0	6	4
water	512:26	0:0	6	;
if	514:12	515:36	6	(avctx -> codec -> id == CODEC_ID_ADPCM_IMA_AMV)
cond	514:16	514:36	7	avctx -> codec -> id == CODEC_ID_ADPCM_IMA_AMV
water	514:16	0:0	8	avctx
op	514:21	0:0	8	->
water	514:23	0:0	8	codec
op	514:28	0:0	8	->
water	514:30	0:0	8	id
op	514:33	0:0	8	==
water	514:36	0:0	8	CODEC_ID_ADPCM_IMA_AMV
stmts	515:16	515:36	7	
call	515:16	515:35	8	FFSWAP
arg	515:23	515:27	9	char
water	515:23	0:0	10	char
arg	515:29	515:31	9	hi
water	515:29	0:0	10	hi
arg	515:33	515:35	9	lo
water	515:33	0:0	10	lo
water	515:36	0:0	8	;
op	517:12	0:0	6	*
water	517:13	0:0	6	samples
op	517:20	0:0	6	++
op	517:23	0:0	6	=
call	517:25	518:21	6	adpcm_ima_expand_nibble
arg	517:49	517:62	7	&c->status[0]
op	517:49	0:0	8	&
water	517:50	0:0	8	c
op	517:51	0:0	8	->
water	517:53	0:0	8	status
op	517:59	0:0	8	[
water	517:60	0:0	8	0
op	517:61	0:0	8	]
arg	518:16	518:18	7	lo
water	518:16	0:0	8	lo
arg	518:20	518:21	7	3
water	518:20	0:0	8	3
water	518:22	0:0	6	;
op	519:12	0:0	6	*
water	519:13	0:0	6	samples
op	519:20	0:0	6	++
op	519:23	0:0	6	=
call	519:25	520:21	6	adpcm_ima_expand_nibble
arg	519:49	519:62	7	&c->status[0]
op	519:49	0:0	8	&
water	519:50	0:0	8	c
op	519:51	0:0	8	->
water	519:53	0:0	8	status
op	519:59	0:0	8	[
water	519:60	0:0	8	0
op	519:61	0:0	8	]
arg	520:16	520:18	7	hi
water	520:16	0:0	8	hi
arg	520:20	520:21	7	3
water	520:20	0:0	8	3
water	520:22	0:0	6	;
water	521:8	0:0	6	}
break	522:8	522:13	4	
label	523:4	523:26	4	case CODEC_ID_ADPCM_CT :
for	524:8	528:8	4	(n = nb_samples >> ( 1 - st ) ;n > 0;n -- , src ++)
forinit	524:13	524:39	5	n = nb_samples >> ( 1 - st ) ;
water	524:13	0:0	6	n
op	524:15	0:0	6	=
water	524:17	0:0	6	nb_samples
op	524:28	0:0	6	>>
water	524:31	0:0	6	(
water	524:32	0:0	6	1
op	524:34	0:0	6	-
water	524:36	0:0	6	st
water	524:38	0:0	6	)
water	524:39	0:0	6	;
cond	524:41	524:45	5	n > 0
water	524:41	0:0	6	n
op	524:43	0:0	6	>
water	524:45	0:0	6	0
forexpr	524:48	524:56	5	n -- , src ++
water	524:48	0:0	6	n
op	524:49	0:0	6	--
water	524:51	0:0	6	,
water	524:53	0:0	6	src
op	524:56	0:0	6	++
stmts	524:60	528:8	5	
water	524:60	0:0	6	{
decl	525:12	525:28	6	uint8_t	v
op	525:22	0:0	6	=
op	525:24	0:0	6	*
water	525:25	0:0	6	src
op	526:12	0:0	6	*
water	526:13	0:0	6	samples
op	526:20	0:0	6	++
op	526:23	0:0	6	=
call	526:25	526:72	6	adpcm_ct_expand_nibble
arg	526:48	526:62	7	&c->status[0]
op	526:48	0:0	8	&
water	526:49	0:0	8	c
op	526:50	0:0	8	->
water	526:52	0:0	8	status
op	526:58	0:0	8	[
water	526:59	0:0	8	0
op	526:61	0:0	8	]
arg	526:64	526:72	7	v>>4
water	526:64	0:0	8	v
op	526:66	0:0	8	>>
water	526:69	0:0	8	4
water	526:73	0:0	6	;
op	527:12	0:0	6	*
water	527:13	0:0	6	samples
op	527:20	0:0	6	++
op	527:23	0:0	6	=
call	527:25	527:72	6	adpcm_ct_expand_nibble
arg	527:48	527:62	7	&c->status[st]
op	527:48	0:0	8	&
water	527:49	0:0	8	c
op	527:50	0:0	8	->
water	527:52	0:0	8	status
op	527:58	0:0	8	[
water	527:59	0:0	8	st
op	527:61	0:0	8	]
arg	527:64	527:72	7	v&0x0F
water	527:64	0:0	8	v
op	527:66	0:0	8	&
water	527:68	0:0	8	0
water	527:69	0:0	8	x0F
water	527:73	0:0	6	;
water	528:8	0:0	6	}
break	529:8	529:13	4	
label	530:4	530:31	4	case CODEC_ID_ADPCM_SBPRO_4 :
label	531:4	531:31	4	case CODEC_ID_ADPCM_SBPRO_3 :
label	532:4	532:31	4	case CODEC_ID_ADPCM_SBPRO_2 :
if	533:8	540:8	4	(! c -> status [ 0 ] . step_index)
cond	533:12	533:26	5	! c -> status [ 0 ] . step_index
op	533:12	0:0	6	!
water	533:13	0:0	6	c
op	533:14	0:0	6	->
water	533:16	0:0	6	status
op	533:22	0:0	6	[
water	533:23	0:0	6	0
op	533:24	0:0	6	]
op	533:25	0:0	6	.
water	533:26	0:0	6	step_index
stmts	533:38	540:8	5	
water	533:38	0:0	6	{
op	535:12	0:0	6	*
water	535:13	0:0	6	samples
op	535:20	0:0	6	++
op	535:23	0:0	6	=
water	535:25	0:0	6	128
op	535:29	0:0	6	*
water	535:31	0:0	6	(
op	535:32	0:0	6	*
water	535:33	0:0	6	src
op	535:36	0:0	6	++
op	535:39	0:0	6	-
water	535:41	0:0	6	0
water	535:42	0:0	6	x80
water	535:45	0:0	6	)
water	535:46	0:0	6	;
if	536:12	537:48	6	(st)
cond	536:16	536:16	7	st
water	536:16	0:0	8	st
stmts	537:14	537:48	7	
op	537:14	0:0	8	*
water	537:15	0:0	8	samples
op	537:22	0:0	8	++
op	537:25	0:0	8	=
water	537:27	0:0	8	128
op	537:31	0:0	8	*
water	537:33	0:0	8	(
op	537:34	0:0	8	*
water	537:35	0:0	8	src
op	537:38	0:0	8	++
op	537:41	0:0	8	-
water	537:43	0:0	8	0
water	537:44	0:0	8	x80
water	537:47	0:0	8	)
water	537:48	0:0	8	;
water	538:12	0:0	6	c
op	538:13	0:0	6	->
water	538:15	0:0	6	status
op	538:21	0:0	6	[
water	538:22	0:0	6	0
op	538:23	0:0	6	]
op	538:24	0:0	6	.
water	538:25	0:0	6	step_index
op	538:36	0:0	6	=
water	538:38	0:0	6	1
water	538:39	0:0	6	;
water	539:12	0:0	6	nb_samples
op	539:22	0:0	6	--
water	539:24	0:0	6	;
water	540:8	0:0	6	}
if	541:8	548:8	4	(avctx -> codec -> id == CODEC_ID_ADPCM_SBPRO_4)
cond	541:12	541:32	5	avctx -> codec -> id == CODEC_ID_ADPCM_SBPRO_4
water	541:12	0:0	6	avctx
op	541:17	0:0	6	->
water	541:19	0:0	6	codec
op	541:24	0:0	6	->
water	541:26	0:0	6	id
op	541:29	0:0	6	==
water	541:32	0:0	6	CODEC_ID_ADPCM_SBPRO_4
stmts	541:56	548:8	5	
water	541:56	0:0	6	{
for	542:12	547:12	6	(n = nb_samples >> ( 1 - st ) ;n > 0;n -- , src ++)
forinit	542:17	542:43	7	n = nb_samples >> ( 1 - st ) ;
water	542:17	0:0	8	n
op	542:19	0:0	8	=
water	542:21	0:0	8	nb_samples
op	542:32	0:0	8	>>
water	542:35	0:0	8	(
water	542:36	0:0	8	1
op	542:38	0:0	8	-
water	542:40	0:0	8	st
water	542:42	0:0	8	)
water	542:43	0:0	8	;
cond	542:45	542:49	7	n > 0
water	542:45	0:0	8	n
op	542:47	0:0	8	>
water	542:49	0:0	8	0
forexpr	542:52	542:60	7	n -- , src ++
water	542:52	0:0	8	n
op	542:53	0:0	8	--
water	542:55	0:0	8	,
water	542:57	0:0	8	src
op	542:60	0:0	8	++
stmts	542:64	547:12	7	
water	542:64	0:0	8	{
op	543:16	0:0	8	*
water	543:17	0:0	8	samples
op	543:24	0:0	8	++
op	543:27	0:0	8	=
call	543:29	544:37	8	adpcm_sbpro_expand_nibble
arg	543:55	543:68	9	&c->status[0]
op	543:55	0:0	10	&
water	543:56	0:0	10	c
op	543:57	0:0	10	->
water	543:59	0:0	10	status
op	543:65	0:0	10	[
water	543:66	0:0	10	0
op	543:67	0:0	10	]
arg	544:20	544:31	9	src[0]>>4
water	544:20	0:0	10	src
op	544:23	0:0	10	[
water	544:24	0:0	10	0
op	544:25	0:0	10	]
op	544:27	0:0	10	>>
water	544:30	0:0	10	4
arg	544:33	544:34	9	4
water	544:33	0:0	10	4
arg	544:36	544:37	9	0
water	544:36	0:0	10	0
water	544:38	0:0	8	;
op	545:16	0:0	8	*
water	545:17	0:0	8	samples
op	545:24	0:0	8	++
op	545:27	0:0	8	=
call	545:29	546:39	8	adpcm_sbpro_expand_nibble
arg	545:55	545:69	9	&c->status[st]
op	545:55	0:0	10	&
water	545:56	0:0	10	c
op	545:57	0:0	10	->
water	545:59	0:0	10	status
op	545:65	0:0	10	[
water	545:66	0:0	10	st
op	545:68	0:0	10	]
arg	546:20	546:33	9	src[0]&0x0F
water	546:20	0:0	10	src
op	546:23	0:0	10	[
water	546:24	0:0	10	0
op	546:25	0:0	10	]
op	546:27	0:0	10	&
water	546:29	0:0	10	0
water	546:30	0:0	10	x0F
arg	546:35	546:36	9	4
water	546:35	0:0	10	4
arg	546:38	546:39	9	0
water	546:38	0:0	10	0
water	546:40	0:0	8	;
water	547:12	0:0	8	}
water	548:8	0:0	6	}
else	548:10	557:8	4
stmts	548:15	557:8	5	
if	548:15	557:8	6	(avctx -> codec -> id == CODEC_ID_ADPCM_SBPRO_3)
cond	548:19	548:39	7	avctx -> codec -> id == CODEC_ID_ADPCM_SBPRO_3
water	548:19	0:0	8	avctx
op	548:24	0:0	8	->
water	548:26	0:0	8	codec
op	548:31	0:0	8	->
water	548:33	0:0	8	id
op	548:36	0:0	8	==
water	548:39	0:0	8	CODEC_ID_ADPCM_SBPRO_3
stmts	548:63	557:8	7	
water	548:63	0:0	8	{
for	549:12	556:12	8	(n = nb_samples / 3 ;n > 0;n -- , src ++)
forinit	549:17	549:35	9	n = nb_samples / 3 ;
water	549:17	0:0	10	n
op	549:19	0:0	10	=
water	549:21	0:0	10	nb_samples
op	549:32	0:0	10	/
water	549:34	0:0	10	3
water	549:35	0:0	10	;
cond	549:37	549:41	9	n > 0
water	549:37	0:0	10	n
op	549:39	0:0	10	>
water	549:41	0:0	10	0
forexpr	549:44	549:52	9	n -- , src ++
water	549:44	0:0	10	n
op	549:45	0:0	10	--
water	549:47	0:0	10	,
water	549:49	0:0	10	src
op	549:52	0:0	10	++
stmts	549:56	556:12	9	
water	549:56	0:0	10	{
op	550:16	0:0	10	*
water	550:17	0:0	10	samples
op	550:24	0:0	10	++
op	550:27	0:0	10	=
call	550:29	551:46	10	adpcm_sbpro_expand_nibble
arg	550:55	550:68	11	&c->status[0]
op	550:55	0:0	12	&
water	550:56	0:0	12	c
op	550:57	0:0	12	->
water	550:59	0:0	12	status
op	550:65	0:0	12	[
water	550:66	0:0	12	0
op	550:67	0:0	12	]
arg	551:21	551:40	11	src[0]>>5
water	551:21	0:0	12	src
op	551:24	0:0	12	[
water	551:25	0:0	12	0
op	551:26	0:0	12	]
op	551:28	0:0	12	>>
water	551:31	0:0	12	5
arg	551:42	551:43	11	3
water	551:42	0:0	12	3
arg	551:45	551:46	11	0
water	551:45	0:0	12	0
water	551:47	0:0	10	;
op	552:16	0:0	10	*
water	552:17	0:0	10	samples
op	552:24	0:0	10	++
op	552:27	0:0	10	=
call	552:29	553:46	10	adpcm_sbpro_expand_nibble
arg	552:55	552:68	11	&c->status[0]
op	552:55	0:0	12	&
water	552:56	0:0	12	c
op	552:57	0:0	12	->
water	552:59	0:0	12	status
op	552:65	0:0	12	[
water	552:66	0:0	12	0
op	552:67	0:0	12	]
arg	553:20	553:40	11	(src[0]>>2)&0x07
water	553:20	0:0	12	(
water	553:21	0:0	12	src
op	553:24	0:0	12	[
water	553:25	0:0	12	0
op	553:26	0:0	12	]
op	553:28	0:0	12	>>
water	553:31	0:0	12	2
water	553:32	0:0	12	)
op	553:34	0:0	12	&
water	553:36	0:0	12	0
water	553:37	0:0	12	x07
arg	553:42	553:43	11	3
water	553:42	0:0	12	3
arg	553:45	553:46	11	0
water	553:45	0:0	12	0
water	553:47	0:0	10	;
op	554:16	0:0	10	*
water	554:17	0:0	10	samples
op	554:24	0:0	10	++
op	554:27	0:0	10	=
call	554:29	555:39	10	adpcm_sbpro_expand_nibble
arg	554:55	554:68	11	&c->status[0]
op	554:55	0:0	12	&
water	554:56	0:0	12	c
op	554:57	0:0	12	->
water	554:59	0:0	12	status
op	554:65	0:0	12	[
water	554:66	0:0	12	0
op	554:67	0:0	12	]
arg	555:20	555:33	11	src[0]&0x03
water	555:20	0:0	12	src
op	555:23	0:0	12	[
water	555:24	0:0	12	0
op	555:25	0:0	12	]
op	555:27	0:0	12	&
water	555:29	0:0	12	0
water	555:30	0:0	12	x03
arg	555:35	555:36	11	2
water	555:35	0:0	12	2
arg	555:38	555:39	11	0
water	555:38	0:0	12	0
water	555:40	0:0	10	;
water	556:12	0:0	10	}
water	557:8	0:0	8	}
else	557:10	568:8	4
stmts	557:15	568:8	5	
water	557:15	0:0	6	{
for	558:12	567:12	6	(n = nb_samples >> ( 2 - st ) ;n > 0;n -- , src ++)
forinit	558:17	558:43	7	n = nb_samples >> ( 2 - st ) ;
water	558:17	0:0	8	n
op	558:19	0:0	8	=
water	558:21	0:0	8	nb_samples
op	558:32	0:0	8	>>
water	558:35	0:0	8	(
water	558:36	0:0	8	2
op	558:38	0:0	8	-
water	558:40	0:0	8	st
water	558:42	0:0	8	)
water	558:43	0:0	8	;
cond	558:45	558:49	7	n > 0
water	558:45	0:0	8	n
op	558:47	0:0	8	>
water	558:49	0:0	8	0
forexpr	558:52	558:60	7	n -- , src ++
water	558:52	0:0	8	n
op	558:53	0:0	8	--
water	558:55	0:0	8	,
water	558:57	0:0	8	src
op	558:60	0:0	8	++
stmts	558:64	567:12	7	
water	558:64	0:0	8	{
op	559:16	0:0	8	*
water	559:17	0:0	8	samples
op	559:24	0:0	8	++
op	559:27	0:0	8	=
call	559:29	560:46	8	adpcm_sbpro_expand_nibble
arg	559:55	559:68	9	&c->status[0]
op	559:55	0:0	10	&
water	559:56	0:0	10	c
op	559:57	0:0	10	->
water	559:59	0:0	10	status
op	559:65	0:0	10	[
water	559:66	0:0	10	0
op	559:67	0:0	10	]
arg	560:21	560:40	9	src[0]>>6
water	560:21	0:0	10	src
op	560:24	0:0	10	[
water	560:25	0:0	10	0
op	560:26	0:0	10	]
op	560:28	0:0	10	>>
water	560:31	0:0	10	6
arg	560:42	560:43	9	2
water	560:42	0:0	10	2
arg	560:45	560:46	9	2
water	560:45	0:0	10	2
water	560:47	0:0	8	;
op	561:16	0:0	8	*
water	561:17	0:0	8	samples
op	561:24	0:0	8	++
op	561:27	0:0	8	=
call	561:29	562:46	8	adpcm_sbpro_expand_nibble
arg	561:55	561:69	9	&c->status[st]
op	561:55	0:0	10	&
water	561:56	0:0	10	c
op	561:57	0:0	10	->
water	561:59	0:0	10	status
op	561:65	0:0	10	[
water	561:66	0:0	10	st
op	561:68	0:0	10	]
arg	562:20	562:40	9	(src[0]>>4)&0x03
water	562:20	0:0	10	(
water	562:21	0:0	10	src
op	562:24	0:0	10	[
water	562:25	0:0	10	0
op	562:26	0:0	10	]
op	562:28	0:0	10	>>
water	562:31	0:0	10	4
water	562:32	0:0	10	)
op	562:34	0:0	10	&
water	562:36	0:0	10	0
water	562:37	0:0	10	x03
arg	562:42	562:43	9	2
water	562:42	0:0	10	2
arg	562:45	562:46	9	2
water	562:45	0:0	10	2
water	562:47	0:0	8	;
op	563:16	0:0	8	*
water	563:17	0:0	8	samples
op	563:24	0:0	8	++
op	563:27	0:0	8	=
call	563:29	564:46	8	adpcm_sbpro_expand_nibble
arg	563:55	563:68	9	&c->status[0]
op	563:55	0:0	10	&
water	563:56	0:0	10	c
op	563:57	0:0	10	->
water	563:59	0:0	10	status
op	563:65	0:0	10	[
water	563:66	0:0	10	0
op	563:67	0:0	10	]
arg	564:20	564:40	9	(src[0]>>2)&0x03
water	564:20	0:0	10	(
water	564:21	0:0	10	src
op	564:24	0:0	10	[
water	564:25	0:0	10	0
op	564:26	0:0	10	]
op	564:28	0:0	10	>>
water	564:31	0:0	10	2
water	564:32	0:0	10	)
op	564:34	0:0	10	&
water	564:36	0:0	10	0
water	564:37	0:0	10	x03
arg	564:42	564:43	9	2
water	564:42	0:0	10	2
arg	564:45	564:46	9	2
water	564:45	0:0	10	2
water	564:47	0:0	8	;
op	565:16	0:0	8	*
water	565:17	0:0	8	samples
op	565:24	0:0	8	++
op	565:27	0:0	8	=
call	565:29	566:39	8	adpcm_sbpro_expand_nibble
arg	565:55	565:69	9	&c->status[st]
op	565:55	0:0	10	&
water	565:56	0:0	10	c
op	565:57	0:0	10	->
water	565:59	0:0	10	status
op	565:65	0:0	10	[
water	565:66	0:0	10	st
op	565:68	0:0	10	]
arg	566:20	566:33	9	src[0]&0x03
water	566:20	0:0	10	src
op	566:23	0:0	10	[
water	566:24	0:0	10	0
op	566:25	0:0	10	]
op	566:27	0:0	10	&
water	566:29	0:0	10	0
water	566:30	0:0	10	x03
arg	566:35	566:36	9	2
water	566:35	0:0	10	2
arg	566:38	566:39	9	2
water	566:38	0:0	10	2
water	566:40	0:0	8	;
water	567:12	0:0	8	}
water	568:8	0:0	6	}
break	569:8	569:13	4	
label	570:4	570:27	4	case CODEC_ID_ADPCM_SWF :
water	571:4	0:0	4	{
decl	572:8	572:24	4	GetBitContext	gb
decl	573:8	573:24	4	const int	*table
decl	574:8	574:40	4	int	k0
water	574:14	0:0	4	,
decl	574:8	574:40	4	int	signmask
water	574:24	0:0	4	,
decl	574:8	574:40	4	int	nb_bits
water	574:33	0:0	4	,
decl	574:8	574:40	4	int	count
decl	575:8	575:29	4	int	size
op	575:17	0:0	4	=
water	575:19	0:0	4	buf_size
op	575:27	0:0	4	*
water	575:28	0:0	4	8
call	577:8	577:36	4	init_get_bits
arg	577:22	577:25	5	&gb
op	577:22	0:0	6	&
water	577:23	0:0	6	gb
arg	577:27	577:30	5	buf
water	577:27	0:0	6	buf
arg	577:32	577:36	5	size
water	577:32	0:0	6	size
water	577:37	0:0	4	;
water	580:8	0:0	4	nb_bits
op	580:16	0:0	4	=
call	580:18	580:33	4	get_bits
arg	580:27	580:30	5	&gb
op	580:27	0:0	6	&
water	580:28	0:0	6	gb
arg	580:32	580:33	5	2
water	580:32	0:0	6	2
op	580:34	0:0	4	+
water	580:35	0:0	4	2
water	580:36	0:0	4	;
water	582:8	0:0	4	table
op	582:14	0:0	4	=
water	582:16	0:0	4	swf_index_tables
op	582:32	0:0	4	[
water	582:33	0:0	4	nb_bits
op	582:40	0:0	4	-
water	582:41	0:0	4	2
op	582:42	0:0	4	]
water	582:43	0:0	4	;
water	583:8	0:0	4	k0
op	583:11	0:0	4	=
water	583:13	0:0	4	1
op	583:15	0:0	4	<<
water	583:18	0:0	4	(
water	583:19	0:0	4	nb_bits
op	583:26	0:0	4	-
water	583:27	0:0	4	2
water	583:28	0:0	4	)
water	583:29	0:0	4	;
water	584:8	0:0	4	signmask
op	584:17	0:0	4	=
water	584:19	0:0	4	1
op	584:21	0:0	4	<<
water	584:24	0:0	4	(
water	584:25	0:0	4	nb_bits
op	584:32	0:0	4	-
water	584:33	0:0	4	1
water	584:34	0:0	4	)
water	584:35	0:0	4	;
while	586:8	623:8	4	(get_bits_count (& gb ) <= size - 22 * avctx -> channels)
cond	586:15	586:55	5	get_bits_count (& gb ) <= size - 22 * avctx -> channels
call	586:15	586:33	6	get_bits_count
arg	586:30	586:33	7	&gb
op	586:30	0:0	8	&
water	586:31	0:0	8	gb
op	586:35	0:0	6	<=
water	586:38	0:0	6	size
op	586:43	0:0	6	-
water	586:45	0:0	6	22
op	586:47	0:0	6	*
water	586:48	0:0	6	avctx
op	586:53	0:0	6	->
water	586:55	0:0	6	channels
stmts	586:65	623:8	5	
water	586:65	0:0	6	{
for	587:12	590:12	6	(i = 0 ;i < avctx -> channels;i ++)
forinit	587:17	587:22	7	i = 0 ;
water	587:17	0:0	8	i
op	587:19	0:0	8	=
water	587:21	0:0	8	0
water	587:22	0:0	8	;
cond	587:24	587:35	7	i < avctx -> channels
water	587:24	0:0	8	i
op	587:26	0:0	8	<
water	587:28	0:0	8	avctx
op	587:33	0:0	8	->
water	587:35	0:0	8	channels
forexpr	587:45	587:46	7	i ++
water	587:45	0:0	8	i
op	587:46	0:0	8	++
stmts	587:50	590:12	7	
water	587:50	0:0	8	{
op	588:16	0:0	8	*
water	588:17	0:0	8	samples
op	588:24	0:0	8	++
op	588:27	0:0	8	=
water	588:29	0:0	8	c
op	588:30	0:0	8	->
water	588:32	0:0	8	status
op	588:38	0:0	8	[
water	588:39	0:0	8	i
op	588:40	0:0	8	]
op	588:41	0:0	8	.
water	588:42	0:0	8	predictor
op	588:52	0:0	8	=
call	588:54	588:71	8	get_sbits
arg	588:64	588:67	9	&gb
op	588:64	0:0	10	&
water	588:65	0:0	10	gb
arg	588:69	588:71	9	16
water	588:69	0:0	10	16
water	588:72	0:0	8	;
water	589:16	0:0	8	c
op	589:17	0:0	8	->
water	589:19	0:0	8	status
op	589:25	0:0	8	[
water	589:26	0:0	8	i
op	589:27	0:0	8	]
op	589:28	0:0	8	.
water	589:29	0:0	8	step_index
op	589:40	0:0	8	=
call	589:42	589:57	8	get_bits
arg	589:51	589:54	9	&gb
op	589:51	0:0	10	&
water	589:52	0:0	10	gb
arg	589:56	589:57	9	6
water	589:56	0:0	10	6
water	589:58	0:0	8	;
water	590:12	0:0	8	}
for	592:12	622:12	6	(count = 0 ;get_bits_count (& gb ) <= size - nb_bits * avctx -> channels && count < 4095;count ++)
forinit	592:17	592:26	7	count = 0 ;
water	592:17	0:0	8	count
op	592:23	0:0	8	=
water	592:25	0:0	8	0
water	592:26	0:0	8	;
cond	592:28	592:93	7	get_bits_count (& gb ) <= size - nb_bits * avctx -> channels && count < 4095
call	592:28	592:46	8	get_bits_count
arg	592:43	592:46	9	&gb
op	592:43	0:0	10	&
water	592:44	0:0	10	gb
op	592:48	0:0	8	<=
water	592:51	0:0	8	size
op	592:56	0:0	8	-
water	592:58	0:0	8	nb_bits
op	592:65	0:0	8	*
water	592:66	0:0	8	avctx
op	592:71	0:0	8	->
water	592:73	0:0	8	channels
op	592:82	0:0	8	&&
water	592:85	0:0	8	count
op	592:91	0:0	8	<
water	592:93	0:0	8	4095
forexpr	592:99	592:104	7	count ++
water	592:99	0:0	8	count
op	592:104	0:0	8	++
stmts	592:108	622:12	7	
water	592:108	0:0	8	{
decl	593:16	593:21	8	int	i
for	595:16	621:16	8	(i = 0 ;i < avctx -> channels;i ++)
forinit	595:21	595:26	9	i = 0 ;
water	595:21	0:0	10	i
op	595:23	0:0	10	=
water	595:25	0:0	10	0
water	595:26	0:0	10	;
cond	595:28	595:39	9	i < avctx -> channels
water	595:28	0:0	10	i
op	595:30	0:0	10	<
water	595:32	0:0	10	avctx
op	595:37	0:0	10	->
water	595:39	0:0	10	channels
forexpr	595:49	595:50	9	i ++
water	595:49	0:0	10	i
op	595:50	0:0	10	++
stmts	595:54	621:16	9	
water	595:54	0:0	10	{
decl	597:20	597:54	10	int	delta
op	597:30	0:0	10	=
call	597:32	597:53	11	get_bits
arg	597:41	597:44	12	&gb
op	597:41	0:0	13	&
water	597:42	0:0	13	gb
arg	597:46	597:53	12	nb_bits
water	597:46	0:0	13	nb_bits
decl	598:20	598:75	10	int	step
op	598:29	0:0	10	=
water	598:31	0:0	10	ff_adpcm_step_table
op	598:50	0:0	10	[
water	598:51	0:0	10	c
op	598:52	0:0	10	->
water	598:54	0:0	10	status
op	598:60	0:0	10	[
water	598:61	0:0	10	i
op	598:62	0:0	10	]
op	598:63	0:0	10	.
water	598:64	0:0	10	step_index
op	598:74	0:0	10	]
decl	599:20	599:35	10	long	vpdiff
op	599:32	0:0	10	=
water	599:34	0:0	10	0
decl	600:20	600:30	10	int	k
op	600:26	0:0	10	=
water	600:28	0:0	10	k0
do	602:20	607:20	10	(k)
cond	607:28	607:28	11	k
water	607:28	0:0	12	k
stmts	602:23	607:20	11	
water	602:23	0:0	12	{
if	603:24	604:42	12	(delta & k)
cond	603:28	603:36	13	delta & k
water	603:28	0:0	14	delta
op	603:34	0:0	14	&
water	603:36	0:0	14	k
stmts	604:28	604:42	13	
water	604:28	0:0	14	vpdiff
op	604:35	0:0	14	+=
water	604:38	0:0	14	step
water	604:42	0:0	14	;
water	605:24	0:0	12	step
op	605:29	0:0	12	>>=
water	605:33	0:0	12	1
water	605:34	0:0	12	;
water	606:24	0:0	12	k
op	606:26	0:0	12	>>=
water	606:30	0:0	12	1
water	606:31	0:0	12	;
water	607:20	0:0	12	}
water	607:30	0:0	10	;
water	608:20	0:0	10	vpdiff
op	608:27	0:0	10	+=
water	608:30	0:0	10	step
water	608:34	0:0	10	;
if	610:20	611:56	10	(delta & signmask)
cond	610:24	610:32	11	delta & signmask
water	610:24	0:0	12	delta
op	610:30	0:0	12	&
water	610:32	0:0	12	signmask
stmts	611:24	611:56	11	
water	611:24	0:0	12	c
op	611:25	0:0	12	->
water	611:27	0:0	12	status
op	611:33	0:0	12	[
water	611:34	0:0	12	i
op	611:35	0:0	12	]
op	611:36	0:0	12	.
water	611:37	0:0	12	predictor
op	611:47	0:0	12	-=
water	611:50	0:0	12	vpdiff
water	611:56	0:0	12	;
else	612:20	613:56	10
stmts	613:24	613:56	11	
water	613:24	0:0	12	c
op	613:25	0:0	12	->
water	613:27	0:0	12	status
op	613:33	0:0	12	[
water	613:34	0:0	12	i
op	613:35	0:0	12	]
op	613:36	0:0	12	.
water	613:37	0:0	12	predictor
op	613:47	0:0	12	+=
water	613:50	0:0	12	vpdiff
water	613:56	0:0	12	;
water	615:20	0:0	10	c
op	615:21	0:0	10	->
water	615:23	0:0	10	status
op	615:29	0:0	10	[
water	615:30	0:0	10	i
op	615:31	0:0	10	]
op	615:32	0:0	10	.
water	615:33	0:0	10	step_index
op	615:44	0:0	10	+=
water	615:47	0:0	10	table
op	615:52	0:0	10	[
water	615:53	0:0	10	delta
op	615:59	0:0	10	&
water	615:61	0:0	10	(
water	615:62	0:0	10	~signmask
water	615:71	0:0	10	)
op	615:72	0:0	10	]
water	615:73	0:0	10	;
water	617:20	0:0	10	c
op	617:21	0:0	10	->
water	617:23	0:0	10	status
op	617:29	0:0	10	[
water	617:30	0:0	10	i
op	617:31	0:0	10	]
op	617:32	0:0	10	.
water	617:33	0:0	10	step_index
op	617:44	0:0	10	=
call	617:46	617:84	10	av_clip
arg	617:54	617:77	11	c->status[i].step_index
water	617:54	0:0	12	c
op	617:55	0:0	12	->
water	617:57	0:0	12	status
op	617:63	0:0	12	[
water	617:64	0:0	12	i
op	617:65	0:0	12	]
op	617:66	0:0	12	.
water	617:67	0:0	12	step_index
arg	617:79	617:80	11	0
water	617:79	0:0	12	0
arg	617:82	617:84	11	88
water	617:82	0:0	12	88
water	617:85	0:0	10	;
water	618:20	0:0	10	c
op	618:21	0:0	10	->
water	618:23	0:0	10	status
op	618:29	0:0	10	[
water	618:30	0:0	10	i
op	618:31	0:0	10	]
op	618:32	0:0	10	.
water	618:33	0:0	10	predictor
op	618:43	0:0	10	=
call	618:45	618:81	10	av_clip_int16
arg	618:59	618:81	11	c->status[i].predictor
water	618:59	0:0	12	c
op	618:60	0:0	12	->
water	618:62	0:0	12	status
op	618:68	0:0	12	[
water	618:69	0:0	12	i
op	618:70	0:0	12	]
op	618:71	0:0	12	.
water	618:72	0:0	12	predictor
water	618:82	0:0	10	;
op	620:20	0:0	10	*
water	620:21	0:0	10	samples
op	620:28	0:0	10	++
op	620:31	0:0	10	=
water	620:33	0:0	10	c
op	620:34	0:0	10	->
water	620:36	0:0	10	status
op	620:42	0:0	10	[
water	620:43	0:0	10	i
op	620:44	0:0	10	]
op	620:45	0:0	10	.
water	620:46	0:0	10	predictor
water	620:55	0:0	10	;
water	621:16	0:0	10	}
water	622:12	0:0	8	}
water	623:8	0:0	6	}
water	624:8	0:0	4	src
op	624:12	0:0	4	+=
water	624:15	0:0	4	buf_size
water	624:23	0:0	4	;
break	625:8	625:13	4	
water	626:4	0:0	4	}
label	627:4	627:30	4	case CODEC_ID_ADPCM_YAMAHA :
for	628:8	632:8	4	(n = nb_samples >> ( 1 - st ) ;n > 0;n -- , src ++)
forinit	628:13	628:39	5	n = nb_samples >> ( 1 - st ) ;
water	628:13	0:0	6	n
op	628:15	0:0	6	=
water	628:17	0:0	6	nb_samples
op	628:28	0:0	6	>>
water	628:31	0:0	6	(
water	628:32	0:0	6	1
op	628:34	0:0	6	-
water	628:36	0:0	6	st
water	628:38	0:0	6	)
water	628:39	0:0	6	;
cond	628:41	628:45	5	n > 0
water	628:41	0:0	6	n
op	628:43	0:0	6	>
water	628:45	0:0	6	0
forexpr	628:48	628:56	5	n -- , src ++
water	628:48	0:0	6	n
op	628:49	0:0	6	--
water	628:51	0:0	6	,
water	628:53	0:0	6	src
op	628:56	0:0	6	++
stmts	628:60	632:8	5	
water	628:60	0:0	6	{
decl	629:12	629:28	6	uint8_t	v
op	629:22	0:0	6	=
op	629:24	0:0	6	*
water	629:25	0:0	6	src
op	630:12	0:0	6	*
water	630:13	0:0	6	samples
op	630:20	0:0	6	++
op	630:23	0:0	6	=
call	630:25	630:76	6	adpcm_yamaha_expand_nibble
arg	630:52	630:66	7	&c->status[0]
op	630:52	0:0	8	&
water	630:53	0:0	8	c
op	630:54	0:0	8	->
water	630:56	0:0	8	status
op	630:62	0:0	8	[
water	630:63	0:0	8	0
op	630:65	0:0	8	]
arg	630:68	630:76	7	v&0x0F
water	630:68	0:0	8	v
op	630:70	0:0	8	&
water	630:72	0:0	8	0
water	630:73	0:0	8	x0F
water	630:77	0:0	6	;
op	631:12	0:0	6	*
water	631:13	0:0	6	samples
op	631:20	0:0	6	++
op	631:23	0:0	6	=
call	631:25	631:76	6	adpcm_yamaha_expand_nibble
arg	631:52	631:66	7	&c->status[st]
op	631:52	0:0	8	&
water	631:53	0:0	8	c
op	631:54	0:0	8	->
water	631:56	0:0	8	status
op	631:62	0:0	8	[
water	631:63	0:0	8	st
op	631:65	0:0	8	]
arg	631:68	631:76	7	v>>4
water	631:68	0:0	8	v
op	631:70	0:0	8	>>
water	631:73	0:0	8	4
water	631:77	0:0	6	;
water	632:8	0:0	6	}
break	633:8	633:13	4	
label	634:4	634:27	4	case CODEC_ID_ADPCM_THP :
water	635:4	0:0	4	{
water	636:8	0:0	4	int
water	636:12	0:0	4	table
op	636:17	0:0	4	[
water	636:18	0:0	4	2
op	636:19	0:0	4	]
op	636:20	0:0	4	[
water	636:21	0:0	4	16
op	636:23	0:0	4	]
water	636:24	0:0	4	;
water	637:8	0:0	4	int
water	637:12	0:0	4	prev
op	637:16	0:0	4	[
water	637:17	0:0	4	2
op	637:18	0:0	4	]
op	637:19	0:0	4	[
water	637:20	0:0	4	2
op	637:21	0:0	4	]
water	637:22	0:0	4	;
decl	638:8	638:14	4	int	ch
water	640:8	0:0	4	src
op	640:12	0:0	4	+=
water	640:15	0:0	4	4
water	640:16	0:0	4	;
water	641:8	0:0	4	src
op	641:12	0:0	4	+=
water	641:15	0:0	4	4
water	641:16	0:0	4	;
for	643:8	644:60	4	(i = 0 ;i < 32;i ++)
forinit	643:13	643:18	5	i = 0 ;
water	643:13	0:0	6	i
op	643:15	0:0	6	=
water	643:17	0:0	6	0
water	643:18	0:0	6	;
cond	643:20	643:24	5	i < 32
water	643:20	0:0	6	i
op	643:22	0:0	6	<
water	643:24	0:0	6	32
forexpr	643:28	643:29	5	i ++
water	643:28	0:0	6	i
op	643:29	0:0	6	++
stmts	644:12	644:60	5	
water	644:12	0:0	6	table
op	644:17	0:0	6	[
water	644:18	0:0	6	0
op	644:19	0:0	6	]
op	644:20	0:0	6	[
water	644:21	0:0	6	i
op	644:22	0:0	6	]
op	644:24	0:0	6	=
water	644:26	0:0	6	(
water	644:27	0:0	6	int16_t
water	644:34	0:0	6	)
call	644:35	644:59	6	bytestream_get_be16
arg	644:55	644:59	7	&src
op	644:55	0:0	8	&
water	644:56	0:0	8	src
water	644:60	0:0	6	;
for	647:8	648:59	4	(i = 0 ;i < 4;i ++)
forinit	647:13	647:18	5	i = 0 ;
water	647:13	0:0	6	i
op	647:15	0:0	6	=
water	647:17	0:0	6	0
water	647:18	0:0	6	;
cond	647:20	647:24	5	i < 4
water	647:20	0:0	6	i
op	647:22	0:0	6	<
water	647:24	0:0	6	4
forexpr	647:27	647:28	5	i ++
water	647:27	0:0	6	i
op	647:28	0:0	6	++
stmts	648:12	648:59	5	
water	648:12	0:0	6	prev
op	648:16	0:0	6	[
water	648:17	0:0	6	0
op	648:18	0:0	6	]
op	648:19	0:0	6	[
water	648:20	0:0	6	i
op	648:21	0:0	6	]
op	648:23	0:0	6	=
water	648:25	0:0	6	(
water	648:26	0:0	6	int16_t
water	648:33	0:0	6	)
call	648:34	648:58	6	bytestream_get_be16
arg	648:54	648:58	7	&src
op	648:54	0:0	8	&
water	648:55	0:0	8	src
water	648:59	0:0	6	;
for	650:8	677:8	4	(ch = 0 ;ch <= st;ch ++)
forinit	650:13	650:19	5	ch = 0 ;
water	650:13	0:0	6	ch
op	650:16	0:0	6	=
water	650:18	0:0	6	0
water	650:19	0:0	6	;
cond	650:21	650:27	5	ch <= st
water	650:21	0:0	6	ch
op	650:24	0:0	6	<=
water	650:27	0:0	6	st
forexpr	650:31	650:33	5	ch ++
water	650:31	0:0	6	ch
op	650:33	0:0	6	++
stmts	650:37	677:8	5	
water	650:37	0:0	6	{
water	651:12	0:0	6	samples
op	651:20	0:0	6	=
water	651:22	0:0	6	(
water	651:23	0:0	6	short
op	651:29	0:0	6	*
water	651:30	0:0	6	)
water	651:31	0:0	6	c
op	651:32	0:0	6	->
water	651:34	0:0	6	frame
op	651:39	0:0	6	.
water	651:40	0:0	6	data
op	651:44	0:0	6	[
water	651:45	0:0	6	0
op	651:46	0:0	6	]
op	651:48	0:0	6	+
water	651:50	0:0	6	ch
water	651:52	0:0	6	;
for	654:12	676:12	6	(i = 0 ;i < nb_samples / 14;i ++)
forinit	654:17	654:22	7	i = 0 ;
water	654:17	0:0	8	i
op	654:19	0:0	8	=
water	654:21	0:0	8	0
water	654:22	0:0	8	;
cond	654:24	654:41	7	i < nb_samples / 14
water	654:24	0:0	8	i
op	654:26	0:0	8	<
water	654:28	0:0	8	nb_samples
op	654:39	0:0	8	/
water	654:41	0:0	8	14
forexpr	654:45	654:46	7	i ++
water	654:45	0:0	8	i
op	654:46	0:0	8	++
stmts	654:50	676:12	7	
water	654:50	0:0	8	{
decl	655:16	655:43	8	int	index
op	655:26	0:0	8	=
water	655:28	0:0	8	(
op	655:29	0:0	8	*
water	655:30	0:0	8	src
op	655:34	0:0	8	>>
water	655:37	0:0	8	4
water	655:38	0:0	8	)
op	655:40	0:0	8	&
water	655:42	0:0	8	7
decl	656:16	656:46	8	unsigned int	exp
op	656:33	0:0	8	=
op	656:35	0:0	8	*
water	656:36	0:0	8	src
op	656:39	0:0	8	++
op	656:42	0:0	8	&
water	656:44	0:0	8	15
decl	657:16	657:50	8	int	factor1
op	657:28	0:0	8	=
water	657:30	0:0	8	table
op	657:35	0:0	8	[
water	657:36	0:0	8	ch
op	657:38	0:0	8	]
op	657:39	0:0	8	[
water	657:40	0:0	8	index
op	657:46	0:0	8	*
water	657:48	0:0	8	2
op	657:49	0:0	8	]
decl	658:16	658:54	8	int	factor2
op	658:28	0:0	8	=
water	658:30	0:0	8	table
op	658:35	0:0	8	[
water	658:36	0:0	8	ch
op	658:38	0:0	8	]
op	658:39	0:0	8	[
water	658:40	0:0	8	index
op	658:46	0:0	8	*
water	658:48	0:0	8	2
op	658:50	0:0	8	+
water	658:52	0:0	8	1
op	658:53	0:0	8	]
for	661:16	675:16	8	(n = 0 ;n < 14;n ++)
forinit	661:21	661:26	9	n = 0 ;
water	661:21	0:0	10	n
op	661:23	0:0	10	=
water	661:25	0:0	10	0
water	661:26	0:0	10	;
cond	661:28	661:32	9	n < 14
water	661:28	0:0	10	n
op	661:30	0:0	10	<
water	661:32	0:0	10	14
forexpr	661:36	661:37	9	n ++
water	661:36	0:0	10	n
op	661:37	0:0	10	++
stmts	661:41	675:16	9	
water	661:41	0:0	10	{
decl	662:20	662:37	10	int32_t	sampledat
if	663:20	663:62	10	(n & 1)
cond	663:23	663:25	11	n & 1
water	663:23	0:0	12	n
op	663:24	0:0	12	&
water	663:25	0:0	12	1
stmts	663:28	663:62	11	
water	663:28	0:0	12	sampledat
op	663:38	0:0	12	=
call	663:40	663:61	12	sign_extend
arg	663:52	663:58	13	*src++
op	663:52	0:0	14	*
water	663:53	0:0	14	src
op	663:56	0:0	14	++
arg	663:60	663:61	13	4
water	663:60	0:0	14	4
water	663:62	0:0	12	;
else	664:20	664:65	10
stmts	664:28	664:65	11	
water	664:28	0:0	12	sampledat
op	664:38	0:0	12	=
call	664:40	664:64	12	sign_extend
arg	664:52	664:61	13	*src>>4
op	664:52	0:0	14	*
water	664:53	0:0	14	src
op	664:57	0:0	14	>>
water	664:60	0:0	14	4
arg	664:63	664:64	13	4
water	664:63	0:0	14	4
water	664:65	0:0	12	;
water	666:20	0:0	10	sampledat
op	666:30	0:0	10	=
water	666:32	0:0	10	(
water	666:33	0:0	10	(
water	666:34	0:0	10	prev
op	666:38	0:0	10	[
water	666:39	0:0	10	ch
op	666:41	0:0	10	]
op	666:42	0:0	10	[
water	666:43	0:0	10	0
op	666:44	0:0	10	]
op	666:45	0:0	10	*
water	666:46	0:0	10	factor1
op	667:32	0:0	10	+
water	667:34	0:0	10	prev
op	667:38	0:0	10	[
water	667:39	0:0	10	ch
op	667:41	0:0	10	]
op	667:42	0:0	10	[
water	667:43	0:0	10	1
op	667:44	0:0	10	]
op	667:45	0:0	10	*
water	667:46	0:0	10	factor2
water	667:53	0:0	10	)
op	667:55	0:0	10	>>
water	667:58	0:0	10	11
water	667:60	0:0	10	)
op	667:62	0:0	10	+
water	667:64	0:0	10	(
water	667:65	0:0	10	sampledat
op	667:75	0:0	10	<<
water	667:78	0:0	10	exp
water	667:81	0:0	10	)
water	667:82	0:0	10	;
op	668:20	0:0	10	*
water	668:21	0:0	10	samples
op	668:29	0:0	10	=
call	668:31	668:54	10	av_clip_int16
arg	668:45	668:54	11	sampledat
water	668:45	0:0	12	sampledat
water	668:55	0:0	10	;
water	669:20	0:0	10	prev
op	669:24	0:0	10	[
water	669:25	0:0	10	ch
op	669:27	0:0	10	]
op	669:28	0:0	10	[
water	669:29	0:0	10	1
op	669:30	0:0	10	]
op	669:32	0:0	10	=
water	669:34	0:0	10	prev
op	669:38	0:0	10	[
water	669:39	0:0	10	ch
op	669:41	0:0	10	]
op	669:42	0:0	10	[
water	669:43	0:0	10	0
op	669:44	0:0	10	]
water	669:45	0:0	10	;
water	670:20	0:0	10	prev
op	670:24	0:0	10	[
water	670:25	0:0	10	ch
op	670:27	0:0	10	]
op	670:28	0:0	10	[
water	670:29	0:0	10	0
op	670:30	0:0	10	]
op	670:32	0:0	10	=
op	670:34	0:0	10	*
water	670:35	0:0	10	samples
op	670:42	0:0	10	++
water	670:44	0:0	10	;
water	674:20	0:0	10	samples
op	674:28	0:0	10	+=
water	674:31	0:0	10	st
water	674:33	0:0	10	;
water	675:16	0:0	10	}
water	676:12	0:0	8	}
water	677:8	0:0	6	}
break	678:8	678:13	4	
water	679:4	0:0	4	}
label	681:4	681:11	4	default :
return	682:8	682:17	4	-1
op	682:15	0:0	5	-
water	682:16	0:0	5	1
water	683:4	0:0	4	}
op	685:4	0:0	2	*
water	685:5	0:0	2	got_frame_ptr
op	685:21	0:0	2	=
water	685:23	0:0	2	1
water	685:24	0:0	2	;
op	686:4	0:0	2	*
water	686:5	0:0	2	(
water	686:6	0:0	2	AVFrame
op	686:14	0:0	2	*
water	686:15	0:0	2	)
water	686:16	0:0	2	data
op	686:21	0:0	2	=
water	686:23	0:0	2	c
op	686:24	0:0	2	->
water	686:26	0:0	2	frame
water	686:31	0:0	2	;
return	688:4	688:20	2	src-buf
water	688:11	0:0	3	src
op	688:15	0:0	3	-
water	688:17	0:0	3	buf
