func	2:0	297:0	0	static int	avi_read_packet
params	2:26	0:0	1	
param	2:27	2:45	2	AVFormatContext *	s
param	2:47	2:60	2	AVPacket *	pkt
stmnts	0:0	296:22	1	
decl	4:4	4:34	2	AVIContext	*avi
op	4:20	0:0	2	=
water	4:22	0:0	2	s
op	4:23	0:0	2	->
water	4:25	0:0	2	priv_data
decl	5:4	5:27	2	AVIOContext	*pb
op	5:20	0:0	2	=
water	5:22	0:0	2	s
op	5:23	0:0	2	->
water	5:25	0:0	2	pb
decl	6:4	6:15	2	int	n
water	6:9	0:0	2	,
decl	6:4	6:15	2	int	d[8]
decl	7:4	7:21	2	unsigned int	size
decl	8:4	8:19	2	int64_t	i
water	8:13	0:0	2	,
decl	8:4	8:19	2	int64_t	sync
decl	9:4	9:14	2	void	*dstr
if	11:4	15:4	2	(CONFIG_DV_DEMUXER && avi -> dv_demux)
cond	11:8	11:34	3	CONFIG_DV_DEMUXER && avi -> dv_demux
water	11:8	0:0	4	CONFIG_DV_DEMUXER
op	11:26	0:0	4	&&
water	11:29	0:0	4	avi
op	11:32	0:0	4	->
water	11:34	0:0	4	dv_demux
stmts	11:44	15:4	3	
water	11:44	0:0	4	{
decl	12:8	12:52	4	int	size
op	12:17	0:0	4	=
call	12:19	12:51	5	dv_get_packet
arg	12:33	12:46	6	avi->dv_demux
water	12:33	0:0	7	avi
op	12:36	0:0	7	->
water	12:38	0:0	7	dv_demux
arg	12:48	12:51	6	pkt
water	12:48	0:0	7	pkt
if	13:8	14:23	4	(size >= 0)
cond	13:12	13:20	5	size >= 0
water	13:12	0:0	6	size
op	13:17	0:0	6	>=
water	13:20	0:0	6	0
stmts	14:12	14:23	5	
return	14:12	14:23	6	size
water	14:19	0:0	7	size
water	15:4	0:0	4	}
if	17:4	73:4	2	(avi -> non_interleaved)
cond	17:7	17:12	3	avi -> non_interleaved
water	17:7	0:0	4	avi
op	17:10	0:0	4	->
water	17:12	0:0	4	non_interleaved
stmts	17:28	73:4	3	
water	17:28	0:0	4	{
decl	18:8	18:33	4	int	best_stream_index
op	18:30	0:0	4	=
water	18:32	0:0	4	0
decl	19:8	19:31	4	AVStream	*best_st
op	19:25	0:0	4	=
water	19:27	0:0	4	NULL
decl	20:8	20:27	4	AVIStream	*best_ast
decl	21:8	21:34	4	int64_t	best_ts
op	21:23	0:0	4	=
water	21:25	0:0	4	INT64_MAX
decl	22:8	22:13	4	int	i
for	24:8	45:8	4	(i = 0 ;i < s -> nb_streams;i ++)
forinit	24:12	24:15	5	i = 0 ;
water	24:12	0:0	6	i
op	24:13	0:0	6	=
water	24:14	0:0	6	0
water	24:15	0:0	6	;
cond	24:17	24:22	5	i < s -> nb_streams
water	24:17	0:0	6	i
op	24:18	0:0	6	<
water	24:19	0:0	6	s
op	24:20	0:0	6	->
water	24:22	0:0	6	nb_streams
forexpr	24:34	24:35	5	i ++
water	24:34	0:0	6	i
op	24:35	0:0	6	++
stmts	24:38	45:8	5	
water	24:38	0:0	6	{
decl	25:12	25:40	6	AVStream	*st
op	25:25	0:0	6	=
water	25:27	0:0	6	s
op	25:28	0:0	6	->
water	25:30	0:0	6	streams
op	25:37	0:0	6	[
water	25:38	0:0	6	i
op	25:39	0:0	6	]
decl	26:12	26:42	6	AVIStream	*ast
op	26:27	0:0	6	=
water	26:29	0:0	6	st
op	26:31	0:0	6	->
water	26:33	0:0	6	priv_data
decl	27:12	27:41	6	int64_t	ts
op	27:22	0:0	6	=
water	27:24	0:0	6	ast
op	27:27	0:0	6	->
water	27:29	0:0	6	frame_offset
decl	28:12	28:27	6	int64_t	last_ts
if	30:12	31:24	6	(! st -> nb_index_entries)
cond	30:15	30:20	7	! st -> nb_index_entries
op	30:15	0:0	8	!
water	30:16	0:0	8	st
op	30:18	0:0	8	->
water	30:20	0:0	8	nb_index_entries
stmts	31:16	31:24	7	
continue	31:16	31:24	8	
water	33:12	0:0	6	last_ts
op	33:20	0:0	6	=
water	33:22	0:0	6	st
op	33:24	0:0	6	->
water	33:26	0:0	6	index_entries
op	33:39	0:0	6	[
water	33:40	0:0	6	st
op	33:42	0:0	6	->
water	33:44	0:0	6	nb_index_entries
op	33:61	0:0	6	-
water	33:63	0:0	6	1
op	33:64	0:0	6	]
op	33:65	0:0	6	.
water	33:66	0:0	6	timestamp
water	33:75	0:0	6	;
if	34:12	35:24	6	(! ast -> remaining && ts > last_ts)
cond	34:15	34:39	7	! ast -> remaining && ts > last_ts
op	34:15	0:0	8	!
water	34:16	0:0	8	ast
op	34:19	0:0	8	->
water	34:21	0:0	8	remaining
op	34:31	0:0	8	&&
water	34:34	0:0	8	ts
op	34:37	0:0	8	>
water	34:39	0:0	8	last_ts
stmts	35:16	35:24	7	
continue	35:16	35:24	8	
water	37:12	0:0	6	ts
op	37:15	0:0	6	=
call	37:17	37:103	6	av_rescale_q
arg	37:30	37:32	7	ts
water	37:30	0:0	8	ts
arg	37:34	37:47	7	st->time_base
water	37:34	0:0	8	st
op	37:36	0:0	8	->
water	37:38	0:0	8	time_base
arg	37:49	37:103	7	(AVRational){FFMAX(1,ast->sample_size),AV_TIME_BASE}
water	37:49	0:0	8	(
water	37:50	0:0	8	AVRational
water	37:60	0:0	8	)
water	37:61	0:0	8	{
call	37:62	37:87	8	FFMAX
arg	37:68	37:69	9	1
water	37:68	0:0	10	1
arg	37:71	37:87	9	ast->sample_size
water	37:71	0:0	10	ast
op	37:74	0:0	10	->
water	37:76	0:0	10	sample_size
water	37:88	0:0	8	,
water	37:90	0:0	8	AV_TIME_BASE
water	37:102	0:0	8	}
water	37:104	0:0	6	;
if	40:12	44:12	6	(ts < best_ts)
cond	40:15	40:20	7	ts < best_ts
water	40:15	0:0	8	ts
op	40:18	0:0	8	<
water	40:20	0:0	8	best_ts
stmts	40:28	44:12	7	
water	40:28	0:0	8	{
water	41:16	0:0	8	best_ts
op	41:23	0:0	8	=
water	41:25	0:0	8	ts
water	41:27	0:0	8	;
water	42:16	0:0	8	best_st
op	42:23	0:0	8	=
water	42:25	0:0	8	st
water	42:27	0:0	8	;
water	43:16	0:0	8	best_stream_index
op	43:33	0:0	8	=
water	43:35	0:0	8	i
water	43:36	0:0	8	;
water	44:12	0:0	8	}
water	45:8	0:0	6	}
if	46:8	47:21	4	(! best_st)
cond	46:11	46:12	5	! best_st
op	46:11	0:0	6	!
water	46:12	0:0	6	best_st
stmts	47:12	47:21	5	
return	47:12	47:21	6	-1
op	47:19	0:0	7	-
water	47:20	0:0	7	1
water	49:8	0:0	4	best_ast
op	49:17	0:0	4	=
water	49:19	0:0	4	best_st
op	49:26	0:0	4	->
water	49:28	0:0	4	priv_data
water	49:37	0:0	4	;
water	50:8	0:0	4	best_ts
op	50:16	0:0	4	=
call	50:18	50:119	4	av_rescale_q
arg	50:31	50:38	5	best_ts
water	50:31	0:0	6	best_ts
arg	50:40	50:99	5	(AVRational){FFMAX(1,best_ast->sample_size),AV_TIME_BASE}
water	50:40	0:0	6	(
water	50:41	0:0	6	AVRational
water	50:51	0:0	6	)
water	50:52	0:0	6	{
call	50:53	50:83	6	FFMAX
arg	50:59	50:60	7	1
water	50:59	0:0	8	1
arg	50:62	50:83	7	best_ast->sample_size
water	50:62	0:0	8	best_ast
op	50:70	0:0	8	->
water	50:72	0:0	8	sample_size
water	50:84	0:0	6	,
water	50:86	0:0	6	AV_TIME_BASE
water	50:98	0:0	6	}
arg	50:101	50:119	5	best_st->time_base
water	50:101	0:0	6	best_st
op	50:108	0:0	6	->
water	50:110	0:0	6	time_base
water	50:120	0:0	4	;
if	51:8	52:98	4	(best_ast -> remaining)
cond	51:11	51:21	5	best_ast -> remaining
water	51:11	0:0	6	best_ast
op	51:19	0:0	6	->
water	51:21	0:0	6	remaining
stmts	52:12	52:98	5	
water	52:12	0:0	6	i
op	52:13	0:0	6	=
call	52:15	52:97	6	av_index_search_timestamp
arg	52:41	52:48	7	best_st
water	52:41	0:0	8	best_st
arg	52:50	52:57	7	best_ts
water	52:50	0:0	8	best_ts
arg	52:59	52:97	7	AVSEEK_FLAG_ANY|AVSEEK_FLAG_BACKWARD
water	52:59	0:0	8	AVSEEK_FLAG_ANY
op	52:75	0:0	8	|
water	52:77	0:0	8	AVSEEK_FLAG_BACKWARD
water	52:98	0:0	6	;
else	53:8	57:8	4
stmts	53:12	57:8	5	
water	53:12	0:0	6	{
water	54:12	0:0	6	i
op	54:13	0:0	6	=
call	54:15	54:74	6	av_index_search_timestamp
arg	54:41	54:48	7	best_st
water	54:41	0:0	8	best_st
arg	54:50	54:57	7	best_ts
water	54:50	0:0	8	best_ts
arg	54:59	54:74	7	AVSEEK_FLAG_ANY
water	54:59	0:0	8	AVSEEK_FLAG_ANY
water	54:75	0:0	6	;
if	55:12	56:75	6	(i >= 0)
cond	55:15	55:18	7	i >= 0
water	55:15	0:0	8	i
op	55:16	0:0	8	>=
water	55:18	0:0	8	0
stmts	56:16	56:75	7	
water	56:16	0:0	8	best_ast
op	56:24	0:0	8	->
water	56:26	0:0	8	frame_offset
op	56:38	0:0	8	=
water	56:40	0:0	8	best_st
op	56:47	0:0	8	->
water	56:49	0:0	8	index_entries
op	56:62	0:0	8	[
water	56:63	0:0	8	i
op	56:64	0:0	8	]
op	56:65	0:0	8	.
water	56:66	0:0	8	timestamp
water	56:75	0:0	8	;
water	57:8	0:0	6	}
if	60:8	72:8	4	(i >= 0)
cond	60:11	60:14	5	i >= 0
water	60:11	0:0	6	i
op	60:12	0:0	6	>=
water	60:14	0:0	6	0
stmts	60:16	72:8	5	
water	60:16	0:0	6	{
decl	61:12	61:54	6	int64_t	pos
op	61:23	0:0	6	=
water	61:25	0:0	6	best_st
op	61:32	0:0	6	->
water	61:34	0:0	6	index_entries
op	61:47	0:0	6	[
water	61:48	0:0	6	i
op	61:49	0:0	6	]
op	61:50	0:0	6	.
water	61:51	0:0	6	pos
water	62:12	0:0	6	pos
op	62:16	0:0	6	+=
water	62:19	0:0	6	best_ast
op	62:27	0:0	6	->
water	62:29	0:0	6	packet_size
op	62:41	0:0	6	-
water	62:43	0:0	6	best_ast
op	62:51	0:0	6	->
water	62:53	0:0	6	remaining
water	62:62	0:0	6	;
call	63:12	63:46	6	avio_seek
arg	63:22	63:27	7	s->pb
water	63:22	0:0	8	s
op	63:23	0:0	8	->
water	63:25	0:0	8	pb
arg	63:29	63:36	7	pos+8
water	63:29	0:0	8	pos
op	63:33	0:0	8	+
water	63:35	0:0	8	8
arg	63:38	63:46	7	SEEK_SET
water	63:38	0:0	8	SEEK_SET
water	63:47	0:0	6	;
call	66:12	66:63	6	assert
arg	66:19	66:63	7	best_ast->remaining<=best_ast->packet_size
water	66:19	0:0	8	best_ast
op	66:27	0:0	8	->
water	66:29	0:0	8	remaining
op	66:39	0:0	8	<=
water	66:42	0:0	8	best_ast
op	66:50	0:0	8	->
water	66:52	0:0	8	packet_size
water	66:64	0:0	6	;
water	68:12	0:0	6	avi
op	68:15	0:0	6	->
water	68:17	0:0	6	stream_index
op	68:29	0:0	6	=
water	68:31	0:0	6	best_stream_index
water	68:48	0:0	6	;
if	69:12	71:67	6	(! best_ast -> remaining)
cond	69:15	69:26	7	! best_ast -> remaining
op	69:15	0:0	8	!
water	69:16	0:0	8	best_ast
op	69:24	0:0	8	->
water	69:26	0:0	8	remaining
stmts	70:16	71:67	7	
water	70:16	0:0	8	best_ast
op	70:24	0:0	8	->
water	70:26	0:0	8	packet_size
op	70:37	0:0	8	=
water	71:16	0:0	8	best_ast
op	71:24	0:0	8	->
water	71:26	0:0	8	remaining
op	71:35	0:0	8	=
water	71:37	0:0	8	best_st
op	71:44	0:0	8	->
water	71:46	0:0	8	index_entries
op	71:59	0:0	8	[
water	71:60	0:0	8	i
op	71:61	0:0	8	]
op	71:62	0:0	8	.
water	71:63	0:0	8	size
water	71:67	0:0	8	;
water	72:8	0:0	6	}
water	73:4	0:0	4	}
if	76:4	180:4	2	(avi -> stream_index >= 0)
cond	76:7	76:28	3	avi -> stream_index >= 0
water	76:7	0:0	4	avi
op	76:10	0:0	4	->
water	76:12	0:0	4	stream_index
op	76:25	0:0	4	>=
water	76:28	0:0	4	0
stmts	76:30	180:4	3	
water	76:30	0:0	4	{
decl	77:8	77:53	4	AVStream	*st
op	77:20	0:0	4	=
water	77:22	0:0	4	s
op	77:23	0:0	4	->
water	77:25	0:0	4	streams
op	77:32	0:0	4	[
water	77:34	0:0	4	avi
op	77:37	0:0	4	->
water	77:39	0:0	4	stream_index
op	77:52	0:0	4	]
decl	78:8	78:37	4	AVIStream	*ast
op	78:22	0:0	4	=
water	78:24	0:0	4	st
op	78:26	0:0	4	->
water	78:28	0:0	4	priv_data
decl	79:8	79:21	4	int	size
water	79:16	0:0	4	,
decl	79:8	79:21	4	int	err
if	81:8	82:20	4	(get_subtitle_pkt (s ,st ,pkt ))
cond	81:11	81:38	5	get_subtitle_pkt (s ,st ,pkt )
call	81:11	81:38	6	get_subtitle_pkt
arg	81:28	81:29	7	s
water	81:28	0:0	8	s
arg	81:31	81:33	7	st
water	81:31	0:0	8	st
arg	81:35	81:38	7	pkt
water	81:35	0:0	8	pkt
stmts	82:12	82:20	5	
return	82:12	82:20	6	0
water	82:19	0:0	7	0
if	84:8	85:25	4	(ast -> sample_size <= 1)
cond	84:11	84:31	5	ast -> sample_size <= 1
water	84:11	0:0	6	ast
op	84:14	0:0	6	->
water	84:16	0:0	6	sample_size
op	84:28	0:0	6	<=
water	84:31	0:0	6	1
stmts	85:12	85:25	5	
water	85:12	0:0	6	size
op	85:16	0:0	6	=
water	85:18	0:0	6	INT_MAX
water	85:25	0:0	6	;
else	86:8	88:39	4
stmts	86:13	88:39	5	
if	86:13	88:39	6	(ast -> sample_size < 32)
cond	86:16	86:35	7	ast -> sample_size < 32
water	86:16	0:0	8	ast
op	86:19	0:0	8	->
water	86:21	0:0	8	sample_size
op	86:33	0:0	8	<
water	86:35	0:0	8	32
stmts	88:12	88:39	7	
water	88:12	0:0	8	size
op	88:16	0:0	8	=
water	88:18	0:0	8	1024
op	88:22	0:0	8	*
water	88:23	0:0	8	ast
op	88:26	0:0	8	->
water	88:28	0:0	8	sample_size
water	88:39	0:0	8	;
else	89:8	90:34	4
stmts	90:12	90:34	5	
water	90:12	0:0	6	size
op	90:16	0:0	6	=
water	90:18	0:0	6	ast
op	90:21	0:0	6	->
water	90:23	0:0	6	sample_size
water	90:34	0:0	6	;
if	92:8	93:32	4	(size > ast -> remaining)
cond	92:11	92:23	5	size > ast -> remaining
water	92:11	0:0	6	size
op	92:16	0:0	6	>
water	92:18	0:0	6	ast
op	92:21	0:0	6	->
water	92:23	0:0	6	remaining
stmts	93:12	93:32	5	
water	93:12	0:0	6	size
op	93:16	0:0	6	=
water	93:18	0:0	6	ast
op	93:21	0:0	6	->
water	93:23	0:0	6	remaining
water	93:32	0:0	6	;
water	94:8	0:0	4	avi
op	94:11	0:0	4	->
water	94:13	0:0	4	last_pkt_pos
op	94:25	0:0	4	=
call	94:27	94:39	4	avio_tell
arg	94:37	94:39	5	pb
water	94:37	0:0	6	pb
water	94:40	0:0	4	;
water	95:8	0:0	4	err
op	95:11	0:0	4	=
call	95:13	95:40	4	av_get_packet
arg	95:27	95:29	5	pb
water	95:27	0:0	6	pb
arg	95:31	95:34	5	pkt
water	95:31	0:0	6	pkt
arg	95:36	95:40	5	size
water	95:36	0:0	6	size
water	95:41	0:0	4	;
if	96:8	97:22	4	(err < 0)
cond	96:11	96:15	5	err < 0
water	96:11	0:0	6	err
op	96:14	0:0	6	<
water	96:15	0:0	6	0
stmts	97:12	97:22	5	
return	97:12	97:22	6	err
water	97:19	0:0	7	err
if	99:8	108:8	4	(ast -> has_pal && pkt -> data && pkt -> size < ( unsigned ) INT_MAX / 2)
cond	99:11	99:68	5	ast -> has_pal && pkt -> data && pkt -> size < ( unsigned ) INT_MAX / 2
water	99:11	0:0	6	ast
op	99:14	0:0	6	->
water	99:16	0:0	6	has_pal
op	99:24	0:0	6	&&
water	99:27	0:0	6	pkt
op	99:30	0:0	6	->
water	99:32	0:0	6	data
op	99:37	0:0	6	&&
water	99:40	0:0	6	pkt
op	99:43	0:0	6	->
water	99:45	0:0	6	size
op	99:49	0:0	6	<
water	99:50	0:0	6	(
water	99:51	0:0	6	unsigned
water	99:59	0:0	6	)
water	99:60	0:0	6	INT_MAX
op	99:67	0:0	6	/
water	99:68	0:0	6	2
stmts	99:70	108:8	5	
water	99:70	0:0	6	{
decl	100:12	100:24	6	uint8_t	*pal
water	101:12	0:0	6	pal
op	101:16	0:0	6	=
call	101:18	101:82	6	av_packet_new_side_data
arg	101:42	101:45	7	pkt
water	101:42	0:0	8	pkt
arg	101:47	101:66	7	AV_PKT_DATA_PALETTE
water	101:47	0:0	8	AV_PKT_DATA_PALETTE
arg	101:68	101:82	7	AVPALETTE_SIZE
water	101:68	0:0	8	AVPALETTE_SIZE
water	101:83	0:0	6	;
if	102:12	104:12	6	(! pal)
cond	102:15	102:16	7	! pal
op	102:15	0:0	8	!
water	102:16	0:0	8	pal
stmts	102:20	104:12	7	
water	102:20	0:0	8	{
call	103:16	103:79	8	av_log
arg	103:23	103:24	9	s
water	103:23	0:0	10	s
arg	103:26	103:38	9	AV_LOG_ERROR
water	103:26	0:0	10	AV_LOG_ERROR
arg	103:40	103:79	9	"Failed to allocate data for palette\n"
water	103:40	0:0	10	"Failed to allocate data for palette\n"
water	103:80	0:0	8	;
water	104:12	0:0	8	}
else	104:13	107:12	6
stmts	104:17	107:12	7	
water	104:17	0:0	8	{
call	105:16	105:52	8	memcpy
arg	105:23	105:26	9	pal
water	105:23	0:0	10	pal
arg	105:28	105:36	9	ast->pal
water	105:28	0:0	10	ast
op	105:31	0:0	10	->
water	105:33	0:0	10	pal
arg	105:38	105:52	9	AVPALETTE_SIZE
water	105:38	0:0	10	AVPALETTE_SIZE
water	105:53	0:0	8	;
water	106:16	0:0	8	ast
op	106:19	0:0	8	->
water	106:21	0:0	8	has_pal
op	106:29	0:0	8	=
water	106:31	0:0	8	0
water	106:32	0:0	8	;
water	107:12	0:0	8	}
water	108:8	0:0	6	}
if	110:8	118:8	4	(CONFIG_DV_DEMUXER && avi -> dv_demux)
cond	110:12	110:38	5	CONFIG_DV_DEMUXER && avi -> dv_demux
water	110:12	0:0	6	CONFIG_DV_DEMUXER
op	110:30	0:0	6	&&
water	110:33	0:0	6	avi
op	110:36	0:0	6	->
water	110:38	0:0	6	dv_demux
stmts	110:48	118:8	5	
water	110:48	0:0	6	{
water	111:12	0:0	6	dstr
op	111:17	0:0	6	=
water	111:19	0:0	6	pkt
op	111:22	0:0	6	->
water	111:24	0:0	6	destruct
water	111:32	0:0	6	;
water	112:12	0:0	6	size
op	112:17	0:0	6	=
call	112:19	113:66	6	dv_produce_packet
arg	112:37	112:50	7	avi->dv_demux
water	112:37	0:0	8	avi
op	112:40	0:0	8	->
water	112:42	0:0	8	dv_demux
arg	112:52	112:55	7	pkt
water	112:52	0:0	8	pkt
arg	113:36	113:45	7	pkt->data
water	113:36	0:0	8	pkt
op	113:39	0:0	8	->
water	113:41	0:0	8	data
arg	113:47	113:56	7	pkt->size
water	113:47	0:0	8	pkt
op	113:50	0:0	8	->
water	113:52	0:0	8	size
arg	113:58	113:66	7	pkt->pos
water	113:58	0:0	8	pkt
op	113:61	0:0	8	->
water	113:63	0:0	8	pos
water	113:67	0:0	6	;
water	114:12	0:0	6	pkt
op	114:15	0:0	6	->
water	114:17	0:0	6	destruct
op	114:26	0:0	6	=
water	114:28	0:0	6	dstr
water	114:32	0:0	6	;
water	115:12	0:0	6	pkt
op	115:15	0:0	6	->
water	115:17	0:0	6	flags
op	115:23	0:0	6	|=
water	115:26	0:0	6	AV_PKT_FLAG_KEY
water	115:41	0:0	6	;
if	116:12	117:35	6	(size < 0)
cond	116:16	116:23	7	size < 0
water	116:16	0:0	8	size
op	116:21	0:0	8	<
water	116:23	0:0	8	0
stmts	117:16	117:35	7	
call	117:16	117:34	8	av_free_packet
arg	117:31	117:34	9	pkt
water	117:31	0:0	10	pkt
water	117:35	0:0	8	;
water	118:8	0:0	6	}
else	118:10	124:8	4
stmts	118:15	124:8	5	
if	118:15	124:8	6	(st -> codec -> codec_type == AVMEDIA_TYPE_SUBTITLE && ! st -> codec -> codec_tag &&read_gab2_sub (st ,pkt ))
cond	118:19	119:68	7	st -> codec -> codec_type == AVMEDIA_TYPE_SUBTITLE && ! st -> codec -> codec_tag &&read_gab2_sub (st ,pkt )
water	118:19	0:0	8	st
op	118:21	0:0	8	->
water	118:23	0:0	8	codec
op	118:28	0:0	8	->
water	118:30	0:0	8	codec_type
op	118:41	0:0	8	==
water	118:44	0:0	8	AVMEDIA_TYPE_SUBTITLE
op	119:19	0:0	8	&&
op	119:22	0:0	8	!
water	119:23	0:0	8	st
op	119:25	0:0	8	->
water	119:27	0:0	8	codec
op	119:32	0:0	8	->
water	119:34	0:0	8	codec_tag
op	119:44	0:0	8	&&
call	119:47	119:68	8	read_gab2_sub
arg	119:61	119:63	9	st
water	119:61	0:0	10	st
arg	119:65	119:68	9	pkt
water	119:65	0:0	10	pkt
stmts	119:71	124:8	7	
water	119:71	0:0	8	{
water	120:12	0:0	8	ast
op	120:15	0:0	8	->
water	120:17	0:0	8	frame_offset
op	120:29	0:0	8	++
water	120:31	0:0	8	;
water	121:12	0:0	8	avi
op	121:15	0:0	8	->
water	121:17	0:0	8	stream_index
op	121:30	0:0	8	=
op	121:32	0:0	8	-
water	121:33	0:0	8	1
water	121:34	0:0	8	;
water	122:12	0:0	8	ast
op	122:15	0:0	8	->
water	122:17	0:0	8	remaining
op	122:27	0:0	8	=
water	122:29	0:0	8	0
water	122:30	0:0	8	;
goto	123:12	123:23	8	resync
water	123:17	0:0	9	resync
water	124:8	0:0	8	}
else	124:10	166:8	4
stmts	124:15	166:8	5	
water	124:15	0:0	6	{
water	126:12	0:0	6	pkt
op	126:15	0:0	6	->
water	126:17	0:0	6	dts
op	126:21	0:0	6	=
water	126:23	0:0	6	ast
op	126:26	0:0	6	->
water	126:28	0:0	6	frame_offset
water	126:40	0:0	6	;
if	128:12	129:44	6	(ast -> sample_size)
cond	128:15	128:20	7	ast -> sample_size
water	128:15	0:0	8	ast
op	128:18	0:0	8	->
water	128:20	0:0	8	sample_size
stmts	129:16	129:44	7	
water	129:16	0:0	8	pkt
op	129:19	0:0	8	->
water	129:21	0:0	8	dts
op	129:25	0:0	8	/=
water	129:28	0:0	8	ast
op	129:31	0:0	8	->
water	129:33	0:0	8	sample_size
water	129:44	0:0	8	;
water	131:12	0:0	6	pkt
op	131:15	0:0	6	->
water	131:17	0:0	6	stream_index
op	131:30	0:0	6	=
water	131:32	0:0	6	avi
op	131:35	0:0	6	->
water	131:37	0:0	6	stream_index
water	131:49	0:0	6	;
if	133:12	162:12	6	(st -> codec -> codec_type == AVMEDIA_TYPE_VIDEO)
cond	133:16	133:41	7	st -> codec -> codec_type == AVMEDIA_TYPE_VIDEO
water	133:16	0:0	8	st
op	133:18	0:0	8	->
water	133:20	0:0	8	codec
op	133:25	0:0	8	->
water	133:27	0:0	8	codec_type
op	133:38	0:0	8	==
water	133:41	0:0	8	AVMEDIA_TYPE_VIDEO
stmts	133:61	162:12	7	
water	133:61	0:0	8	{
decl	134:16	134:31	8	AVIndexEntry	*e
decl	135:16	135:25	8	int	index
call	136:16	136:40	8	assert
arg	136:23	136:40	9	st->index_entries
water	136:23	0:0	10	st
op	136:25	0:0	10	->
water	136:27	0:0	10	index_entries
water	136:41	0:0	8	;
water	138:16	0:0	8	index
op	138:21	0:0	8	=
call	138:23	138:73	8	av_index_search_timestamp
arg	138:49	138:51	9	st
water	138:49	0:0	10	st
arg	138:53	138:70	9	ast->frame_offset
water	138:53	0:0	10	ast
op	138:56	0:0	10	->
water	138:58	0:0	10	frame_offset
arg	138:72	138:73	9	0
water	138:72	0:0	10	0
water	138:74	0:0	8	;
water	139:16	0:0	8	e
op	139:17	0:0	8	=
op	139:19	0:0	8	&
water	139:20	0:0	8	st
op	139:22	0:0	8	->
water	139:24	0:0	8	index_entries
op	139:37	0:0	8	[
water	139:38	0:0	8	index
op	139:43	0:0	8	]
water	139:44	0:0	8	;
if	141:16	161:16	8	(index >= 0 && e -> timestamp == ast -> frame_offset)
cond	141:19	141:54	9	index >= 0 && e -> timestamp == ast -> frame_offset
water	141:19	0:0	10	index
op	141:25	0:0	10	>=
water	141:28	0:0	10	0
op	141:30	0:0	10	&&
water	141:33	0:0	10	e
op	141:34	0:0	10	->
water	141:36	0:0	10	timestamp
op	141:46	0:0	10	==
water	141:49	0:0	10	ast
op	141:52	0:0	10	->
water	141:54	0:0	10	frame_offset
stmts	141:67	161:16	9	
water	141:67	0:0	10	{
if	142:20	158:20	10	(index == st -> nb_index_entries - 1)
cond	142:24	142:54	11	index == st -> nb_index_entries - 1
water	142:24	0:0	12	index
op	142:30	0:0	12	==
water	142:33	0:0	12	st
op	142:35	0:0	12	->
water	142:37	0:0	12	nb_index_entries
op	142:53	0:0	12	-
water	142:54	0:0	12	1
stmts	142:56	158:20	11	
water	142:56	0:0	12	{
decl	143:24	143:33	12	int	key
op	143:31	0:0	12	=
water	143:32	0:0	12	1
decl	144:24	144:29	12	int	i
decl	145:24	145:41	12	uint32_t	state
op	145:38	0:0	12	=
op	145:39	0:0	12	-
water	145:40	0:0	12	1
for	146:24	155:24	12	(i = 0 ;i <FFMIN (size ,256 );i ++)
forinit	146:28	146:31	13	i = 0 ;
water	146:28	0:0	14	i
op	146:29	0:0	14	=
water	146:30	0:0	14	0
water	146:31	0:0	14	;
cond	146:33	146:49	13	i <FFMIN (size ,256 )
water	146:33	0:0	14	i
op	146:34	0:0	14	<
call	146:35	146:49	14	FFMIN
arg	146:41	146:45	15	size
water	146:41	0:0	16	size
arg	146:46	146:49	15	256
water	146:46	0:0	16	256
forexpr	146:52	146:53	13	i ++
water	146:52	0:0	14	i
op	146:53	0:0	14	++
stmts	146:56	155:24	13	
water	146:56	0:0	14	{
if	147:28	152:28	14	(st -> codec -> codec_id == CODEC_ID_MPEG4)
cond	147:31	147:54	15	st -> codec -> codec_id == CODEC_ID_MPEG4
water	147:31	0:0	16	st
op	147:33	0:0	16	->
water	147:35	0:0	16	codec
op	147:40	0:0	16	->
water	147:42	0:0	16	codec_id
op	147:51	0:0	16	==
water	147:54	0:0	16	CODEC_ID_MPEG4
stmts	147:69	152:28	15	
water	147:69	0:0	16	{
if	148:32	151:32	16	(state == 0 x1B6)
cond	148:35	148:45	17	state == 0 x1B6
water	148:35	0:0	18	state
op	148:41	0:0	18	==
water	148:44	0:0	18	0
water	148:45	0:0	18	x1B6
stmts	148:50	151:32	17	
water	148:50	0:0	18	{
water	149:36	0:0	18	key
op	149:39	0:0	18	=
op	149:41	0:0	18	!
water	149:42	0:0	18	(
water	149:43	0:0	18	pkt
op	149:46	0:0	18	->
water	149:48	0:0	18	data
op	149:52	0:0	18	[
water	149:53	0:0	18	i
op	149:54	0:0	18	]
op	149:55	0:0	18	&
water	149:56	0:0	18	0
water	149:57	0:0	18	xC0
water	149:60	0:0	18	)
water	149:61	0:0	18	;
break	150:36	150:41	18	
water	151:32	0:0	18	}
water	152:28	0:0	16	}
else	152:29	153:37	14
stmts	153:32	153:37	15	
break	153:32	153:37	16	
water	154:28	0:0	14	state
op	154:33	0:0	14	=
water	154:35	0:0	14	(
water	154:36	0:0	14	state
op	154:41	0:0	14	<<
water	154:43	0:0	14	8
water	154:44	0:0	14	)
op	154:46	0:0	14	+
water	154:48	0:0	14	pkt
op	154:51	0:0	14	->
water	154:53	0:0	14	data
op	154:57	0:0	14	[
water	154:58	0:0	14	i
op	154:59	0:0	14	]
water	154:60	0:0	14	;
water	155:24	0:0	14	}
if	156:24	157:57	12	(! key)
cond	156:27	156:28	13	! key
op	156:27	0:0	14	!
water	156:28	0:0	14	key
stmts	157:28	157:57	13	
water	157:28	0:0	14	e
op	157:29	0:0	14	->
water	157:31	0:0	14	flags
op	157:37	0:0	14	&=
water	157:40	0:0	14	~AVINDEX_KEYFRAME
water	157:57	0:0	14	;
water	158:20	0:0	12	}
if	159:20	160:53	10	(e -> flags & AVINDEX_KEYFRAME)
cond	159:24	159:35	11	e -> flags & AVINDEX_KEYFRAME
water	159:24	0:0	12	e
op	159:25	0:0	12	->
water	159:27	0:0	12	flags
op	159:33	0:0	12	&
water	159:35	0:0	12	AVINDEX_KEYFRAME
stmts	160:24	160:53	11	
water	160:24	0:0	12	pkt
op	160:27	0:0	12	->
water	160:29	0:0	12	flags
op	160:35	0:0	12	|=
water	160:38	0:0	12	AV_PKT_FLAG_KEY
water	160:53	0:0	12	;
water	161:16	0:0	10	}
water	162:12	0:0	8	}
else	162:14	164:12	6
stmts	162:19	164:12	7	
water	162:19	0:0	8	{
water	163:16	0:0	8	pkt
op	163:19	0:0	8	->
water	163:21	0:0	8	flags
op	163:27	0:0	8	|=
water	163:30	0:0	8	AV_PKT_FLAG_KEY
water	163:45	0:0	8	;
water	164:12	0:0	8	}
water	165:12	0:0	6	ast
op	165:15	0:0	6	->
water	165:17	0:0	6	frame_offset
op	165:30	0:0	6	+=
call	165:33	165:60	6	get_duration
arg	165:46	165:49	7	ast
water	165:46	0:0	8	ast
arg	165:51	165:60	7	pkt->size
water	165:51	0:0	8	pkt
op	165:54	0:0	8	->
water	165:56	0:0	8	size
water	165:61	0:0	6	;
water	166:8	0:0	6	}
water	167:8	0:0	4	ast
op	167:11	0:0	4	->
water	167:13	0:0	4	remaining
op	167:23	0:0	4	-=
water	167:26	0:0	4	size
water	167:30	0:0	4	;
if	168:8	171:8	4	(! ast -> remaining)
cond	168:11	168:17	5	! ast -> remaining
op	168:11	0:0	6	!
water	168:12	0:0	6	ast
op	168:15	0:0	6	->
water	168:17	0:0	6	remaining
stmts	168:27	171:8	5	
water	168:27	0:0	6	{
water	169:12	0:0	6	avi
op	169:15	0:0	6	->
water	169:17	0:0	6	stream_index
op	169:29	0:0	6	=
op	169:31	0:0	6	-
water	169:32	0:0	6	1
water	169:33	0:0	6	;
water	170:12	0:0	6	ast
op	170:15	0:0	6	->
water	170:17	0:0	6	packet_size
op	170:28	0:0	6	=
water	170:30	0:0	6	0
water	170:31	0:0	6	;
water	171:8	0:0	6	}
if	173:8	176:8	4	(! avi -> non_interleaved && pkt -> pos >= 0 && ast -> seek_pos > pkt -> pos)
cond	173:11	173:74	5	! avi -> non_interleaved && pkt -> pos >= 0 && ast -> seek_pos > pkt -> pos
op	173:11	0:0	6	!
water	173:12	0:0	6	avi
op	173:15	0:0	6	->
water	173:17	0:0	6	non_interleaved
op	173:33	0:0	6	&&
water	173:36	0:0	6	pkt
op	173:39	0:0	6	->
water	173:41	0:0	6	pos
op	173:45	0:0	6	>=
water	173:48	0:0	6	0
op	173:50	0:0	6	&&
water	173:53	0:0	6	ast
op	173:56	0:0	6	->
water	173:58	0:0	6	seek_pos
op	173:67	0:0	6	>
water	173:69	0:0	6	pkt
op	173:72	0:0	6	->
water	173:74	0:0	6	pos
stmts	173:78	176:8	5	
water	173:78	0:0	6	{
call	174:12	174:30	6	av_free_packet
arg	174:27	174:30	7	pkt
water	174:27	0:0	8	pkt
water	174:31	0:0	6	;
goto	175:12	175:23	6	resync
water	175:17	0:0	7	resync
water	176:8	0:0	6	}
water	177:8	0:0	4	ast
op	177:11	0:0	4	->
water	177:13	0:0	4	seek_pos
op	177:21	0:0	4	=
water	177:23	0:0	4	0
water	177:24	0:0	4	;
return	179:8	179:19	4	size
water	179:15	0:0	5	size
water	180:4	0:0	4	}
call	182:4	182:31	2	memset
arg	182:11	182:12	3	d
water	182:11	0:0	4	d
arg	182:14	182:16	3	-1
op	182:14	0:0	4	-
water	182:15	0:0	4	1
arg	182:18	182:31	3	sizeof(int)*8
op	182:18	0:0	4	sizeof
water	182:24	0:0	4	(
water	182:25	0:0	4	int
water	182:28	0:0	4	)
op	182:29	0:0	4	*
water	182:30	0:0	4	8
water	182:32	0:0	2	;
for	183:4	294:4	2	(i = sync =avio_tell (pb ) ;!url_feof (pb );i ++)
forinit	183:8	183:28	3	i = sync =avio_tell (pb ) ;
water	183:8	0:0	4	i
op	183:9	0:0	4	=
water	183:10	0:0	4	sync
op	183:14	0:0	4	=
call	183:15	183:27	4	avio_tell
arg	183:25	183:27	5	pb
water	183:25	0:0	6	pb
water	183:28	0:0	4	;
cond	183:30	183:42	3	!url_feof (pb )
op	183:30	0:0	4	!
call	183:31	183:42	4	url_feof
arg	183:40	183:42	5	pb
water	183:40	0:0	6	pb
forexpr	183:45	183:46	3	i ++
water	183:45	0:0	4	i
op	183:46	0:0	4	++
stmts	183:50	294:4	3	
water	183:50	0:0	4	{
decl	184:8	184:13	4	int	j
for	186:8	187:24	4	(j = 0 ;j < 7;j ++)
forinit	186:12	186:15	5	j = 0 ;
water	186:12	0:0	6	j
op	186:13	0:0	6	=
water	186:14	0:0	6	0
water	186:15	0:0	6	;
cond	186:17	186:19	5	j < 7
water	186:17	0:0	6	j
op	186:18	0:0	6	<
water	186:19	0:0	6	7
forexpr	186:22	186:23	5	j ++
water	186:22	0:0	6	j
op	186:23	0:0	6	++
stmts	187:12	187:24	5	
water	187:12	0:0	6	d
op	187:13	0:0	6	[
water	187:14	0:0	6	j
op	187:15	0:0	6	]
op	187:16	0:0	6	=
water	187:18	0:0	6	d
op	187:19	0:0	6	[
water	187:20	0:0	6	j
op	187:21	0:0	6	+
water	187:22	0:0	6	1
op	187:23	0:0	6	]
water	187:24	0:0	6	;
water	188:8	0:0	4	d
op	188:9	0:0	4	[
water	188:10	0:0	4	7
op	188:11	0:0	4	]
op	188:12	0:0	4	=
call	188:14	188:24	4	avio_r8
arg	188:22	188:24	5	pb
water	188:22	0:0	6	pb
water	188:25	0:0	4	;
water	190:8	0:0	4	size
op	190:12	0:0	4	=
water	190:14	0:0	4	d
op	190:15	0:0	4	[
water	190:16	0:0	4	4
op	190:17	0:0	4	]
op	190:19	0:0	4	+
water	190:21	0:0	4	(
water	190:22	0:0	4	d
op	190:23	0:0	4	[
water	190:24	0:0	4	5
op	190:25	0:0	4	]
op	190:26	0:0	4	<<
water	190:28	0:0	4	8
water	190:29	0:0	4	)
op	190:31	0:0	4	+
water	190:33	0:0	4	(
water	190:34	0:0	4	d
op	190:35	0:0	4	[
water	190:36	0:0	4	6
op	190:37	0:0	4	]
op	190:38	0:0	4	<<
water	190:40	0:0	4	16
water	190:42	0:0	4	)
op	190:44	0:0	4	+
water	190:46	0:0	4	(
water	190:47	0:0	4	d
op	190:48	0:0	4	[
water	190:49	0:0	4	7
op	190:50	0:0	4	]
op	190:51	0:0	4	<<
water	190:53	0:0	4	24
water	190:55	0:0	4	)
water	190:56	0:0	4	;
water	192:8	0:0	4	n
op	192:9	0:0	4	=
call	192:11	192:29	4	get_stream_idx
arg	192:26	192:29	5	d+2
water	192:26	0:0	6	d
op	192:27	0:0	6	+
water	192:28	0:0	6	2
water	192:30	0:0	4	;
if	194:8	195:20	4	(i + ( uint64_t ) size > avi -> fsize || d [ 0 ] < 0)
cond	194:11	194:51	5	i + ( uint64_t ) size > avi -> fsize || d [ 0 ] < 0
water	194:11	0:0	6	i
op	194:13	0:0	6	+
water	194:15	0:0	6	(
water	194:16	0:0	6	uint64_t
water	194:24	0:0	6	)
water	194:25	0:0	6	size
op	194:30	0:0	6	>
water	194:32	0:0	6	avi
op	194:35	0:0	6	->
water	194:37	0:0	6	fsize
op	194:43	0:0	6	||
water	194:46	0:0	6	d
op	194:47	0:0	6	[
water	194:48	0:0	6	0
op	194:49	0:0	6	]
op	194:50	0:0	6	<
water	194:51	0:0	6	0
stmts	195:12	195:20	5	
continue	195:12	195:20	6	
if	198:8	205:8	4	(( d [ 0 ] == 'i' && d [ 1 ] == 'x' && n < s -> nb_streams ) || ( d [ 0 ] == 'J' && d [ 1 ] == 'U' && d [ 2 ] == 'N' && d [ 3 ] == 'K' ) || ( d [ 0 ] == 'i' && d [ 1 ] == 'd' && d [ 2 ] == 'x' && d [ 3 ] == '1' ))
cond	198:13	201:70	5	( d [ 0 ] == 'i' && d [ 1 ] == 'x' && n < s -> nb_streams ) || ( d [ 0 ] == 'J' && d [ 1 ] == 'U' && d [ 2 ] == 'N' && d [ 3 ] == 'K' ) || ( d [ 0 ] == 'i' && d [ 1 ] == 'd' && d [ 2 ] == 'x' && d [ 3 ] == '1' )
water	198:13	0:0	6	(
water	198:14	0:0	6	d
op	198:15	0:0	6	[
water	198:16	0:0	6	0
op	198:17	0:0	6	]
op	198:19	0:0	6	==
water	198:22	0:0	6	'i'
op	198:26	0:0	6	&&
water	198:29	0:0	6	d
op	198:30	0:0	6	[
water	198:31	0:0	6	1
op	198:32	0:0	6	]
op	198:34	0:0	6	==
water	198:37	0:0	6	'x'
op	198:41	0:0	6	&&
water	198:44	0:0	6	n
op	198:46	0:0	6	<
water	198:48	0:0	6	s
op	198:49	0:0	6	->
water	198:51	0:0	6	nb_streams
water	198:61	0:0	6	)
op	200:11	0:0	6	||
water	200:13	0:0	6	(
water	200:14	0:0	6	d
op	200:15	0:0	6	[
water	200:16	0:0	6	0
op	200:17	0:0	6	]
op	200:19	0:0	6	==
water	200:22	0:0	6	'J'
op	200:26	0:0	6	&&
water	200:29	0:0	6	d
op	200:30	0:0	6	[
water	200:31	0:0	6	1
op	200:32	0:0	6	]
op	200:34	0:0	6	==
water	200:37	0:0	6	'U'
op	200:41	0:0	6	&&
water	200:44	0:0	6	d
op	200:45	0:0	6	[
water	200:46	0:0	6	2
op	200:47	0:0	6	]
op	200:49	0:0	6	==
water	200:52	0:0	6	'N'
op	200:56	0:0	6	&&
water	200:59	0:0	6	d
op	200:60	0:0	6	[
water	200:61	0:0	6	3
op	200:62	0:0	6	]
op	200:64	0:0	6	==
water	200:67	0:0	6	'K'
water	200:70	0:0	6	)
op	201:11	0:0	6	||
water	201:13	0:0	6	(
water	201:14	0:0	6	d
op	201:15	0:0	6	[
water	201:16	0:0	6	0
op	201:17	0:0	6	]
op	201:19	0:0	6	==
water	201:22	0:0	6	'i'
op	201:26	0:0	6	&&
water	201:29	0:0	6	d
op	201:30	0:0	6	[
water	201:31	0:0	6	1
op	201:32	0:0	6	]
op	201:34	0:0	6	==
water	201:37	0:0	6	'd'
op	201:41	0:0	6	&&
water	201:44	0:0	6	d
op	201:45	0:0	6	[
water	201:46	0:0	6	2
op	201:47	0:0	6	]
op	201:49	0:0	6	==
water	201:52	0:0	6	'x'
op	201:56	0:0	6	&&
water	201:59	0:0	6	d
op	201:60	0:0	6	[
water	201:61	0:0	6	3
op	201:62	0:0	6	]
op	201:64	0:0	6	==
water	201:67	0:0	6	'1'
water	201:70	0:0	6	)
stmts	201:72	205:8	5	
water	201:72	0:0	6	{
call	202:12	202:30	6	avio_skip
arg	202:22	202:24	7	pb
water	202:22	0:0	8	pb
arg	202:26	202:30	7	size
water	202:26	0:0	8	size
water	202:31	0:0	6	;
goto	204:12	204:23	6	resync
water	204:17	0:0	7	resync
water	205:8	0:0	6	}
if	208:8	211:8	4	(d [ 0 ] == 'L' && d [ 1 ] == 'I' && d [ 2 ] == 'S' && d [ 3 ] == 'T')
cond	208:11	208:64	5	d [ 0 ] == 'L' && d [ 1 ] == 'I' && d [ 2 ] == 'S' && d [ 3 ] == 'T'
water	208:11	0:0	6	d
op	208:12	0:0	6	[
water	208:13	0:0	6	0
op	208:14	0:0	6	]
op	208:16	0:0	6	==
water	208:19	0:0	6	'L'
op	208:23	0:0	6	&&
water	208:26	0:0	6	d
op	208:27	0:0	6	[
water	208:28	0:0	6	1
op	208:29	0:0	6	]
op	208:31	0:0	6	==
water	208:34	0:0	6	'I'
op	208:38	0:0	6	&&
water	208:41	0:0	6	d
op	208:42	0:0	6	[
water	208:43	0:0	6	2
op	208:44	0:0	6	]
op	208:46	0:0	6	==
water	208:49	0:0	6	'S'
op	208:53	0:0	6	&&
water	208:56	0:0	6	d
op	208:57	0:0	6	[
water	208:58	0:0	6	3
op	208:59	0:0	6	]
op	208:61	0:0	6	==
water	208:64	0:0	6	'T'
stmts	208:68	211:8	5	
water	208:68	0:0	6	{
call	209:12	209:27	6	avio_skip
arg	209:22	209:24	7	pb
water	209:22	0:0	8	pb
arg	209:26	209:27	7	4
water	209:26	0:0	8	4
water	209:28	0:0	6	;
goto	210:12	210:23	6	resync
water	210:17	0:0	7	resync
water	211:8	0:0	6	}
water	213:8	0:0	4	n
op	213:9	0:0	4	=
call	213:11	213:27	4	get_stream_idx
arg	213:26	213:27	5	d
water	213:26	0:0	6	d
water	213:28	0:0	4	;
if	215:8	216:20	4	(! ( ( i - avi -> last_pkt_pos ) & 1 ) &&get_stream_idx (d + 1 ) < s -> nb_streams)
cond	215:11	215:66	5	! ( ( i - avi -> last_pkt_pos ) & 1 ) &&get_stream_idx (d + 1 ) < s -> nb_streams
op	215:11	0:0	6	!
water	215:12	0:0	6	(
water	215:13	0:0	6	(
water	215:14	0:0	6	i
op	215:15	0:0	6	-
water	215:16	0:0	6	avi
op	215:19	0:0	6	->
water	215:21	0:0	6	last_pkt_pos
water	215:33	0:0	6	)
op	215:34	0:0	6	&
water	215:35	0:0	6	1
water	215:36	0:0	6	)
op	215:38	0:0	6	&&
call	215:41	215:59	6	get_stream_idx
arg	215:56	215:59	7	d+1
water	215:56	0:0	8	d
op	215:57	0:0	8	+
water	215:58	0:0	8	1
op	215:61	0:0	6	<
water	215:63	0:0	6	s
op	215:64	0:0	6	->
water	215:66	0:0	6	nb_streams
stmts	216:12	216:20	5	
continue	216:12	216:20	6	
if	219:8	222:8	4	(d [ 2 ] == 'i' && d [ 3 ] == 'x' && n < s -> nb_streams)
cond	219:11	219:48	5	d [ 2 ] == 'i' && d [ 3 ] == 'x' && n < s -> nb_streams
water	219:11	0:0	6	d
op	219:12	0:0	6	[
water	219:13	0:0	6	2
op	219:14	0:0	6	]
op	219:16	0:0	6	==
water	219:19	0:0	6	'i'
op	219:23	0:0	6	&&
water	219:26	0:0	6	d
op	219:27	0:0	6	[
water	219:28	0:0	6	3
op	219:29	0:0	6	]
op	219:31	0:0	6	==
water	219:34	0:0	6	'x'
op	219:38	0:0	6	&&
water	219:41	0:0	6	n
op	219:43	0:0	6	<
water	219:45	0:0	6	s
op	219:46	0:0	6	->
water	219:48	0:0	6	nb_streams
stmts	219:59	222:8	5	
water	219:59	0:0	6	{
call	220:12	220:30	6	avio_skip
arg	220:22	220:24	7	pb
water	220:22	0:0	8	pb
arg	220:26	220:30	7	size
water	220:26	0:0	8	size
water	220:31	0:0	6	;
goto	221:12	221:23	6	resync
water	221:17	0:0	7	resync
water	222:8	0:0	6	}
if	225:8	293:8	4	(n < s -> nb_streams)
cond	225:11	225:18	5	n < s -> nb_streams
water	225:11	0:0	6	n
op	225:13	0:0	6	<
water	225:15	0:0	6	s
op	225:16	0:0	6	->
water	225:18	0:0	6	nb_streams
stmts	225:29	293:8	5	
water	225:29	0:0	6	{
decl	226:12	226:24	6	AVStream	*st
decl	227:12	227:26	6	AVIStream	*ast
water	228:12	0:0	6	st
op	228:15	0:0	6	=
water	228:17	0:0	6	s
op	228:18	0:0	6	->
water	228:20	0:0	6	streams
op	228:27	0:0	6	[
water	228:28	0:0	6	n
op	228:29	0:0	6	]
water	228:30	0:0	6	;
water	229:12	0:0	6	ast
op	229:16	0:0	6	=
water	229:18	0:0	6	st
op	229:20	0:0	6	->
water	229:22	0:0	6	priv_data
water	229:31	0:0	6	;
if	231:12	247:12	6	(s -> nb_streams >= 2)
cond	231:15	231:30	7	s -> nb_streams >= 2
water	231:15	0:0	8	s
op	231:16	0:0	8	->
water	231:18	0:0	8	nb_streams
op	231:28	0:0	8	>=
water	231:30	0:0	8	2
stmts	231:32	247:12	7	
water	231:32	0:0	8	{
decl	232:16	232:46	8	AVStream	*st1
op	232:31	0:0	8	=
water	232:33	0:0	8	s
op	232:34	0:0	8	->
water	232:36	0:0	8	streams
op	232:43	0:0	8	[
water	232:44	0:0	8	1
op	232:45	0:0	8	]
decl	233:16	233:47	8	AVIStream	*ast1
op	233:31	0:0	8	=
water	233:33	0:0	8	st1
op	233:36	0:0	8	->
water	233:38	0:0	8	priv_data
if	235:16	246:16	8	(d [ 2 ] == 'w' && d [ 3 ] == 'b' && n == 0 && st -> codec -> codec_type == AVMEDIA_TYPE_VIDEO && st1 -> codec -> codec_type == AVMEDIA_TYPE_AUDIO && ast -> prefix == 'd' * 256 + 'c' && ( d [ 2 ] * 256 + d [ 3 ] == ast1 -> prefix || ! ast1 -> prefix_count ))
cond	235:22	240:75	9	d [ 2 ] == 'w' && d [ 3 ] == 'b' && n == 0 && st -> codec -> codec_type == AVMEDIA_TYPE_VIDEO && st1 -> codec -> codec_type == AVMEDIA_TYPE_AUDIO && ast -> prefix == 'd' * 256 + 'c' && ( d [ 2 ] * 256 + d [ 3 ] == ast1 -> prefix || ! ast1 -> prefix_count )
water	235:22	0:0	10	d
op	235:23	0:0	10	[
water	235:24	0:0	10	2
op	235:25	0:0	10	]
op	235:27	0:0	10	==
water	235:30	0:0	10	'w'
op	235:34	0:0	10	&&
water	235:37	0:0	10	d
op	235:38	0:0	10	[
water	235:39	0:0	10	3
op	235:40	0:0	10	]
op	235:42	0:0	10	==
water	235:45	0:0	10	'b'
op	236:19	0:0	10	&&
water	236:22	0:0	10	n
op	236:23	0:0	10	==
water	236:25	0:0	10	0
op	237:19	0:0	10	&&
water	237:22	0:0	10	st
op	237:25	0:0	10	->
water	237:27	0:0	10	codec
op	237:32	0:0	10	->
water	237:34	0:0	10	codec_type
op	237:45	0:0	10	==
water	237:48	0:0	10	AVMEDIA_TYPE_VIDEO
op	238:19	0:0	10	&&
water	238:22	0:0	10	st1
op	238:25	0:0	10	->
water	238:27	0:0	10	codec
op	238:32	0:0	10	->
water	238:34	0:0	10	codec_type
op	238:45	0:0	10	==
water	238:48	0:0	10	AVMEDIA_TYPE_AUDIO
op	239:19	0:0	10	&&
water	239:22	0:0	10	ast
op	239:25	0:0	10	->
water	239:27	0:0	10	prefix
op	239:34	0:0	10	==
water	239:37	0:0	10	'd'
op	239:40	0:0	10	*
water	239:41	0:0	10	256
op	239:44	0:0	10	+
water	239:45	0:0	10	'c'
op	240:19	0:0	10	&&
water	240:22	0:0	10	(
water	240:23	0:0	10	d
op	240:24	0:0	10	[
water	240:25	0:0	10	2
op	240:26	0:0	10	]
op	240:27	0:0	10	*
water	240:28	0:0	10	256
op	240:31	0:0	10	+
water	240:32	0:0	10	d
op	240:33	0:0	10	[
water	240:34	0:0	10	3
op	240:35	0:0	10	]
op	240:37	0:0	10	==
water	240:40	0:0	10	ast1
op	240:44	0:0	10	->
water	240:46	0:0	10	prefix
op	240:53	0:0	10	||
op	240:56	0:0	10	!
water	240:57	0:0	10	ast1
op	240:61	0:0	10	->
water	240:63	0:0	10	prefix_count
water	240:75	0:0	10	)
stmts	241:19	246:16	9	
water	241:19	0:0	10	{
water	242:20	0:0	10	n
op	242:21	0:0	10	=
water	242:22	0:0	10	1
water	242:23	0:0	10	;
water	243:20	0:0	10	st
op	243:23	0:0	10	=
water	243:25	0:0	10	st1
water	243:28	0:0	10	;
water	244:20	0:0	10	ast
op	244:24	0:0	10	=
water	244:26	0:0	10	ast1
water	244:30	0:0	10	;
call	245:20	245:102	10	av_log
arg	245:27	245:28	11	s
water	245:27	0:0	12	s
arg	245:30	245:44	11	AV_LOG_WARNING
water	245:30	0:0	12	AV_LOG_WARNING
arg	245:46	245:102	11	"Invalid stream + prefix combination, assuming audio.\n"
water	245:46	0:0	12	"Invalid stream + prefix combination, assuming audio.\n"
water	245:103	0:0	10	;
water	246:16	0:0	10	}
water	247:12	0:0	8	}
if	250:12	256:12	6	(( st -> discard >= AVDISCARD_DEFAULT && size == 0 ) || st -> discard >= AVDISCARD_ALL)
cond	250:18	252:33	7	( st -> discard >= AVDISCARD_DEFAULT && size == 0 ) || st -> discard >= AVDISCARD_ALL
water	250:18	0:0	8	(
water	250:19	0:0	8	st
op	250:21	0:0	8	->
water	250:23	0:0	8	discard
op	250:31	0:0	8	>=
water	250:34	0:0	8	AVDISCARD_DEFAULT
op	250:52	0:0	8	&&
water	250:55	0:0	8	size
op	250:59	0:0	8	==
water	250:61	0:0	8	0
water	250:62	0:0	8	)
op	252:15	0:0	8	||
water	252:18	0:0	8	st
op	252:20	0:0	8	->
water	252:22	0:0	8	discard
op	252:30	0:0	8	>=
water	252:33	0:0	8	AVDISCARD_ALL
stmts	252:47	256:12	7	
water	252:47	0:0	8	{
water	253:16	0:0	8	ast
op	253:19	0:0	8	->
water	253:21	0:0	8	frame_offset
op	253:34	0:0	8	+=
call	253:37	253:59	8	get_duration
arg	253:50	253:53	9	ast
water	253:50	0:0	10	ast
arg	253:55	253:59	9	size
water	253:55	0:0	10	size
water	253:60	0:0	8	;
call	254:16	254:34	8	avio_skip
arg	254:26	254:28	9	pb
water	254:26	0:0	10	pb
arg	254:30	254:34	9	size
water	254:30	0:0	10	size
water	254:35	0:0	8	;
goto	255:16	255:27	8	resync
water	255:21	0:0	9	resync
water	256:12	0:0	8	}
if	258:12	268:12	6	(d [ 2 ] == 'p' && d [ 3 ] == 'c' && size <= 4 * 256 + 4)
cond	258:16	258:58	7	d [ 2 ] == 'p' && d [ 3 ] == 'c' && size <= 4 * 256 + 4
water	258:16	0:0	8	d
op	258:17	0:0	8	[
water	258:18	0:0	8	2
op	258:19	0:0	8	]
op	258:21	0:0	8	==
water	258:24	0:0	8	'p'
op	258:28	0:0	8	&&
water	258:31	0:0	8	d
op	258:32	0:0	8	[
water	258:33	0:0	8	3
op	258:34	0:0	8	]
op	258:36	0:0	8	==
water	258:39	0:0	8	'c'
op	258:43	0:0	8	&&
water	258:46	0:0	8	size
op	258:50	0:0	8	<=
water	258:52	0:0	8	4
op	258:53	0:0	8	*
water	258:54	0:0	8	256
op	258:57	0:0	8	+
water	258:58	0:0	8	4
stmts	258:61	268:12	7	
water	258:61	0:0	8	{
decl	259:16	259:35	8	int	k
op	259:22	0:0	8	=
call	259:24	259:34	9	avio_r8
arg	259:32	259:34	10	pb
water	259:32	0:0	11	pb
decl	260:16	260:55	8	int	last
op	260:25	0:0	8	=
water	260:27	0:0	8	(
water	260:28	0:0	8	k
op	260:30	0:0	8	+
call	260:32	260:42	9	avio_r8
arg	260:40	260:42	10	pb
water	260:40	0:0	11	pb
op	260:44	0:0	8	-
water	260:46	0:0	8	1
water	260:47	0:0	8	)
op	260:49	0:0	8	&
water	260:51	0:0	8	0
water	260:52	0:0	8	xFF
call	262:16	262:28	8	avio_rl16
arg	262:26	262:28	9	pb
water	262:26	0:0	10	pb
water	262:29	0:0	8	;
for	264:16	265:50	8	(;k <= last;k ++)
forinit	264:21	264:21	9	;
water	264:21	0:0	10	;
cond	264:23	264:28	9	k <= last
water	264:23	0:0	10	k
op	264:25	0:0	10	<=
water	264:28	0:0	10	last
forexpr	264:34	264:35	9	k ++
water	264:34	0:0	10	k
op	264:35	0:0	10	++
stmts	265:20	265:50	9	
water	265:20	0:0	10	ast
op	265:23	0:0	10	->
water	265:25	0:0	10	pal
op	265:28	0:0	10	[
water	265:29	0:0	10	k
op	265:30	0:0	10	]
op	265:32	0:0	10	=
call	265:34	265:46	10	avio_rb32
arg	265:44	265:46	11	pb
water	265:44	0:0	12	pb
op	265:47	0:0	10	>>
water	265:49	0:0	10	8
water	265:50	0:0	10	;
water	266:16	0:0	8	ast
op	266:19	0:0	8	->
water	266:21	0:0	8	has_pal
op	266:28	0:0	8	=
water	266:30	0:0	8	1
water	266:31	0:0	8	;
goto	267:16	267:27	8	resync
water	267:21	0:0	9	resync
water	268:12	0:0	8	}
else	268:14	292:12	6
stmts	268:19	292:12	7	
if	268:19	292:12	8	(( ( ast -> prefix_count < 5 || sync + 9 > i ) && d [ 2 ] < 128 && d [ 3 ] < 128 ) || d [ 2 ] * 256 + d [ 3 ] == ast -> prefix)
cond	268:25	269:47	9	( ( ast -> prefix_count < 5 || sync + 9 > i ) && d [ 2 ] < 128 && d [ 3 ] < 128 ) || d [ 2 ] * 256 + d [ 3 ] == ast -> prefix
water	268:25	0:0	10	(
water	268:26	0:0	10	(
water	268:27	0:0	10	ast
op	268:30	0:0	10	->
water	268:32	0:0	10	prefix_count
op	268:44	0:0	10	<
water	268:45	0:0	10	5
op	268:47	0:0	10	||
water	268:50	0:0	10	sync
op	268:54	0:0	10	+
water	268:55	0:0	10	9
op	268:57	0:0	10	>
water	268:59	0:0	10	i
water	268:60	0:0	10	)
op	268:62	0:0	10	&&
water	268:65	0:0	10	d
op	268:66	0:0	10	[
water	268:67	0:0	10	2
op	268:68	0:0	10	]
op	268:69	0:0	10	<
water	268:70	0:0	10	128
op	268:74	0:0	10	&&
water	268:77	0:0	10	d
op	268:78	0:0	10	[
water	268:79	0:0	10	3
op	268:80	0:0	10	]
op	268:81	0:0	10	<
water	268:82	0:0	10	128
water	268:85	0:0	10	)
op	268:87	0:0	10	||
water	269:25	0:0	10	d
op	269:26	0:0	10	[
water	269:27	0:0	10	2
op	269:28	0:0	10	]
op	269:29	0:0	10	*
water	269:30	0:0	10	256
op	269:33	0:0	10	+
water	269:34	0:0	10	d
op	269:35	0:0	10	[
water	269:36	0:0	10	3
op	269:37	0:0	10	]
op	269:39	0:0	10	==
water	269:42	0:0	10	ast
op	269:45	0:0	10	->
water	269:47	0:0	10	prefix
stmts	271:2	292:12	9	
water	271:2	0:0	10	{
if	274:16	275:39	10	(d [ 2 ] * 256 + d [ 3 ] == ast -> prefix)
cond	274:19	274:41	11	d [ 2 ] * 256 + d [ 3 ] == ast -> prefix
water	274:19	0:0	12	d
op	274:20	0:0	12	[
water	274:21	0:0	12	2
op	274:22	0:0	12	]
op	274:23	0:0	12	*
water	274:24	0:0	12	256
op	274:27	0:0	12	+
water	274:28	0:0	12	d
op	274:29	0:0	12	[
water	274:30	0:0	12	3
op	274:31	0:0	12	]
op	274:33	0:0	12	==
water	274:36	0:0	12	ast
op	274:39	0:0	12	->
water	274:41	0:0	12	prefix
stmts	275:20	275:39	11	
water	275:20	0:0	12	ast
op	275:23	0:0	12	->
water	275:25	0:0	12	prefix_count
op	275:37	0:0	12	++
water	275:39	0:0	12	;
else	276:16	279:16	10
stmts	276:20	279:16	11	
water	276:20	0:0	12	{
water	277:20	0:0	12	ast
op	277:23	0:0	12	->
water	277:25	0:0	12	prefix
op	277:31	0:0	12	=
water	277:33	0:0	12	d
op	277:34	0:0	12	[
water	277:35	0:0	12	2
op	277:36	0:0	12	]
op	277:37	0:0	12	*
water	277:38	0:0	12	256
op	277:41	0:0	12	+
water	277:42	0:0	12	d
op	277:43	0:0	12	[
water	277:44	0:0	12	3
op	277:45	0:0	12	]
water	277:46	0:0	12	;
water	278:20	0:0	12	ast
op	278:23	0:0	12	->
water	278:25	0:0	12	prefix_count
op	278:37	0:0	12	=
water	278:39	0:0	12	0
water	278:40	0:0	12	;
water	279:16	0:0	12	}
water	281:16	0:0	10	avi
op	281:19	0:0	10	->
water	281:21	0:0	10	stream_index
op	281:33	0:0	10	=
water	281:35	0:0	10	n
water	281:36	0:0	10	;
water	282:16	0:0	10	ast
op	282:19	0:0	10	->
water	282:21	0:0	10	packet_size
op	282:32	0:0	10	=
water	282:34	0:0	10	size
op	282:39	0:0	10	+
water	282:41	0:0	10	8
water	282:42	0:0	10	;
water	283:16	0:0	10	ast
op	283:19	0:0	10	->
water	283:21	0:0	10	remaining
op	283:30	0:0	10	=
water	283:32	0:0	10	size
water	283:36	0:0	10	;
if	285:16	290:16	10	(size || ! ast -> sample_size)
cond	285:19	285:33	11	size || ! ast -> sample_size
water	285:19	0:0	12	size
op	285:24	0:0	12	||
op	285:27	0:0	12	!
water	285:28	0:0	12	ast
op	285:31	0:0	12	->
water	285:33	0:0	12	sample_size
stmts	285:45	290:16	11	
water	285:45	0:0	12	{
decl	286:20	286:51	12	uint64_t	pos
op	286:32	0:0	12	=
call	286:34	286:46	13	avio_tell
arg	286:44	286:46	14	pb
water	286:44	0:0	15	pb
op	286:48	0:0	12	-
water	286:50	0:0	12	8
if	287:20	289:20	12	(! st -> index_entries || ! st -> nb_index_entries || st -> index_entries [ st -> nb_index_entries - 1 ] . pos < pos)
cond	287:23	287:120	13	! st -> index_entries || ! st -> nb_index_entries || st -> index_entries [ st -> nb_index_entries - 1 ] . pos < pos
op	287:23	0:0	14	!
water	287:24	0:0	14	st
op	287:26	0:0	14	->
water	287:28	0:0	14	index_entries
op	287:42	0:0	14	||
op	287:45	0:0	14	!
water	287:46	0:0	14	st
op	287:48	0:0	14	->
water	287:50	0:0	14	nb_index_entries
op	287:67	0:0	14	||
water	287:70	0:0	14	st
op	287:72	0:0	14	->
water	287:74	0:0	14	index_entries
op	287:87	0:0	14	[
water	287:88	0:0	14	st
op	287:90	0:0	14	->
water	287:92	0:0	14	nb_index_entries
op	287:109	0:0	14	-
water	287:111	0:0	14	1
op	287:112	0:0	14	]
op	287:113	0:0	14	.
water	287:114	0:0	14	pos
op	287:118	0:0	14	<
water	287:120	0:0	14	pos
stmts	287:124	289:20	13	
water	287:124	0:0	14	{
call	288:24	288:96	14	av_add_index_entry
arg	288:43	288:45	15	st
water	288:43	0:0	16	st
arg	288:47	288:50	15	pos
water	288:47	0:0	16	pos
arg	288:52	288:69	15	ast->frame_offset
water	288:52	0:0	16	ast
op	288:55	0:0	16	->
water	288:57	0:0	16	frame_offset
arg	288:71	288:75	15	size
water	288:71	0:0	16	size
arg	288:77	288:78	15	0
water	288:77	0:0	16	0
arg	288:80	288:96	15	AVINDEX_KEYFRAME
water	288:80	0:0	16	AVINDEX_KEYFRAME
water	288:97	0:0	14	;
water	289:20	0:0	14	}
water	290:16	0:0	12	}
goto	291:16	291:27	10	resync
water	291:21	0:0	11	resync
water	292:12	0:0	10	}
water	293:8	0:0	6	}
water	294:4	0:0	4	}
return	296:4	296:22	2	AVERROR_EOF
water	296:11	0:0	3	AVERROR_EOF
