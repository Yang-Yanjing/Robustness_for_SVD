func	2:0	296:0	0	static int	avi_read_packet
params	2:26	0:0	1	
param	2:27	2:45	2	AVFormatContext *	s
param	2:47	2:60	2	AVPacket *	pkt
stmnts	0:0	295:22	1	
decl	4:4	4:34	2	AVIContext	*avi
op	4:20	0:0	2	=
water	4:22	0:0	2	s
op	4:23	0:0	2	->
water	4:25	0:0	2	priv_data
decl	5:4	5:27	2	AVIOContext	*pb
op	5:20	0:0	2	=
water	5:22	0:0	2	s
op	5:23	0:0	2	->
water	5:25	0:0	2	pb
decl	6:4	6:15	2	int	n
water	6:9	0:0	2	,
decl	6:4	6:15	2	int	d[8]
decl	7:4	7:21	2	unsigned int	size
decl	8:4	8:19	2	int64_t	i
water	8:13	0:0	2	,
decl	8:4	8:19	2	int64_t	sync
decl	9:4	9:14	2	void	*dstr
if	11:4	15:4	2	(CONFIG_DV_DEMUXER && avi -> dv_demux)
cond	11:8	11:34	3	CONFIG_DV_DEMUXER && avi -> dv_demux
water	11:8	0:0	4	CONFIG_DV_DEMUXER
op	11:26	0:0	4	&&
water	11:29	0:0	4	avi
op	11:32	0:0	4	->
water	11:34	0:0	4	dv_demux
stmts	11:44	15:4	3	
water	11:44	0:0	4	{
decl	12:8	12:52	4	int	size
op	12:17	0:0	4	=
call	12:19	12:51	5	dv_get_packet
arg	12:33	12:46	6	avi->dv_demux
water	12:33	0:0	7	avi
op	12:36	0:0	7	->
water	12:38	0:0	7	dv_demux
arg	12:48	12:51	6	pkt
water	12:48	0:0	7	pkt
if	13:8	14:23	4	(size >= 0)
cond	13:12	13:20	5	size >= 0
water	13:12	0:0	6	size
op	13:17	0:0	6	>=
water	13:20	0:0	6	0
stmts	14:12	14:23	5	
return	14:12	14:23	6	size
water	14:19	0:0	7	size
water	15:4	0:0	4	}
if	17:4	73:4	2	(avi -> non_interleaved)
cond	17:7	17:12	3	avi -> non_interleaved
water	17:7	0:0	4	avi
op	17:10	0:0	4	->
water	17:12	0:0	4	non_interleaved
stmts	17:28	73:4	3	
water	17:28	0:0	4	{
decl	18:8	18:33	4	int	best_stream_index
op	18:30	0:0	4	=
water	18:32	0:0	4	0
decl	19:8	19:31	4	AVStream	*best_st
op	19:25	0:0	4	=
water	19:27	0:0	4	NULL
decl	20:8	20:27	4	AVIStream	*best_ast
decl	21:8	21:34	4	int64_t	best_ts
op	21:23	0:0	4	=
water	21:25	0:0	4	INT64_MAX
decl	22:8	22:13	4	int	i
for	24:8	45:8	4	(i = 0 ;i < s -> nb_streams;i ++)
forinit	24:12	24:15	5	i = 0 ;
water	24:12	0:0	6	i
op	24:13	0:0	6	=
water	24:14	0:0	6	0
water	24:15	0:0	6	;
cond	24:17	24:22	5	i < s -> nb_streams
water	24:17	0:0	6	i
op	24:18	0:0	6	<
water	24:19	0:0	6	s
op	24:20	0:0	6	->
water	24:22	0:0	6	nb_streams
forexpr	24:34	24:35	5	i ++
water	24:34	0:0	6	i
op	24:35	0:0	6	++
stmts	24:38	45:8	5	
water	24:38	0:0	6	{
decl	25:12	25:40	6	AVStream	*st
op	25:25	0:0	6	=
water	25:27	0:0	6	s
op	25:28	0:0	6	->
water	25:30	0:0	6	streams
op	25:37	0:0	6	[
water	25:38	0:0	6	i
op	25:39	0:0	6	]
decl	26:12	26:42	6	AVIStream	*ast
op	26:27	0:0	6	=
water	26:29	0:0	6	st
op	26:31	0:0	6	->
water	26:33	0:0	6	priv_data
decl	27:12	27:41	6	int64_t	ts
op	27:22	0:0	6	=
water	27:24	0:0	6	ast
op	27:27	0:0	6	->
water	27:29	0:0	6	frame_offset
decl	28:12	28:27	6	int64_t	last_ts
if	30:12	31:24	6	(! st -> nb_index_entries)
cond	30:15	30:20	7	! st -> nb_index_entries
op	30:15	0:0	8	!
water	30:16	0:0	8	st
op	30:18	0:0	8	->
water	30:20	0:0	8	nb_index_entries
stmts	31:16	31:24	7	
continue	31:16	31:24	8	
water	33:12	0:0	6	last_ts
op	33:20	0:0	6	=
water	33:22	0:0	6	st
op	33:24	0:0	6	->
water	33:26	0:0	6	index_entries
op	33:39	0:0	6	[
water	33:40	0:0	6	st
op	33:42	0:0	6	->
water	33:44	0:0	6	nb_index_entries
op	33:61	0:0	6	-
water	33:63	0:0	6	1
op	33:64	0:0	6	]
op	33:65	0:0	6	.
water	33:66	0:0	6	timestamp
water	33:75	0:0	6	;
if	34:12	35:24	6	(! ast -> remaining && ts > last_ts)
cond	34:15	34:39	7	! ast -> remaining && ts > last_ts
op	34:15	0:0	8	!
water	34:16	0:0	8	ast
op	34:19	0:0	8	->
water	34:21	0:0	8	remaining
op	34:31	0:0	8	&&
water	34:34	0:0	8	ts
op	34:37	0:0	8	>
water	34:39	0:0	8	last_ts
stmts	35:16	35:24	7	
continue	35:16	35:24	8	
water	37:12	0:0	6	ts
op	37:15	0:0	6	=
call	37:17	37:103	6	av_rescale_q
arg	37:30	37:32	7	ts
water	37:30	0:0	8	ts
arg	37:34	37:47	7	st->time_base
water	37:34	0:0	8	st
op	37:36	0:0	8	->
water	37:38	0:0	8	time_base
arg	37:49	37:103	7	(AVRational){FFMAX(1,ast->sample_size),AV_TIME_BASE}
water	37:49	0:0	8	(
water	37:50	0:0	8	AVRational
water	37:60	0:0	8	)
water	37:61	0:0	8	{
call	37:62	37:87	8	FFMAX
arg	37:68	37:69	9	1
water	37:68	0:0	10	1
arg	37:71	37:87	9	ast->sample_size
water	37:71	0:0	10	ast
op	37:74	0:0	10	->
water	37:76	0:0	10	sample_size
water	37:88	0:0	8	,
water	37:90	0:0	8	AV_TIME_BASE
water	37:102	0:0	8	}
water	37:104	0:0	6	;
if	40:12	44:12	6	(ts < best_ts)
cond	40:15	40:20	7	ts < best_ts
water	40:15	0:0	8	ts
op	40:18	0:0	8	<
water	40:20	0:0	8	best_ts
stmts	40:28	44:12	7	
water	40:28	0:0	8	{
water	41:16	0:0	8	best_ts
op	41:23	0:0	8	=
water	41:25	0:0	8	ts
water	41:27	0:0	8	;
water	42:16	0:0	8	best_st
op	42:23	0:0	8	=
water	42:25	0:0	8	st
water	42:27	0:0	8	;
water	43:16	0:0	8	best_stream_index
op	43:33	0:0	8	=
water	43:35	0:0	8	i
water	43:36	0:0	8	;
water	44:12	0:0	8	}
water	45:8	0:0	6	}
if	46:8	47:21	4	(! best_st)
cond	46:11	46:12	5	! best_st
op	46:11	0:0	6	!
water	46:12	0:0	6	best_st
stmts	47:12	47:21	5	
return	47:12	47:21	6	-1
op	47:19	0:0	7	-
water	47:20	0:0	7	1
water	49:8	0:0	4	best_ast
op	49:17	0:0	4	=
water	49:19	0:0	4	best_st
op	49:26	0:0	4	->
water	49:28	0:0	4	priv_data
water	49:37	0:0	4	;
water	50:8	0:0	4	best_ts
op	50:16	0:0	4	=
call	50:18	50:119	4	av_rescale_q
arg	50:31	50:38	5	best_ts
water	50:31	0:0	6	best_ts
arg	50:40	50:99	5	(AVRational){FFMAX(1,best_ast->sample_size),AV_TIME_BASE}
water	50:40	0:0	6	(
water	50:41	0:0	6	AVRational
water	50:51	0:0	6	)
water	50:52	0:0	6	{
call	50:53	50:83	6	FFMAX
arg	50:59	50:60	7	1
water	50:59	0:0	8	1
arg	50:62	50:83	7	best_ast->sample_size
water	50:62	0:0	8	best_ast
op	50:70	0:0	8	->
water	50:72	0:0	8	sample_size
water	50:84	0:0	6	,
water	50:86	0:0	6	AV_TIME_BASE
water	50:98	0:0	6	}
arg	50:101	50:119	5	best_st->time_base
water	50:101	0:0	6	best_st
op	50:108	0:0	6	->
water	50:110	0:0	6	time_base
water	50:120	0:0	4	;
if	51:8	52:98	4	(best_ast -> remaining)
cond	51:11	51:21	5	best_ast -> remaining
water	51:11	0:0	6	best_ast
op	51:19	0:0	6	->
water	51:21	0:0	6	remaining
stmts	52:12	52:98	5	
water	52:12	0:0	6	i
op	52:13	0:0	6	=
call	52:15	52:97	6	av_index_search_timestamp
arg	52:41	52:48	7	best_st
water	52:41	0:0	8	best_st
arg	52:50	52:57	7	best_ts
water	52:50	0:0	8	best_ts
arg	52:59	52:97	7	AVSEEK_FLAG_ANY|AVSEEK_FLAG_BACKWARD
water	52:59	0:0	8	AVSEEK_FLAG_ANY
op	52:75	0:0	8	|
water	52:77	0:0	8	AVSEEK_FLAG_BACKWARD
water	52:98	0:0	6	;
else	53:8	57:8	4
stmts	53:12	57:8	5	
water	53:12	0:0	6	{
water	54:12	0:0	6	i
op	54:13	0:0	6	=
call	54:15	54:74	6	av_index_search_timestamp
arg	54:41	54:48	7	best_st
water	54:41	0:0	8	best_st
arg	54:50	54:57	7	best_ts
water	54:50	0:0	8	best_ts
arg	54:59	54:74	7	AVSEEK_FLAG_ANY
water	54:59	0:0	8	AVSEEK_FLAG_ANY
water	54:75	0:0	6	;
if	55:12	56:75	6	(i >= 0)
cond	55:15	55:18	7	i >= 0
water	55:15	0:0	8	i
op	55:16	0:0	8	>=
water	55:18	0:0	8	0
stmts	56:16	56:75	7	
water	56:16	0:0	8	best_ast
op	56:24	0:0	8	->
water	56:26	0:0	8	frame_offset
op	56:38	0:0	8	=
water	56:40	0:0	8	best_st
op	56:47	0:0	8	->
water	56:49	0:0	8	index_entries
op	56:62	0:0	8	[
water	56:63	0:0	8	i
op	56:64	0:0	8	]
op	56:65	0:0	8	.
water	56:66	0:0	8	timestamp
water	56:75	0:0	8	;
water	57:8	0:0	6	}
if	60:8	72:8	4	(i >= 0)
cond	60:11	60:14	5	i >= 0
water	60:11	0:0	6	i
op	60:12	0:0	6	>=
water	60:14	0:0	6	0
stmts	60:16	72:8	5	
water	60:16	0:0	6	{
decl	61:12	61:54	6	int64_t	pos
op	61:23	0:0	6	=
water	61:25	0:0	6	best_st
op	61:32	0:0	6	->
water	61:34	0:0	6	index_entries
op	61:47	0:0	6	[
water	61:48	0:0	6	i
op	61:49	0:0	6	]
op	61:50	0:0	6	.
water	61:51	0:0	6	pos
water	62:12	0:0	6	pos
op	62:16	0:0	6	+=
water	62:19	0:0	6	best_ast
op	62:27	0:0	6	->
water	62:29	0:0	6	packet_size
op	62:41	0:0	6	-
water	62:43	0:0	6	best_ast
op	62:51	0:0	6	->
water	62:53	0:0	6	remaining
water	62:62	0:0	6	;
call	63:12	63:46	6	avio_seek
arg	63:22	63:27	7	s->pb
water	63:22	0:0	8	s
op	63:23	0:0	8	->
water	63:25	0:0	8	pb
arg	63:29	63:36	7	pos+8
water	63:29	0:0	8	pos
op	63:33	0:0	8	+
water	63:35	0:0	8	8
arg	63:38	63:46	7	SEEK_SET
water	63:38	0:0	8	SEEK_SET
water	63:47	0:0	6	;
call	66:12	66:63	6	assert
arg	66:19	66:63	7	best_ast->remaining<=best_ast->packet_size
water	66:19	0:0	8	best_ast
op	66:27	0:0	8	->
water	66:29	0:0	8	remaining
op	66:39	0:0	8	<=
water	66:42	0:0	8	best_ast
op	66:50	0:0	8	->
water	66:52	0:0	8	packet_size
water	66:64	0:0	6	;
water	68:12	0:0	6	avi
op	68:15	0:0	6	->
water	68:17	0:0	6	stream_index
op	68:29	0:0	6	=
water	68:31	0:0	6	best_stream_index
water	68:48	0:0	6	;
if	69:12	71:67	6	(! best_ast -> remaining)
cond	69:15	69:26	7	! best_ast -> remaining
op	69:15	0:0	8	!
water	69:16	0:0	8	best_ast
op	69:24	0:0	8	->
water	69:26	0:0	8	remaining
stmts	70:16	71:67	7	
water	70:16	0:0	8	best_ast
op	70:24	0:0	8	->
water	70:26	0:0	8	packet_size
op	70:37	0:0	8	=
water	71:16	0:0	8	best_ast
op	71:24	0:0	8	->
water	71:26	0:0	8	remaining
op	71:35	0:0	8	=
water	71:37	0:0	8	best_st
op	71:44	0:0	8	->
water	71:46	0:0	8	index_entries
op	71:59	0:0	8	[
water	71:60	0:0	8	i
op	71:61	0:0	8	]
op	71:62	0:0	8	.
water	71:63	0:0	8	size
water	71:67	0:0	8	;
water	72:8	0:0	6	}
water	73:4	0:0	4	}
if	75:4	179:4	2	(avi -> stream_index >= 0)
cond	75:7	75:28	3	avi -> stream_index >= 0
water	75:7	0:0	4	avi
op	75:10	0:0	4	->
water	75:12	0:0	4	stream_index
op	75:25	0:0	4	>=
water	75:28	0:0	4	0
stmts	75:30	179:4	3	
water	75:30	0:0	4	{
decl	76:8	76:53	4	AVStream	*st
op	76:20	0:0	4	=
water	76:22	0:0	4	s
op	76:23	0:0	4	->
water	76:25	0:0	4	streams
op	76:32	0:0	4	[
water	76:34	0:0	4	avi
op	76:37	0:0	4	->
water	76:39	0:0	4	stream_index
op	76:52	0:0	4	]
decl	77:8	77:37	4	AVIStream	*ast
op	77:22	0:0	4	=
water	77:24	0:0	4	st
op	77:26	0:0	4	->
water	77:28	0:0	4	priv_data
decl	78:8	78:21	4	int	size
water	78:16	0:0	4	,
decl	78:8	78:21	4	int	err
if	80:8	81:20	4	(get_subtitle_pkt (s ,st ,pkt ))
cond	80:11	80:38	5	get_subtitle_pkt (s ,st ,pkt )
call	80:11	80:38	6	get_subtitle_pkt
arg	80:28	80:29	7	s
water	80:28	0:0	8	s
arg	80:31	80:33	7	st
water	80:31	0:0	8	st
arg	80:35	80:38	7	pkt
water	80:35	0:0	8	pkt
stmts	81:12	81:20	5	
return	81:12	81:20	6	0
water	81:19	0:0	7	0
if	83:8	84:25	4	(ast -> sample_size <= 1)
cond	83:11	83:31	5	ast -> sample_size <= 1
water	83:11	0:0	6	ast
op	83:14	0:0	6	->
water	83:16	0:0	6	sample_size
op	83:28	0:0	6	<=
water	83:31	0:0	6	1
stmts	84:12	84:25	5	
water	84:12	0:0	6	size
op	84:16	0:0	6	=
water	84:18	0:0	6	INT_MAX
water	84:25	0:0	6	;
else	85:8	87:39	4
stmts	85:13	87:39	5	
if	85:13	87:39	6	(ast -> sample_size < 32)
cond	85:16	85:35	7	ast -> sample_size < 32
water	85:16	0:0	8	ast
op	85:19	0:0	8	->
water	85:21	0:0	8	sample_size
op	85:33	0:0	8	<
water	85:35	0:0	8	32
stmts	87:12	87:39	7	
water	87:12	0:0	8	size
op	87:16	0:0	8	=
water	87:18	0:0	8	1024
op	87:22	0:0	8	*
water	87:23	0:0	8	ast
op	87:26	0:0	8	->
water	87:28	0:0	8	sample_size
water	87:39	0:0	8	;
else	88:8	89:34	4
stmts	89:12	89:34	5	
water	89:12	0:0	6	size
op	89:16	0:0	6	=
water	89:18	0:0	6	ast
op	89:21	0:0	6	->
water	89:23	0:0	6	sample_size
water	89:34	0:0	6	;
if	91:8	92:32	4	(size > ast -> remaining)
cond	91:11	91:23	5	size > ast -> remaining
water	91:11	0:0	6	size
op	91:16	0:0	6	>
water	91:18	0:0	6	ast
op	91:21	0:0	6	->
water	91:23	0:0	6	remaining
stmts	92:12	92:32	5	
water	92:12	0:0	6	size
op	92:16	0:0	6	=
water	92:18	0:0	6	ast
op	92:21	0:0	6	->
water	92:23	0:0	6	remaining
water	92:32	0:0	6	;
water	93:8	0:0	4	avi
op	93:11	0:0	4	->
water	93:13	0:0	4	last_pkt_pos
op	93:25	0:0	4	=
call	93:27	93:39	4	avio_tell
arg	93:37	93:39	5	pb
water	93:37	0:0	6	pb
water	93:40	0:0	4	;
water	94:8	0:0	4	err
op	94:11	0:0	4	=
call	94:13	94:40	4	av_get_packet
arg	94:27	94:29	5	pb
water	94:27	0:0	6	pb
arg	94:31	94:34	5	pkt
water	94:31	0:0	6	pkt
arg	94:36	94:40	5	size
water	94:36	0:0	6	size
water	94:41	0:0	4	;
if	95:8	96:22	4	(err < 0)
cond	95:11	95:15	5	err < 0
water	95:11	0:0	6	err
op	95:14	0:0	6	<
water	95:15	0:0	6	0
stmts	96:12	96:22	5	
return	96:12	96:22	6	err
water	96:19	0:0	7	err
if	98:8	107:8	4	(ast -> has_pal && pkt -> data && pkt -> size < ( unsigned ) INT_MAX / 2)
cond	98:11	98:68	5	ast -> has_pal && pkt -> data && pkt -> size < ( unsigned ) INT_MAX / 2
water	98:11	0:0	6	ast
op	98:14	0:0	6	->
water	98:16	0:0	6	has_pal
op	98:24	0:0	6	&&
water	98:27	0:0	6	pkt
op	98:30	0:0	6	->
water	98:32	0:0	6	data
op	98:37	0:0	6	&&
water	98:40	0:0	6	pkt
op	98:43	0:0	6	->
water	98:45	0:0	6	size
op	98:49	0:0	6	<
water	98:50	0:0	6	(
water	98:51	0:0	6	unsigned
water	98:59	0:0	6	)
water	98:60	0:0	6	INT_MAX
op	98:67	0:0	6	/
water	98:68	0:0	6	2
stmts	98:70	107:8	5	
water	98:70	0:0	6	{
decl	99:12	99:24	6	uint8_t	*pal
water	100:12	0:0	6	pal
op	100:16	0:0	6	=
call	100:18	100:82	6	av_packet_new_side_data
arg	100:42	100:45	7	pkt
water	100:42	0:0	8	pkt
arg	100:47	100:66	7	AV_PKT_DATA_PALETTE
water	100:47	0:0	8	AV_PKT_DATA_PALETTE
arg	100:68	100:82	7	AVPALETTE_SIZE
water	100:68	0:0	8	AVPALETTE_SIZE
water	100:83	0:0	6	;
if	101:12	103:12	6	(! pal)
cond	101:15	101:16	7	! pal
op	101:15	0:0	8	!
water	101:16	0:0	8	pal
stmts	101:20	103:12	7	
water	101:20	0:0	8	{
call	102:16	102:79	8	av_log
arg	102:23	102:24	9	s
water	102:23	0:0	10	s
arg	102:26	102:38	9	AV_LOG_ERROR
water	102:26	0:0	10	AV_LOG_ERROR
arg	102:40	102:79	9	"Failed to allocate data for palette\n"
water	102:40	0:0	10	"Failed to allocate data for palette\n"
water	102:80	0:0	8	;
water	103:12	0:0	8	}
else	103:13	106:12	6
stmts	103:17	106:12	7	
water	103:17	0:0	8	{
call	104:16	104:52	8	memcpy
arg	104:23	104:26	9	pal
water	104:23	0:0	10	pal
arg	104:28	104:36	9	ast->pal
water	104:28	0:0	10	ast
op	104:31	0:0	10	->
water	104:33	0:0	10	pal
arg	104:38	104:52	9	AVPALETTE_SIZE
water	104:38	0:0	10	AVPALETTE_SIZE
water	104:53	0:0	8	;
water	105:16	0:0	8	ast
op	105:19	0:0	8	->
water	105:21	0:0	8	has_pal
op	105:29	0:0	8	=
water	105:31	0:0	8	0
water	105:32	0:0	8	;
water	106:12	0:0	8	}
water	107:8	0:0	6	}
if	109:8	117:8	4	(CONFIG_DV_DEMUXER && avi -> dv_demux)
cond	109:12	109:38	5	CONFIG_DV_DEMUXER && avi -> dv_demux
water	109:12	0:0	6	CONFIG_DV_DEMUXER
op	109:30	0:0	6	&&
water	109:33	0:0	6	avi
op	109:36	0:0	6	->
water	109:38	0:0	6	dv_demux
stmts	109:48	117:8	5	
water	109:48	0:0	6	{
water	110:12	0:0	6	dstr
op	110:17	0:0	6	=
water	110:19	0:0	6	pkt
op	110:22	0:0	6	->
water	110:24	0:0	6	destruct
water	110:32	0:0	6	;
water	111:12	0:0	6	size
op	111:17	0:0	6	=
call	111:19	112:66	6	dv_produce_packet
arg	111:37	111:50	7	avi->dv_demux
water	111:37	0:0	8	avi
op	111:40	0:0	8	->
water	111:42	0:0	8	dv_demux
arg	111:52	111:55	7	pkt
water	111:52	0:0	8	pkt
arg	112:36	112:45	7	pkt->data
water	112:36	0:0	8	pkt
op	112:39	0:0	8	->
water	112:41	0:0	8	data
arg	112:47	112:56	7	pkt->size
water	112:47	0:0	8	pkt
op	112:50	0:0	8	->
water	112:52	0:0	8	size
arg	112:58	112:66	7	pkt->pos
water	112:58	0:0	8	pkt
op	112:61	0:0	8	->
water	112:63	0:0	8	pos
water	112:67	0:0	6	;
water	113:12	0:0	6	pkt
op	113:15	0:0	6	->
water	113:17	0:0	6	destruct
op	113:26	0:0	6	=
water	113:28	0:0	6	dstr
water	113:32	0:0	6	;
water	114:12	0:0	6	pkt
op	114:15	0:0	6	->
water	114:17	0:0	6	flags
op	114:23	0:0	6	|=
water	114:26	0:0	6	AV_PKT_FLAG_KEY
water	114:41	0:0	6	;
if	115:12	116:35	6	(size < 0)
cond	115:16	115:23	7	size < 0
water	115:16	0:0	8	size
op	115:21	0:0	8	<
water	115:23	0:0	8	0
stmts	116:16	116:35	7	
call	116:16	116:34	8	av_free_packet
arg	116:31	116:34	9	pkt
water	116:31	0:0	10	pkt
water	116:35	0:0	8	;
water	117:8	0:0	6	}
else	117:10	123:8	4
stmts	117:15	123:8	5	
if	117:15	123:8	6	(st -> codec -> codec_type == AVMEDIA_TYPE_SUBTITLE && ! st -> codec -> codec_tag &&read_gab2_sub (st ,pkt ))
cond	117:19	118:68	7	st -> codec -> codec_type == AVMEDIA_TYPE_SUBTITLE && ! st -> codec -> codec_tag &&read_gab2_sub (st ,pkt )
water	117:19	0:0	8	st
op	117:21	0:0	8	->
water	117:23	0:0	8	codec
op	117:28	0:0	8	->
water	117:30	0:0	8	codec_type
op	117:41	0:0	8	==
water	117:44	0:0	8	AVMEDIA_TYPE_SUBTITLE
op	118:19	0:0	8	&&
op	118:22	0:0	8	!
water	118:23	0:0	8	st
op	118:25	0:0	8	->
water	118:27	0:0	8	codec
op	118:32	0:0	8	->
water	118:34	0:0	8	codec_tag
op	118:44	0:0	8	&&
call	118:47	118:68	8	read_gab2_sub
arg	118:61	118:63	9	st
water	118:61	0:0	10	st
arg	118:65	118:68	9	pkt
water	118:65	0:0	10	pkt
stmts	118:71	123:8	7	
water	118:71	0:0	8	{
water	119:12	0:0	8	ast
op	119:15	0:0	8	->
water	119:17	0:0	8	frame_offset
op	119:29	0:0	8	++
water	119:31	0:0	8	;
water	120:12	0:0	8	avi
op	120:15	0:0	8	->
water	120:17	0:0	8	stream_index
op	120:30	0:0	8	=
op	120:32	0:0	8	-
water	120:33	0:0	8	1
water	120:34	0:0	8	;
water	121:12	0:0	8	ast
op	121:15	0:0	8	->
water	121:17	0:0	8	remaining
op	121:27	0:0	8	=
water	121:29	0:0	8	0
water	121:30	0:0	8	;
goto	122:12	122:23	8	resync
water	122:17	0:0	9	resync
water	123:8	0:0	8	}
else	123:10	165:8	4
stmts	123:15	165:8	5	
water	123:15	0:0	6	{
water	125:12	0:0	6	pkt
op	125:15	0:0	6	->
water	125:17	0:0	6	dts
op	125:21	0:0	6	=
water	125:23	0:0	6	ast
op	125:26	0:0	6	->
water	125:28	0:0	6	frame_offset
water	125:40	0:0	6	;
if	127:12	128:44	6	(ast -> sample_size)
cond	127:15	127:20	7	ast -> sample_size
water	127:15	0:0	8	ast
op	127:18	0:0	8	->
water	127:20	0:0	8	sample_size
stmts	128:16	128:44	7	
water	128:16	0:0	8	pkt
op	128:19	0:0	8	->
water	128:21	0:0	8	dts
op	128:25	0:0	8	/=
water	128:28	0:0	8	ast
op	128:31	0:0	8	->
water	128:33	0:0	8	sample_size
water	128:44	0:0	8	;
water	130:12	0:0	6	pkt
op	130:15	0:0	6	->
water	130:17	0:0	6	stream_index
op	130:30	0:0	6	=
water	130:32	0:0	6	avi
op	130:35	0:0	6	->
water	130:37	0:0	6	stream_index
water	130:49	0:0	6	;
if	132:12	161:12	6	(st -> codec -> codec_type == AVMEDIA_TYPE_VIDEO)
cond	132:16	132:41	7	st -> codec -> codec_type == AVMEDIA_TYPE_VIDEO
water	132:16	0:0	8	st
op	132:18	0:0	8	->
water	132:20	0:0	8	codec
op	132:25	0:0	8	->
water	132:27	0:0	8	codec_type
op	132:38	0:0	8	==
water	132:41	0:0	8	AVMEDIA_TYPE_VIDEO
stmts	132:61	161:12	7	
water	132:61	0:0	8	{
decl	133:16	133:31	8	AVIndexEntry	*e
decl	134:16	134:25	8	int	index
call	135:16	135:40	8	assert
arg	135:23	135:40	9	st->index_entries
water	135:23	0:0	10	st
op	135:25	0:0	10	->
water	135:27	0:0	10	index_entries
water	135:41	0:0	8	;
water	137:16	0:0	8	index
op	137:21	0:0	8	=
call	137:23	137:73	8	av_index_search_timestamp
arg	137:49	137:51	9	st
water	137:49	0:0	10	st
arg	137:53	137:70	9	ast->frame_offset
water	137:53	0:0	10	ast
op	137:56	0:0	10	->
water	137:58	0:0	10	frame_offset
arg	137:72	137:73	9	0
water	137:72	0:0	10	0
water	137:74	0:0	8	;
water	138:16	0:0	8	e
op	138:17	0:0	8	=
op	138:19	0:0	8	&
water	138:20	0:0	8	st
op	138:22	0:0	8	->
water	138:24	0:0	8	index_entries
op	138:37	0:0	8	[
water	138:38	0:0	8	index
op	138:43	0:0	8	]
water	138:44	0:0	8	;
if	140:16	160:16	8	(index >= 0 && e -> timestamp == ast -> frame_offset)
cond	140:19	140:54	9	index >= 0 && e -> timestamp == ast -> frame_offset
water	140:19	0:0	10	index
op	140:25	0:0	10	>=
water	140:28	0:0	10	0
op	140:30	0:0	10	&&
water	140:33	0:0	10	e
op	140:34	0:0	10	->
water	140:36	0:0	10	timestamp
op	140:46	0:0	10	==
water	140:49	0:0	10	ast
op	140:52	0:0	10	->
water	140:54	0:0	10	frame_offset
stmts	140:67	160:16	9	
water	140:67	0:0	10	{
if	141:20	157:20	10	(index == st -> nb_index_entries - 1)
cond	141:24	141:54	11	index == st -> nb_index_entries - 1
water	141:24	0:0	12	index
op	141:30	0:0	12	==
water	141:33	0:0	12	st
op	141:35	0:0	12	->
water	141:37	0:0	12	nb_index_entries
op	141:53	0:0	12	-
water	141:54	0:0	12	1
stmts	141:56	157:20	11	
water	141:56	0:0	12	{
decl	142:24	142:33	12	int	key
op	142:31	0:0	12	=
water	142:32	0:0	12	1
decl	143:24	143:29	12	int	i
decl	144:24	144:41	12	uint32_t	state
op	144:38	0:0	12	=
op	144:39	0:0	12	-
water	144:40	0:0	12	1
for	145:24	154:24	12	(i = 0 ;i <FFMIN (size ,256 );i ++)
forinit	145:28	145:31	13	i = 0 ;
water	145:28	0:0	14	i
op	145:29	0:0	14	=
water	145:30	0:0	14	0
water	145:31	0:0	14	;
cond	145:33	145:49	13	i <FFMIN (size ,256 )
water	145:33	0:0	14	i
op	145:34	0:0	14	<
call	145:35	145:49	14	FFMIN
arg	145:41	145:45	15	size
water	145:41	0:0	16	size
arg	145:46	145:49	15	256
water	145:46	0:0	16	256
forexpr	145:52	145:53	13	i ++
water	145:52	0:0	14	i
op	145:53	0:0	14	++
stmts	145:56	154:24	13	
water	145:56	0:0	14	{
if	146:28	151:28	14	(st -> codec -> codec_id == CODEC_ID_MPEG4)
cond	146:31	146:54	15	st -> codec -> codec_id == CODEC_ID_MPEG4
water	146:31	0:0	16	st
op	146:33	0:0	16	->
water	146:35	0:0	16	codec
op	146:40	0:0	16	->
water	146:42	0:0	16	codec_id
op	146:51	0:0	16	==
water	146:54	0:0	16	CODEC_ID_MPEG4
stmts	146:69	151:28	15	
water	146:69	0:0	16	{
if	147:32	150:32	16	(state == 0 x1B6)
cond	147:35	147:45	17	state == 0 x1B6
water	147:35	0:0	18	state
op	147:41	0:0	18	==
water	147:44	0:0	18	0
water	147:45	0:0	18	x1B6
stmts	147:50	150:32	17	
water	147:50	0:0	18	{
water	148:36	0:0	18	key
op	148:39	0:0	18	=
op	148:41	0:0	18	!
water	148:42	0:0	18	(
water	148:43	0:0	18	pkt
op	148:46	0:0	18	->
water	148:48	0:0	18	data
op	148:52	0:0	18	[
water	148:53	0:0	18	i
op	148:54	0:0	18	]
op	148:55	0:0	18	&
water	148:56	0:0	18	0
water	148:57	0:0	18	xC0
water	148:60	0:0	18	)
water	148:61	0:0	18	;
break	149:36	149:41	18	
water	150:32	0:0	18	}
water	151:28	0:0	16	}
else	151:29	152:37	14
stmts	152:32	152:37	15	
break	152:32	152:37	16	
water	153:28	0:0	14	state
op	153:33	0:0	14	=
water	153:35	0:0	14	(
water	153:36	0:0	14	state
op	153:41	0:0	14	<<
water	153:43	0:0	14	8
water	153:44	0:0	14	)
op	153:46	0:0	14	+
water	153:48	0:0	14	pkt
op	153:51	0:0	14	->
water	153:53	0:0	14	data
op	153:57	0:0	14	[
water	153:58	0:0	14	i
op	153:59	0:0	14	]
water	153:60	0:0	14	;
water	154:24	0:0	14	}
if	155:24	156:57	12	(! key)
cond	155:27	155:28	13	! key
op	155:27	0:0	14	!
water	155:28	0:0	14	key
stmts	156:28	156:57	13	
water	156:28	0:0	14	e
op	156:29	0:0	14	->
water	156:31	0:0	14	flags
op	156:37	0:0	14	&=
water	156:40	0:0	14	~AVINDEX_KEYFRAME
water	156:57	0:0	14	;
water	157:20	0:0	12	}
if	158:20	159:53	10	(e -> flags & AVINDEX_KEYFRAME)
cond	158:24	158:35	11	e -> flags & AVINDEX_KEYFRAME
water	158:24	0:0	12	e
op	158:25	0:0	12	->
water	158:27	0:0	12	flags
op	158:33	0:0	12	&
water	158:35	0:0	12	AVINDEX_KEYFRAME
stmts	159:24	159:53	11	
water	159:24	0:0	12	pkt
op	159:27	0:0	12	->
water	159:29	0:0	12	flags
op	159:35	0:0	12	|=
water	159:38	0:0	12	AV_PKT_FLAG_KEY
water	159:53	0:0	12	;
water	160:16	0:0	10	}
water	161:12	0:0	8	}
else	161:14	163:12	6
stmts	161:19	163:12	7	
water	161:19	0:0	8	{
water	162:16	0:0	8	pkt
op	162:19	0:0	8	->
water	162:21	0:0	8	flags
op	162:27	0:0	8	|=
water	162:30	0:0	8	AV_PKT_FLAG_KEY
water	162:45	0:0	8	;
water	163:12	0:0	8	}
water	164:12	0:0	6	ast
op	164:15	0:0	6	->
water	164:17	0:0	6	frame_offset
op	164:30	0:0	6	+=
call	164:33	164:60	6	get_duration
arg	164:46	164:49	7	ast
water	164:46	0:0	8	ast
arg	164:51	164:60	7	pkt->size
water	164:51	0:0	8	pkt
op	164:54	0:0	8	->
water	164:56	0:0	8	size
water	164:61	0:0	6	;
water	165:8	0:0	6	}
water	166:8	0:0	4	ast
op	166:11	0:0	4	->
water	166:13	0:0	4	remaining
op	166:23	0:0	4	-=
water	166:26	0:0	4	size
water	166:30	0:0	4	;
if	167:8	170:8	4	(! ast -> remaining)
cond	167:11	167:17	5	! ast -> remaining
op	167:11	0:0	6	!
water	167:12	0:0	6	ast
op	167:15	0:0	6	->
water	167:17	0:0	6	remaining
stmts	167:27	170:8	5	
water	167:27	0:0	6	{
water	168:12	0:0	6	avi
op	168:15	0:0	6	->
water	168:17	0:0	6	stream_index
op	168:29	0:0	6	=
op	168:31	0:0	6	-
water	168:32	0:0	6	1
water	168:33	0:0	6	;
water	169:12	0:0	6	ast
op	169:15	0:0	6	->
water	169:17	0:0	6	packet_size
op	169:28	0:0	6	=
water	169:30	0:0	6	0
water	169:31	0:0	6	;
water	170:8	0:0	6	}
if	172:8	175:8	4	(! avi -> non_interleaved && pkt -> pos >= 0 && ast -> seek_pos > pkt -> pos)
cond	172:11	172:74	5	! avi -> non_interleaved && pkt -> pos >= 0 && ast -> seek_pos > pkt -> pos
op	172:11	0:0	6	!
water	172:12	0:0	6	avi
op	172:15	0:0	6	->
water	172:17	0:0	6	non_interleaved
op	172:33	0:0	6	&&
water	172:36	0:0	6	pkt
op	172:39	0:0	6	->
water	172:41	0:0	6	pos
op	172:45	0:0	6	>=
water	172:48	0:0	6	0
op	172:50	0:0	6	&&
water	172:53	0:0	6	ast
op	172:56	0:0	6	->
water	172:58	0:0	6	seek_pos
op	172:67	0:0	6	>
water	172:69	0:0	6	pkt
op	172:72	0:0	6	->
water	172:74	0:0	6	pos
stmts	172:78	175:8	5	
water	172:78	0:0	6	{
call	173:12	173:30	6	av_free_packet
arg	173:27	173:30	7	pkt
water	173:27	0:0	8	pkt
water	173:31	0:0	6	;
goto	174:12	174:23	6	resync
water	174:17	0:0	7	resync
water	175:8	0:0	6	}
water	176:8	0:0	4	ast
op	176:11	0:0	4	->
water	176:13	0:0	4	seek_pos
op	176:21	0:0	4	=
water	176:23	0:0	4	0
water	176:24	0:0	4	;
return	178:8	178:19	4	size
water	178:15	0:0	5	size
water	179:4	0:0	4	}
call	181:4	181:31	2	memset
arg	181:11	181:12	3	d
water	181:11	0:0	4	d
arg	181:14	181:16	3	-1
op	181:14	0:0	4	-
water	181:15	0:0	4	1
arg	181:18	181:31	3	sizeof(int)*8
op	181:18	0:0	4	sizeof
water	181:24	0:0	4	(
water	181:25	0:0	4	int
water	181:28	0:0	4	)
op	181:29	0:0	4	*
water	181:30	0:0	4	8
water	181:32	0:0	2	;
for	182:4	293:4	2	(i = sync =avio_tell (pb ) ;!url_feof (pb );i ++)
forinit	182:8	182:28	3	i = sync =avio_tell (pb ) ;
water	182:8	0:0	4	i
op	182:9	0:0	4	=
water	182:10	0:0	4	sync
op	182:14	0:0	4	=
call	182:15	182:27	4	avio_tell
arg	182:25	182:27	5	pb
water	182:25	0:0	6	pb
water	182:28	0:0	4	;
cond	182:30	182:42	3	!url_feof (pb )
op	182:30	0:0	4	!
call	182:31	182:42	4	url_feof
arg	182:40	182:42	5	pb
water	182:40	0:0	6	pb
forexpr	182:45	182:46	3	i ++
water	182:45	0:0	4	i
op	182:46	0:0	4	++
stmts	182:50	293:4	3	
water	182:50	0:0	4	{
decl	183:8	183:13	4	int	j
for	185:8	186:24	4	(j = 0 ;j < 7;j ++)
forinit	185:12	185:15	5	j = 0 ;
water	185:12	0:0	6	j
op	185:13	0:0	6	=
water	185:14	0:0	6	0
water	185:15	0:0	6	;
cond	185:17	185:19	5	j < 7
water	185:17	0:0	6	j
op	185:18	0:0	6	<
water	185:19	0:0	6	7
forexpr	185:22	185:23	5	j ++
water	185:22	0:0	6	j
op	185:23	0:0	6	++
stmts	186:12	186:24	5	
water	186:12	0:0	6	d
op	186:13	0:0	6	[
water	186:14	0:0	6	j
op	186:15	0:0	6	]
op	186:16	0:0	6	=
water	186:18	0:0	6	d
op	186:19	0:0	6	[
water	186:20	0:0	6	j
op	186:21	0:0	6	+
water	186:22	0:0	6	1
op	186:23	0:0	6	]
water	186:24	0:0	6	;
water	187:8	0:0	4	d
op	187:9	0:0	4	[
water	187:10	0:0	4	7
op	187:11	0:0	4	]
op	187:12	0:0	4	=
call	187:14	187:24	4	avio_r8
arg	187:22	187:24	5	pb
water	187:22	0:0	6	pb
water	187:25	0:0	4	;
water	189:8	0:0	4	size
op	189:12	0:0	4	=
water	189:14	0:0	4	d
op	189:15	0:0	4	[
water	189:16	0:0	4	4
op	189:17	0:0	4	]
op	189:19	0:0	4	+
water	189:21	0:0	4	(
water	189:22	0:0	4	d
op	189:23	0:0	4	[
water	189:24	0:0	4	5
op	189:25	0:0	4	]
op	189:26	0:0	4	<<
water	189:28	0:0	4	8
water	189:29	0:0	4	)
op	189:31	0:0	4	+
water	189:33	0:0	4	(
water	189:34	0:0	4	d
op	189:35	0:0	4	[
water	189:36	0:0	4	6
op	189:37	0:0	4	]
op	189:38	0:0	4	<<
water	189:40	0:0	4	16
water	189:42	0:0	4	)
op	189:44	0:0	4	+
water	189:46	0:0	4	(
water	189:47	0:0	4	d
op	189:48	0:0	4	[
water	189:49	0:0	4	7
op	189:50	0:0	4	]
op	189:51	0:0	4	<<
water	189:53	0:0	4	24
water	189:55	0:0	4	)
water	189:56	0:0	4	;
water	191:8	0:0	4	n
op	191:9	0:0	4	=
call	191:11	191:29	4	get_stream_idx
arg	191:26	191:29	5	d+2
water	191:26	0:0	6	d
op	191:27	0:0	6	+
water	191:28	0:0	6	2
water	191:30	0:0	4	;
if	193:8	194:20	4	(i + ( uint64_t ) size > avi -> fsize || d [ 0 ] < 0)
cond	193:11	193:51	5	i + ( uint64_t ) size > avi -> fsize || d [ 0 ] < 0
water	193:11	0:0	6	i
op	193:13	0:0	6	+
water	193:15	0:0	6	(
water	193:16	0:0	6	uint64_t
water	193:24	0:0	6	)
water	193:25	0:0	6	size
op	193:30	0:0	6	>
water	193:32	0:0	6	avi
op	193:35	0:0	6	->
water	193:37	0:0	6	fsize
op	193:43	0:0	6	||
water	193:46	0:0	6	d
op	193:47	0:0	6	[
water	193:48	0:0	6	0
op	193:49	0:0	6	]
op	193:50	0:0	6	<
water	193:51	0:0	6	0
stmts	194:12	194:20	5	
continue	194:12	194:20	6	
if	197:8	204:8	4	(( d [ 0 ] == 'i' && d [ 1 ] == 'x' && n < s -> nb_streams ) || ( d [ 0 ] == 'J' && d [ 1 ] == 'U' && d [ 2 ] == 'N' && d [ 3 ] == 'K' ) || ( d [ 0 ] == 'i' && d [ 1 ] == 'd' && d [ 2 ] == 'x' && d [ 3 ] == '1' ))
cond	197:13	200:70	5	( d [ 0 ] == 'i' && d [ 1 ] == 'x' && n < s -> nb_streams ) || ( d [ 0 ] == 'J' && d [ 1 ] == 'U' && d [ 2 ] == 'N' && d [ 3 ] == 'K' ) || ( d [ 0 ] == 'i' && d [ 1 ] == 'd' && d [ 2 ] == 'x' && d [ 3 ] == '1' )
water	197:13	0:0	6	(
water	197:14	0:0	6	d
op	197:15	0:0	6	[
water	197:16	0:0	6	0
op	197:17	0:0	6	]
op	197:19	0:0	6	==
water	197:22	0:0	6	'i'
op	197:26	0:0	6	&&
water	197:29	0:0	6	d
op	197:30	0:0	6	[
water	197:31	0:0	6	1
op	197:32	0:0	6	]
op	197:34	0:0	6	==
water	197:37	0:0	6	'x'
op	197:41	0:0	6	&&
water	197:44	0:0	6	n
op	197:46	0:0	6	<
water	197:48	0:0	6	s
op	197:49	0:0	6	->
water	197:51	0:0	6	nb_streams
water	197:61	0:0	6	)
op	199:11	0:0	6	||
water	199:13	0:0	6	(
water	199:14	0:0	6	d
op	199:15	0:0	6	[
water	199:16	0:0	6	0
op	199:17	0:0	6	]
op	199:19	0:0	6	==
water	199:22	0:0	6	'J'
op	199:26	0:0	6	&&
water	199:29	0:0	6	d
op	199:30	0:0	6	[
water	199:31	0:0	6	1
op	199:32	0:0	6	]
op	199:34	0:0	6	==
water	199:37	0:0	6	'U'
op	199:41	0:0	6	&&
water	199:44	0:0	6	d
op	199:45	0:0	6	[
water	199:46	0:0	6	2
op	199:47	0:0	6	]
op	199:49	0:0	6	==
water	199:52	0:0	6	'N'
op	199:56	0:0	6	&&
water	199:59	0:0	6	d
op	199:60	0:0	6	[
water	199:61	0:0	6	3
op	199:62	0:0	6	]
op	199:64	0:0	6	==
water	199:67	0:0	6	'K'
water	199:70	0:0	6	)
op	200:11	0:0	6	||
water	200:13	0:0	6	(
water	200:14	0:0	6	d
op	200:15	0:0	6	[
water	200:16	0:0	6	0
op	200:17	0:0	6	]
op	200:19	0:0	6	==
water	200:22	0:0	6	'i'
op	200:26	0:0	6	&&
water	200:29	0:0	6	d
op	200:30	0:0	6	[
water	200:31	0:0	6	1
op	200:32	0:0	6	]
op	200:34	0:0	6	==
water	200:37	0:0	6	'd'
op	200:41	0:0	6	&&
water	200:44	0:0	6	d
op	200:45	0:0	6	[
water	200:46	0:0	6	2
op	200:47	0:0	6	]
op	200:49	0:0	6	==
water	200:52	0:0	6	'x'
op	200:56	0:0	6	&&
water	200:59	0:0	6	d
op	200:60	0:0	6	[
water	200:61	0:0	6	3
op	200:62	0:0	6	]
op	200:64	0:0	6	==
water	200:67	0:0	6	'1'
water	200:70	0:0	6	)
stmts	200:72	204:8	5	
water	200:72	0:0	6	{
call	201:12	201:30	6	avio_skip
arg	201:22	201:24	7	pb
water	201:22	0:0	8	pb
arg	201:26	201:30	7	size
water	201:26	0:0	8	size
water	201:31	0:0	6	;
goto	203:12	203:23	6	resync
water	203:17	0:0	7	resync
water	204:8	0:0	6	}
if	207:8	210:8	4	(d [ 0 ] == 'L' && d [ 1 ] == 'I' && d [ 2 ] == 'S' && d [ 3 ] == 'T')
cond	207:11	207:64	5	d [ 0 ] == 'L' && d [ 1 ] == 'I' && d [ 2 ] == 'S' && d [ 3 ] == 'T'
water	207:11	0:0	6	d
op	207:12	0:0	6	[
water	207:13	0:0	6	0
op	207:14	0:0	6	]
op	207:16	0:0	6	==
water	207:19	0:0	6	'L'
op	207:23	0:0	6	&&
water	207:26	0:0	6	d
op	207:27	0:0	6	[
water	207:28	0:0	6	1
op	207:29	0:0	6	]
op	207:31	0:0	6	==
water	207:34	0:0	6	'I'
op	207:38	0:0	6	&&
water	207:41	0:0	6	d
op	207:42	0:0	6	[
water	207:43	0:0	6	2
op	207:44	0:0	6	]
op	207:46	0:0	6	==
water	207:49	0:0	6	'S'
op	207:53	0:0	6	&&
water	207:56	0:0	6	d
op	207:57	0:0	6	[
water	207:58	0:0	6	3
op	207:59	0:0	6	]
op	207:61	0:0	6	==
water	207:64	0:0	6	'T'
stmts	207:68	210:8	5	
water	207:68	0:0	6	{
call	208:12	208:27	6	avio_skip
arg	208:22	208:24	7	pb
water	208:22	0:0	8	pb
arg	208:26	208:27	7	4
water	208:26	0:0	8	4
water	208:28	0:0	6	;
goto	209:12	209:23	6	resync
water	209:17	0:0	7	resync
water	210:8	0:0	6	}
water	212:8	0:0	4	n
op	212:9	0:0	4	=
call	212:11	212:27	4	get_stream_idx
arg	212:26	212:27	5	d
water	212:26	0:0	6	d
water	212:28	0:0	4	;
if	214:8	215:20	4	(! ( ( i - avi -> last_pkt_pos ) & 1 ) &&get_stream_idx (d + 1 ) < s -> nb_streams)
cond	214:11	214:66	5	! ( ( i - avi -> last_pkt_pos ) & 1 ) &&get_stream_idx (d + 1 ) < s -> nb_streams
op	214:11	0:0	6	!
water	214:12	0:0	6	(
water	214:13	0:0	6	(
water	214:14	0:0	6	i
op	214:15	0:0	6	-
water	214:16	0:0	6	avi
op	214:19	0:0	6	->
water	214:21	0:0	6	last_pkt_pos
water	214:33	0:0	6	)
op	214:34	0:0	6	&
water	214:35	0:0	6	1
water	214:36	0:0	6	)
op	214:38	0:0	6	&&
call	214:41	214:59	6	get_stream_idx
arg	214:56	214:59	7	d+1
water	214:56	0:0	8	d
op	214:57	0:0	8	+
water	214:58	0:0	8	1
op	214:61	0:0	6	<
water	214:63	0:0	6	s
op	214:64	0:0	6	->
water	214:66	0:0	6	nb_streams
stmts	215:12	215:20	5	
continue	215:12	215:20	6	
if	218:8	221:8	4	(d [ 2 ] == 'i' && d [ 3 ] == 'x' && n < s -> nb_streams)
cond	218:11	218:48	5	d [ 2 ] == 'i' && d [ 3 ] == 'x' && n < s -> nb_streams
water	218:11	0:0	6	d
op	218:12	0:0	6	[
water	218:13	0:0	6	2
op	218:14	0:0	6	]
op	218:16	0:0	6	==
water	218:19	0:0	6	'i'
op	218:23	0:0	6	&&
water	218:26	0:0	6	d
op	218:27	0:0	6	[
water	218:28	0:0	6	3
op	218:29	0:0	6	]
op	218:31	0:0	6	==
water	218:34	0:0	6	'x'
op	218:38	0:0	6	&&
water	218:41	0:0	6	n
op	218:43	0:0	6	<
water	218:45	0:0	6	s
op	218:46	0:0	6	->
water	218:48	0:0	6	nb_streams
stmts	218:59	221:8	5	
water	218:59	0:0	6	{
call	219:12	219:30	6	avio_skip
arg	219:22	219:24	7	pb
water	219:22	0:0	8	pb
arg	219:26	219:30	7	size
water	219:26	0:0	8	size
water	219:31	0:0	6	;
goto	220:12	220:23	6	resync
water	220:17	0:0	7	resync
water	221:8	0:0	6	}
if	224:8	292:8	4	(n < s -> nb_streams)
cond	224:11	224:18	5	n < s -> nb_streams
water	224:11	0:0	6	n
op	224:13	0:0	6	<
water	224:15	0:0	6	s
op	224:16	0:0	6	->
water	224:18	0:0	6	nb_streams
stmts	224:29	292:8	5	
water	224:29	0:0	6	{
decl	225:12	225:24	6	AVStream	*st
decl	226:12	226:26	6	AVIStream	*ast
water	227:12	0:0	6	st
op	227:15	0:0	6	=
water	227:17	0:0	6	s
op	227:18	0:0	6	->
water	227:20	0:0	6	streams
op	227:27	0:0	6	[
water	227:28	0:0	6	n
op	227:29	0:0	6	]
water	227:30	0:0	6	;
water	228:12	0:0	6	ast
op	228:16	0:0	6	=
water	228:18	0:0	6	st
op	228:20	0:0	6	->
water	228:22	0:0	6	priv_data
water	228:31	0:0	6	;
if	230:12	246:12	6	(s -> nb_streams >= 2)
cond	230:15	230:30	7	s -> nb_streams >= 2
water	230:15	0:0	8	s
op	230:16	0:0	8	->
water	230:18	0:0	8	nb_streams
op	230:28	0:0	8	>=
water	230:30	0:0	8	2
stmts	230:32	246:12	7	
water	230:32	0:0	8	{
decl	231:16	231:46	8	AVStream	*st1
op	231:31	0:0	8	=
water	231:33	0:0	8	s
op	231:34	0:0	8	->
water	231:36	0:0	8	streams
op	231:43	0:0	8	[
water	231:44	0:0	8	1
op	231:45	0:0	8	]
decl	232:16	232:47	8	AVIStream	*ast1
op	232:31	0:0	8	=
water	232:33	0:0	8	st1
op	232:36	0:0	8	->
water	232:38	0:0	8	priv_data
if	234:16	245:16	8	(d [ 2 ] == 'w' && d [ 3 ] == 'b' && n == 0 && st -> codec -> codec_type == AVMEDIA_TYPE_VIDEO && st1 -> codec -> codec_type == AVMEDIA_TYPE_AUDIO && ast -> prefix == 'd' * 256 + 'c' && ( d [ 2 ] * 256 + d [ 3 ] == ast1 -> prefix || ! ast1 -> prefix_count ))
cond	234:22	239:75	9	d [ 2 ] == 'w' && d [ 3 ] == 'b' && n == 0 && st -> codec -> codec_type == AVMEDIA_TYPE_VIDEO && st1 -> codec -> codec_type == AVMEDIA_TYPE_AUDIO && ast -> prefix == 'd' * 256 + 'c' && ( d [ 2 ] * 256 + d [ 3 ] == ast1 -> prefix || ! ast1 -> prefix_count )
water	234:22	0:0	10	d
op	234:23	0:0	10	[
water	234:24	0:0	10	2
op	234:25	0:0	10	]
op	234:27	0:0	10	==
water	234:30	0:0	10	'w'
op	234:34	0:0	10	&&
water	234:37	0:0	10	d
op	234:38	0:0	10	[
water	234:39	0:0	10	3
op	234:40	0:0	10	]
op	234:42	0:0	10	==
water	234:45	0:0	10	'b'
op	235:19	0:0	10	&&
water	235:22	0:0	10	n
op	235:23	0:0	10	==
water	235:25	0:0	10	0
op	236:19	0:0	10	&&
water	236:22	0:0	10	st
op	236:25	0:0	10	->
water	236:27	0:0	10	codec
op	236:32	0:0	10	->
water	236:34	0:0	10	codec_type
op	236:45	0:0	10	==
water	236:48	0:0	10	AVMEDIA_TYPE_VIDEO
op	237:19	0:0	10	&&
water	237:22	0:0	10	st1
op	237:25	0:0	10	->
water	237:27	0:0	10	codec
op	237:32	0:0	10	->
water	237:34	0:0	10	codec_type
op	237:45	0:0	10	==
water	237:48	0:0	10	AVMEDIA_TYPE_AUDIO
op	238:19	0:0	10	&&
water	238:22	0:0	10	ast
op	238:25	0:0	10	->
water	238:27	0:0	10	prefix
op	238:34	0:0	10	==
water	238:37	0:0	10	'd'
op	238:40	0:0	10	*
water	238:41	0:0	10	256
op	238:44	0:0	10	+
water	238:45	0:0	10	'c'
op	239:19	0:0	10	&&
water	239:22	0:0	10	(
water	239:23	0:0	10	d
op	239:24	0:0	10	[
water	239:25	0:0	10	2
op	239:26	0:0	10	]
op	239:27	0:0	10	*
water	239:28	0:0	10	256
op	239:31	0:0	10	+
water	239:32	0:0	10	d
op	239:33	0:0	10	[
water	239:34	0:0	10	3
op	239:35	0:0	10	]
op	239:37	0:0	10	==
water	239:40	0:0	10	ast1
op	239:44	0:0	10	->
water	239:46	0:0	10	prefix
op	239:53	0:0	10	||
op	239:56	0:0	10	!
water	239:57	0:0	10	ast1
op	239:61	0:0	10	->
water	239:63	0:0	10	prefix_count
water	239:75	0:0	10	)
stmts	240:19	245:16	9	
water	240:19	0:0	10	{
water	241:20	0:0	10	n
op	241:21	0:0	10	=
water	241:22	0:0	10	1
water	241:23	0:0	10	;
water	242:20	0:0	10	st
op	242:23	0:0	10	=
water	242:25	0:0	10	st1
water	242:28	0:0	10	;
water	243:20	0:0	10	ast
op	243:24	0:0	10	=
water	243:26	0:0	10	ast1
water	243:30	0:0	10	;
call	244:20	244:102	10	av_log
arg	244:27	244:28	11	s
water	244:27	0:0	12	s
arg	244:30	244:44	11	AV_LOG_WARNING
water	244:30	0:0	12	AV_LOG_WARNING
arg	244:46	244:102	11	"Invalid stream + prefix combination, assuming audio.\n"
water	244:46	0:0	12	"Invalid stream + prefix combination, assuming audio.\n"
water	244:103	0:0	10	;
water	245:16	0:0	10	}
water	246:12	0:0	8	}
if	249:12	255:12	6	(( st -> discard >= AVDISCARD_DEFAULT && size == 0 ) || st -> discard >= AVDISCARD_ALL)
cond	249:18	251:33	7	( st -> discard >= AVDISCARD_DEFAULT && size == 0 ) || st -> discard >= AVDISCARD_ALL
water	249:18	0:0	8	(
water	249:19	0:0	8	st
op	249:21	0:0	8	->
water	249:23	0:0	8	discard
op	249:31	0:0	8	>=
water	249:34	0:0	8	AVDISCARD_DEFAULT
op	249:52	0:0	8	&&
water	249:55	0:0	8	size
op	249:59	0:0	8	==
water	249:61	0:0	8	0
water	249:62	0:0	8	)
op	251:15	0:0	8	||
water	251:18	0:0	8	st
op	251:20	0:0	8	->
water	251:22	0:0	8	discard
op	251:30	0:0	8	>=
water	251:33	0:0	8	AVDISCARD_ALL
stmts	251:47	255:12	7	
water	251:47	0:0	8	{
water	252:16	0:0	8	ast
op	252:19	0:0	8	->
water	252:21	0:0	8	frame_offset
op	252:34	0:0	8	+=
call	252:37	252:59	8	get_duration
arg	252:50	252:53	9	ast
water	252:50	0:0	10	ast
arg	252:55	252:59	9	size
water	252:55	0:0	10	size
water	252:60	0:0	8	;
call	253:16	253:34	8	avio_skip
arg	253:26	253:28	9	pb
water	253:26	0:0	10	pb
arg	253:30	253:34	9	size
water	253:30	0:0	10	size
water	253:35	0:0	8	;
goto	254:16	254:27	8	resync
water	254:21	0:0	9	resync
water	255:12	0:0	8	}
if	257:12	267:12	6	(d [ 2 ] == 'p' && d [ 3 ] == 'c' && size <= 4 * 256 + 4)
cond	257:16	257:58	7	d [ 2 ] == 'p' && d [ 3 ] == 'c' && size <= 4 * 256 + 4
water	257:16	0:0	8	d
op	257:17	0:0	8	[
water	257:18	0:0	8	2
op	257:19	0:0	8	]
op	257:21	0:0	8	==
water	257:24	0:0	8	'p'
op	257:28	0:0	8	&&
water	257:31	0:0	8	d
op	257:32	0:0	8	[
water	257:33	0:0	8	3
op	257:34	0:0	8	]
op	257:36	0:0	8	==
water	257:39	0:0	8	'c'
op	257:43	0:0	8	&&
water	257:46	0:0	8	size
op	257:50	0:0	8	<=
water	257:52	0:0	8	4
op	257:53	0:0	8	*
water	257:54	0:0	8	256
op	257:57	0:0	8	+
water	257:58	0:0	8	4
stmts	257:61	267:12	7	
water	257:61	0:0	8	{
decl	258:16	258:35	8	int	k
op	258:22	0:0	8	=
call	258:24	258:34	9	avio_r8
arg	258:32	258:34	10	pb
water	258:32	0:0	11	pb
decl	259:16	259:55	8	int	last
op	259:25	0:0	8	=
water	259:27	0:0	8	(
water	259:28	0:0	8	k
op	259:30	0:0	8	+
call	259:32	259:42	9	avio_r8
arg	259:40	259:42	10	pb
water	259:40	0:0	11	pb
op	259:44	0:0	8	-
water	259:46	0:0	8	1
water	259:47	0:0	8	)
op	259:49	0:0	8	&
water	259:51	0:0	8	0
water	259:52	0:0	8	xFF
call	261:16	261:28	8	avio_rl16
arg	261:26	261:28	9	pb
water	261:26	0:0	10	pb
water	261:29	0:0	8	;
for	263:16	264:50	8	(;k <= last;k ++)
forinit	263:21	263:21	9	;
water	263:21	0:0	10	;
cond	263:23	263:28	9	k <= last
water	263:23	0:0	10	k
op	263:25	0:0	10	<=
water	263:28	0:0	10	last
forexpr	263:34	263:35	9	k ++
water	263:34	0:0	10	k
op	263:35	0:0	10	++
stmts	264:20	264:50	9	
water	264:20	0:0	10	ast
op	264:23	0:0	10	->
water	264:25	0:0	10	pal
op	264:28	0:0	10	[
water	264:29	0:0	10	k
op	264:30	0:0	10	]
op	264:32	0:0	10	=
call	264:34	264:46	10	avio_rb32
arg	264:44	264:46	11	pb
water	264:44	0:0	12	pb
op	264:47	0:0	10	>>
water	264:49	0:0	10	8
water	264:50	0:0	10	;
water	265:16	0:0	8	ast
op	265:19	0:0	8	->
water	265:21	0:0	8	has_pal
op	265:28	0:0	8	=
water	265:30	0:0	8	1
water	265:31	0:0	8	;
goto	266:16	266:27	8	resync
water	266:21	0:0	9	resync
water	267:12	0:0	8	}
else	267:14	291:12	6
stmts	267:19	291:12	7	
if	267:19	291:12	8	(( ( ast -> prefix_count < 5 || sync + 9 > i ) && d [ 2 ] < 128 && d [ 3 ] < 128 ) || d [ 2 ] * 256 + d [ 3 ] == ast -> prefix)
cond	267:25	268:47	9	( ( ast -> prefix_count < 5 || sync + 9 > i ) && d [ 2 ] < 128 && d [ 3 ] < 128 ) || d [ 2 ] * 256 + d [ 3 ] == ast -> prefix
water	267:25	0:0	10	(
water	267:26	0:0	10	(
water	267:27	0:0	10	ast
op	267:30	0:0	10	->
water	267:32	0:0	10	prefix_count
op	267:44	0:0	10	<
water	267:45	0:0	10	5
op	267:47	0:0	10	||
water	267:50	0:0	10	sync
op	267:54	0:0	10	+
water	267:55	0:0	10	9
op	267:57	0:0	10	>
water	267:59	0:0	10	i
water	267:60	0:0	10	)
op	267:62	0:0	10	&&
water	267:65	0:0	10	d
op	267:66	0:0	10	[
water	267:67	0:0	10	2
op	267:68	0:0	10	]
op	267:69	0:0	10	<
water	267:70	0:0	10	128
op	267:74	0:0	10	&&
water	267:77	0:0	10	d
op	267:78	0:0	10	[
water	267:79	0:0	10	3
op	267:80	0:0	10	]
op	267:81	0:0	10	<
water	267:82	0:0	10	128
water	267:85	0:0	10	)
op	267:87	0:0	10	||
water	268:25	0:0	10	d
op	268:26	0:0	10	[
water	268:27	0:0	10	2
op	268:28	0:0	10	]
op	268:29	0:0	10	*
water	268:30	0:0	10	256
op	268:33	0:0	10	+
water	268:34	0:0	10	d
op	268:35	0:0	10	[
water	268:36	0:0	10	3
op	268:37	0:0	10	]
op	268:39	0:0	10	==
water	268:42	0:0	10	ast
op	268:45	0:0	10	->
water	268:47	0:0	10	prefix
stmts	270:2	291:12	9	
water	270:2	0:0	10	{
if	273:16	274:39	10	(d [ 2 ] * 256 + d [ 3 ] == ast -> prefix)
cond	273:19	273:41	11	d [ 2 ] * 256 + d [ 3 ] == ast -> prefix
water	273:19	0:0	12	d
op	273:20	0:0	12	[
water	273:21	0:0	12	2
op	273:22	0:0	12	]
op	273:23	0:0	12	*
water	273:24	0:0	12	256
op	273:27	0:0	12	+
water	273:28	0:0	12	d
op	273:29	0:0	12	[
water	273:30	0:0	12	3
op	273:31	0:0	12	]
op	273:33	0:0	12	==
water	273:36	0:0	12	ast
op	273:39	0:0	12	->
water	273:41	0:0	12	prefix
stmts	274:20	274:39	11	
water	274:20	0:0	12	ast
op	274:23	0:0	12	->
water	274:25	0:0	12	prefix_count
op	274:37	0:0	12	++
water	274:39	0:0	12	;
else	275:16	278:16	10
stmts	275:20	278:16	11	
water	275:20	0:0	12	{
water	276:20	0:0	12	ast
op	276:23	0:0	12	->
water	276:25	0:0	12	prefix
op	276:31	0:0	12	=
water	276:33	0:0	12	d
op	276:34	0:0	12	[
water	276:35	0:0	12	2
op	276:36	0:0	12	]
op	276:37	0:0	12	*
water	276:38	0:0	12	256
op	276:41	0:0	12	+
water	276:42	0:0	12	d
op	276:43	0:0	12	[
water	276:44	0:0	12	3
op	276:45	0:0	12	]
water	276:46	0:0	12	;
water	277:20	0:0	12	ast
op	277:23	0:0	12	->
water	277:25	0:0	12	prefix_count
op	277:37	0:0	12	=
water	277:39	0:0	12	0
water	277:40	0:0	12	;
water	278:16	0:0	12	}
water	280:16	0:0	10	avi
op	280:19	0:0	10	->
water	280:21	0:0	10	stream_index
op	280:33	0:0	10	=
water	280:35	0:0	10	n
water	280:36	0:0	10	;
water	281:16	0:0	10	ast
op	281:19	0:0	10	->
water	281:21	0:0	10	packet_size
op	281:32	0:0	10	=
water	281:34	0:0	10	size
op	281:39	0:0	10	+
water	281:41	0:0	10	8
water	281:42	0:0	10	;
water	282:16	0:0	10	ast
op	282:19	0:0	10	->
water	282:21	0:0	10	remaining
op	282:30	0:0	10	=
water	282:32	0:0	10	size
water	282:36	0:0	10	;
if	284:16	289:16	10	(size || ! ast -> sample_size)
cond	284:19	284:33	11	size || ! ast -> sample_size
water	284:19	0:0	12	size
op	284:24	0:0	12	||
op	284:27	0:0	12	!
water	284:28	0:0	12	ast
op	284:31	0:0	12	->
water	284:33	0:0	12	sample_size
stmts	284:45	289:16	11	
water	284:45	0:0	12	{
decl	285:20	285:51	12	uint64_t	pos
op	285:32	0:0	12	=
call	285:34	285:46	13	avio_tell
arg	285:44	285:46	14	pb
water	285:44	0:0	15	pb
op	285:48	0:0	12	-
water	285:50	0:0	12	8
if	286:20	288:20	12	(! st -> index_entries || ! st -> nb_index_entries || st -> index_entries [ st -> nb_index_entries - 1 ] . pos < pos)
cond	286:23	286:120	13	! st -> index_entries || ! st -> nb_index_entries || st -> index_entries [ st -> nb_index_entries - 1 ] . pos < pos
op	286:23	0:0	14	!
water	286:24	0:0	14	st
op	286:26	0:0	14	->
water	286:28	0:0	14	index_entries
op	286:42	0:0	14	||
op	286:45	0:0	14	!
water	286:46	0:0	14	st
op	286:48	0:0	14	->
water	286:50	0:0	14	nb_index_entries
op	286:67	0:0	14	||
water	286:70	0:0	14	st
op	286:72	0:0	14	->
water	286:74	0:0	14	index_entries
op	286:87	0:0	14	[
water	286:88	0:0	14	st
op	286:90	0:0	14	->
water	286:92	0:0	14	nb_index_entries
op	286:109	0:0	14	-
water	286:111	0:0	14	1
op	286:112	0:0	14	]
op	286:113	0:0	14	.
water	286:114	0:0	14	pos
op	286:118	0:0	14	<
water	286:120	0:0	14	pos
stmts	286:124	288:20	13	
water	286:124	0:0	14	{
call	287:24	287:96	14	av_add_index_entry
arg	287:43	287:45	15	st
water	287:43	0:0	16	st
arg	287:47	287:50	15	pos
water	287:47	0:0	16	pos
arg	287:52	287:69	15	ast->frame_offset
water	287:52	0:0	16	ast
op	287:55	0:0	16	->
water	287:57	0:0	16	frame_offset
arg	287:71	287:75	15	size
water	287:71	0:0	16	size
arg	287:77	287:78	15	0
water	287:77	0:0	16	0
arg	287:80	287:96	15	AVINDEX_KEYFRAME
water	287:80	0:0	16	AVINDEX_KEYFRAME
water	287:97	0:0	14	;
water	288:20	0:0	14	}
water	289:16	0:0	12	}
goto	290:16	290:27	10	resync
water	290:21	0:0	11	resync
water	291:12	0:0	10	}
water	292:8	0:0	6	}
water	293:4	0:0	4	}
return	295:4	295:22	2	AVERROR_EOF
water	295:11	0:0	3	AVERROR_EOF
