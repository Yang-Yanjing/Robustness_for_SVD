func	10:0	75:0	0	static int	decodeTonalComponents
params	10:33	0:0	1	
param	10:34	10:51	2	GetBitContext *	gb
param	10:53	10:80	2	tonal_component *	pComponent
param	10:82	10:94	2	int	numBands
stmnts	0:0	74:26	1	
decl	12:4	12:17	2	int	i
water	12:9	0:0	2	,
decl	12:4	12:17	2	int	j
water	12:11	0:0	2	,
decl	12:4	12:17	2	int	k
water	12:13	0:0	2	,
decl	12:4	12:17	2	int	cnt
decl	13:4	13:83	2	int	components
water	13:20	0:0	2	,
decl	13:4	13:83	2	int	coding_mode_selector
water	13:42	0:0	2	,
decl	13:4	13:83	2	int	coding_mode
water	13:55	0:0	2	,
decl	13:4	13:83	2	int	coded_values_per_component
decl	14:4	14:84	2	int	sfIndx
water	14:16	0:0	2	,
decl	14:4	14:84	2	int	coded_values
water	14:30	0:0	2	,
decl	14:4	14:84	2	int	max_coded_values
water	14:48	0:0	2	,
decl	14:4	14:84	2	int	quant_step_index
water	14:66	0:0	2	,
decl	14:4	14:84	2	int	coded_components
decl	15:4	15:36	2	int	band_flags[4]
water	15:23	0:0	2	,
decl	15:4	15:36	2	int	mantissa[8]
decl	16:4	16:17	2	float	*pCoef
decl	17:4	17:22	2	float	scalefactor
decl	18:4	18:29	2	int	component_count
op	18:26	0:0	2	=
water	18:28	0:0	2	0
water	20:4	0:0	2	components
op	20:15	0:0	2	=
call	20:17	20:30	2	get_bits
arg	20:26	20:28	3	gb
water	20:26	0:0	4	gb
arg	20:29	20:30	3	5
water	20:29	0:0	4	5
water	20:31	0:0	2	;
if	23:4	24:16	2	(components == 0)
cond	23:8	23:22	3	components == 0
water	23:8	0:0	4	components
op	23:19	0:0	4	==
water	23:22	0:0	4	0
stmts	24:8	24:16	3	
return	24:8	24:16	4	0
water	24:15	0:0	5	0
water	26:4	0:0	2	coding_mode_selector
op	26:25	0:0	2	=
call	26:27	26:40	2	get_bits
arg	26:36	26:38	3	gb
water	26:36	0:0	4	gb
arg	26:39	26:40	3	2
water	26:39	0:0	4	2
water	26:41	0:0	2	;
if	27:4	28:17	2	(coding_mode_selector == 2)
cond	27:8	27:32	3	coding_mode_selector == 2
water	27:8	0:0	4	coding_mode_selector
op	27:29	0:0	4	==
water	27:32	0:0	4	2
stmts	28:8	28:17	3	
return	28:8	28:17	4	-1
op	28:15	0:0	5	-
water	28:16	0:0	5	1
water	30:4	0:0	2	coding_mode
op	30:16	0:0	2	=
water	30:18	0:0	2	coding_mode_selector
op	30:39	0:0	2	&
water	30:41	0:0	2	1
water	30:42	0:0	2	;
for	32:4	72:4	2	(i = 0 ;i < components;i ++)
forinit	32:9	32:14	3	i = 0 ;
water	32:9	0:0	4	i
op	32:11	0:0	4	=
water	32:13	0:0	4	0
water	32:14	0:0	4	;
cond	32:16	32:20	3	i < components
water	32:16	0:0	4	i
op	32:18	0:0	4	<
water	32:20	0:0	4	components
forexpr	32:32	32:33	3	i ++
water	32:32	0:0	4	i
op	32:33	0:0	4	++
stmts	32:37	72:4	3	
water	32:37	0:0	4	{
for	33:8	34:43	4	(cnt = 0 ;cnt <= numBands;cnt ++)
forinit	33:13	33:20	5	cnt = 0 ;
water	33:13	0:0	6	cnt
op	33:17	0:0	6	=
water	33:19	0:0	6	0
water	33:20	0:0	6	;
cond	33:22	33:29	5	cnt <= numBands
water	33:22	0:0	6	cnt
op	33:26	0:0	6	<=
water	33:29	0:0	6	numBands
forexpr	33:39	33:42	5	cnt ++
water	33:39	0:0	6	cnt
op	33:42	0:0	6	++
stmts	34:12	34:43	5	
water	34:12	0:0	6	band_flags
op	34:22	0:0	6	[
water	34:23	0:0	6	cnt
op	34:26	0:0	6	]
op	34:28	0:0	6	=
call	34:30	34:42	6	get_bits1
arg	34:40	34:42	7	gb
water	34:40	0:0	8	gb
water	34:43	0:0	6	;
water	36:8	0:0	4	coded_values_per_component
op	36:35	0:0	4	=
call	36:37	36:50	4	get_bits
arg	36:46	36:48	5	gb
water	36:46	0:0	6	gb
arg	36:49	36:50	5	3
water	36:49	0:0	6	3
water	36:51	0:0	4	;
water	38:8	0:0	4	quant_step_index
op	38:25	0:0	4	=
call	38:27	38:40	4	get_bits
arg	38:36	38:38	5	gb
water	38:36	0:0	6	gb
arg	38:39	38:40	5	3
water	38:39	0:0	6	3
water	38:41	0:0	4	;
if	39:8	40:21	4	(quant_step_index <= 1)
cond	39:12	39:32	5	quant_step_index <= 1
water	39:12	0:0	6	quant_step_index
op	39:29	0:0	6	<=
water	39:32	0:0	6	1
stmts	40:12	40:21	5	
return	40:12	40:21	6	-1
op	40:19	0:0	7	-
water	40:20	0:0	7	1
if	42:8	43:39	4	(coding_mode_selector == 3)
cond	42:12	42:36	5	coding_mode_selector == 3
water	42:12	0:0	6	coding_mode_selector
op	42:33	0:0	6	==
water	42:36	0:0	6	3
stmts	43:12	43:39	5	
water	43:12	0:0	6	coding_mode
op	43:24	0:0	6	=
call	43:26	43:38	6	get_bits1
arg	43:36	43:38	7	gb
water	43:36	0:0	8	gb
water	43:39	0:0	6	;
for	45:8	71:8	4	(j = 0 ;j < ( numBands + 1 ) * 4;j ++)
forinit	45:13	45:18	5	j = 0 ;
water	45:13	0:0	6	j
op	45:15	0:0	6	=
water	45:17	0:0	6	0
water	45:18	0:0	6	;
cond	45:20	45:41	5	j < ( numBands + 1 ) * 4
water	45:20	0:0	6	j
op	45:22	0:0	6	<
water	45:24	0:0	6	(
water	45:25	0:0	6	numBands
op	45:34	0:0	6	+
water	45:36	0:0	6	1
water	45:37	0:0	6	)
op	45:39	0:0	6	*
water	45:41	0:0	6	4
forexpr	45:44	45:45	5	j ++
water	45:44	0:0	6	j
op	45:45	0:0	6	++
stmts	45:49	71:8	5	
water	45:49	0:0	6	{
if	46:12	47:24	6	(band_flags [ j >> 2 ] == 0)
cond	46:16	46:38	7	band_flags [ j >> 2 ] == 0
water	46:16	0:0	8	band_flags
op	46:26	0:0	8	[
water	46:27	0:0	8	j
op	46:29	0:0	8	>>
water	46:32	0:0	8	2
op	46:33	0:0	8	]
op	46:35	0:0	8	==
water	46:38	0:0	8	0
stmts	47:16	47:24	7	
continue	47:16	47:24	8	
water	49:12	0:0	6	coded_components
op	49:29	0:0	6	=
call	49:31	49:44	6	get_bits
arg	49:40	49:42	7	gb
water	49:40	0:0	8	gb
arg	49:43	49:44	7	3
water	49:43	0:0	8	3
water	49:45	0:0	6	;
for	51:12	70:12	6	(k = 0 ;k < coded_components;k ++)
forinit	51:17	51:20	7	k = 0 ;
water	51:17	0:0	8	k
op	51:18	0:0	8	=
water	51:19	0:0	8	0
water	51:20	0:0	8	;
cond	51:22	51:24	7	k < coded_components
water	51:22	0:0	8	k
op	51:23	0:0	8	<
water	51:24	0:0	8	coded_components
forexpr	51:42	51:43	7	k ++
water	51:42	0:0	8	k
op	51:43	0:0	8	++
stmts	51:47	70:12	7	
water	51:47	0:0	8	{
water	52:16	0:0	8	sfIndx
op	52:23	0:0	8	=
call	52:25	52:38	8	get_bits
arg	52:34	52:36	9	gb
water	52:34	0:0	10	gb
arg	52:37	52:38	9	6
water	52:37	0:0	10	6
water	52:39	0:0	8	;
water	53:16	0:0	8	pComponent
op	53:26	0:0	8	[
water	53:27	0:0	8	component_count
op	53:42	0:0	8	]
op	53:43	0:0	8	.
water	53:44	0:0	8	pos
op	53:48	0:0	8	=
water	53:50	0:0	8	j
op	53:52	0:0	8	*
water	53:54	0:0	8	64
op	53:57	0:0	8	+
water	53:59	0:0	8	(
call	53:60	53:73	8	get_bits
arg	53:69	53:71	9	gb
water	53:69	0:0	10	gb
arg	53:72	53:73	9	6
water	53:72	0:0	10	6
water	53:74	0:0	8	)
water	53:75	0:0	8	;
water	54:16	0:0	8	max_coded_values
op	54:33	0:0	8	=
water	54:35	0:0	8	1024
op	54:40	0:0	8	-
water	54:42	0:0	8	pComponent
op	54:52	0:0	8	[
water	54:53	0:0	8	component_count
op	54:68	0:0	8	]
op	54:69	0:0	8	.
water	54:70	0:0	8	pos
water	54:73	0:0	8	;
water	55:16	0:0	8	coded_values
op	55:29	0:0	8	=
water	55:31	0:0	8	coded_values_per_component
op	55:58	0:0	8	+
water	55:60	0:0	8	1
water	55:61	0:0	8	;
water	56:16	0:0	8	coded_values
op	56:29	0:0	8	=
call	56:31	56:66	8	FFMIN
arg	56:37	56:53	9	max_coded_values
water	56:37	0:0	10	max_coded_values
arg	56:54	56:66	9	coded_values
water	56:54	0:0	10	coded_values
water	56:67	0:0	8	;
water	58:16	0:0	8	scalefactor
op	58:28	0:0	8	=
water	58:30	0:0	8	ff_atrac_sf_table
op	58:47	0:0	8	[
water	58:48	0:0	8	sfIndx
op	58:54	0:0	8	]
op	58:56	0:0	8	*
water	58:58	0:0	8	iMaxQuant
op	58:67	0:0	8	[
water	58:68	0:0	8	quant_step_index
op	58:84	0:0	8	]
water	58:85	0:0	8	;
call	60:16	60:97	8	readQuantSpectralCoeffs
arg	60:40	60:42	9	gb
water	60:40	0:0	10	gb
arg	60:44	60:60	9	quant_step_index
water	60:44	0:0	10	quant_step_index
arg	60:62	60:73	9	coding_mode
water	60:62	0:0	10	coding_mode
arg	60:75	60:83	9	mantissa
water	60:75	0:0	10	mantissa
arg	60:85	60:97	9	coded_values
water	60:85	0:0	10	coded_values
water	60:98	0:0	8	;
water	62:16	0:0	8	pComponent
op	62:26	0:0	8	[
water	62:27	0:0	8	component_count
op	62:42	0:0	8	]
op	62:43	0:0	8	.
water	62:44	0:0	8	numCoefs
op	62:53	0:0	8	=
water	62:55	0:0	8	coded_values
water	62:67	0:0	8	;
water	65:16	0:0	8	pCoef
op	65:22	0:0	8	=
water	65:24	0:0	8	pComponent
op	65:34	0:0	8	[
water	65:35	0:0	8	component_count
op	65:50	0:0	8	]
op	65:51	0:0	8	.
water	65:52	0:0	8	coef
water	65:56	0:0	8	;
for	66:16	67:60	8	(cnt = 0 ;cnt < coded_values;cnt ++)
forinit	66:21	66:28	9	cnt = 0 ;
water	66:21	0:0	10	cnt
op	66:25	0:0	10	=
water	66:27	0:0	10	0
water	66:28	0:0	10	;
cond	66:30	66:36	9	cnt < coded_values
water	66:30	0:0	10	cnt
op	66:34	0:0	10	<
water	66:36	0:0	10	coded_values
forexpr	66:50	66:53	9	cnt ++
water	66:50	0:0	10	cnt
op	66:53	0:0	10	++
stmts	67:20	67:60	9	
water	67:20	0:0	10	pCoef
op	67:25	0:0	10	[
water	67:26	0:0	10	cnt
op	67:29	0:0	10	]
op	67:31	0:0	10	=
water	67:33	0:0	10	mantissa
op	67:41	0:0	10	[
water	67:42	0:0	10	cnt
op	67:45	0:0	10	]
op	67:47	0:0	10	*
water	67:49	0:0	10	scalefactor
water	67:60	0:0	10	;
water	69:16	0:0	8	component_count
op	69:31	0:0	8	++
water	69:33	0:0	8	;
water	70:12	0:0	8	}
water	71:8	0:0	6	}
water	72:4	0:0	4	}
return	74:4	74:26	2	component_count
water	74:11	0:0	3	component_count
