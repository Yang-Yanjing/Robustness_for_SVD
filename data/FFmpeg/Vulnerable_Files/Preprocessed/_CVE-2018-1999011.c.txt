func	1:0	31:0	0	static int	parse_video_info
params	1:27	0:0	1	
param	1:28	1:43	2	AVIOContext *	pb
param	1:45	1:57	2	AVStream *	st
stmnts	0:0	30:12	1	
decl	3:4	3:21	2	uint16_t	size_asf
decl	4:4	4:21	2	uint32_t	size_bmp
decl	5:4	5:20	2	unsigned int	tag
water	7:4	0:0	2	st
op	7:6	0:0	2	->
water	7:8	0:0	2	codecpar
op	7:16	0:0	2	->
water	7:18	0:0	2	width
op	7:25	0:0	2	=
call	7:27	7:39	2	avio_rl32
arg	7:37	7:39	3	pb
water	7:37	0:0	4	pb
water	7:40	0:0	2	;
water	8:4	0:0	2	st
op	8:6	0:0	2	->
water	8:8	0:0	2	codecpar
op	8:16	0:0	2	->
water	8:18	0:0	2	height
op	8:25	0:0	2	=
call	8:27	8:39	2	avio_rl32
arg	8:37	8:39	3	pb
water	8:37	0:0	4	pb
water	8:40	0:0	2	;
call	9:4	9:19	2	avio_skip
arg	9:14	9:16	3	pb
water	9:14	0:0	4	pb
arg	9:18	9:19	3	1
water	9:18	0:0	4	1
water	9:20	0:0	2	;
water	10:4	0:0	2	size_asf
op	10:13	0:0	2	=
call	10:15	10:27	2	avio_rl16
arg	10:25	10:27	3	pb
water	10:25	0:0	4	pb
water	10:28	0:0	2	;
water	11:4	0:0	2	tag
op	11:8	0:0	2	=
call	11:10	11:45	2	ff_get_bmp_header
arg	11:28	11:30	3	pb
water	11:28	0:0	4	pb
arg	11:32	11:34	3	st
water	11:32	0:0	4	st
arg	11:36	11:45	3	&size_bmp
op	11:36	0:0	4	&
water	11:37	0:0	4	size_bmp
water	11:46	0:0	2	;
water	12:4	0:0	2	st
op	12:6	0:0	2	->
water	12:8	0:0	2	codecpar
op	12:16	0:0	2	->
water	12:18	0:0	2	codec_tag
op	12:28	0:0	2	=
water	12:30	0:0	2	tag
water	12:33	0:0	2	;
water	13:4	0:0	2	st
op	13:6	0:0	2	->
water	13:8	0:0	2	codecpar
op	13:16	0:0	2	->
water	13:18	0:0	2	codec_id
op	13:28	0:0	2	=
call	13:30	13:68	2	ff_codec_get_id
arg	13:46	13:63	3	ff_codec_bmp_tags
water	13:46	0:0	4	ff_codec_bmp_tags
arg	13:65	13:68	3	tag
water	13:65	0:0	4	tag
water	13:69	0:0	2	;
water	14:4	0:0	2	size_bmp
op	14:13	0:0	2	=
call	14:15	14:39	2	FFMAX
arg	14:21	14:29	3	size_asf
water	14:21	0:0	4	size_asf
arg	14:31	14:39	3	size_bmp
water	14:31	0:0	4	size_bmp
water	14:40	0:0	2	;
if	16:4	29:4	2	(size_bmp > BMP_HEADER_SIZE)
cond	16:8	16:19	3	size_bmp > BMP_HEADER_SIZE
water	16:8	0:0	4	size_bmp
op	16:17	0:0	4	>
water	16:19	0:0	4	BMP_HEADER_SIZE
stmts	16:36	29:4	3	
water	16:36	0:0	4	{
decl	17:8	17:15	4	int	ret
water	18:8	0:0	4	st
op	18:10	0:0	4	->
water	18:12	0:0	4	codecpar
op	18:20	0:0	4	->
water	18:22	0:0	4	extradata_size
op	18:38	0:0	4	=
water	18:40	0:0	4	size_bmp
op	18:49	0:0	4	-
water	18:51	0:0	4	BMP_HEADER_SIZE
water	18:66	0:0	4	;
if	19:8	23:8	4	(! ( st -> codecpar -> extradata =av_malloc (st -> codecpar -> extradata_size + AV_INPUT_BUFFER_PADDING_SIZE ) ))
cond	19:12	20:76	5	! ( st -> codecpar -> extradata =av_malloc (st -> codecpar -> extradata_size + AV_INPUT_BUFFER_PADDING_SIZE ) )
op	19:12	0:0	6	!
water	19:13	0:0	6	(
water	19:14	0:0	6	st
op	19:16	0:0	6	->
water	19:18	0:0	6	codecpar
op	19:26	0:0	6	->
water	19:28	0:0	6	extradata
op	19:38	0:0	6	=
call	19:40	20:75	6	av_malloc
arg	19:50	20:75	7	st->codecpar->extradata_size+AV_INPUT_BUFFER_PADDING_SIZE
water	19:50	0:0	8	st
op	19:52	0:0	8	->
water	19:54	0:0	8	codecpar
op	19:62	0:0	8	->
water	19:64	0:0	8	extradata_size
op	19:79	0:0	8	+
water	20:47	0:0	8	AV_INPUT_BUFFER_PADDING_SIZE
water	20:76	0:0	6	)
stmts	20:79	23:8	5	
water	20:79	0:0	6	{
water	21:12	0:0	6	st
op	21:14	0:0	6	->
water	21:16	0:0	6	codecpar
op	21:24	0:0	6	->
water	21:26	0:0	6	extradata_size
op	21:41	0:0	6	=
water	21:43	0:0	6	0
water	21:44	0:0	6	;
return	22:12	22:34	6	AVERROR(ENOMEM)
call	22:19	22:33	7	AVERROR
arg	22:27	22:33	8	ENOMEM
water	22:27	0:0	9	ENOMEM
water	23:8	0:0	6	}
call	24:8	25:43	4	memset
arg	24:15	24:70	5	st->codecpar->extradata+st->codecpar->extradata_size
water	24:15	0:0	6	st
op	24:17	0:0	6	->
water	24:19	0:0	6	codecpar
op	24:27	0:0	6	->
water	24:29	0:0	6	extradata
op	24:39	0:0	6	+
water	24:41	0:0	6	st
op	24:43	0:0	6	->
water	24:45	0:0	6	codecpar
op	24:53	0:0	6	->
water	24:55	0:0	6	extradata_size
arg	24:72	24:73	5	0
water	24:72	0:0	6	0
arg	25:15	25:43	5	AV_INPUT_BUFFER_PADDING_SIZE
water	25:15	0:0	6	AV_INPUT_BUFFER_PADDING_SIZE
water	25:44	0:0	4	;
if	26:8	28:22	4	(( ret =avio_read (pb ,st -> codecpar -> extradata ,st -> codecpar -> extradata_size ) ) < 0)
cond	26:12	27:62	5	( ret =avio_read (pb ,st -> codecpar -> extradata ,st -> codecpar -> extradata_size ) ) < 0
water	26:12	0:0	6	(
water	26:13	0:0	6	ret
op	26:17	0:0	6	=
call	26:19	27:57	6	avio_read
arg	26:29	26:31	7	pb
water	26:29	0:0	8	pb
arg	26:33	26:56	7	st->codecpar->extradata
water	26:33	0:0	8	st
op	26:35	0:0	8	->
water	26:37	0:0	8	codecpar
op	26:45	0:0	8	->
water	26:47	0:0	8	extradata
arg	27:29	27:57	7	st->codecpar->extradata_size
water	27:29	0:0	8	st
op	27:31	0:0	8	->
water	27:33	0:0	8	codecpar
op	27:41	0:0	8	->
water	27:43	0:0	8	extradata_size
water	27:58	0:0	6	)
op	27:60	0:0	6	<
water	27:62	0:0	6	0
stmts	28:12	28:22	5	
return	28:12	28:22	6	ret
water	28:19	0:0	7	ret
water	29:4	0:0	4	}
return	30:4	30:12	2	0
water	30:11	0:0	3	0
