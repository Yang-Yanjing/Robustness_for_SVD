func	2:0	86:0	0	static int	old_codec47
params	2:22	0:0	1	
param	2:23	2:44	2	SANMVideoContext *	ctx
param	2:46	2:53	2	int	top
param	3:23	3:31	2	int	left
param	3:33	3:42	2	int	width
param	3:44	3:54	2	int	height
stmnts	0:0	85:12	1	
decl	5:4	5:48	2	int	i
water	5:9	0:0	2	,
decl	5:4	5:48	2	int	j
water	5:12	0:0	2	,
decl	5:4	5:48	2	int	seq
water	5:17	0:0	2	,
decl	5:4	5:48	2	int	compr
water	5:24	0:0	2	,
decl	5:4	5:48	2	int	new_rot
water	5:33	0:0	2	,
decl	5:4	5:48	2	int	tbl_pos
water	5:42	0:0	2	,
decl	5:4	5:48	2	int	skip
decl	6:4	6:31	2	int	stride
op	6:19	0:0	2	=
water	6:21	0:0	2	ctx
op	6:24	0:0	2	->
water	6:26	0:0	2	pitch
decl	7:4	7:64	2	uint8_t	*dst
op	7:19	0:0	2	=
water	7:21	0:0	2	(
water	7:22	0:0	2	(
water	7:23	0:0	2	uint8_t
op	7:30	0:0	2	*
water	7:31	0:0	2	)
water	7:32	0:0	2	ctx
op	7:35	0:0	2	->
water	7:37	0:0	2	frm0
water	7:41	0:0	2	)
op	7:43	0:0	2	+
water	7:45	0:0	2	left
op	7:50	0:0	2	+
water	7:52	0:0	2	top
op	7:56	0:0	2	*
water	7:58	0:0	2	stride
decl	8:4	8:40	2	uint8_t	*prev1
op	8:19	0:0	2	=
water	8:21	0:0	2	(
water	8:22	0:0	2	uint8_t
op	8:29	0:0	2	*
water	8:30	0:0	2	)
water	8:31	0:0	2	ctx
op	8:34	0:0	2	->
water	8:36	0:0	2	frm1
decl	9:4	9:40	2	uint8_t	*prev2
op	9:19	0:0	2	=
water	9:21	0:0	2	(
water	9:22	0:0	2	uint8_t
op	9:29	0:0	2	*
water	9:30	0:0	2	)
water	9:31	0:0	2	ctx
op	9:34	0:0	2	->
water	9:36	0:0	2	frm2
decl	10:4	10:25	2	uint32_t	decoded_size
water	12:4	0:0	2	tbl_pos
op	12:12	0:0	2	=
call	12:14	12:39	2	bytestream2_tell
arg	12:31	12:39	3	&ctx->gb
op	12:31	0:0	4	&
water	12:32	0:0	4	ctx
op	12:35	0:0	4	->
water	12:37	0:0	4	gb
water	12:40	0:0	2	;
water	13:4	0:0	2	seq
op	13:12	0:0	2	=
call	13:14	13:43	2	bytestream2_get_le16
arg	13:35	13:43	3	&ctx->gb
op	13:35	0:0	4	&
water	13:36	0:0	4	ctx
op	13:39	0:0	4	->
water	13:41	0:0	4	gb
water	13:44	0:0	2	;
water	14:4	0:0	2	compr
op	14:12	0:0	2	=
call	14:14	14:43	2	bytestream2_get_byte
arg	14:35	14:43	3	&ctx->gb
op	14:35	0:0	4	&
water	14:36	0:0	4	ctx
op	14:39	0:0	4	->
water	14:41	0:0	4	gb
water	14:44	0:0	2	;
water	15:4	0:0	2	new_rot
op	15:12	0:0	2	=
call	15:14	15:43	2	bytestream2_get_byte
arg	15:35	15:43	3	&ctx->gb
op	15:35	0:0	4	&
water	15:36	0:0	4	ctx
op	15:39	0:0	4	->
water	15:41	0:0	4	gb
water	15:44	0:0	2	;
water	16:4	0:0	2	skip
op	16:12	0:0	2	=
call	16:14	16:43	2	bytestream2_get_byte
arg	16:35	16:43	3	&ctx->gb
op	16:35	0:0	4	&
water	16:36	0:0	4	ctx
op	16:39	0:0	4	->
water	16:41	0:0	4	gb
water	16:44	0:0	2	;
call	17:4	17:32	2	bytestream2_skip
arg	17:21	17:29	3	&ctx->gb
op	17:21	0:0	4	&
water	17:22	0:0	4	ctx
op	17:25	0:0	4	->
water	17:27	0:0	4	gb
arg	17:31	17:32	3	9
water	17:31	0:0	4	9
water	17:33	0:0	2	;
water	18:4	0:0	2	decoded_size
op	18:17	0:0	2	=
call	18:19	18:48	2	bytestream2_get_le32
arg	18:40	18:48	3	&ctx->gb
op	18:40	0:0	4	&
water	18:41	0:0	4	ctx
op	18:44	0:0	4	->
water	18:46	0:0	4	gb
water	18:49	0:0	2	;
call	19:4	19:32	2	bytestream2_skip
arg	19:21	19:29	3	&ctx->gb
op	19:21	0:0	4	&
water	19:22	0:0	4	ctx
op	19:25	0:0	4	->
water	19:27	0:0	4	gb
arg	19:31	19:32	3	8
water	19:31	0:0	4	8
water	19:33	0:0	2	;
if	21:4	22:42	2	(skip & 1)
cond	21:8	21:15	3	skip & 1
water	21:8	0:0	4	skip
op	21:13	0:0	4	&
water	21:15	0:0	4	1
stmts	22:8	22:42	3	
call	22:8	22:41	4	bytestream2_skip
arg	22:25	22:33	5	&ctx->gb
op	22:25	0:0	6	&
water	22:26	0:0	6	ctx
op	22:29	0:0	6	->
water	22:31	0:0	6	gb
arg	22:35	22:41	5	0x8080
water	22:35	0:0	6	0
water	22:36	0:0	6	x8080
water	22:42	0:0	4	;
if	23:4	27:4	2	(! seq)
cond	23:8	23:9	3	! seq
op	23:8	0:0	4	!
water	23:9	0:0	4	seq
stmts	23:14	27:4	3	
water	23:14	0:0	4	{
water	24:8	0:0	4	ctx
op	24:11	0:0	4	->
water	24:13	0:0	4	prev_seq
op	24:22	0:0	4	=
op	24:24	0:0	4	-
water	24:25	0:0	4	1
water	24:26	0:0	4	;
call	25:8	25:45	4	memset
arg	25:15	25:20	5	prev1
water	25:15	0:0	6	prev1
arg	25:22	25:23	5	0
water	25:22	0:0	6	0
arg	25:25	25:45	5	ctx->height*stride
water	25:25	0:0	6	ctx
op	25:28	0:0	6	->
water	25:30	0:0	6	height
op	25:37	0:0	6	*
water	25:39	0:0	6	stride
water	25:46	0:0	4	;
call	26:8	26:45	4	memset
arg	26:15	26:20	5	prev2
water	26:15	0:0	6	prev2
arg	26:22	26:23	5	0
water	26:22	0:0	6	0
arg	26:25	26:45	5	ctx->height*stride
water	26:25	0:0	6	ctx
op	26:28	0:0	6	->
water	26:30	0:0	6	height
op	26:37	0:0	6	*
water	26:39	0:0	6	stride
water	26:46	0:0	4	;
water	27:4	0:0	4	}
call	28:4	28:49	2	av_dlog
arg	28:12	28:22	3	ctx->avctx
water	28:12	0:0	4	ctx
op	28:15	0:0	4	->
water	28:17	0:0	4	avctx
arg	28:24	28:42	3	"compression %d\n"
water	28:24	0:0	4	"compression %d\n"
arg	28:44	28:49	3	compr
water	28:44	0:0	4	compr
water	28:50	0:0	2	;
switch	29:4	78:4	2	(compr)
cond	29:12	29:12	3	compr
water	29:12	0:0	4	compr
stmts	29:19	78:4	3	
water	29:19	0:0	4	{
label	30:4	30:10	4	case 0 :
if	31:8	32:38	4	(bytestream2_get_bytes_left (& ctx -> gb ) < width * height)
cond	31:12	31:59	5	bytestream2_get_bytes_left (& ctx -> gb ) < width * height
call	31:12	31:47	6	bytestream2_get_bytes_left
arg	31:39	31:47	7	&ctx->gb
op	31:39	0:0	8	&
water	31:40	0:0	8	ctx
op	31:43	0:0	8	->
water	31:45	0:0	8	gb
op	31:49	0:0	6	<
water	31:51	0:0	6	width
op	31:57	0:0	6	*
water	31:59	0:0	6	height
stmts	32:12	32:38	5	
return	32:12	32:38	6	AVERROR_INVALIDDATA
water	32:19	0:0	7	AVERROR_INVALIDDATA
for	33:8	37:8	4	(j = 0 ;j < height;j ++)
forinit	33:13	33:18	5	j = 0 ;
water	33:13	0:0	6	j
op	33:15	0:0	6	=
water	33:17	0:0	6	0
water	33:18	0:0	6	;
cond	33:20	33:24	5	j < height
water	33:20	0:0	6	j
op	33:22	0:0	6	<
water	33:24	0:0	6	height
forexpr	33:32	33:33	5	j ++
water	33:32	0:0	6	j
op	33:33	0:0	6	++
stmts	33:37	37:8	5	
water	33:37	0:0	6	{
for	34:12	35:61	6	(i = 0 ;i < width;i ++)
forinit	34:17	34:22	7	i = 0 ;
water	34:17	0:0	8	i
op	34:19	0:0	8	=
water	34:21	0:0	8	0
water	34:22	0:0	8	;
cond	34:24	34:28	7	i < width
water	34:24	0:0	8	i
op	34:26	0:0	8	<
water	34:28	0:0	8	width
forexpr	34:35	34:36	7	i ++
water	34:35	0:0	8	i
op	34:36	0:0	8	++
stmts	35:16	35:61	7	
call	35:16	35:60	8	bytestream2_get_bufferu
arg	35:40	35:48	9	&ctx->gb
op	35:40	0:0	10	&
water	35:41	0:0	10	ctx
op	35:44	0:0	10	->
water	35:46	0:0	10	gb
arg	35:50	35:53	9	dst
water	35:50	0:0	10	dst
arg	35:55	35:60	9	width
water	35:55	0:0	10	width
water	35:61	0:0	8	;
water	36:12	0:0	6	dst
op	36:16	0:0	6	+=
water	36:19	0:0	6	stride
water	36:25	0:0	6	;
water	37:8	0:0	6	}
break	38:8	38:13	4	
label	39:4	39:10	4	case 1 :
if	40:8	41:38	4	(bytestream2_get_bytes_left (& ctx -> gb ) < ( ( width + 1 ) >> 1 ) * ( ( height + 1 ) >> 1 ))
cond	40:12	40:90	5	bytestream2_get_bytes_left (& ctx -> gb ) < ( ( width + 1 ) >> 1 ) * ( ( height + 1 ) >> 1 )
call	40:12	40:47	6	bytestream2_get_bytes_left
arg	40:39	40:47	7	&ctx->gb
op	40:39	0:0	8	&
water	40:40	0:0	8	ctx
op	40:43	0:0	8	->
water	40:45	0:0	8	gb
op	40:49	0:0	6	<
water	40:51	0:0	6	(
water	40:52	0:0	6	(
water	40:53	0:0	6	width
op	40:59	0:0	6	+
water	40:61	0:0	6	1
water	40:62	0:0	6	)
op	40:64	0:0	6	>>
water	40:67	0:0	6	1
water	40:68	0:0	6	)
op	40:70	0:0	6	*
water	40:72	0:0	6	(
water	40:73	0:0	6	(
water	40:74	0:0	6	height
op	40:81	0:0	6	+
water	40:83	0:0	6	1
water	40:84	0:0	6	)
op	40:86	0:0	6	>>
water	40:89	0:0	6	1
water	40:90	0:0	6	)
stmts	41:12	41:38	5	
return	41:12	41:38	6	AVERROR_INVALIDDATA
water	41:19	0:0	7	AVERROR_INVALIDDATA
for	42:8	48:8	4	(j = 0 ;j < height;j += 2)
forinit	42:13	42:18	5	j = 0 ;
water	42:13	0:0	6	j
op	42:15	0:0	6	=
water	42:17	0:0	6	0
water	42:18	0:0	6	;
cond	42:20	42:24	5	j < height
water	42:20	0:0	6	j
op	42:22	0:0	6	<
water	42:24	0:0	6	height
forexpr	42:32	42:37	5	j += 2
water	42:32	0:0	6	j
op	42:34	0:0	6	+=
water	42:37	0:0	6	2
stmts	42:40	48:8	5	
water	42:40	0:0	6	{
for	43:12	46:12	6	(i = 0 ;i < width;i += 2)
forinit	43:17	43:22	7	i = 0 ;
water	43:17	0:0	8	i
op	43:19	0:0	8	=
water	43:21	0:0	8	0
water	43:22	0:0	8	;
cond	43:24	43:28	7	i < width
water	43:24	0:0	8	i
op	43:26	0:0	8	<
water	43:28	0:0	8	width
forexpr	43:35	43:40	7	i += 2
water	43:35	0:0	8	i
op	43:37	0:0	8	+=
water	43:40	0:0	8	2
stmts	43:43	46:12	7	
water	43:43	0:0	8	{
water	44:16	0:0	8	dst
op	44:19	0:0	8	[
water	44:20	0:0	8	i
op	44:21	0:0	8	]
op	44:23	0:0	8	=
water	44:25	0:0	8	dst
op	44:28	0:0	8	[
water	44:29	0:0	8	i
op	44:31	0:0	8	+
water	44:33	0:0	8	1
op	44:34	0:0	8	]
op	44:36	0:0	8	=
water	45:16	0:0	8	dst
op	45:19	0:0	8	[
water	45:20	0:0	8	stride
op	45:27	0:0	8	+
water	45:29	0:0	8	i
op	45:30	0:0	8	]
op	45:32	0:0	8	=
water	45:34	0:0	8	dst
op	45:37	0:0	8	[
water	45:38	0:0	8	stride
op	45:45	0:0	8	+
water	45:47	0:0	8	i
op	45:49	0:0	8	+
water	45:51	0:0	8	1
op	45:52	0:0	8	]
op	45:54	0:0	8	=
call	45:56	45:86	8	bytestream2_get_byteu
arg	45:78	45:86	9	&ctx->gb
op	45:78	0:0	10	&
water	45:79	0:0	10	ctx
op	45:82	0:0	10	->
water	45:84	0:0	10	gb
water	45:87	0:0	8	;
water	46:12	0:0	8	}
water	47:12	0:0	6	dst
op	47:16	0:0	6	+=
water	47:19	0:0	6	stride
op	47:26	0:0	6	*
water	47:28	0:0	6	2
water	47:29	0:0	6	;
water	48:8	0:0	6	}
break	49:8	49:13	4	
label	50:4	50:10	4	case 2 :
if	51:8	62:8	4	(seq == ctx -> prev_seq + 1)
cond	51:12	51:35	5	seq == ctx -> prev_seq + 1
water	51:12	0:0	6	seq
op	51:16	0:0	6	==
water	51:19	0:0	6	ctx
op	51:22	0:0	6	->
water	51:24	0:0	6	prev_seq
op	51:33	0:0	6	+
water	51:35	0:0	6	1
stmts	51:38	62:8	5	
water	51:38	0:0	6	{
for	52:12	61:12	6	(j = 0 ;j < height;j += 8)
forinit	52:17	52:22	7	j = 0 ;
water	52:17	0:0	8	j
op	52:19	0:0	8	=
water	52:21	0:0	8	0
water	52:22	0:0	8	;
cond	52:24	52:28	7	j < height
water	52:24	0:0	8	j
op	52:26	0:0	8	<
water	52:28	0:0	8	height
forexpr	52:36	52:41	7	j += 8
water	52:36	0:0	8	j
op	52:38	0:0	8	+=
water	52:41	0:0	8	8
stmts	52:44	61:12	7	
water	52:44	0:0	8	{
for	53:16	57:16	8	(i = 0 ;i < width;i += 8)
forinit	53:21	53:26	9	i = 0 ;
water	53:21	0:0	10	i
op	53:23	0:0	10	=
water	53:25	0:0	10	0
water	53:26	0:0	10	;
cond	53:28	53:32	9	i < width
water	53:28	0:0	10	i
op	53:30	0:0	10	<
water	53:32	0:0	10	width
forexpr	53:39	53:44	9	i += 8
water	53:39	0:0	10	i
op	53:41	0:0	10	+=
water	53:44	0:0	10	8
stmts	53:47	57:16	9	
water	53:47	0:0	10	{
if	54:20	56:50	10	(process_block (ctx ,dst + i ,prev1 + i ,prev2 + i ,stride ,tbl_pos + 8 ,8 ))
cond	54:24	55:52	11	process_block (ctx ,dst + i ,prev1 + i ,prev2 + i ,stride ,tbl_pos + 8 ,8 )
call	54:24	55:52	12	process_block
arg	54:38	54:41	13	ctx
water	54:38	0:0	14	ctx
arg	54:43	54:50	13	dst+i
water	54:43	0:0	14	dst
op	54:47	0:0	14	+
water	54:49	0:0	14	i
arg	54:52	54:61	13	prev1+i
water	54:52	0:0	14	prev1
op	54:58	0:0	14	+
water	54:60	0:0	14	i
arg	54:63	54:72	13	prev2+i
water	54:63	0:0	14	prev2
op	54:69	0:0	14	+
water	54:71	0:0	14	i
arg	54:74	54:80	13	stride
water	54:74	0:0	14	stride
arg	55:38	55:49	13	tbl_pos+8
water	55:38	0:0	14	tbl_pos
op	55:46	0:0	14	+
water	55:48	0:0	14	8
arg	55:51	55:52	13	8
water	55:51	0:0	14	8
stmts	56:24	56:50	11	
return	56:24	56:50	12	AVERROR_INVALIDDATA
water	56:31	0:0	13	AVERROR_INVALIDDATA
water	57:16	0:0	10	}
water	58:16	0:0	8	dst
op	58:22	0:0	8	+=
water	58:25	0:0	8	stride
op	58:32	0:0	8	*
water	58:34	0:0	8	8
water	58:35	0:0	8	;
water	59:16	0:0	8	prev1
op	59:22	0:0	8	+=
water	59:25	0:0	8	stride
op	59:32	0:0	8	*
water	59:34	0:0	8	8
water	59:35	0:0	8	;
water	60:16	0:0	8	prev2
op	60:22	0:0	8	+=
water	60:25	0:0	8	stride
op	60:32	0:0	8	*
water	60:34	0:0	8	8
water	60:35	0:0	8	;
water	61:12	0:0	8	}
water	62:8	0:0	6	}
break	63:8	63:13	4	
label	64:4	64:10	4	case 3 :
call	65:8	65:61	4	memcpy
arg	65:15	65:24	5	ctx->frm0
water	65:15	0:0	6	ctx
op	65:18	0:0	6	->
water	65:20	0:0	6	frm0
arg	65:26	65:35	5	ctx->frm2
water	65:26	0:0	6	ctx
op	65:29	0:0	6	->
water	65:31	0:0	6	frm2
arg	65:37	65:61	5	ctx->pitch*ctx->height
water	65:37	0:0	6	ctx
op	65:40	0:0	6	->
water	65:42	0:0	6	pitch
op	65:48	0:0	6	*
water	65:50	0:0	6	ctx
op	65:53	0:0	6	->
water	65:55	0:0	6	height
water	65:62	0:0	4	;
break	66:8	66:13	4	
label	67:4	67:10	4	case 4 :
call	68:8	68:61	4	memcpy
arg	68:15	68:24	5	ctx->frm0
water	68:15	0:0	6	ctx
op	68:18	0:0	6	->
water	68:20	0:0	6	frm0
arg	68:26	68:35	5	ctx->frm1
water	68:26	0:0	6	ctx
op	68:29	0:0	6	->
water	68:31	0:0	6	frm1
arg	68:37	68:61	5	ctx->pitch*ctx->height
water	68:37	0:0	6	ctx
op	68:40	0:0	6	->
water	68:42	0:0	6	pitch
op	68:48	0:0	6	*
water	68:50	0:0	6	ctx
op	68:53	0:0	6	->
water	68:55	0:0	6	height
water	68:62	0:0	4	;
break	69:8	69:13	4	
label	70:4	70:10	4	case 5 :
if	71:8	72:38	4	(rle_decode (ctx ,dst ,decoded_size ))
cond	71:12	71:45	5	rle_decode (ctx ,dst ,decoded_size )
call	71:12	71:45	6	rle_decode
arg	71:23	71:26	7	ctx
water	71:23	0:0	8	ctx
arg	71:28	71:31	7	dst
water	71:28	0:0	8	dst
arg	71:33	71:45	7	decoded_size
water	71:33	0:0	8	decoded_size
stmts	72:12	72:38	5	
return	72:12	72:38	6	AVERROR_INVALIDDATA
water	72:19	0:0	7	AVERROR_INVALIDDATA
break	73:8	73:13	4	
label	74:4	74:11	4	default :
call	75:8	76:68	4	av_log
arg	75:15	75:25	5	ctx->avctx
water	75:15	0:0	6	ctx
op	75:18	0:0	6	->
water	75:20	0:0	6	avctx
arg	75:27	75:39	5	AV_LOG_ERROR
water	75:27	0:0	6	AV_LOG_ERROR
arg	76:15	76:61	5	"subcodec 47 compression %d not implemented\n"
water	76:15	0:0	6	"subcodec 47 compression %d not implemented\n"
arg	76:63	76:68	5	compr
water	76:63	0:0	6	compr
water	76:69	0:0	4	;
return	77:8	77:35	4	AVERROR_PATCHWELCOME
water	77:15	0:0	5	AVERROR_PATCHWELCOME
water	78:4	0:0	4	}
if	79:4	80:34	2	(seq == ctx -> prev_seq + 1)
cond	79:8	79:31	3	seq == ctx -> prev_seq + 1
water	79:8	0:0	4	seq
op	79:12	0:0	4	==
water	79:15	0:0	4	ctx
op	79:18	0:0	4	->
water	79:20	0:0	4	prev_seq
op	79:29	0:0	4	+
water	79:31	0:0	4	1
stmts	80:8	80:34	3	
water	80:8	0:0	4	ctx
op	80:11	0:0	4	->
water	80:13	0:0	4	rotate_code
op	80:25	0:0	4	=
water	80:27	0:0	4	new_rot
water	80:34	0:0	4	;
else	81:4	82:28	2
stmts	82:8	82:28	3	
water	82:8	0:0	4	ctx
op	82:11	0:0	4	->
water	82:13	0:0	4	rotate_code
op	82:25	0:0	4	=
water	82:27	0:0	4	0
water	82:28	0:0	4	;
water	83:4	0:0	2	ctx
op	83:7	0:0	2	->
water	83:9	0:0	2	prev_seq
op	83:18	0:0	2	=
water	83:20	0:0	2	seq
water	83:23	0:0	2	;
return	85:4	85:12	2	0
water	85:11	0:0	3	0
