func	2:0	138:0	0	static int	mv_read_header
params	2:25	0:0	1	
param	2:26	2:48	2	AVFormatContext *	avctx
stmnts	0:0	137:12	1	
decl	4:4	4:36	2	MvContext	*mv
op	4:18	0:0	2	=
water	4:20	0:0	2	avctx
op	4:25	0:0	2	->
water	4:27	0:0	2	priv_data
decl	5:4	5:31	2	AVIOContext	*pb
op	5:20	0:0	2	=
water	5:22	0:0	2	avctx
op	5:27	0:0	2	->
water	5:29	0:0	2	pb
decl	6:4	6:37	2	AVStream	*ast
op	6:18	0:0	2	=
water	6:20	0:0	2	NULL
water	6:24	0:0	2	,
decl	6:4	6:37	2	AVStream	*vst
op	6:31	0:0	2	=
water	6:33	0:0	2	NULL
decl	7:4	7:18	2	int	version
water	7:15	0:0	2	,
decl	7:4	7:18	2	int	i
decl	8:4	8:11	2	int	ret
call	10:4	10:19	2	avio_skip
arg	10:14	10:16	3	pb
water	10:14	0:0	4	pb
arg	10:18	10:19	3	4
water	10:18	0:0	4	4
water	10:20	0:0	2	;
water	12:4	0:0	2	version
op	12:12	0:0	2	=
call	12:14	12:26	2	avio_rb16
arg	12:24	12:26	3	pb
water	12:24	0:0	4	pb
water	12:27	0:0	2	;
if	13:4	82:4	2	(version == 2)
cond	13:8	13:19	3	version == 2
water	13:8	0:0	4	version
op	13:16	0:0	4	==
water	13:19	0:0	4	2
stmts	13:22	82:4	3	
water	13:22	0:0	4	{
decl	14:8	14:26	4	uint64_t	timestamp
decl	15:8	15:13	4	int	v
call	16:8	16:24	4	avio_skip
arg	16:18	16:20	5	pb
water	16:18	0:0	6	pb
arg	16:22	16:24	5	22
water	16:22	0:0	6	22
water	16:25	0:0	4	;
water	20:8	0:0	4	ast
op	20:12	0:0	4	=
call	20:14	20:45	4	avformat_new_stream
arg	20:34	20:39	5	avctx
water	20:34	0:0	6	avctx
arg	20:41	20:45	5	NULL
water	20:41	0:0	6	NULL
water	20:46	0:0	4	;
if	21:8	22:34	4	(! ast)
cond	21:12	21:13	5	! ast
op	21:12	0:0	6	!
water	21:13	0:0	6	ast
stmts	22:12	22:34	5	
return	22:12	22:34	6	AVERROR(ENOMEM)
call	22:19	22:33	7	AVERROR
arg	22:27	22:33	8	ENOMEM
water	22:27	0:0	9	ENOMEM
water	24:8	0:0	4	vst
op	24:12	0:0	4	=
call	24:14	24:45	4	avformat_new_stream
arg	24:34	24:39	5	avctx
water	24:34	0:0	6	avctx
arg	24:41	24:45	5	NULL
water	24:41	0:0	6	NULL
water	24:46	0:0	4	;
if	25:8	26:34	4	(! vst)
cond	25:12	25:13	5	! vst
op	25:12	0:0	6	!
water	25:13	0:0	6	vst
stmts	26:12	26:34	5	
return	26:12	26:34	6	AVERROR(ENOMEM)
call	26:19	26:33	7	AVERROR
arg	26:27	26:33	8	ENOMEM
water	26:27	0:0	9	ENOMEM
call	27:8	27:42	4	avpriv_set_pts_info
arg	27:28	27:31	5	vst
water	27:28	0:0	6	vst
arg	27:33	27:35	5	64
water	27:33	0:0	6	64
arg	27:37	27:38	5	1
water	27:37	0:0	6	1
arg	27:40	27:42	5	15
water	27:40	0:0	6	15
water	27:43	0:0	4	;
water	28:8	0:0	4	vst
op	28:11	0:0	4	->
water	28:13	0:0	4	codecpar
op	28:21	0:0	4	->
water	28:23	0:0	4	codec_type
op	28:34	0:0	4	=
water	28:36	0:0	4	AVMEDIA_TYPE_VIDEO
water	28:54	0:0	4	;
water	29:8	0:0	4	vst
op	29:11	0:0	4	->
water	29:13	0:0	4	avg_frame_rate
op	29:31	0:0	4	=
call	29:33	29:56	4	av_inv_q
arg	29:42	29:56	5	vst->time_base
water	29:42	0:0	6	vst
op	29:45	0:0	6	->
water	29:47	0:0	6	time_base
water	29:57	0:0	4	;
water	30:8	0:0	4	vst
op	30:11	0:0	4	->
water	30:13	0:0	4	nb_frames
op	30:31	0:0	4	=
call	30:33	30:45	4	avio_rb32
arg	30:43	30:45	5	pb
water	30:43	0:0	6	pb
water	30:46	0:0	4	;
water	31:8	0:0	4	v
op	31:10	0:0	4	=
call	31:12	31:24	4	avio_rb32
arg	31:22	31:24	5	pb
water	31:22	0:0	6	pb
water	31:25	0:0	4	;
switch	32:8	43:8	4	(v)
cond	32:16	32:16	5	v
water	32:16	0:0	6	v
stmts	32:19	43:8	5	
water	32:19	0:0	6	{
label	33:8	33:14	6	case 1 :
water	34:12	0:0	6	vst
op	34:15	0:0	6	->
water	34:17	0:0	6	codecpar
op	34:25	0:0	6	->
water	34:27	0:0	6	codec_id
op	34:36	0:0	6	=
water	34:38	0:0	6	AV_CODEC_ID_MVC1
water	34:54	0:0	6	;
break	35:12	35:17	6	
label	36:8	36:14	6	case 2 :
water	37:12	0:0	6	vst
op	37:15	0:0	6	->
water	37:17	0:0	6	codecpar
op	37:25	0:0	6	->
water	37:27	0:0	6	format
op	37:34	0:0	6	=
water	37:36	0:0	6	AV_PIX_FMT_ARGB
water	37:51	0:0	6	;
water	38:12	0:0	6	vst
op	38:15	0:0	6	->
water	38:17	0:0	6	codecpar
op	38:25	0:0	6	->
water	38:27	0:0	6	codec_id
op	38:36	0:0	6	=
water	38:38	0:0	6	AV_CODEC_ID_RAWVIDEO
water	38:58	0:0	6	;
break	39:12	39:17	6	
label	40:8	40:15	6	default :
call	41:12	41:66	6	avpriv_request_sample
arg	41:34	41:39	7	avctx
water	41:34	0:0	8	avctx
arg	41:41	41:63	7	"Video compression %i"
water	41:41	0:0	8	"Video compression %i"
arg	41:65	41:66	7	v
water	41:65	0:0	8	v
water	41:67	0:0	6	;
break	42:12	42:17	6	
water	43:8	0:0	6	}
water	44:8	0:0	4	vst
op	44:11	0:0	4	->
water	44:13	0:0	4	codecpar
op	44:21	0:0	4	->
water	44:23	0:0	4	codec_tag
op	44:33	0:0	4	=
water	44:35	0:0	4	0
water	44:36	0:0	4	;
water	45:8	0:0	4	vst
op	45:11	0:0	4	->
water	45:13	0:0	4	codecpar
op	45:21	0:0	4	->
water	45:23	0:0	4	width
op	45:33	0:0	4	=
call	45:35	45:47	4	avio_rb32
arg	45:45	45:47	5	pb
water	45:45	0:0	6	pb
water	45:48	0:0	4	;
water	46:8	0:0	4	vst
op	46:11	0:0	4	->
water	46:13	0:0	4	codecpar
op	46:21	0:0	4	->
water	46:23	0:0	4	height
op	46:33	0:0	4	=
call	46:35	46:47	4	avio_rb32
arg	46:45	46:47	5	pb
water	46:45	0:0	6	pb
water	46:48	0:0	4	;
call	47:8	47:24	4	avio_skip
arg	47:18	47:20	5	pb
water	47:18	0:0	6	pb
arg	47:22	47:24	5	12
water	47:22	0:0	6	12
water	47:25	0:0	4	;
water	49:8	0:0	4	ast
op	49:11	0:0	4	->
water	49:13	0:0	4	codecpar
op	49:21	0:0	4	->
water	49:23	0:0	4	codec_type
op	49:35	0:0	4	=
water	49:37	0:0	4	AVMEDIA_TYPE_AUDIO
water	49:55	0:0	4	;
water	50:8	0:0	4	ast
op	50:11	0:0	4	->
water	50:13	0:0	4	nb_frames
op	50:32	0:0	4	=
water	50:34	0:0	4	vst
op	50:37	0:0	4	->
water	50:39	0:0	4	nb_frames
water	50:48	0:0	4	;
water	51:8	0:0	4	ast
op	51:11	0:0	4	->
water	51:13	0:0	4	codecpar
op	51:21	0:0	4	->
water	51:23	0:0	4	sample_rate
op	51:35	0:0	4	=
call	51:37	51:49	4	avio_rb32
arg	51:47	51:49	5	pb
water	51:47	0:0	6	pb
water	51:50	0:0	4	;
if	52:8	55:8	4	(ast -> codecpar -> sample_rate <= 0)
cond	52:12	52:42	5	ast -> codecpar -> sample_rate <= 0
water	52:12	0:0	6	ast
op	52:15	0:0	6	->
water	52:17	0:0	6	codecpar
op	52:25	0:0	6	->
water	52:27	0:0	6	sample_rate
op	52:39	0:0	6	<=
water	52:42	0:0	6	0
stmts	52:45	55:8	5	
water	52:45	0:0	6	{
call	53:12	53:94	6	av_log
arg	53:19	53:24	7	avctx
water	53:19	0:0	8	avctx
arg	53:26	53:38	7	AV_LOG_ERROR
water	53:26	0:0	8	AV_LOG_ERROR
arg	53:40	53:66	7	"Invalid sample rate %d\n"
water	53:40	0:0	8	"Invalid sample rate %d\n"
arg	53:68	53:94	7	ast->codecpar->sample_rate
water	53:68	0:0	8	ast
op	53:71	0:0	8	->
water	53:73	0:0	8	codecpar
op	53:81	0:0	8	->
water	53:83	0:0	8	sample_rate
water	53:95	0:0	6	;
return	54:12	54:38	6	AVERROR_INVALIDDATA
water	54:19	0:0	7	AVERROR_INVALIDDATA
water	55:8	0:0	6	}
call	56:8	56:66	4	avpriv_set_pts_info
arg	56:28	56:31	5	ast
water	56:28	0:0	6	ast
arg	56:33	56:35	5	33
water	56:33	0:0	6	33
arg	56:37	56:38	5	1
water	56:37	0:0	6	1
arg	56:40	56:66	5	ast->codecpar->sample_rate
water	56:40	0:0	6	ast
op	56:43	0:0	6	->
water	56:45	0:0	6	codecpar
op	56:53	0:0	6	->
water	56:55	0:0	6	sample_rate
water	56:67	0:0	4	;
if	57:8	58:38	4	(set_channels (avctx ,ast ,avio_rb32 (pb ) ) < 0)
cond	57:12	57:54	5	set_channels (avctx ,ast ,avio_rb32 (pb ) ) < 0
call	57:12	57:50	6	set_channels
arg	57:25	57:30	7	avctx
water	57:25	0:0	8	avctx
arg	57:32	57:35	7	ast
water	57:32	0:0	8	ast
arg	57:37	57:50	7	avio_rb32(pb)
call	57:37	57:49	8	avio_rb32
arg	57:47	57:49	9	pb
water	57:47	0:0	10	pb
op	57:52	0:0	6	<
water	57:54	0:0	6	0
stmts	58:12	58:38	5	
return	58:12	58:38	6	AVERROR_INVALIDDATA
water	58:19	0:0	7	AVERROR_INVALIDDATA
water	60:8	0:0	4	v
op	60:10	0:0	4	=
call	60:12	60:24	4	avio_rb32
arg	60:22	60:24	5	pb
water	60:22	0:0	6	pb
water	60:25	0:0	4	;
if	61:8	63:8	4	(v == AUDIO_FORMAT_SIGNED)
cond	61:12	61:17	5	v == AUDIO_FORMAT_SIGNED
water	61:12	0:0	6	v
op	61:14	0:0	6	==
water	61:17	0:0	6	AUDIO_FORMAT_SIGNED
stmts	61:38	63:8	5	
water	61:38	0:0	6	{
water	62:12	0:0	6	ast
op	62:15	0:0	6	->
water	62:17	0:0	6	codecpar
op	62:25	0:0	6	->
water	62:27	0:0	6	codec_id
op	62:36	0:0	6	=
water	62:38	0:0	6	AV_CODEC_ID_PCM_S16BE
water	62:59	0:0	6	;
water	63:8	0:0	6	}
else	63:10	65:8	4
stmts	63:15	65:8	5	
water	63:15	0:0	6	{
call	64:12	64:75	6	avpriv_request_sample
arg	64:34	64:39	7	avctx
water	64:34	0:0	8	avctx
arg	64:41	64:72	7	"Audio compression (format %i)"
water	64:41	0:0	8	"Audio compression (format %i)"
arg	64:74	64:75	7	v
water	64:74	0:0	8	v
water	64:76	0:0	6	;
water	65:8	0:0	6	}
call	67:8	67:24	4	avio_skip
arg	67:18	67:20	5	pb
water	67:18	0:0	6	pb
arg	67:22	67:24	5	12
water	67:22	0:0	6	12
water	67:25	0:0	4	;
call	68:8	68:46	4	var_read_metadata
arg	68:26	68:31	5	avctx
water	68:26	0:0	6	avctx
arg	68:33	68:40	5	"title"
water	68:33	0:0	6	"title"
arg	68:42	68:46	5	0x80
water	68:42	0:0	6	0
water	68:43	0:0	6	x80
water	68:47	0:0	4	;
call	69:8	69:49	4	var_read_metadata
arg	69:26	69:31	5	avctx
water	69:26	0:0	6	avctx
arg	69:33	69:42	5	"comment"
water	69:33	0:0	6	"comment"
arg	69:44	69:49	5	0x100
water	69:44	0:0	6	0
water	69:45	0:0	6	x100
water	69:50	0:0	4	;
call	70:8	70:26	4	avio_skip
arg	70:18	70:20	5	pb
water	70:18	0:0	6	pb
arg	70:22	70:26	5	0x80
water	70:22	0:0	6	0
water	70:23	0:0	6	x80
water	70:27	0:0	4	;
water	72:8	0:0	4	timestamp
op	72:18	0:0	4	=
water	72:20	0:0	4	0
water	72:21	0:0	4	;
for	73:8	81:8	4	(i = 0 ;i < vst -> nb_frames;i ++)
forinit	73:13	73:18	5	i = 0 ;
water	73:13	0:0	6	i
op	73:15	0:0	6	=
water	73:17	0:0	6	0
water	73:18	0:0	6	;
cond	73:20	73:29	5	i < vst -> nb_frames
water	73:20	0:0	6	i
op	73:22	0:0	6	<
water	73:24	0:0	6	vst
op	73:27	0:0	6	->
water	73:29	0:0	6	nb_frames
forexpr	73:40	73:41	5	i ++
water	73:40	0:0	6	i
op	73:41	0:0	6	++
stmts	73:45	81:8	5	
water	73:45	0:0	6	{
decl	74:12	74:42	6	uint32_t	pos
op	74:27	0:0	6	=
call	74:29	74:41	7	avio_rb32
arg	74:39	74:41	8	pb
water	74:39	0:0	9	pb
decl	75:12	75:42	6	uint32_t	asize
op	75:27	0:0	6	=
call	75:29	75:41	7	avio_rb32
arg	75:39	75:41	8	pb
water	75:39	0:0	9	pb
decl	76:12	76:42	6	uint32_t	vsize
op	76:27	0:0	6	=
call	76:29	76:41	7	avio_rb32
arg	76:39	76:41	8	pb
water	76:39	0:0	9	pb
call	77:12	77:27	6	avio_skip
arg	77:22	77:24	7	pb
water	77:22	0:0	8	pb
arg	77:26	77:27	7	8
water	77:26	0:0	8	8
water	77:28	0:0	6	;
call	78:12	78:78	6	av_add_index_entry
arg	78:31	78:34	7	ast
water	78:31	0:0	8	ast
arg	78:36	78:39	7	pos
water	78:36	0:0	8	pos
arg	78:41	78:50	7	timestamp
water	78:41	0:0	8	timestamp
arg	78:52	78:57	7	asize
water	78:52	0:0	8	asize
arg	78:59	78:60	7	0
water	78:59	0:0	8	0
arg	78:62	78:78	7	AVINDEX_KEYFRAME
water	78:62	0:0	8	AVINDEX_KEYFRAME
water	78:79	0:0	6	;
call	79:12	79:78	6	av_add_index_entry
arg	79:31	79:34	7	vst
water	79:31	0:0	8	vst
arg	79:36	79:47	7	pos+asize
water	79:36	0:0	8	pos
op	79:40	0:0	8	+
water	79:42	0:0	8	asize
arg	79:49	79:50	7	i
water	79:49	0:0	8	i
arg	79:52	79:57	7	vsize
water	79:52	0:0	8	vsize
arg	79:59	79:60	7	0
water	79:59	0:0	8	0
arg	79:62	79:78	7	AVINDEX_KEYFRAME
water	79:62	0:0	8	AVINDEX_KEYFRAME
water	79:79	0:0	6	;
water	80:12	0:0	6	timestamp
op	80:22	0:0	6	+=
water	80:25	0:0	6	asize
op	80:31	0:0	6	/
water	80:33	0:0	6	(
water	80:34	0:0	6	ast
op	80:37	0:0	6	->
water	80:39	0:0	6	codecpar
op	80:47	0:0	6	->
water	80:49	0:0	6	channels
op	80:58	0:0	6	*
water	80:60	0:0	6	2
water	80:61	0:0	6	)
water	80:62	0:0	6	;
water	81:8	0:0	6	}
water	82:4	0:0	4	}
else	82:6	132:4	2
stmts	82:11	132:4	3	
if	82:11	132:4	4	(! version &&avio_rb16 (pb ) == 3)
cond	82:15	82:44	5	! version &&avio_rb16 (pb ) == 3
op	82:15	0:0	6	!
water	82:16	0:0	6	version
op	82:24	0:0	6	&&
call	82:27	82:39	6	avio_rb16
arg	82:37	82:39	7	pb
water	82:37	0:0	8	pb
op	82:41	0:0	6	==
water	82:44	0:0	6	3
stmts	82:47	132:4	5	
water	82:47	0:0	6	{
call	83:8	83:23	6	avio_skip
arg	83:18	83:20	7	pb
water	83:18	0:0	8	pb
arg	83:22	83:23	7	4
water	83:22	0:0	8	4
water	83:24	0:0	6	;
if	85:8	86:22	6	(( ret =read_table (avctx ,NULL ,parse_global_var ) ) < 0)
cond	85:12	85:64	7	( ret =read_table (avctx ,NULL ,parse_global_var ) ) < 0
water	85:12	0:0	8	(
water	85:13	0:0	8	ret
op	85:17	0:0	8	=
call	85:19	85:59	8	read_table
arg	85:30	85:35	9	avctx
water	85:30	0:0	10	avctx
arg	85:37	85:41	9	NULL
water	85:37	0:0	10	NULL
arg	85:43	85:59	9	parse_global_var
water	85:43	0:0	10	parse_global_var
water	85:60	0:0	8	)
op	85:62	0:0	8	<
water	85:64	0:0	8	0
stmts	86:12	86:22	7	
return	86:12	86:22	8	ret
water	86:19	0:0	9	ret
if	88:8	91:8	6	(mv -> nb_audio_tracks > 1)
cond	88:12	88:34	7	mv -> nb_audio_tracks > 1
water	88:12	0:0	8	mv
op	88:14	0:0	8	->
water	88:16	0:0	8	nb_audio_tracks
op	88:32	0:0	8	>
water	88:34	0:0	8	1
stmts	88:37	91:8	7	
water	88:37	0:0	8	{
call	89:12	89:73	8	avpriv_request_sample
arg	89:34	89:39	9	avctx
water	89:34	0:0	10	avctx
arg	89:41	89:73	9	"Multiple audio streams support"
water	89:41	0:0	10	"Multiple audio streams support"
water	89:74	0:0	8	;
return	90:12	90:39	8	AVERROR_PATCHWELCOME
water	90:19	0:0	9	AVERROR_PATCHWELCOME
water	91:8	0:0	8	}
else	91:10	113:8	6
stmts	91:15	113:8	7	
if	91:15	113:8	8	(mv -> nb_audio_tracks)
cond	91:19	91:23	9	mv -> nb_audio_tracks
water	91:19	0:0	10	mv
op	91:21	0:0	10	->
water	91:23	0:0	10	nb_audio_tracks
stmts	91:40	113:8	9	
water	91:40	0:0	10	{
water	92:12	0:0	10	ast
op	92:16	0:0	10	=
call	92:18	92:49	10	avformat_new_stream
arg	92:38	92:43	11	avctx
water	92:38	0:0	12	avctx
arg	92:45	92:49	11	NULL
water	92:45	0:0	12	NULL
water	92:50	0:0	10	;
if	93:12	94:38	10	(! ast)
cond	93:16	93:17	11	! ast
op	93:16	0:0	12	!
water	93:17	0:0	12	ast
stmts	94:16	94:38	11	
return	94:16	94:38	12	AVERROR(ENOMEM)
call	94:23	94:37	13	AVERROR
arg	94:31	94:37	14	ENOMEM
water	94:31	0:0	15	ENOMEM
water	95:12	0:0	10	ast
op	95:15	0:0	10	->
water	95:17	0:0	10	codecpar
op	95:25	0:0	10	->
water	95:27	0:0	10	codec_type
op	95:38	0:0	10	=
water	95:40	0:0	10	AVMEDIA_TYPE_AUDIO
water	95:58	0:0	10	;
if	96:12	97:26	10	((read_table (avctx ,ast ,parse_audio_var ) ) < 0)
cond	96:16	96:60	11	(read_table (avctx ,ast ,parse_audio_var ) ) < 0
water	96:16	0:0	12	(
call	96:17	96:55	12	read_table
arg	96:28	96:33	13	avctx
water	96:28	0:0	14	avctx
arg	96:35	96:38	13	ast
water	96:35	0:0	14	ast
arg	96:40	96:55	13	parse_audio_var
water	96:40	0:0	14	parse_audio_var
water	96:56	0:0	12	)
op	96:58	0:0	12	<
water	96:60	0:0	12	0
stmts	97:16	97:26	11	
return	97:16	97:26	12	ret
water	97:23	0:0	13	ret
if	98:12	102:12	10	(mv -> acompression == 100 && mv -> aformat == AUDIO_FORMAT_SIGNED && ast -> codecpar -> bits_per_coded_sample == 16)
cond	98:16	100:56	11	mv -> acompression == 100 && mv -> aformat == AUDIO_FORMAT_SIGNED && ast -> codecpar -> bits_per_coded_sample == 16
water	98:16	0:0	12	mv
op	98:18	0:0	12	->
water	98:20	0:0	12	acompression
op	98:33	0:0	12	==
water	98:36	0:0	12	100
op	98:40	0:0	12	&&
water	99:16	0:0	12	mv
op	99:18	0:0	12	->
water	99:20	0:0	12	aformat
op	99:28	0:0	12	==
water	99:31	0:0	12	AUDIO_FORMAT_SIGNED
op	99:51	0:0	12	&&
water	100:16	0:0	12	ast
op	100:19	0:0	12	->
water	100:21	0:0	12	codecpar
op	100:29	0:0	12	->
water	100:31	0:0	12	bits_per_coded_sample
op	100:53	0:0	12	==
water	100:56	0:0	12	16
stmts	100:60	102:12	11	
water	100:60	0:0	12	{
water	101:16	0:0	12	ast
op	101:19	0:0	12	->
water	101:21	0:0	12	codecpar
op	101:29	0:0	12	->
water	101:31	0:0	12	codec_id
op	101:40	0:0	12	=
water	101:42	0:0	12	AV_CODEC_ID_PCM_S16BE
water	101:63	0:0	12	;
water	102:12	0:0	12	}
else	102:14	108:12	10
stmts	102:19	108:12	11	
water	102:19	0:0	12	{
call	103:16	106:74	12	avpriv_request_sample
arg	103:38	103:43	13	avctx
water	103:38	0:0	14	avctx
arg	104:38	104:79	13	"Audio compression %i (format %i, sr %i)"
water	104:38	0:0	14	"Audio compression %i (format %i, sr %i)"
arg	105:38	105:54	13	mv->acompression
water	105:38	0:0	14	mv
op	105:40	0:0	14	->
water	105:42	0:0	14	acompression
arg	105:56	105:67	13	mv->aformat
water	105:56	0:0	14	mv
op	105:58	0:0	14	->
water	105:60	0:0	14	aformat
arg	106:38	106:74	13	ast->codecpar->bits_per_coded_sample
water	106:38	0:0	14	ast
op	106:41	0:0	14	->
water	106:43	0:0	14	codecpar
op	106:51	0:0	14	->
water	106:53	0:0	14	bits_per_coded_sample
water	106:75	0:0	12	;
water	107:16	0:0	12	ast
op	107:19	0:0	12	->
water	107:21	0:0	12	codecpar
op	107:29	0:0	12	->
water	107:31	0:0	12	codec_id
op	107:40	0:0	12	=
water	107:42	0:0	12	AV_CODEC_ID_NONE
water	107:58	0:0	12	;
water	108:12	0:0	12	}
if	109:12	112:12	10	(ast -> codecpar -> channels <= 0)
cond	109:16	109:43	11	ast -> codecpar -> channels <= 0
water	109:16	0:0	12	ast
op	109:19	0:0	12	->
water	109:21	0:0	12	codecpar
op	109:29	0:0	12	->
water	109:31	0:0	12	channels
op	109:40	0:0	12	<=
water	109:43	0:0	12	0
stmts	109:46	112:12	11	
water	109:46	0:0	12	{
call	110:16	110:77	12	av_log
arg	110:23	110:28	13	avctx
water	110:23	0:0	14	avctx
arg	110:30	110:42	13	AV_LOG_ERROR
water	110:30	0:0	14	AV_LOG_ERROR
arg	110:44	110:77	13	"No valid channel count found.\n"
water	110:44	0:0	14	"No valid channel count found.\n"
water	110:78	0:0	12	;
return	111:16	111:42	12	AVERROR_INVALIDDATA
water	111:23	0:0	13	AVERROR_INVALIDDATA
water	112:12	0:0	12	}
water	113:8	0:0	10	}
if	115:8	118:8	6	(mv -> nb_video_tracks > 1)
cond	115:12	115:34	7	mv -> nb_video_tracks > 1
water	115:12	0:0	8	mv
op	115:14	0:0	8	->
water	115:16	0:0	8	nb_video_tracks
op	115:32	0:0	8	>
water	115:34	0:0	8	1
stmts	115:37	118:8	7	
water	115:37	0:0	8	{
call	116:12	116:73	8	avpriv_request_sample
arg	116:34	116:39	9	avctx
water	116:34	0:0	10	avctx
arg	116:41	116:73	9	"Multiple video streams support"
water	116:41	0:0	10	"Multiple video streams support"
water	116:74	0:0	8	;
return	117:12	117:39	8	AVERROR_PATCHWELCOME
water	117:19	0:0	9	AVERROR_PATCHWELCOME
water	118:8	0:0	8	}
else	118:10	125:8	6
stmts	118:15	125:8	7	
if	118:15	125:8	8	(mv -> nb_video_tracks)
cond	118:19	118:23	9	mv -> nb_video_tracks
water	118:19	0:0	10	mv
op	118:21	0:0	10	->
water	118:23	0:0	10	nb_video_tracks
stmts	118:40	125:8	9	
water	118:40	0:0	10	{
water	119:12	0:0	10	vst
op	119:16	0:0	10	=
call	119:18	119:49	10	avformat_new_stream
arg	119:38	119:43	11	avctx
water	119:38	0:0	12	avctx
arg	119:45	119:49	11	NULL
water	119:45	0:0	12	NULL
water	119:50	0:0	10	;
if	120:12	121:38	10	(! vst)
cond	120:16	120:17	11	! vst
op	120:16	0:0	12	!
water	120:17	0:0	12	vst
stmts	121:16	121:38	11	
return	121:16	121:38	12	AVERROR(ENOMEM)
call	121:23	121:37	13	AVERROR
arg	121:31	121:37	14	ENOMEM
water	121:31	0:0	15	ENOMEM
water	122:12	0:0	10	vst
op	122:15	0:0	10	->
water	122:17	0:0	10	codecpar
op	122:25	0:0	10	->
water	122:27	0:0	10	codec_type
op	122:38	0:0	10	=
water	122:40	0:0	10	AVMEDIA_TYPE_VIDEO
water	122:58	0:0	10	;
if	123:12	124:26	10	(( ret =read_table (avctx ,vst ,parse_video_var ) ) < 0)
cond	123:16	123:64	11	( ret =read_table (avctx ,vst ,parse_video_var ) ) < 0
water	123:16	0:0	12	(
water	123:17	0:0	12	ret
op	123:21	0:0	12	=
call	123:23	123:61	12	read_table
arg	123:34	123:39	13	avctx
water	123:34	0:0	14	avctx
arg	123:41	123:44	13	vst
water	123:41	0:0	14	vst
arg	123:46	123:61	13	parse_video_var
water	123:46	0:0	14	parse_video_var
water	123:62	0:0	12	)
op	123:63	0:0	12	<
water	123:64	0:0	12	0
stmts	124:16	124:26	11	
return	124:16	124:26	12	ret
water	124:23	0:0	13	ret
water	125:8	0:0	10	}
if	127:8	128:31	6	(mv -> nb_audio_tracks)
cond	127:12	127:16	7	mv -> nb_audio_tracks
water	127:12	0:0	8	mv
op	127:14	0:0	8	->
water	127:16	0:0	8	nb_audio_tracks
stmts	128:12	128:31	7	
call	128:12	128:30	8	read_index
arg	128:23	128:25	9	pb
water	128:23	0:0	10	pb
arg	128:27	128:30	9	ast
water	128:27	0:0	10	ast
water	128:31	0:0	8	;
if	130:8	131:31	6	(mv -> nb_video_tracks)
cond	130:12	130:16	7	mv -> nb_video_tracks
water	130:12	0:0	8	mv
op	130:14	0:0	8	->
water	130:16	0:0	8	nb_video_tracks
stmts	131:12	131:31	7	
call	131:12	131:30	8	read_index
arg	131:23	131:25	9	pb
water	131:23	0:0	10	pb
arg	131:27	131:30	9	vst
water	131:27	0:0	10	vst
water	131:31	0:0	8	;
water	132:4	0:0	6	}
else	132:6	135:4	2
stmts	132:11	135:4	3	
water	132:11	0:0	4	{
call	133:8	133:58	4	avpriv_request_sample
arg	133:30	133:35	5	avctx
water	133:30	0:0	6	avctx
arg	133:37	133:49	5	"Version %i"
water	133:37	0:0	6	"Version %i"
arg	133:51	133:58	5	version
water	133:51	0:0	6	version
water	133:59	0:0	4	;
return	134:8	134:35	4	AVERROR_PATCHWELCOME
water	134:15	0:0	5	AVERROR_PATCHWELCOME
water	135:4	0:0	4	}
return	137:4	137:12	2	0
water	137:11	0:0	3	0
