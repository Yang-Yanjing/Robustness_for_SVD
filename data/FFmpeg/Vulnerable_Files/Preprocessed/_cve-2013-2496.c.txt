func	2:0	114:0	0	static int	msrle_decode_8_16_24_32
params	2:34	0:0	1	
param	2:35	2:56	2	AVCodecContext *	avctx
param	2:58	2:72	2	AVPicture *	pic
param	3:35	3:44	2	int	depth
param	3:46	3:64	2	GetByteContext *	gb
stmnts	0:0	113:12	1	
decl	5:4	5:32	2	uint8_t	*output
water	5:19	0:0	2	,
decl	5:4	5:32	2	uint8_t	*output_end
decl	6:4	6:48	2	int	p1
water	6:10	0:0	2	,
decl	6:4	6:48	2	int	p2
water	6:14	0:0	2	,
decl	6:4	6:48	2	int	line
op	6:20	0:0	2	=
water	6:21	0:0	2	avctx
op	6:26	0:0	2	->
water	6:28	0:0	2	height
op	6:35	0:0	2	-
water	6:37	0:0	2	1
water	6:38	0:0	2	,
decl	6:4	6:48	2	int	pos
op	6:43	0:0	2	=
water	6:44	0:0	2	0
water	6:45	0:0	2	,
decl	6:4	6:48	2	int	i
decl	7:4	7:18	2	uint16_t	pix16
decl	8:4	8:18	2	uint32_t	pix32
decl	9:4	9:62	2	unsigned int	width
op	9:22	0:0	2	=
call	9:24	9:46	3	FFABS
arg	9:30	9:46	4	pic->linesize[0]
water	9:30	0:0	5	pic
op	9:33	0:0	5	->
water	9:35	0:0	5	linesize
op	9:43	0:0	5	[
water	9:44	0:0	5	0
op	9:45	0:0	5	]
op	9:48	0:0	2	/
water	9:50	0:0	2	(
water	9:51	0:0	2	depth
op	9:57	0:0	2	>>
water	9:60	0:0	2	3
water	9:61	0:0	2	)
water	11:4	0:0	2	output
op	11:15	0:0	2	=
water	11:17	0:0	2	pic
op	11:20	0:0	2	->
water	11:22	0:0	2	data
op	11:26	0:0	2	[
water	11:27	0:0	2	0
op	11:28	0:0	2	]
op	11:30	0:0	2	+
water	11:32	0:0	2	(
water	11:33	0:0	2	avctx
op	11:38	0:0	2	->
water	11:40	0:0	2	height
op	11:47	0:0	2	-
water	11:49	0:0	2	1
water	11:50	0:0	2	)
op	11:52	0:0	2	*
water	11:54	0:0	2	pic
op	11:57	0:0	2	->
water	11:59	0:0	2	linesize
op	11:67	0:0	2	[
water	11:68	0:0	2	0
op	11:69	0:0	2	]
water	11:70	0:0	2	;
water	12:4	0:0	2	output_end
op	12:15	0:0	2	=
water	12:17	0:0	2	pic
op	12:20	0:0	2	->
water	12:22	0:0	2	data
op	12:26	0:0	2	[
water	12:27	0:0	2	0
op	12:28	0:0	2	]
op	12:30	0:0	2	+
water	12:33	0:0	2	avctx
op	12:38	0:0	2	->
water	12:40	0:0	2	height
op	12:52	0:0	2	*
water	12:54	0:0	2	pic
op	12:57	0:0	2	->
water	12:59	0:0	2	linesize
op	12:67	0:0	2	[
water	12:68	0:0	2	0
op	12:69	0:0	2	]
water	12:70	0:0	2	;
while	13:4	110:4	2	(bytestream2_get_bytes_left (gb ) > 0)
cond	13:11	13:44	3	bytestream2_get_bytes_left (gb ) > 0
call	13:11	13:40	4	bytestream2_get_bytes_left
arg	13:38	13:40	5	gb
water	13:38	0:0	6	gb
op	13:42	0:0	4	>
water	13:44	0:0	4	0
stmts	13:47	110:4	3	
water	13:47	0:0	4	{
water	14:8	0:0	4	p1
op	14:11	0:0	4	=
call	14:13	14:37	4	bytestream2_get_byteu
arg	14:35	14:37	5	gb
water	14:35	0:0	6	gb
water	14:38	0:0	4	;
if	15:8	75:8	4	(p1 == 0)
cond	15:11	15:17	5	p1 == 0
water	15:11	0:0	6	p1
op	15:14	0:0	6	==
water	15:17	0:0	6	0
stmts	15:20	75:8	5	
water	15:20	0:0	6	{
water	16:12	0:0	6	p2
op	16:15	0:0	6	=
call	16:17	16:40	6	bytestream2_get_byte
arg	16:38	16:40	7	gb
water	16:38	0:0	8	gb
water	16:41	0:0	6	;
if	17:12	31:12	6	(p2 == 0)
cond	17:15	17:21	7	p2 == 0
water	17:15	0:0	8	p2
op	17:18	0:0	8	==
water	17:21	0:0	8	0
stmts	17:24	31:12	7	
water	17:24	0:0	8	{
water	18:16	0:0	8	output
op	18:23	0:0	8	=
water	18:25	0:0	8	pic
op	18:28	0:0	8	->
water	18:30	0:0	8	data
op	18:34	0:0	8	[
water	18:35	0:0	8	0
op	18:36	0:0	8	]
op	18:38	0:0	8	+
water	18:40	0:0	8	(
op	18:41	0:0	8	--
water	18:43	0:0	8	line
water	18:47	0:0	8	)
op	18:49	0:0	8	*
water	18:51	0:0	8	pic
op	18:54	0:0	8	->
water	18:56	0:0	8	linesize
op	18:64	0:0	8	[
water	18:65	0:0	8	0
op	18:66	0:0	8	]
water	18:67	0:0	8	;
if	19:16	28:16	8	(line < 0)
cond	19:20	19:27	9	line < 0
water	19:20	0:0	10	line
op	19:25	0:0	10	<
water	19:27	0:0	10	0
stmts	19:30	28:16	9	
water	19:30	0:0	10	{
if	20:20	22:20	10	(bytestream2_get_be16 (gb ) == 1)
cond	20:24	20:52	11	bytestream2_get_be16 (gb ) == 1
call	20:24	20:47	12	bytestream2_get_be16
arg	20:45	20:47	13	gb
water	20:45	0:0	14	gb
op	20:49	0:0	12	==
water	20:52	0:0	12	1
stmts	20:55	22:20	11	
water	20:55	0:0	12	{
return	21:24	21:32	12	0
water	21:31	0:0	13	0
water	22:20	0:0	12	}
else	22:22	27:20	10
stmts	22:27	27:20	11	
water	22:27	0:0	12	{
call	23:24	25:61	12	av_log
arg	23:31	23:36	13	avctx
water	23:31	0:0	14	avctx
arg	23:38	23:50	13	AV_LOG_ERROR
water	23:38	0:0	14	AV_LOG_ERROR
arg	24:31	24:85	13	"Next line is beyond picture bounds (%d bytes left)\n"
water	24:31	0:0	14	"Next line is beyond picture bounds (%d bytes left)\n"
arg	25:31	25:61	13	bytestream2_get_bytes_left(gb)
call	25:31	25:60	14	bytestream2_get_bytes_left
arg	25:58	25:60	15	gb
water	25:58	0:0	16	gb
water	25:62	0:0	12	;
return	26:24	26:50	12	AVERROR_INVALIDDATA
water	26:31	0:0	13	AVERROR_INVALIDDATA
water	27:20	0:0	12	}
water	28:16	0:0	10	}
water	29:16	0:0	8	pos
op	29:20	0:0	8	=
water	29:22	0:0	8	0
water	29:23	0:0	8	;
continue	30:16	30:24	8	
water	31:12	0:0	8	}
else	31:14	33:12	6
stmts	31:19	33:12	7	
if	31:19	33:12	8	(p2 == 1)
cond	31:22	31:28	9	p2 == 1
water	31:22	0:0	10	p2
op	31:25	0:0	10	==
water	31:28	0:0	10	1
stmts	31:31	33:12	9	
water	31:31	0:0	10	{
return	32:16	32:24	10	0
water	32:23	0:0	11	0
water	33:12	0:0	10	}
else	33:14	44:12	6
stmts	33:19	44:12	7	
if	33:19	44:12	8	(p2 == 2)
cond	33:22	33:28	9	p2 == 2
water	33:22	0:0	10	p2
op	33:25	0:0	10	==
water	33:28	0:0	10	2
stmts	33:31	44:12	9	
water	33:31	0:0	10	{
water	34:16	0:0	10	p1
op	34:19	0:0	10	=
call	34:21	34:44	10	bytestream2_get_byte
arg	34:42	34:44	11	gb
water	34:42	0:0	12	gb
water	34:45	0:0	10	;
water	35:16	0:0	10	p2
op	35:19	0:0	10	=
call	35:21	35:44	10	bytestream2_get_byte
arg	35:42	35:44	11	gb
water	35:42	0:0	12	gb
water	35:45	0:0	10	;
water	36:16	0:0	10	line
op	36:21	0:0	10	-=
water	36:24	0:0	10	p2
water	36:26	0:0	10	;
water	37:16	0:0	10	pos
op	37:20	0:0	10	+=
water	37:23	0:0	10	p1
water	37:25	0:0	10	;
if	38:16	41:16	10	(line < 0 || pos >= width)
cond	38:20	38:39	11	line < 0 || pos >= width
water	38:20	0:0	12	line
op	38:25	0:0	12	<
water	38:27	0:0	12	0
op	38:29	0:0	12	||
water	38:32	0:0	12	pos
op	38:36	0:0	12	>=
water	38:39	0:0	12	width
stmts	38:45	41:16	11	
water	38:45	0:0	12	{
call	39:20	39:78	12	av_log
arg	39:27	39:32	13	avctx
water	39:27	0:0	14	avctx
arg	39:34	39:46	13	AV_LOG_ERROR
water	39:34	0:0	14	AV_LOG_ERROR
arg	39:48	39:78	13	"Skip beyond picture bounds\n"
water	39:48	0:0	14	"Skip beyond picture bounds\n"
water	39:79	0:0	12	;
return	40:20	40:29	12	-1
op	40:27	0:0	13	-
water	40:28	0:0	13	1
water	41:16	0:0	12	}
water	42:16	0:0	10	output
op	42:23	0:0	10	=
water	42:25	0:0	10	pic
op	42:28	0:0	10	->
water	42:30	0:0	10	data
op	42:34	0:0	10	[
water	42:35	0:0	10	0
op	42:36	0:0	10	]
op	42:38	0:0	10	+
water	42:40	0:0	10	line
op	42:45	0:0	10	*
water	42:47	0:0	10	pic
op	42:50	0:0	10	->
water	42:52	0:0	10	linesize
op	42:60	0:0	10	[
water	42:61	0:0	10	0
op	42:62	0:0	10	]
op	42:64	0:0	10	+
water	42:66	0:0	10	pos
op	42:70	0:0	10	*
water	42:72	0:0	10	(
water	42:73	0:0	10	depth
op	42:79	0:0	10	>>
water	42:82	0:0	10	3
water	42:83	0:0	10	)
water	42:84	0:0	10	;
continue	43:16	43:24	10	
water	44:12	0:0	10	}
if	46:12	50:12	6	(( pic -> linesize [ 0 ] > 0 && output + p2 * ( depth >> 3 ) > output_end ) || ( pic -> linesize [ 0 ] < 0 && output + p2 * ( depth >> 3 ) < output_end ))
cond	46:16	47:80	7	( pic -> linesize [ 0 ] > 0 && output + p2 * ( depth >> 3 ) > output_end ) || ( pic -> linesize [ 0 ] < 0 && output + p2 * ( depth >> 3 ) < output_end )
water	46:16	0:0	8	(
water	46:17	0:0	8	pic
op	46:20	0:0	8	->
water	46:22	0:0	8	linesize
op	46:30	0:0	8	[
water	46:31	0:0	8	0
op	46:32	0:0	8	]
op	46:34	0:0	8	>
water	46:36	0:0	8	0
op	46:38	0:0	8	&&
water	46:41	0:0	8	output
op	46:48	0:0	8	+
water	46:50	0:0	8	p2
op	46:53	0:0	8	*
water	46:55	0:0	8	(
water	46:56	0:0	8	depth
op	46:62	0:0	8	>>
water	46:65	0:0	8	3
water	46:66	0:0	8	)
op	46:68	0:0	8	>
water	46:70	0:0	8	output_end
water	46:80	0:0	8	)
op	46:82	0:0	8	||
water	47:16	0:0	8	(
water	47:17	0:0	8	pic
op	47:20	0:0	8	->
water	47:22	0:0	8	linesize
op	47:30	0:0	8	[
water	47:31	0:0	8	0
op	47:32	0:0	8	]
op	47:34	0:0	8	<
water	47:36	0:0	8	0
op	47:38	0:0	8	&&
water	47:41	0:0	8	output
op	47:48	0:0	8	+
water	47:50	0:0	8	p2
op	47:53	0:0	8	*
water	47:55	0:0	8	(
water	47:56	0:0	8	depth
op	47:62	0:0	8	>>
water	47:65	0:0	8	3
water	47:66	0:0	8	)
op	47:68	0:0	8	<
water	47:70	0:0	8	output_end
water	47:80	0:0	8	)
stmts	47:83	50:12	7	
water	47:83	0:0	8	{
call	48:16	48:53	8	bytestream2_skip
arg	48:33	48:35	9	gb
water	48:33	0:0	10	gb
arg	48:37	48:53	9	2*(depth>>3)
water	48:37	0:0	10	2
op	48:39	0:0	10	*
water	48:41	0:0	10	(
water	48:42	0:0	10	depth
op	48:48	0:0	10	>>
water	48:51	0:0	10	3
water	48:52	0:0	10	)
water	48:54	0:0	8	;
continue	49:16	49:24	8	
water	50:12	0:0	8	}
else	50:14	53:12	6
stmts	50:19	53:12	7	
if	50:19	53:12	8	(bytestream2_get_bytes_left (gb ) < p2 * ( depth >> 3 ))
cond	50:23	50:72	9	bytestream2_get_bytes_left (gb ) < p2 * ( depth >> 3 )
call	50:23	50:52	10	bytestream2_get_bytes_left
arg	50:50	50:52	11	gb
water	50:50	0:0	12	gb
op	50:54	0:0	10	<
water	50:56	0:0	10	p2
op	50:59	0:0	10	*
water	50:61	0:0	10	(
water	50:62	0:0	10	depth
op	50:68	0:0	10	>>
water	50:71	0:0	10	3
water	50:72	0:0	10	)
stmts	50:75	53:12	9	
water	50:75	0:0	10	{
call	51:16	51:66	10	av_log
arg	51:23	51:28	11	avctx
water	51:23	0:0	12	avctx
arg	51:30	51:42	11	AV_LOG_ERROR
water	51:30	0:0	12	AV_LOG_ERROR
arg	51:44	51:66	11	"bytestream overrun\n"
water	51:44	0:0	12	"bytestream overrun\n"
water	51:67	0:0	10	;
return	52:16	52:42	10	AVERROR_INVALIDDATA
water	52:23	0:0	11	AVERROR_INVALIDDATA
water	53:12	0:0	10	}
if	55:12	63:12	6	(( depth == 8 ) || ( depth == 24 ))
cond	55:16	55:44	7	( depth == 8 ) || ( depth == 24 )
water	55:16	0:0	8	(
water	55:17	0:0	8	depth
op	55:23	0:0	8	==
water	55:26	0:0	8	8
water	55:27	0:0	8	)
op	55:29	0:0	8	||
water	55:32	0:0	8	(
water	55:33	0:0	8	depth
op	55:39	0:0	8	==
water	55:42	0:0	8	24
water	55:44	0:0	8	)
stmts	55:47	63:12	7	
water	55:47	0:0	8	{
for	56:16	58:16	8	(i = 0 ;i < p2 * ( depth >> 3 );i ++)
forinit	56:20	56:25	9	i = 0 ;
water	56:20	0:0	10	i
op	56:22	0:0	10	=
water	56:24	0:0	10	0
water	56:25	0:0	10	;
cond	56:27	56:47	9	i < p2 * ( depth >> 3 )
water	56:27	0:0	10	i
op	56:29	0:0	10	<
water	56:31	0:0	10	p2
op	56:34	0:0	10	*
water	56:36	0:0	10	(
water	56:37	0:0	10	depth
op	56:43	0:0	10	>>
water	56:46	0:0	10	3
water	56:47	0:0	10	)
forexpr	56:50	56:51	9	i ++
water	56:50	0:0	10	i
op	56:51	0:0	10	++
stmts	56:55	58:16	9	
water	56:55	0:0	10	{
op	57:20	0:0	10	*
water	57:21	0:0	10	output
op	57:27	0:0	10	++
op	57:30	0:0	10	=
call	57:32	57:56	10	bytestream2_get_byteu
arg	57:54	57:56	11	gb
water	57:54	0:0	12	gb
water	57:57	0:0	10	;
water	58:16	0:0	10	}
if	60:16	62:16	8	(depth == 8 && ( p2 & 1 ))
cond	60:19	60:40	9	depth == 8 && ( p2 & 1 )
water	60:19	0:0	10	depth
op	60:25	0:0	10	==
water	60:28	0:0	10	8
op	60:30	0:0	10	&&
water	60:33	0:0	10	(
water	60:34	0:0	10	p2
op	60:37	0:0	10	&
water	60:39	0:0	10	1
water	60:40	0:0	10	)
stmts	60:43	62:16	9	
water	60:43	0:0	10	{
call	61:20	61:42	10	bytestream2_skip
arg	61:37	61:39	11	gb
water	61:37	0:0	12	gb
arg	61:41	61:42	11	1
water	61:41	0:0	12	1
water	61:43	0:0	10	;
water	62:16	0:0	10	}
water	63:12	0:0	8	}
else	63:14	68:12	6
stmts	63:19	68:12	7	
if	63:19	68:12	8	(depth == 16)
cond	63:23	63:32	9	depth == 16
water	63:23	0:0	10	depth
op	63:29	0:0	10	==
water	63:32	0:0	10	16
stmts	63:36	68:12	9	
water	63:36	0:0	10	{
for	64:16	67:16	10	(i = 0 ;i < p2;i ++)
forinit	64:20	64:25	11	i = 0 ;
water	64:20	0:0	12	i
op	64:22	0:0	12	=
water	64:24	0:0	12	0
water	64:25	0:0	12	;
cond	64:27	64:31	11	i < p2
water	64:27	0:0	12	i
op	64:29	0:0	12	<
water	64:31	0:0	12	p2
forexpr	64:35	64:36	11	i ++
water	64:35	0:0	12	i
op	64:36	0:0	12	++
stmts	64:40	67:16	11	
water	64:40	0:0	12	{
op	65:20	0:0	12	*
water	65:21	0:0	12	(
water	65:22	0:0	12	uint16_t
op	65:30	0:0	12	*
water	65:31	0:0	12	)
water	65:32	0:0	12	output
op	65:39	0:0	12	=
call	65:41	65:65	12	bytestream2_get_le16u
arg	65:63	65:65	13	gb
water	65:63	0:0	14	gb
water	65:66	0:0	12	;
water	66:20	0:0	12	output
op	66:27	0:0	12	+=
water	66:30	0:0	12	2
water	66:31	0:0	12	;
water	67:16	0:0	12	}
water	68:12	0:0	10	}
else	68:14	73:12	6
stmts	68:19	73:12	7	
if	68:19	73:12	8	(depth == 32)
cond	68:23	68:32	9	depth == 32
water	68:23	0:0	10	depth
op	68:29	0:0	10	==
water	68:32	0:0	10	32
stmts	68:36	73:12	9	
water	68:36	0:0	10	{
for	69:16	72:16	10	(i = 0 ;i < p2;i ++)
forinit	69:20	69:25	11	i = 0 ;
water	69:20	0:0	12	i
op	69:22	0:0	12	=
water	69:24	0:0	12	0
water	69:25	0:0	12	;
cond	69:27	69:31	11	i < p2
water	69:27	0:0	12	i
op	69:29	0:0	12	<
water	69:31	0:0	12	p2
forexpr	69:35	69:36	11	i ++
water	69:35	0:0	12	i
op	69:36	0:0	12	++
stmts	69:40	72:16	11	
water	69:40	0:0	12	{
op	70:20	0:0	12	*
water	70:21	0:0	12	(
water	70:22	0:0	12	uint32_t
op	70:30	0:0	12	*
water	70:31	0:0	12	)
water	70:32	0:0	12	output
op	70:39	0:0	12	=
call	70:41	70:65	12	bytestream2_get_le32u
arg	70:63	70:65	13	gb
water	70:63	0:0	14	gb
water	70:66	0:0	12	;
water	71:20	0:0	12	output
op	71:27	0:0	12	+=
water	71:30	0:0	12	4
water	71:31	0:0	12	;
water	72:16	0:0	12	}
water	73:12	0:0	10	}
water	74:12	0:0	6	pos
op	74:16	0:0	6	+=
water	74:19	0:0	6	p2
water	74:21	0:0	6	;
water	75:8	0:0	6	}
else	75:10	109:8	4
stmts	75:15	109:8	5	
water	75:15	0:0	6	{
decl	76:12	76:26	6	uint8_t	pix[3]
switch	77:12	88:12	6	(depth)
cond	77:19	77:19	7	depth
water	77:19	0:0	8	depth
stmts	77:25	88:12	7	
water	77:25	0:0	8	{
label	78:12	78:19	8	case 8 :
water	78:21	0:0	8	pix
op	78:24	0:0	8	[
water	78:25	0:0	8	0
op	78:26	0:0	8	]
op	78:28	0:0	8	=
call	78:30	78:53	8	bytestream2_get_byte
arg	78:51	78:53	9	gb
water	78:51	0:0	10	gb
water	78:54	0:0	8	;
break	79:21	79:26	8	
label	80:12	80:19	8	case 16 :
water	80:21	0:0	8	pix16
op	80:28	0:0	8	=
call	80:30	80:53	8	bytestream2_get_le16
arg	80:51	80:53	9	gb
water	80:51	0:0	10	gb
water	80:54	0:0	8	;
break	81:21	81:26	8	
label	82:12	82:19	8	case 24 :
water	82:21	0:0	8	pix
op	82:24	0:0	8	[
water	82:25	0:0	8	0
op	82:26	0:0	8	]
op	82:28	0:0	8	=
call	82:30	82:53	8	bytestream2_get_byte
arg	82:51	82:53	9	gb
water	82:51	0:0	10	gb
water	82:54	0:0	8	;
water	83:21	0:0	8	pix
op	83:24	0:0	8	[
water	83:25	0:0	8	1
op	83:26	0:0	8	]
op	83:28	0:0	8	=
call	83:30	83:53	8	bytestream2_get_byte
arg	83:51	83:53	9	gb
water	83:51	0:0	10	gb
water	83:54	0:0	8	;
water	84:21	0:0	8	pix
op	84:24	0:0	8	[
water	84:25	0:0	8	2
op	84:26	0:0	8	]
op	84:28	0:0	8	=
call	84:30	84:53	8	bytestream2_get_byte
arg	84:51	84:53	9	gb
water	84:51	0:0	10	gb
water	84:54	0:0	8	;
break	85:21	85:26	8	
label	86:12	86:19	8	case 32 :
water	86:21	0:0	8	pix32
op	86:28	0:0	8	=
call	86:30	86:53	8	bytestream2_get_le32
arg	86:51	86:53	9	gb
water	86:51	0:0	10	gb
water	86:54	0:0	8	;
break	87:21	87:26	8	
water	88:12	0:0	8	}
if	89:12	91:24	6	(( pic -> linesize [ 0 ] > 0 && output + p1 * ( depth >> 3 ) > output_end ) || ( pic -> linesize [ 0 ] < 0 && output + p1 * ( depth >> 3 ) < output_end ))
cond	89:16	90:80	7	( pic -> linesize [ 0 ] > 0 && output + p1 * ( depth >> 3 ) > output_end ) || ( pic -> linesize [ 0 ] < 0 && output + p1 * ( depth >> 3 ) < output_end )
water	89:16	0:0	8	(
water	89:17	0:0	8	pic
op	89:20	0:0	8	->
water	89:22	0:0	8	linesize
op	89:30	0:0	8	[
water	89:31	0:0	8	0
op	89:32	0:0	8	]
op	89:34	0:0	8	>
water	89:36	0:0	8	0
op	89:38	0:0	8	&&
water	89:41	0:0	8	output
op	89:48	0:0	8	+
water	89:50	0:0	8	p1
op	89:53	0:0	8	*
water	89:55	0:0	8	(
water	89:56	0:0	8	depth
op	89:62	0:0	8	>>
water	89:65	0:0	8	3
water	89:66	0:0	8	)
op	89:68	0:0	8	>
water	89:70	0:0	8	output_end
water	89:80	0:0	8	)
op	89:82	0:0	8	||
water	90:16	0:0	8	(
water	90:17	0:0	8	pic
op	90:20	0:0	8	->
water	90:22	0:0	8	linesize
op	90:30	0:0	8	[
water	90:31	0:0	8	0
op	90:32	0:0	8	]
op	90:34	0:0	8	<
water	90:36	0:0	8	0
op	90:38	0:0	8	&&
water	90:41	0:0	8	output
op	90:48	0:0	8	+
water	90:50	0:0	8	p1
op	90:53	0:0	8	*
water	90:55	0:0	8	(
water	90:56	0:0	8	depth
op	90:62	0:0	8	>>
water	90:65	0:0	8	3
water	90:66	0:0	8	)
op	90:68	0:0	8	<
water	90:70	0:0	8	output_end
water	90:80	0:0	8	)
stmts	91:16	91:24	7	
continue	91:16	91:24	8	
for	92:12	107:12	6	(i = 0 ;i < p1;i ++)
forinit	92:16	92:21	7	i = 0 ;
water	92:16	0:0	8	i
op	92:18	0:0	8	=
water	92:20	0:0	8	0
water	92:21	0:0	8	;
cond	92:23	92:27	7	i < p1
water	92:23	0:0	8	i
op	92:25	0:0	8	<
water	92:27	0:0	8	p1
forexpr	92:31	92:32	7	i ++
water	92:31	0:0	8	i
op	92:32	0:0	8	++
stmts	92:36	107:12	7	
water	92:36	0:0	8	{
switch	93:16	106:16	8	(depth)
cond	93:23	93:23	9	depth
water	93:23	0:0	10	depth
stmts	93:29	106:16	9	
water	93:29	0:0	10	{
label	94:16	94:23	10	case 8 :
op	94:25	0:0	10	*
water	94:26	0:0	10	output
op	94:32	0:0	10	++
op	94:35	0:0	10	=
water	94:37	0:0	10	pix
op	94:40	0:0	10	[
water	94:41	0:0	10	0
op	94:42	0:0	10	]
water	94:43	0:0	10	;
break	95:25	95:30	10	
label	96:16	96:23	10	case 16 :
op	96:25	0:0	10	*
water	96:26	0:0	10	(
water	96:27	0:0	10	uint16_t
op	96:35	0:0	10	*
water	96:36	0:0	10	)
water	96:37	0:0	10	output
op	96:44	0:0	10	=
water	96:46	0:0	10	pix16
water	96:51	0:0	10	;
water	97:25	0:0	10	output
op	97:32	0:0	10	+=
water	97:35	0:0	10	2
water	97:36	0:0	10	;
break	98:25	98:30	10	
label	99:16	99:23	10	case 24 :
op	99:25	0:0	10	*
water	99:26	0:0	10	output
op	99:32	0:0	10	++
op	99:35	0:0	10	=
water	99:37	0:0	10	pix
op	99:40	0:0	10	[
water	99:41	0:0	10	0
op	99:42	0:0	10	]
water	99:43	0:0	10	;
op	100:25	0:0	10	*
water	100:26	0:0	10	output
op	100:32	0:0	10	++
op	100:35	0:0	10	=
water	100:37	0:0	10	pix
op	100:40	0:0	10	[
water	100:41	0:0	10	1
op	100:42	0:0	10	]
water	100:43	0:0	10	;
op	101:25	0:0	10	*
water	101:26	0:0	10	output
op	101:32	0:0	10	++
op	101:35	0:0	10	=
water	101:37	0:0	10	pix
op	101:40	0:0	10	[
water	101:41	0:0	10	2
op	101:42	0:0	10	]
water	101:43	0:0	10	;
break	102:25	102:30	10	
label	103:16	103:23	10	case 32 :
op	103:25	0:0	10	*
water	103:26	0:0	10	(
water	103:27	0:0	10	uint32_t
op	103:35	0:0	10	*
water	103:36	0:0	10	)
water	103:37	0:0	10	output
op	103:44	0:0	10	=
water	103:46	0:0	10	pix32
water	103:51	0:0	10	;
water	104:25	0:0	10	output
op	104:32	0:0	10	+=
water	104:35	0:0	10	4
water	104:36	0:0	10	;
break	105:25	105:30	10	
water	106:16	0:0	10	}
water	107:12	0:0	8	}
water	108:12	0:0	6	pos
op	108:16	0:0	6	+=
water	108:19	0:0	6	p1
water	108:21	0:0	6	;
water	109:8	0:0	6	}
water	110:4	0:0	4	}
call	112:4	112:76	2	av_log
arg	112:11	112:16	3	avctx
water	112:11	0:0	4	avctx
arg	112:18	112:32	3	AV_LOG_WARNING
water	112:18	0:0	4	AV_LOG_WARNING
arg	112:34	112:76	3	"MS RLE warning: no end-of-picture code\n"
water	112:34	0:0	4	"MS RLE warning: no end-of-picture code\n"
water	112:77	0:0	2	;
return	113:4	113:12	2	0
water	113:11	0:0	3	0
