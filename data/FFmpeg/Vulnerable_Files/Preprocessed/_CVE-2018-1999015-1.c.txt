func	1:0	273:0	0	static int	decode_vop_header
params	1:28	0:0	1	
param	1:29	1:49	2	Mpeg4DecContext *	ctx
param	1:51	1:68	2	GetBitContext *	gb
stmnts	0:0	272:12	1	
decl	3:4	3:31	2	MpegEncContext	*s
op	3:22	0:0	2	=
op	3:24	0:0	2	&
water	3:25	0:0	2	ctx
op	3:28	0:0	2	->
water	3:30	0:0	2	m
decl	4:4	4:33	2	int	time_incr
water	4:17	0:0	2	,
decl	4:4	4:33	2	int	time_increment
decl	5:4	5:15	2	int64_t	pts
water	7:4	0:0	2	s
op	7:5	0:0	2	->
water	7:7	0:0	2	mcsel
op	7:19	0:0	2	=
water	7:21	0:0	2	0
water	7:22	0:0	2	;
water	8:4	0:0	2	s
op	8:5	0:0	2	->
water	8:7	0:0	2	pict_type
op	8:17	0:0	2	=
call	8:19	8:33	2	get_bits
arg	8:28	8:30	3	gb
water	8:28	0:0	4	gb
arg	8:32	8:33	3	2
water	8:32	0:0	4	2
op	8:35	0:0	2	+
water	8:37	0:0	2	AV_PICTURE_TYPE_I
water	8:54	0:0	2	;
if	9:4	13:4	2	(s -> pict_type == AV_PICTURE_TYPE_B && s -> low_delay && ctx -> vol_control_parameters == 0 && ! ( s -> avctx -> flags & AV_CODEC_FLAG_LOW_DELAY ))
cond	9:8	10:87	3	s -> pict_type == AV_PICTURE_TYPE_B && s -> low_delay && ctx -> vol_control_parameters == 0 && ! ( s -> avctx -> flags & AV_CODEC_FLAG_LOW_DELAY )
water	9:8	0:0	4	s
op	9:9	0:0	4	->
water	9:11	0:0	4	pict_type
op	9:21	0:0	4	==
water	9:24	0:0	4	AV_PICTURE_TYPE_B
op	9:42	0:0	4	&&
water	9:45	0:0	4	s
op	9:46	0:0	4	->
water	9:48	0:0	4	low_delay
op	9:58	0:0	4	&&
water	10:8	0:0	4	ctx
op	10:11	0:0	4	->
water	10:13	0:0	4	vol_control_parameters
op	10:36	0:0	4	==
water	10:39	0:0	4	0
op	10:41	0:0	4	&&
op	10:44	0:0	4	!
water	10:45	0:0	4	(
water	10:46	0:0	4	s
op	10:47	0:0	4	->
water	10:49	0:0	4	avctx
op	10:54	0:0	4	->
water	10:56	0:0	4	flags
op	10:62	0:0	4	&
water	10:64	0:0	4	AV_CODEC_FLAG_LOW_DELAY
water	10:87	0:0	4	)
stmts	10:90	13:4	3	
water	10:90	0:0	4	{
call	11:8	11:86	4	av_log
arg	11:15	11:23	5	s->avctx
water	11:15	0:0	6	s
op	11:16	0:0	6	->
water	11:18	0:0	6	avctx
arg	11:25	11:37	5	AV_LOG_ERROR
water	11:25	0:0	6	AV_LOG_ERROR
arg	11:39	11:86	5	"low_delay flag set incorrectly, clearing it\n"
water	11:39	0:0	6	"low_delay flag set incorrectly, clearing it\n"
water	11:87	0:0	4	;
water	12:8	0:0	4	s
op	12:9	0:0	4	->
water	12:11	0:0	4	low_delay
op	12:21	0:0	4	=
water	12:23	0:0	4	0
water	12:24	0:0	4	;
water	13:4	0:0	4	}
water	15:4	0:0	2	s
op	15:5	0:0	2	->
water	15:7	0:0	2	partitioned_frame
op	15:25	0:0	2	=
water	15:27	0:0	2	s
op	15:28	0:0	2	->
water	15:30	0:0	2	data_partitioning
op	15:48	0:0	2	&&
water	15:51	0:0	2	s
op	15:52	0:0	2	->
water	15:54	0:0	2	pict_type
op	15:64	0:0	2	!=
water	15:67	0:0	2	AV_PICTURE_TYPE_B
water	15:84	0:0	2	;
if	16:4	17:50	2	(s -> partitioned_frame)
cond	16:8	16:11	3	s -> partitioned_frame
water	16:8	0:0	4	s
op	16:9	0:0	4	->
water	16:11	0:0	4	partitioned_frame
stmts	17:8	17:50	3	
water	17:8	0:0	4	s
op	17:9	0:0	4	->
water	17:11	0:0	4	decode_mb
op	17:21	0:0	4	=
water	17:23	0:0	4	mpeg4_decode_partitioned_mb
water	17:50	0:0	4	;
else	18:4	19:38	2
stmts	19:8	19:38	3	
water	19:8	0:0	4	s
op	19:9	0:0	4	->
water	19:11	0:0	4	decode_mb
op	19:21	0:0	4	=
water	19:23	0:0	4	mpeg4_decode_mb
water	19:38	0:0	4	;
water	21:4	0:0	2	time_incr
op	21:14	0:0	2	=
water	21:16	0:0	2	0
water	21:17	0:0	2	;
while	22:4	23:19	2	(get_bits1 (gb ) != 0)
cond	22:11	22:28	3	get_bits1 (gb ) != 0
call	22:11	22:23	4	get_bits1
arg	22:21	22:23	5	gb
water	22:21	0:0	6	gb
op	22:25	0:0	4	!=
water	22:28	0:0	4	0
stmts	23:8	23:19	3	
water	23:8	0:0	4	time_incr
op	23:17	0:0	4	++
water	23:19	0:0	4	;
call	25:4	25:54	2	check_marker
arg	25:17	25:25	3	s->avctx
water	25:17	0:0	4	s
op	25:18	0:0	4	->
water	25:20	0:0	4	avctx
arg	25:27	25:29	3	gb
water	25:27	0:0	4	gb
arg	25:31	25:54	3	"before time_increment"
water	25:31	0:0	4	"before time_increment"
water	25:55	0:0	2	;
if	27:4	50:4	2	(ctx -> time_increment_bits == 0 || ! (show_bits (gb ,ctx -> time_increment_bits + 1 ) & 1 ))
cond	27:8	28:57	3	ctx -> time_increment_bits == 0 || ! (show_bits (gb ,ctx -> time_increment_bits + 1 ) & 1 )
water	27:8	0:0	4	ctx
op	27:11	0:0	4	->
water	27:13	0:0	4	time_increment_bits
op	27:33	0:0	4	==
water	27:36	0:0	4	0
op	27:38	0:0	4	||
op	28:8	0:0	4	!
water	28:9	0:0	4	(
call	28:10	28:52	4	show_bits
arg	28:20	28:22	5	gb
water	28:20	0:0	6	gb
arg	28:24	28:52	5	ctx->time_increment_bits+1
water	28:24	0:0	6	ctx
op	28:27	0:0	6	->
water	28:29	0:0	6	time_increment_bits
op	28:49	0:0	6	+
water	28:51	0:0	6	1
op	28:54	0:0	4	&
water	28:56	0:0	4	1
water	28:57	0:0	4	)
stmts	28:60	50:4	3	
water	28:60	0:0	4	{
call	29:8	30:162	4	av_log
arg	29:15	29:23	5	s->avctx
water	29:15	0:0	6	s
op	29:16	0:0	6	->
water	29:18	0:0	6	avctx
arg	29:25	29:39	5	AV_LOG_WARNING
water	29:25	0:0	6	AV_LOG_WARNING
arg	30:15	30:136	5	"time_increment_bits %d is invalid in relation to the current bitstream, this is likely caused by a missing VOL header\n"
water	30:15	0:0	6	"time_increment_bits %d is invalid in relation to the current bitstream, this is likely caused by a missing VOL header\n"
arg	30:138	30:162	5	ctx->time_increment_bits
water	30:138	0:0	6	ctx
op	30:141	0:0	6	->
water	30:143	0:0	6	time_increment_bits
water	30:163	0:0	4	;
for	32:8	42:8	4	(ctx -> time_increment_bits = 1 ;ctx -> time_increment_bits < 16;ctx -> time_increment_bits ++)
forinit	32:13	32:41	5	ctx -> time_increment_bits = 1 ;
water	32:13	0:0	6	ctx
op	32:16	0:0	6	->
water	32:18	0:0	6	time_increment_bits
op	32:38	0:0	6	=
water	32:40	0:0	6	1
water	32:41	0:0	6	;
cond	33:13	33:40	5	ctx -> time_increment_bits < 16
water	33:13	0:0	6	ctx
op	33:16	0:0	6	->
water	33:18	0:0	6	time_increment_bits
op	33:38	0:0	6	<
water	33:40	0:0	6	16
forexpr	34:13	34:37	5	ctx -> time_increment_bits ++
water	34:13	0:0	6	ctx
op	34:16	0:0	6	->
water	34:18	0:0	6	time_increment_bits
op	34:37	0:0	6	++
stmts	34:41	42:8	5	
water	34:41	0:0	6	{
if	35:12	40:12	6	(s -> pict_type == AV_PICTURE_TYPE_P || ( s -> pict_type == AV_PICTURE_TYPE_S && ctx -> vol_sprite_usage == GMC_SPRITE ))
cond	35:16	37:52	7	s -> pict_type == AV_PICTURE_TYPE_P || ( s -> pict_type == AV_PICTURE_TYPE_S && ctx -> vol_sprite_usage == GMC_SPRITE )
water	35:16	0:0	8	s
op	35:17	0:0	8	->
water	35:19	0:0	8	pict_type
op	35:29	0:0	8	==
water	35:32	0:0	8	AV_PICTURE_TYPE_P
op	35:50	0:0	8	||
water	36:16	0:0	8	(
water	36:17	0:0	8	s
op	36:18	0:0	8	->
water	36:20	0:0	8	pict_type
op	36:30	0:0	8	==
water	36:33	0:0	8	AV_PICTURE_TYPE_S
op	36:51	0:0	8	&&
water	37:17	0:0	8	ctx
op	37:20	0:0	8	->
water	37:22	0:0	8	vol_sprite_usage
op	37:39	0:0	8	==
water	37:42	0:0	8	GMC_SPRITE
water	37:52	0:0	8	)
stmts	37:55	40:12	7	
water	37:55	0:0	8	{
if	38:16	39:25	8	((show_bits (gb ,ctx -> time_increment_bits + 6 ) & 0 x37 ) == 0 x30)
cond	38:20	38:77	9	(show_bits (gb ,ctx -> time_increment_bits + 6 ) & 0 x37 ) == 0 x30
water	38:20	0:0	10	(
call	38:21	38:63	10	show_bits
arg	38:31	38:33	11	gb
water	38:31	0:0	12	gb
arg	38:35	38:63	11	ctx->time_increment_bits+6
water	38:35	0:0	12	ctx
op	38:38	0:0	12	->
water	38:40	0:0	12	time_increment_bits
op	38:60	0:0	12	+
water	38:62	0:0	12	6
op	38:65	0:0	10	&
water	38:67	0:0	10	0
water	38:68	0:0	10	x37
water	38:71	0:0	10	)
op	38:73	0:0	10	==
water	38:76	0:0	10	0
water	38:77	0:0	10	x30
stmts	39:20	39:25	9	
break	39:20	39:25	10	
water	40:12	0:0	8	}
else	40:14	41:21	6
stmts	40:19	41:21	7	
if	40:19	41:21	8	((show_bits (gb ,ctx -> time_increment_bits + 5 ) & 0 x1F ) == 0 x18)
cond	40:23	40:80	9	(show_bits (gb ,ctx -> time_increment_bits + 5 ) & 0 x1F ) == 0 x18
water	40:23	0:0	10	(
call	40:24	40:66	10	show_bits
arg	40:34	40:36	11	gb
water	40:34	0:0	12	gb
arg	40:38	40:66	11	ctx->time_increment_bits+5
water	40:38	0:0	12	ctx
op	40:41	0:0	12	->
water	40:43	0:0	12	time_increment_bits
op	40:63	0:0	12	+
water	40:65	0:0	12	5
op	40:68	0:0	10	&
water	40:70	0:0	10	0
water	40:71	0:0	10	x1F
water	40:74	0:0	10	)
op	40:76	0:0	10	==
water	40:79	0:0	10	0
water	40:80	0:0	10	x18
stmts	41:16	41:21	9	
break	41:16	41:21	10	
water	42:8	0:0	6	}
call	44:8	45:108	4	av_log
arg	44:15	44:23	5	s->avctx
water	44:15	0:0	6	s
op	44:16	0:0	6	->
water	44:18	0:0	6	avctx
arg	44:25	44:39	5	AV_LOG_WARNING
water	44:25	0:0	6	AV_LOG_WARNING
arg	45:15	45:82	5	"time_increment_bits set to %d bits, based on bitstream analysis\n"
water	45:15	0:0	6	"time_increment_bits set to %d bits, based on bitstream analysis\n"
arg	45:84	45:108	5	ctx->time_increment_bits
water	45:84	0:0	6	ctx
op	45:87	0:0	6	->
water	45:89	0:0	6	time_increment_bits
water	45:109	0:0	4	;
if	46:8	49:8	4	(s -> avctx -> framerate . num && 4 * s -> avctx -> framerate . num < 1 << ctx -> time_increment_bits)
cond	46:12	46:75	5	s -> avctx -> framerate . num && 4 * s -> avctx -> framerate . num < 1 << ctx -> time_increment_bits
water	46:12	0:0	6	s
op	46:13	0:0	6	->
water	46:15	0:0	6	avctx
op	46:20	0:0	6	->
water	46:22	0:0	6	framerate
op	46:31	0:0	6	.
water	46:32	0:0	6	num
op	46:36	0:0	6	&&
water	46:39	0:0	6	4
op	46:40	0:0	6	*
water	46:41	0:0	6	s
op	46:42	0:0	6	->
water	46:44	0:0	6	avctx
op	46:49	0:0	6	->
water	46:51	0:0	6	framerate
op	46:60	0:0	6	.
water	46:61	0:0	6	num
op	46:65	0:0	6	<
water	46:67	0:0	6	1
op	46:68	0:0	6	<<
water	46:70	0:0	6	ctx
op	46:73	0:0	6	->
water	46:75	0:0	6	time_increment_bits
stmts	46:96	49:8	5	
water	46:96	0:0	6	{
water	47:12	0:0	6	s
op	47:13	0:0	6	->
water	47:15	0:0	6	avctx
op	47:20	0:0	6	->
water	47:22	0:0	6	framerate
op	47:31	0:0	6	.
water	47:32	0:0	6	num
op	47:36	0:0	6	=
water	47:38	0:0	6	1
op	47:39	0:0	6	<<
water	47:41	0:0	6	ctx
op	47:44	0:0	6	->
water	47:46	0:0	6	time_increment_bits
water	47:65	0:0	6	;
water	48:12	0:0	6	s
op	48:13	0:0	6	->
water	48:15	0:0	6	avctx
op	48:20	0:0	6	->
water	48:22	0:0	6	time_base
op	48:32	0:0	6	=
call	48:34	48:116	6	av_inv_q
arg	48:43	48:116	7	av_mul_q(s->avctx->framerate,(AVRational){s->avctx->ticks_per_frame,1})
call	48:43	48:115	8	av_mul_q
arg	48:52	48:71	9	s->avctx->framerate
water	48:52	0:0	10	s
op	48:53	0:0	10	->
water	48:55	0:0	10	avctx
op	48:60	0:0	10	->
water	48:62	0:0	10	framerate
arg	48:73	48:115	9	(AVRational){s->avctx->ticks_per_frame,1}
water	48:73	0:0	10	(
water	48:74	0:0	10	AVRational
water	48:84	0:0	10	)
water	48:85	0:0	10	{
water	48:86	0:0	10	s
op	48:87	0:0	10	->
water	48:89	0:0	10	avctx
op	48:94	0:0	10	->
water	48:96	0:0	10	ticks_per_frame
water	48:111	0:0	10	,
water	48:113	0:0	10	1
water	48:114	0:0	10	}
water	48:117	0:0	6	;
water	49:8	0:0	6	}
water	50:4	0:0	4	}
if	52:4	53:38	2	(IS_3IV1)
cond	52:8	52:8	3	IS_3IV1
water	52:8	0:0	4	IS_3IV1
stmts	53:8	53:38	3	
water	53:8	0:0	4	time_increment
op	53:23	0:0	4	=
call	53:25	53:37	4	get_bits1
arg	53:35	53:37	5	gb
water	53:35	0:0	6	gb
water	53:38	0:0	4	;
else	54:4	55:63	2
stmts	55:8	55:63	3	
water	55:8	0:0	4	time_increment
op	55:23	0:0	4	=
call	55:25	55:62	4	get_bits
arg	55:34	55:36	5	gb
water	55:34	0:0	6	gb
arg	55:38	55:62	5	ctx->time_increment_bits
water	55:38	0:0	6	ctx
op	55:41	0:0	6	->
water	55:43	0:0	6	time_increment_bits
water	55:63	0:0	4	;
if	57:4	71:4	2	(s -> pict_type != AV_PICTURE_TYPE_B)
cond	57:8	57:24	3	s -> pict_type != AV_PICTURE_TYPE_B
water	57:8	0:0	4	s
op	57:9	0:0	4	->
water	57:11	0:0	4	pict_type
op	57:21	0:0	4	!=
water	57:24	0:0	4	AV_PICTURE_TYPE_B
stmts	57:43	71:4	3	
water	57:43	0:0	4	{
water	58:8	0:0	4	s
op	58:9	0:0	4	->
water	58:11	0:0	4	last_time_base
op	58:26	0:0	4	=
water	58:28	0:0	4	s
op	58:29	0:0	4	->
water	58:31	0:0	4	time_base
water	58:40	0:0	4	;
water	59:8	0:0	4	s
op	59:9	0:0	4	->
water	59:11	0:0	4	time_base
op	59:25	0:0	4	+=
water	59:28	0:0	4	time_incr
water	59:37	0:0	4	;
water	60:8	0:0	4	s
op	60:9	0:0	4	->
water	60:11	0:0	4	time
op	60:16	0:0	4	=
water	60:18	0:0	4	s
op	60:19	0:0	4	->
water	60:21	0:0	4	time_base
op	60:31	0:0	4	*
water	60:33	0:0	4	(
water	60:34	0:0	4	int64_t
water	60:41	0:0	4	)
water	60:42	0:0	4	s
op	60:43	0:0	4	->
water	60:45	0:0	4	avctx
op	60:50	0:0	4	->
water	60:52	0:0	4	framerate
op	60:61	0:0	4	.
water	60:62	0:0	4	num
op	60:66	0:0	4	+
water	60:68	0:0	4	time_increment
water	60:82	0:0	4	;
if	61:8	68:8	4	(s -> workaround_bugs & FF_BUG_UMP4)
cond	61:12	61:33	5	s -> workaround_bugs & FF_BUG_UMP4
water	61:12	0:0	6	s
op	61:13	0:0	6	->
water	61:15	0:0	6	workaround_bugs
op	61:31	0:0	6	&
water	61:33	0:0	6	FF_BUG_UMP4
stmts	61:46	68:8	5	
water	61:46	0:0	6	{
if	62:12	67:12	6	(s -> time < s -> last_non_b_time)
cond	62:16	62:29	7	s -> time < s -> last_non_b_time
water	62:16	0:0	8	s
op	62:17	0:0	8	->
water	62:19	0:0	8	time
op	62:24	0:0	8	<
water	62:26	0:0	8	s
op	62:27	0:0	8	->
water	62:29	0:0	8	last_non_b_time
stmts	62:46	67:12	7	
water	62:46	0:0	8	{
water	65:16	0:0	8	s
op	65:17	0:0	8	->
water	65:19	0:0	8	time_base
op	65:28	0:0	8	++
water	65:30	0:0	8	;
water	66:16	0:0	8	s
op	66:17	0:0	8	->
water	66:19	0:0	8	time
op	66:24	0:0	8	+=
water	66:27	0:0	8	s
op	66:28	0:0	8	->
water	66:30	0:0	8	avctx
op	66:35	0:0	8	->
water	66:37	0:0	8	framerate
op	66:46	0:0	8	.
water	66:47	0:0	8	num
water	66:50	0:0	8	;
water	67:12	0:0	8	}
water	68:8	0:0	6	}
water	69:8	0:0	4	s
op	69:9	0:0	4	->
water	69:11	0:0	4	pp_time
op	69:27	0:0	4	=
water	69:29	0:0	4	s
op	69:30	0:0	4	->
water	69:32	0:0	4	time
op	69:37	0:0	4	-
water	69:39	0:0	4	s
op	69:40	0:0	4	->
water	69:42	0:0	4	last_non_b_time
water	69:57	0:0	4	;
water	70:8	0:0	4	s
op	70:9	0:0	4	->
water	70:11	0:0	4	last_non_b_time
op	70:27	0:0	4	=
water	70:29	0:0	4	s
op	70:30	0:0	4	->
water	70:32	0:0	4	time
water	70:36	0:0	4	;
water	71:4	0:0	4	}
else	71:6	96:4	2
stmts	71:11	96:4	3	
water	71:11	0:0	4	{
water	72:8	0:0	4	s
op	72:9	0:0	4	->
water	72:11	0:0	4	time
op	72:19	0:0	4	=
water	72:21	0:0	4	(
water	72:22	0:0	4	s
op	72:23	0:0	4	->
water	72:25	0:0	4	last_time_base
op	72:40	0:0	4	+
water	72:42	0:0	4	time_incr
water	72:51	0:0	4	)
op	72:53	0:0	4	*
water	72:55	0:0	4	(
water	72:56	0:0	4	int64_t
water	72:63	0:0	4	)
water	72:64	0:0	4	s
op	72:65	0:0	4	->
water	72:67	0:0	4	avctx
op	72:72	0:0	4	->
water	72:74	0:0	4	framerate
op	72:83	0:0	4	.
water	72:84	0:0	4	num
op	72:88	0:0	4	+
water	72:90	0:0	4	time_increment
water	72:104	0:0	4	;
water	73:8	0:0	4	s
op	73:9	0:0	4	->
water	73:11	0:0	4	pb_time
op	73:19	0:0	4	=
water	73:21	0:0	4	s
op	73:22	0:0	4	->
water	73:24	0:0	4	pp_time
op	73:32	0:0	4	-
water	73:34	0:0	4	(
water	73:35	0:0	4	s
op	73:36	0:0	4	->
water	73:38	0:0	4	last_non_b_time
op	73:54	0:0	4	-
water	73:56	0:0	4	s
op	73:57	0:0	4	->
water	73:59	0:0	4	time
water	73:63	0:0	4	)
water	73:64	0:0	4	;
if	74:8	79:8	4	(s -> pp_time <= s -> pb_time || s -> pp_time <= s -> pp_time - s -> pb_time || s -> pp_time <= 0)
cond	74:12	76:26	5	s -> pp_time <= s -> pb_time || s -> pp_time <= s -> pp_time - s -> pb_time || s -> pp_time <= 0
water	74:12	0:0	6	s
op	74:13	0:0	6	->
water	74:15	0:0	6	pp_time
op	74:23	0:0	6	<=
water	74:26	0:0	6	s
op	74:27	0:0	6	->
water	74:29	0:0	6	pb_time
op	74:37	0:0	6	||
water	75:12	0:0	6	s
op	75:13	0:0	6	->
water	75:15	0:0	6	pp_time
op	75:23	0:0	6	<=
water	75:26	0:0	6	s
op	75:27	0:0	6	->
water	75:29	0:0	6	pp_time
op	75:37	0:0	6	-
water	75:39	0:0	6	s
op	75:40	0:0	6	->
water	75:42	0:0	6	pb_time
op	75:50	0:0	6	||
water	76:12	0:0	6	s
op	76:13	0:0	6	->
water	76:15	0:0	6	pp_time
op	76:23	0:0	6	<=
water	76:26	0:0	6	0
stmts	76:29	79:8	5	
water	76:29	0:0	6	{
return	78:12	78:32	6	FRAME_SKIPPED
water	78:19	0:0	7	FRAME_SKIPPED
water	79:8	0:0	6	}
call	80:8	80:33	4	ff_mpeg4_init_direct_mv
arg	80:32	80:33	5	s
water	80:32	0:0	6	s
water	80:34	0:0	4	;
if	82:8	83:37	4	(ctx -> t_frame == 0)
cond	82:12	82:28	5	ctx -> t_frame == 0
water	82:12	0:0	6	ctx
op	82:15	0:0	6	->
water	82:17	0:0	6	t_frame
op	82:25	0:0	6	==
water	82:28	0:0	6	0
stmts	83:12	83:37	5	
water	83:12	0:0	6	ctx
op	83:15	0:0	6	->
water	83:17	0:0	6	t_frame
op	83:25	0:0	6	=
water	83:27	0:0	6	s
op	83:28	0:0	6	->
water	83:30	0:0	6	pb_time
water	83:37	0:0	6	;
if	84:8	85:28	4	(ctx -> t_frame == 0)
cond	84:12	84:28	5	ctx -> t_frame == 0
water	84:12	0:0	6	ctx
op	84:15	0:0	6	->
water	84:17	0:0	6	t_frame
op	84:25	0:0	6	==
water	84:28	0:0	6	0
stmts	85:12	85:28	5	
water	85:12	0:0	6	ctx
op	85:15	0:0	6	->
water	85:17	0:0	6	t_frame
op	85:25	0:0	6	=
water	85:27	0:0	6	1
water	85:28	0:0	6	;
water	86:8	0:0	4	s
op	86:9	0:0	4	->
water	86:11	0:0	4	pp_field_time
op	86:25	0:0	4	=
water	86:27	0:0	4	(
call	86:28	86:72	4	ROUNDED_DIV
arg	86:40	86:58	5	s->last_non_b_time
water	86:40	0:0	6	s
op	86:41	0:0	6	->
water	86:43	0:0	6	last_non_b_time
arg	86:60	86:72	5	ctx->t_frame
water	86:60	0:0	6	ctx
op	86:63	0:0	6	->
water	86:65	0:0	6	t_frame
op	86:74	0:0	4	-
call	87:28	87:85	4	ROUNDED_DIV
arg	87:40	87:71	5	s->last_non_b_time-s->pp_time
water	87:40	0:0	6	s
op	87:41	0:0	6	->
water	87:43	0:0	6	last_non_b_time
op	87:59	0:0	6	-
water	87:61	0:0	6	s
op	87:62	0:0	6	->
water	87:64	0:0	6	pp_time
arg	87:73	87:85	5	ctx->t_frame
water	87:73	0:0	6	ctx
op	87:76	0:0	6	->
water	87:78	0:0	6	t_frame
water	87:86	0:0	4	)
op	87:88	0:0	4	*
water	87:90	0:0	4	2
water	87:91	0:0	4	;
water	88:8	0:0	4	s
op	88:9	0:0	4	->
water	88:11	0:0	4	pb_field_time
op	88:25	0:0	4	=
water	88:27	0:0	4	(
call	88:28	88:61	4	ROUNDED_DIV
arg	88:40	88:47	5	s->time
water	88:40	0:0	6	s
op	88:41	0:0	6	->
water	88:43	0:0	6	time
arg	88:49	88:61	5	ctx->t_frame
water	88:49	0:0	6	ctx
op	88:52	0:0	6	->
water	88:54	0:0	6	t_frame
op	88:63	0:0	4	-
call	89:28	89:85	4	ROUNDED_DIV
arg	89:40	89:71	5	s->last_non_b_time-s->pp_time
water	89:40	0:0	6	s
op	89:41	0:0	6	->
water	89:43	0:0	6	last_non_b_time
op	89:59	0:0	6	-
water	89:61	0:0	6	s
op	89:62	0:0	6	->
water	89:64	0:0	6	pp_time
arg	89:73	89:85	5	ctx->t_frame
water	89:73	0:0	6	ctx
op	89:76	0:0	6	->
water	89:78	0:0	6	t_frame
water	89:86	0:0	4	)
op	89:88	0:0	4	*
water	89:90	0:0	4	2
water	89:91	0:0	4	;
if	90:8	95:8	4	(s -> pp_field_time <= s -> pb_field_time || s -> pb_field_time <= 1)
cond	90:12	90:72	5	s -> pp_field_time <= s -> pb_field_time || s -> pb_field_time <= 1
water	90:12	0:0	6	s
op	90:13	0:0	6	->
water	90:15	0:0	6	pp_field_time
op	90:29	0:0	6	<=
water	90:32	0:0	6	s
op	90:33	0:0	6	->
water	90:35	0:0	6	pb_field_time
op	90:49	0:0	6	||
water	90:52	0:0	6	s
op	90:53	0:0	6	->
water	90:55	0:0	6	pb_field_time
op	90:69	0:0	6	<=
water	90:72	0:0	6	1
stmts	90:75	95:8	5	
water	90:75	0:0	6	{
water	91:12	0:0	6	s
op	91:13	0:0	6	->
water	91:15	0:0	6	pb_field_time
op	91:29	0:0	6	=
water	91:31	0:0	6	2
water	91:32	0:0	6	;
water	92:12	0:0	6	s
op	92:13	0:0	6	->
water	92:15	0:0	6	pp_field_time
op	92:29	0:0	6	=
water	92:31	0:0	6	4
water	92:32	0:0	6	;
if	93:12	94:36	6	(! s -> progressive_sequence)
cond	93:16	93:20	7	! s -> progressive_sequence
op	93:16	0:0	8	!
water	93:17	0:0	8	s
op	93:18	0:0	8	->
water	93:20	0:0	8	progressive_sequence
stmts	94:16	94:36	7	
return	94:16	94:36	8	FRAME_SKIPPED
water	94:23	0:0	9	FRAME_SKIPPED
water	95:8	0:0	6	}
water	96:4	0:0	4	}
if	98:4	99:59	2	(s -> avctx -> framerate . den)
cond	98:8	98:28	3	s -> avctx -> framerate . den
water	98:8	0:0	4	s
op	98:9	0:0	4	->
water	98:11	0:0	4	avctx
op	98:16	0:0	4	->
water	98:18	0:0	4	framerate
op	98:27	0:0	4	.
water	98:28	0:0	4	den
stmts	99:8	99:59	3	
water	99:8	0:0	4	pts
op	99:12	0:0	4	=
call	99:14	99:58	4	ROUNDED_DIV
arg	99:26	99:33	5	s->time
water	99:26	0:0	6	s
op	99:27	0:0	6	->
water	99:29	0:0	6	time
arg	99:35	99:58	5	s->avctx->framerate.den
water	99:35	0:0	6	s
op	99:36	0:0	6	->
water	99:38	0:0	6	avctx
op	99:43	0:0	6	->
water	99:45	0:0	6	framerate
op	99:54	0:0	6	.
water	99:55	0:0	6	den
water	99:59	0:0	4	;
else	100:4	101:28	2
stmts	101:8	101:28	3	
water	101:8	0:0	4	pts
op	101:12	0:0	4	=
water	101:14	0:0	4	AV_NOPTS_VALUE
water	101:28	0:0	4	;
call	102:4	102:51	2	ff_dlog
arg	102:12	102:20	3	s->avctx
water	102:12	0:0	4	s
op	102:13	0:0	4	->
water	102:15	0:0	4	avctx
arg	102:22	102:46	3	"MPEG4 PTS: %"PRId64"\n"
water	102:22	0:0	4	"MPEG4 PTS: %"
water	102:36	0:0	4	PRId64
water	102:42	0:0	4	"\n"
arg	102:48	102:51	3	pts
water	102:48	0:0	4	pts
water	102:52	0:0	2	;
call	104:4	104:49	2	check_marker
arg	104:17	104:25	3	s->avctx
water	104:17	0:0	4	s
op	104:18	0:0	4	->
water	104:20	0:0	4	avctx
arg	104:27	104:29	3	gb
water	104:27	0:0	4	gb
arg	104:31	104:49	3	"before vop_coded"
water	104:31	0:0	4	"before vop_coded"
water	104:50	0:0	2	;
if	107:4	111:4	2	(get_bits1 (gb ) != 1)
cond	107:8	107:25	3	get_bits1 (gb ) != 1
call	107:8	107:20	4	get_bits1
arg	107:18	107:20	5	gb
water	107:18	0:0	6	gb
op	107:22	0:0	4	!=
water	107:25	0:0	4	1
stmts	107:28	111:4	3	
water	107:28	0:0	4	{
if	108:8	109:61	4	(s -> avctx -> debug & FF_DEBUG_PICT_INFO)
cond	108:12	108:30	5	s -> avctx -> debug & FF_DEBUG_PICT_INFO
water	108:12	0:0	6	s
op	108:13	0:0	6	->
water	108:15	0:0	6	avctx
op	108:20	0:0	6	->
water	108:22	0:0	6	debug
op	108:28	0:0	6	&
water	108:30	0:0	6	FF_DEBUG_PICT_INFO
stmts	109:12	109:61	5	
call	109:12	109:60	6	av_log
arg	109:19	109:27	7	s->avctx
water	109:19	0:0	8	s
op	109:20	0:0	8	->
water	109:22	0:0	8	avctx
arg	109:29	109:41	7	AV_LOG_ERROR
water	109:29	0:0	8	AV_LOG_ERROR
arg	109:43	109:60	7	"vop not coded\n"
water	109:43	0:0	8	"vop not coded\n"
water	109:61	0:0	6	;
return	110:8	110:28	4	FRAME_SKIPPED
water	110:15	0:0	5	FRAME_SKIPPED
water	111:4	0:0	4	}
if	112:4	113:32	2	(ctx -> new_pred)
cond	112:8	112:13	3	ctx -> new_pred
water	112:8	0:0	4	ctx
op	112:11	0:0	4	->
water	112:13	0:0	4	new_pred
stmts	113:8	113:32	3	
call	113:8	113:31	4	decode_new_pred
arg	113:24	113:27	5	ctx
water	113:24	0:0	6	ctx
arg	113:29	113:31	5	gb
water	113:29	0:0	6	gb
water	113:32	0:0	4	;
if	115:4	121:4	2	(ctx -> shape != BIN_ONLY_SHAPE && ( s -> pict_type == AV_PICTURE_TYPE_P || ( s -> pict_type == AV_PICTURE_TYPE_S && ctx -> vol_sprite_usage == GMC_SPRITE ) ))
cond	115:8	118:58	3	ctx -> shape != BIN_ONLY_SHAPE && ( s -> pict_type == AV_PICTURE_TYPE_P || ( s -> pict_type == AV_PICTURE_TYPE_S && ctx -> vol_sprite_usage == GMC_SPRITE ) )
water	115:8	0:0	4	ctx
op	115:11	0:0	4	->
water	115:13	0:0	4	shape
op	115:19	0:0	4	!=
water	115:22	0:0	4	BIN_ONLY_SHAPE
op	115:37	0:0	4	&&
water	116:20	0:0	4	(
water	116:21	0:0	4	s
op	116:22	0:0	4	->
water	116:24	0:0	4	pict_type
op	116:34	0:0	4	==
water	116:37	0:0	4	AV_PICTURE_TYPE_P
op	116:55	0:0	4	||
water	117:21	0:0	4	(
water	117:22	0:0	4	s
op	117:23	0:0	4	->
water	117:25	0:0	4	pict_type
op	117:35	0:0	4	==
water	117:38	0:0	4	AV_PICTURE_TYPE_S
op	117:56	0:0	4	&&
water	118:22	0:0	4	ctx
op	118:25	0:0	4	->
water	118:27	0:0	4	vol_sprite_usage
op	118:44	0:0	4	==
water	118:47	0:0	4	GMC_SPRITE
water	118:57	0:0	4	)
water	118:58	0:0	4	)
stmts	118:61	121:4	3	
water	118:61	0:0	4	{
water	120:8	0:0	4	s
op	120:9	0:0	4	->
water	120:11	0:0	4	no_rounding
op	120:23	0:0	4	=
call	120:25	120:37	4	get_bits1
arg	120:35	120:37	5	gb
water	120:35	0:0	6	gb
water	120:38	0:0	4	;
water	121:4	0:0	4	}
else	121:6	123:4	2
stmts	121:11	123:4	3	
water	121:11	0:0	4	{
water	122:8	0:0	4	s
op	122:9	0:0	4	->
water	122:11	0:0	4	no_rounding
op	122:23	0:0	4	=
water	122:25	0:0	4	0
water	122:26	0:0	4	;
water	123:4	0:0	4	}
if	126:4	140:4	2	(ctx -> shape != RECT_SHAPE)
cond	126:8	126:22	3	ctx -> shape != RECT_SHAPE
water	126:8	0:0	4	ctx
op	126:11	0:0	4	->
water	126:13	0:0	4	shape
op	126:19	0:0	4	!=
water	126:22	0:0	4	RECT_SHAPE
stmts	126:34	140:4	3	
water	126:34	0:0	4	{
if	127:8	135:8	4	(ctx -> vol_sprite_usage != 1 || s -> pict_type != AV_PICTURE_TYPE_I)
cond	127:12	127:58	5	ctx -> vol_sprite_usage != 1 || s -> pict_type != AV_PICTURE_TYPE_I
water	127:12	0:0	6	ctx
op	127:15	0:0	6	->
water	127:17	0:0	6	vol_sprite_usage
op	127:34	0:0	6	!=
water	127:37	0:0	6	1
op	127:39	0:0	6	||
water	127:42	0:0	6	s
op	127:43	0:0	6	->
water	127:45	0:0	6	pict_type
op	127:55	0:0	6	!=
water	127:58	0:0	6	AV_PICTURE_TYPE_I
stmts	127:77	135:8	5	
water	127:77	0:0	6	{
call	128:12	128:28	6	skip_bits
arg	128:22	128:24	7	gb
water	128:22	0:0	8	gb
arg	128:26	128:28	7	13
water	128:26	0:0	8	13
water	128:29	0:0	6	;
call	129:12	129:52	6	check_marker
arg	129:25	129:33	7	s->avctx
water	129:25	0:0	8	s
op	129:26	0:0	8	->
water	129:28	0:0	8	avctx
arg	129:35	129:37	7	gb
water	129:35	0:0	8	gb
arg	129:39	129:52	7	"after width"
water	129:39	0:0	8	"after width"
water	129:53	0:0	6	;
call	130:12	130:28	6	skip_bits
arg	130:22	130:24	7	gb
water	130:22	0:0	8	gb
arg	130:26	130:28	7	13
water	130:26	0:0	8	13
water	130:29	0:0	6	;
call	131:12	131:53	6	check_marker
arg	131:25	131:33	7	s->avctx
water	131:25	0:0	8	s
op	131:26	0:0	8	->
water	131:28	0:0	8	avctx
arg	131:35	131:37	7	gb
water	131:35	0:0	8	gb
arg	131:39	131:53	7	"after height"
water	131:39	0:0	8	"after height"
water	131:54	0:0	6	;
call	132:12	132:28	6	skip_bits
arg	132:22	132:24	7	gb
water	132:22	0:0	8	gb
arg	132:26	132:28	7	13
water	132:26	0:0	8	13
water	132:29	0:0	6	;
call	133:12	133:59	6	check_marker
arg	133:25	133:33	7	s->avctx
water	133:25	0:0	8	s
op	133:26	0:0	8	->
water	133:28	0:0	8	avctx
arg	133:35	133:37	7	gb
water	133:35	0:0	8	gb
arg	133:39	133:59	7	"after hor_spat_ref"
water	133:39	0:0	8	"after hor_spat_ref"
water	133:60	0:0	6	;
call	134:12	134:28	6	skip_bits
arg	134:22	134:24	7	gb
water	134:22	0:0	8	gb
arg	134:26	134:28	7	13
water	134:26	0:0	8	13
water	134:29	0:0	6	;
water	135:8	0:0	6	}
call	136:8	136:21	4	skip_bits1
arg	136:19	136:21	5	gb
water	136:19	0:0	6	gb
water	136:22	0:0	4	;
if	138:8	139:28	4	(get_bits1 (gb ) != 0)
cond	138:12	138:29	5	get_bits1 (gb ) != 0
call	138:12	138:24	6	get_bits1
arg	138:22	138:24	7	gb
water	138:22	0:0	8	gb
op	138:26	0:0	6	!=
water	138:29	0:0	6	0
stmts	139:12	139:28	5	
call	139:12	139:27	6	skip_bits
arg	139:22	139:24	7	gb
water	139:22	0:0	8	gb
arg	139:26	139:27	7	8
water	139:26	0:0	8	8
water	139:28	0:0	6	;
water	140:4	0:0	4	}
if	144:4	161:4	2	(ctx -> shape != BIN_ONLY_SHAPE)
cond	144:8	144:22	3	ctx -> shape != BIN_ONLY_SHAPE
water	144:8	0:0	4	ctx
op	144:11	0:0	4	->
water	144:13	0:0	4	shape
op	144:19	0:0	4	!=
water	144:22	0:0	4	BIN_ONLY_SHAPE
stmts	144:38	161:4	3	
water	144:38	0:0	4	{
call	145:8	145:55	4	skip_bits_long
arg	145:23	145:25	5	gb
water	145:23	0:0	6	gb
arg	145:27	145:55	5	ctx->cplx_estimation_trash_i
water	145:27	0:0	6	ctx
op	145:30	0:0	6	->
water	145:32	0:0	6	cplx_estimation_trash_i
water	145:56	0:0	4	;
if	146:8	147:60	4	(s -> pict_type != AV_PICTURE_TYPE_I)
cond	146:12	146:28	5	s -> pict_type != AV_PICTURE_TYPE_I
water	146:12	0:0	6	s
op	146:13	0:0	6	->
water	146:15	0:0	6	pict_type
op	146:25	0:0	6	!=
water	146:28	0:0	6	AV_PICTURE_TYPE_I
stmts	147:12	147:60	5	
call	147:12	147:59	6	skip_bits_long
arg	147:27	147:29	7	gb
water	147:27	0:0	8	gb
arg	147:31	147:59	7	ctx->cplx_estimation_trash_p
water	147:31	0:0	8	ctx
op	147:34	0:0	8	->
water	147:36	0:0	8	cplx_estimation_trash_p
water	147:60	0:0	6	;
if	148:8	149:60	4	(s -> pict_type == AV_PICTURE_TYPE_B)
cond	148:12	148:28	5	s -> pict_type == AV_PICTURE_TYPE_B
water	148:12	0:0	6	s
op	148:13	0:0	6	->
water	148:15	0:0	6	pict_type
op	148:25	0:0	6	==
water	148:28	0:0	6	AV_PICTURE_TYPE_B
stmts	149:12	149:60	5	
call	149:12	149:59	6	skip_bits_long
arg	149:27	149:29	7	gb
water	149:27	0:0	8	gb
arg	149:31	149:59	7	ctx->cplx_estimation_trash_b
water	149:31	0:0	8	ctx
op	149:34	0:0	8	->
water	149:36	0:0	8	cplx_estimation_trash_b
water	149:60	0:0	6	;
if	151:8	154:8	4	(get_bits_left (gb ) < 3)
cond	151:12	151:32	5	get_bits_left (gb ) < 3
call	151:12	151:28	6	get_bits_left
arg	151:26	151:28	7	gb
water	151:26	0:0	8	gb
op	151:30	0:0	6	<
water	151:32	0:0	6	3
stmts	151:35	154:8	5	
water	151:35	0:0	6	{
call	152:12	152:63	6	av_log
arg	152:19	152:27	7	s->avctx
water	152:19	0:0	8	s
op	152:20	0:0	8	->
water	152:22	0:0	8	avctx
arg	152:29	152:41	7	AV_LOG_ERROR
water	152:29	0:0	8	AV_LOG_ERROR
arg	152:43	152:63	7	"Header truncated\n"
water	152:43	0:0	8	"Header truncated\n"
water	152:64	0:0	6	;
return	153:12	153:38	6	AVERROR_INVALIDDATA
water	153:19	0:0	7	AVERROR_INVALIDDATA
water	154:8	0:0	6	}
water	155:8	0:0	4	ctx
op	155:11	0:0	4	->
water	155:13	0:0	4	intra_dc_threshold
op	155:32	0:0	4	=
water	155:34	0:0	4	ff_mpeg4_dc_threshold
op	155:55	0:0	4	[
call	155:56	155:70	4	get_bits
arg	155:65	155:67	5	gb
water	155:65	0:0	6	gb
arg	155:69	155:70	5	3
water	155:69	0:0	6	3
op	155:71	0:0	4	]
water	155:72	0:0	4	;
if	156:8	159:8	4	(! s -> progressive_sequence)
cond	156:12	156:16	5	! s -> progressive_sequence
op	156:12	0:0	6	!
water	156:13	0:0	6	s
op	156:14	0:0	6	->
water	156:16	0:0	6	progressive_sequence
stmts	156:38	159:8	5	
water	156:38	0:0	6	{
water	157:12	0:0	6	s
op	157:13	0:0	6	->
water	157:15	0:0	6	top_field_first
op	157:31	0:0	6	=
call	157:33	157:45	6	get_bits1
arg	157:43	157:45	7	gb
water	157:43	0:0	8	gb
water	157:46	0:0	6	;
water	158:12	0:0	6	s
op	158:13	0:0	6	->
water	158:15	0:0	6	alternate_scan
op	158:31	0:0	6	=
call	158:33	158:45	6	get_bits1
arg	158:43	158:45	7	gb
water	158:43	0:0	8	gb
water	158:46	0:0	6	;
water	159:8	0:0	6	}
else	159:10	160:33	4
stmts	160:12	160:33	5	
water	160:12	0:0	6	s
op	160:13	0:0	6	->
water	160:15	0:0	6	alternate_scan
op	160:30	0:0	6	=
water	160:32	0:0	6	0
water	160:33	0:0	6	;
water	161:4	0:0	4	}
if	163:4	168:4	2	(s -> alternate_scan)
cond	163:8	163:11	3	s -> alternate_scan
water	163:8	0:0	4	s
op	163:9	0:0	4	->
water	163:11	0:0	4	alternate_scan
stmts	163:27	168:4	3	
water	163:27	0:0	4	{
call	164:8	164:101	4	ff_init_scantable
arg	164:26	164:50	5	s->idsp.idct_permutation
water	164:26	0:0	6	s
op	164:27	0:0	6	->
water	164:29	0:0	6	idsp
op	164:33	0:0	6	.
water	164:34	0:0	6	idct_permutation
arg	164:52	164:71	5	&s->inter_scantable
op	164:52	0:0	6	&
water	164:53	0:0	6	s
op	164:54	0:0	6	->
water	164:56	0:0	6	inter_scantable
arg	164:75	164:101	5	ff_alternate_vertical_scan
water	164:75	0:0	6	ff_alternate_vertical_scan
water	164:102	0:0	4	;
call	165:8	165:101	4	ff_init_scantable
arg	165:26	165:50	5	s->idsp.idct_permutation
water	165:26	0:0	6	s
op	165:27	0:0	6	->
water	165:29	0:0	6	idsp
op	165:33	0:0	6	.
water	165:34	0:0	6	idct_permutation
arg	165:52	165:71	5	&s->intra_scantable
op	165:52	0:0	6	&
water	165:53	0:0	6	s
op	165:54	0:0	6	->
water	165:56	0:0	6	intra_scantable
arg	165:75	165:101	5	ff_alternate_vertical_scan
water	165:75	0:0	6	ff_alternate_vertical_scan
water	165:102	0:0	4	;
call	166:8	166:101	4	ff_init_scantable
arg	166:26	166:50	5	s->idsp.idct_permutation
water	166:26	0:0	6	s
op	166:27	0:0	6	->
water	166:29	0:0	6	idsp
op	166:33	0:0	6	.
water	166:34	0:0	6	idct_permutation
arg	166:52	166:73	5	&s->intra_h_scantable
op	166:52	0:0	6	&
water	166:53	0:0	6	s
op	166:54	0:0	6	->
water	166:56	0:0	6	intra_h_scantable
arg	166:75	166:101	5	ff_alternate_vertical_scan
water	166:75	0:0	6	ff_alternate_vertical_scan
water	166:102	0:0	4	;
call	167:8	167:101	4	ff_init_scantable
arg	167:26	167:50	5	s->idsp.idct_permutation
water	167:26	0:0	6	s
op	167:27	0:0	6	->
water	167:29	0:0	6	idsp
op	167:33	0:0	6	.
water	167:34	0:0	6	idct_permutation
arg	167:52	167:73	5	&s->intra_v_scantable
op	167:52	0:0	6	&
water	167:53	0:0	6	s
op	167:54	0:0	6	->
water	167:56	0:0	6	intra_v_scantable
arg	167:75	167:101	5	ff_alternate_vertical_scan
water	167:75	0:0	6	ff_alternate_vertical_scan
water	167:102	0:0	4	;
water	168:4	0:0	4	}
else	168:6	173:4	2
stmts	168:11	173:4	3	
water	168:11	0:0	4	{
call	169:8	169:91	4	ff_init_scantable
arg	169:26	169:50	5	s->idsp.idct_permutation
water	169:26	0:0	6	s
op	169:27	0:0	6	->
water	169:29	0:0	6	idsp
op	169:33	0:0	6	.
water	169:34	0:0	6	idct_permutation
arg	169:52	169:71	5	&s->inter_scantable
op	169:52	0:0	6	&
water	169:53	0:0	6	s
op	169:54	0:0	6	->
water	169:56	0:0	6	inter_scantable
arg	169:75	169:91	5	ff_zigzag_direct
water	169:75	0:0	6	ff_zigzag_direct
water	169:92	0:0	4	;
call	170:8	170:91	4	ff_init_scantable
arg	170:26	170:50	5	s->idsp.idct_permutation
water	170:26	0:0	6	s
op	170:27	0:0	6	->
water	170:29	0:0	6	idsp
op	170:33	0:0	6	.
water	170:34	0:0	6	idct_permutation
arg	170:52	170:71	5	&s->intra_scantable
op	170:52	0:0	6	&
water	170:53	0:0	6	s
op	170:54	0:0	6	->
water	170:56	0:0	6	intra_scantable
arg	170:75	170:91	5	ff_zigzag_direct
water	170:75	0:0	6	ff_zigzag_direct
water	170:92	0:0	4	;
call	171:8	171:103	4	ff_init_scantable
arg	171:26	171:50	5	s->idsp.idct_permutation
water	171:26	0:0	6	s
op	171:27	0:0	6	->
water	171:29	0:0	6	idsp
op	171:33	0:0	6	.
water	171:34	0:0	6	idct_permutation
arg	171:52	171:73	5	&s->intra_h_scantable
op	171:52	0:0	6	&
water	171:53	0:0	6	s
op	171:54	0:0	6	->
water	171:56	0:0	6	intra_h_scantable
arg	171:75	171:103	5	ff_alternate_horizontal_scan
water	171:75	0:0	6	ff_alternate_horizontal_scan
water	171:104	0:0	4	;
call	172:8	172:101	4	ff_init_scantable
arg	172:26	172:50	5	s->idsp.idct_permutation
water	172:26	0:0	6	s
op	172:27	0:0	6	->
water	172:29	0:0	6	idsp
op	172:33	0:0	6	.
water	172:34	0:0	6	idct_permutation
arg	172:52	172:73	5	&s->intra_v_scantable
op	172:52	0:0	6	&
water	172:53	0:0	6	s
op	172:54	0:0	6	->
water	172:56	0:0	6	intra_v_scantable
arg	172:75	172:101	5	ff_alternate_vertical_scan
water	172:75	0:0	6	ff_alternate_vertical_scan
water	172:102	0:0	4	;
water	173:4	0:0	4	}
if	175:4	189:4	2	(s -> pict_type == AV_PICTURE_TYPE_S)
cond	175:8	175:24	3	s -> pict_type == AV_PICTURE_TYPE_S
water	175:8	0:0	4	s
op	175:9	0:0	4	->
water	175:11	0:0	4	pict_type
op	175:21	0:0	4	==
water	175:24	0:0	4	AV_PICTURE_TYPE_S
stmts	175:43	189:4	3	
water	175:43	0:0	4	{
if	176:8	185:8	4	(( ctx -> vol_sprite_usage == STATIC_SPRITE || ctx -> vol_sprite_usage == GMC_SPRITE ))
cond	176:11	177:47	5	( ctx -> vol_sprite_usage == STATIC_SPRITE || ctx -> vol_sprite_usage == GMC_SPRITE )
water	176:11	0:0	6	(
water	176:12	0:0	6	ctx
op	176:15	0:0	6	->
water	176:17	0:0	6	vol_sprite_usage
op	176:34	0:0	6	==
water	176:37	0:0	6	STATIC_SPRITE
op	176:51	0:0	6	||
water	177:12	0:0	6	ctx
op	177:15	0:0	6	->
water	177:17	0:0	6	vol_sprite_usage
op	177:34	0:0	6	==
water	177:37	0:0	6	GMC_SPRITE
water	177:47	0:0	6	)
stmts	177:50	185:8	5	
water	177:50	0:0	6	{
if	178:12	179:42	6	(mpeg4_decode_sprite_trajectory (ctx ,gb ) < 0)
cond	178:16	178:58	7	mpeg4_decode_sprite_trajectory (ctx ,gb ) < 0
call	178:16	178:54	8	mpeg4_decode_sprite_trajectory
arg	178:47	178:50	9	ctx
water	178:47	0:0	10	ctx
arg	178:52	178:54	9	gb
water	178:52	0:0	10	gb
op	178:56	0:0	8	<
water	178:58	0:0	8	0
stmts	179:16	179:42	7	
return	179:16	179:42	8	AVERROR_INVALIDDATA
water	179:23	0:0	9	AVERROR_INVALIDDATA
if	180:12	182:63	6	(ctx -> sprite_brightness_change)
cond	180:16	180:21	7	ctx -> sprite_brightness_change
water	180:16	0:0	8	ctx
op	180:19	0:0	8	->
water	180:21	0:0	8	sprite_brightness_change
stmts	181:16	182:63	7	
call	181:16	182:62	8	av_log
arg	181:23	181:31	9	s->avctx
water	181:23	0:0	10	s
op	181:24	0:0	10	->
water	181:26	0:0	10	avctx
arg	181:33	181:45	9	AV_LOG_ERROR
water	181:33	0:0	10	AV_LOG_ERROR
arg	182:20	182:62	9	"sprite_brightness_change not supported\n"
water	182:20	0:0	10	"sprite_brightness_change not supported\n"
water	182:63	0:0	8	;
if	183:12	184:79	6	(ctx -> vol_sprite_usage == STATIC_SPRITE)
cond	183:16	183:41	7	ctx -> vol_sprite_usage == STATIC_SPRITE
water	183:16	0:0	8	ctx
op	183:19	0:0	8	->
water	183:21	0:0	8	vol_sprite_usage
op	183:38	0:0	8	==
water	183:41	0:0	8	STATIC_SPRITE
stmts	184:16	184:79	7	
call	184:16	184:78	8	av_log
arg	184:23	184:31	9	s->avctx
water	184:23	0:0	10	s
op	184:24	0:0	10	->
water	184:26	0:0	10	avctx
arg	184:33	184:45	9	AV_LOG_ERROR
water	184:33	0:0	10	AV_LOG_ERROR
arg	184:47	184:78	9	"static sprite not supported\n"
water	184:47	0:0	10	"static sprite not supported\n"
water	184:79	0:0	8	;
water	185:8	0:0	6	}
else	185:10	188:8	4
stmts	185:15	188:8	5	
water	185:15	0:0	6	{
call	186:12	186:64	6	memset
arg	186:19	186:35	7	s->sprite_offset
water	186:19	0:0	8	s
op	186:20	0:0	8	->
water	186:22	0:0	8	sprite_offset
arg	186:37	186:38	7	0
water	186:37	0:0	8	0
arg	186:40	186:64	7	sizeof(s->sprite_offset)
op	186:40	0:0	8	sizeof
water	186:46	0:0	8	(
water	186:47	0:0	8	s
op	186:48	0:0	8	->
water	186:50	0:0	8	sprite_offset
water	186:63	0:0	8	)
water	186:65	0:0	6	;
call	187:12	187:62	6	memset
arg	187:19	187:34	7	s->sprite_delta
water	187:19	0:0	8	s
op	187:20	0:0	8	->
water	187:22	0:0	8	sprite_delta
arg	187:36	187:37	7	0
water	187:36	0:0	8	0
arg	187:39	187:62	7	sizeof(s->sprite_delta)
op	187:39	0:0	8	sizeof
water	187:45	0:0	8	(
water	187:46	0:0	8	s
op	187:47	0:0	8	->
water	187:49	0:0	8	sprite_delta
water	187:61	0:0	8	)
water	187:63	0:0	6	;
water	188:8	0:0	6	}
water	189:4	0:0	4	}
if	191:4	251:4	2	(ctx -> shape != BIN_ONLY_SHAPE)
cond	191:8	191:22	3	ctx -> shape != BIN_ONLY_SHAPE
water	191:8	0:0	4	ctx
op	191:11	0:0	4	->
water	191:13	0:0	4	shape
op	191:19	0:0	4	!=
water	191:22	0:0	4	BIN_ONLY_SHAPE
stmts	191:38	251:4	3	
water	191:38	0:0	4	{
water	192:8	0:0	4	s
op	192:9	0:0	4	->
water	192:11	0:0	4	chroma_qscale
op	192:25	0:0	4	=
water	192:27	0:0	4	s
op	192:28	0:0	4	->
water	192:30	0:0	4	qscale
op	192:37	0:0	4	=
call	192:39	192:70	4	get_bits
arg	192:48	192:50	5	gb
water	192:48	0:0	6	gb
arg	192:52	192:70	5	s->quant_precision
water	192:52	0:0	6	s
op	192:53	0:0	6	->
water	192:55	0:0	6	quant_precision
water	192:71	0:0	4	;
if	193:8	197:8	4	(s -> qscale == 0)
cond	193:12	193:25	5	s -> qscale == 0
water	193:12	0:0	6	s
op	193:13	0:0	6	->
water	193:15	0:0	6	qscale
op	193:22	0:0	6	==
water	193:25	0:0	6	0
stmts	193:28	197:8	5	
water	193:28	0:0	6	{
call	194:12	195:76	6	av_log
arg	194:19	194:27	7	s->avctx
water	194:19	0:0	8	s
op	194:20	0:0	8	->
water	194:22	0:0	8	avctx
arg	194:29	194:41	7	AV_LOG_ERROR
water	194:29	0:0	8	AV_LOG_ERROR
arg	195:19	195:76	7	"Error, header damaged or not MPEG-4 header (qscale=0)\n"
water	195:19	0:0	8	"Error, header damaged or not MPEG-4 header (qscale=0)\n"
water	195:77	0:0	6	;
return	196:12	196:38	6	AVERROR_INVALIDDATA
water	196:19	0:0	7	AVERROR_INVALIDDATA
water	197:8	0:0	6	}
if	199:8	207:8	4	(s -> pict_type != AV_PICTURE_TYPE_I)
cond	199:12	199:28	5	s -> pict_type != AV_PICTURE_TYPE_I
water	199:12	0:0	6	s
op	199:13	0:0	6	->
water	199:15	0:0	6	pict_type
op	199:25	0:0	6	!=
water	199:28	0:0	6	AV_PICTURE_TYPE_I
stmts	199:47	207:8	5	
water	199:47	0:0	6	{
water	200:12	0:0	6	s
op	200:13	0:0	6	->
water	200:15	0:0	6	f_code
op	200:22	0:0	6	=
call	200:24	200:38	6	get_bits
arg	200:33	200:35	7	gb
water	200:33	0:0	8	gb
arg	200:37	200:38	7	3
water	200:37	0:0	8	3
water	200:39	0:0	6	;
if	201:12	206:12	6	(s -> f_code == 0)
cond	201:16	201:29	7	s -> f_code == 0
water	201:16	0:0	8	s
op	201:17	0:0	8	->
water	201:19	0:0	8	f_code
op	201:26	0:0	8	==
water	201:29	0:0	8	0
stmts	201:32	206:12	7	
water	201:32	0:0	8	{
call	202:16	203:80	8	av_log
arg	202:23	202:31	9	s->avctx
water	202:23	0:0	10	s
op	202:24	0:0	10	->
water	202:26	0:0	10	avctx
arg	202:33	202:45	9	AV_LOG_ERROR
water	202:33	0:0	10	AV_LOG_ERROR
arg	203:23	203:80	9	"Error, header damaged or not MPEG-4 header (f_code=0)\n"
water	203:23	0:0	10	"Error, header damaged or not MPEG-4 header (f_code=0)\n"
water	203:81	0:0	8	;
water	204:16	0:0	8	s
op	204:17	0:0	8	->
water	204:19	0:0	8	f_code
op	204:26	0:0	8	=
water	204:28	0:0	8	1
water	204:29	0:0	8	;
return	205:16	205:42	8	AVERROR_INVALIDDATA
water	205:23	0:0	9	AVERROR_INVALIDDATA
water	206:12	0:0	8	}
water	207:8	0:0	6	}
else	207:10	208:25	4
stmts	208:12	208:25	5	
water	208:12	0:0	6	s
op	208:13	0:0	6	->
water	208:15	0:0	6	f_code
op	208:22	0:0	6	=
water	208:24	0:0	6	1
water	208:25	0:0	6	;
if	210:8	218:8	4	(s -> pict_type == AV_PICTURE_TYPE_B)
cond	210:12	210:28	5	s -> pict_type == AV_PICTURE_TYPE_B
water	210:12	0:0	6	s
op	210:13	0:0	6	->
water	210:15	0:0	6	pict_type
op	210:25	0:0	6	==
water	210:28	0:0	6	AV_PICTURE_TYPE_B
stmts	210:47	218:8	5	
water	210:47	0:0	6	{
water	211:12	0:0	6	s
op	211:13	0:0	6	->
water	211:15	0:0	6	b_code
op	211:22	0:0	6	=
call	211:24	211:38	6	get_bits
arg	211:33	211:35	7	gb
water	211:33	0:0	8	gb
arg	211:37	211:38	7	3
water	211:37	0:0	8	3
water	211:39	0:0	6	;
if	212:12	217:12	6	(s -> b_code == 0)
cond	212:16	212:29	7	s -> b_code == 0
water	212:16	0:0	8	s
op	212:17	0:0	8	->
water	212:19	0:0	8	b_code
op	212:26	0:0	8	==
water	212:29	0:0	8	0
stmts	212:32	217:12	7	
water	212:32	0:0	8	{
call	213:16	214:79	8	av_log
arg	213:23	213:31	9	s->avctx
water	213:23	0:0	10	s
op	213:24	0:0	10	->
water	213:26	0:0	10	avctx
arg	213:33	213:45	9	AV_LOG_ERROR
water	213:33	0:0	10	AV_LOG_ERROR
arg	214:23	214:79	9	"Error, header damaged or not MPEG4 header (b_code=0)\n"
water	214:23	0:0	10	"Error, header damaged or not MPEG4 header (b_code=0)\n"
water	214:80	0:0	8	;
water	215:16	0:0	8	s
op	215:17	0:0	8	->
water	215:19	0:0	8	b_code
op	215:25	0:0	8	=
water	215:26	0:0	8	1
water	215:27	0:0	8	;
return	216:16	216:42	8	AVERROR_INVALIDDATA
water	216:23	0:0	9	AVERROR_INVALIDDATA
water	217:12	0:0	8	}
water	218:8	0:0	6	}
else	218:10	219:25	4
stmts	219:12	219:25	5	
water	219:12	0:0	6	s
op	219:13	0:0	6	->
water	219:15	0:0	6	b_code
op	219:22	0:0	6	=
water	219:24	0:0	6	1
water	219:25	0:0	6	;
if	221:8	237:8	4	(s -> avctx -> debug & FF_DEBUG_PICT_INFO)
cond	221:12	221:30	5	s -> avctx -> debug & FF_DEBUG_PICT_INFO
water	221:12	0:0	6	s
op	221:13	0:0	6	->
water	221:15	0:0	6	avctx
op	221:20	0:0	6	->
water	221:22	0:0	6	debug
op	221:28	0:0	6	&
water	221:30	0:0	6	FF_DEBUG_PICT_INFO
stmts	221:50	237:8	5	
water	221:50	0:0	6	{
call	222:12	236:18	6	av_log
arg	222:19	222:27	7	s->avctx
water	222:19	0:0	8	s
op	222:20	0:0	8	->
water	222:22	0:0	8	avctx
arg	222:29	222:41	7	AV_LOG_DEBUG
water	222:29	0:0	8	AV_LOG_DEBUG
arg	223:19	223:161	7	"qp:%d fc:%d,%d %s size:%d pro:%d alt:%d top:%d %spel part:%d resync:%d w:%d a:%d rnd:%d vot:%d%s dc:%d ce:%d/%d/%d time:%"PRId64" tincr:%d\n"
water	223:19	0:0	8	"qp:%d fc:%d,%d %s size:%d pro:%d alt:%d top:%d %spel part:%d resync:%d w:%d a:%d rnd:%d vot:%d%s dc:%d ce:%d/%d/%d time:%"
water	223:142	0:0	8	PRId64
water	223:148	0:0	8	" tincr:%d\n"
arg	224:19	224:28	7	s->qscale
water	224:19	0:0	8	s
op	224:20	0:0	8	->
water	224:22	0:0	8	qscale
arg	224:30	224:39	7	s->f_code
water	224:30	0:0	8	s
op	224:31	0:0	8	->
water	224:33	0:0	8	f_code
arg	224:41	224:50	7	s->b_code
water	224:41	0:0	8	s
op	224:42	0:0	8	->
water	224:44	0:0	8	b_code
arg	225:19	225:152	7	s->pict_type==AV_PICTURE_TYPE_I?"I":(s->pict_type==AV_PICTURE_TYPE_P?"P":(s->pict_type==AV_PICTURE_TYPE_B?"B":"S"))
water	225:19	0:0	8	s
op	225:20	0:0	8	->
water	225:22	0:0	8	pict_type
op	225:32	0:0	8	==
water	225:35	0:0	8	AV_PICTURE_TYPE_I
water	225:53	0:0	8	?
water	225:55	0:0	8	"I"
water	225:59	0:0	8	:
water	225:61	0:0	8	(
water	225:62	0:0	8	s
op	225:63	0:0	8	->
water	225:65	0:0	8	pict_type
op	225:75	0:0	8	==
water	225:78	0:0	8	AV_PICTURE_TYPE_P
water	225:96	0:0	8	?
water	225:98	0:0	8	"P"
water	225:102	0:0	8	:
water	225:104	0:0	8	(
water	225:105	0:0	8	s
op	225:106	0:0	8	->
water	225:108	0:0	8	pict_type
op	225:118	0:0	8	==
water	225:121	0:0	8	AV_PICTURE_TYPE_B
water	225:139	0:0	8	?
water	225:141	0:0	8	"B"
water	225:145	0:0	8	:
water	225:147	0:0	8	"S"
water	225:150	0:0	8	)
water	225:151	0:0	8	)
arg	226:19	226:35	7	gb->size_in_bits
water	226:19	0:0	8	gb
op	226:21	0:0	8	->
water	226:23	0:0	8	size_in_bits
arg	226:36	226:59	7	s->progressive_sequence
water	226:36	0:0	8	s
op	226:37	0:0	8	->
water	226:39	0:0	8	progressive_sequence
arg	226:61	226:78	7	s->alternate_scan
water	226:61	0:0	8	s
op	226:62	0:0	8	->
water	226:64	0:0	8	alternate_scan
arg	227:19	227:37	7	s->top_field_first
water	227:19	0:0	8	s
op	227:20	0:0	8	->
water	227:22	0:0	8	top_field_first
arg	227:39	227:68	7	s->quarter_sample?"q":"h"
water	227:39	0:0	8	s
op	227:40	0:0	8	->
water	227:42	0:0	8	quarter_sample
water	227:57	0:0	8	?
water	227:59	0:0	8	"q"
water	227:63	0:0	8	:
water	227:65	0:0	8	"h"
arg	228:19	228:39	7	s->data_partitioning
water	228:19	0:0	8	s
op	228:20	0:0	8	->
water	228:22	0:0	8	data_partitioning
arg	228:41	228:59	7	ctx->resync_marker
water	228:41	0:0	8	ctx
op	228:44	0:0	8	->
water	228:46	0:0	8	resync_marker
arg	229:19	229:49	7	ctx->num_sprite_warping_points
water	229:19	0:0	8	ctx
op	229:22	0:0	8	->
water	229:24	0:0	8	num_sprite_warping_points
arg	229:51	229:77	7	s->sprite_warping_accuracy
water	229:51	0:0	8	s
op	229:52	0:0	8	->
water	229:54	0:0	8	sprite_warping_accuracy
arg	230:19	230:37	7	1-s->no_rounding
water	230:19	0:0	8	1
op	230:21	0:0	8	-
water	230:23	0:0	8	s
op	230:24	0:0	8	->
water	230:26	0:0	8	no_rounding
arg	230:39	230:49	7	s->vo_type
water	230:39	0:0	8	s
op	230:40	0:0	8	->
water	230:42	0:0	8	vo_type
arg	231:19	231:62	7	ctx->vol_control_parameters?" VOLC":" "
water	231:19	0:0	8	ctx
op	231:22	0:0	8	->
water	231:24	0:0	8	vol_control_parameters
water	231:47	0:0	8	?
water	231:49	0:0	8	" VOLC"
water	231:57	0:0	8	:
water	231:59	0:0	8	" "
arg	231:64	231:87	7	ctx->intra_dc_threshold
water	231:64	0:0	8	ctx
op	231:67	0:0	8	->
water	231:69	0:0	8	intra_dc_threshold
arg	232:19	232:47	7	ctx->cplx_estimation_trash_i
water	232:19	0:0	8	ctx
op	232:22	0:0	8	->
water	232:24	0:0	8	cplx_estimation_trash_i
arg	232:49	232:77	7	ctx->cplx_estimation_trash_p
water	232:49	0:0	8	ctx
op	232:52	0:0	8	->
water	232:54	0:0	8	cplx_estimation_trash_p
arg	233:19	233:47	7	ctx->cplx_estimation_trash_b
water	233:19	0:0	8	ctx
op	233:22	0:0	8	->
water	233:24	0:0	8	cplx_estimation_trash_b
arg	234:19	234:26	7	s->time
water	234:19	0:0	8	s
op	234:20	0:0	8	->
water	234:22	0:0	8	time
arg	235:19	236:18	7	time_increment
water	235:19	0:0	8	time_increment
water	236:19	0:0	6	;
water	237:8	0:0	6	}
if	239:8	242:8	4	(! ctx -> scalability)
cond	239:12	239:18	5	! ctx -> scalability
op	239:12	0:0	6	!
water	239:13	0:0	6	ctx
op	239:16	0:0	6	->
water	239:18	0:0	6	scalability
stmts	239:31	242:8	5	
water	239:31	0:0	6	{
if	240:12	241:30	6	(ctx -> shape != RECT_SHAPE && s -> pict_type != AV_PICTURE_TYPE_I)
cond	240:16	240:60	7	ctx -> shape != RECT_SHAPE && s -> pict_type != AV_PICTURE_TYPE_I
water	240:16	0:0	8	ctx
op	240:19	0:0	8	->
water	240:21	0:0	8	shape
op	240:27	0:0	8	!=
water	240:30	0:0	8	RECT_SHAPE
op	240:41	0:0	8	&&
water	240:44	0:0	8	s
op	240:45	0:0	8	->
water	240:47	0:0	8	pict_type
op	240:57	0:0	8	!=
water	240:60	0:0	8	AV_PICTURE_TYPE_I
stmts	241:16	241:30	7	
call	241:16	241:29	8	skip_bits1
arg	241:27	241:29	9	gb
water	241:27	0:0	10	gb
water	241:30	0:0	8	;
water	242:8	0:0	6	}
else	242:10	250:8	4
stmts	242:15	250:8	5	
water	242:15	0:0	6	{
if	243:12	248:12	6	(ctx -> enhancement_type)
cond	243:16	243:21	7	ctx -> enhancement_type
water	243:16	0:0	8	ctx
op	243:19	0:0	8	->
water	243:21	0:0	8	enhancement_type
stmts	243:39	248:12	7	
water	243:39	0:0	8	{
decl	244:16	244:55	8	int	load_backward_shape
op	244:40	0:0	8	=
call	244:42	244:54	9	get_bits1
arg	244:52	244:54	10	gb
water	244:52	0:0	11	gb
if	245:16	247:67	8	(load_backward_shape)
cond	245:20	245:20	9	load_backward_shape
water	245:20	0:0	10	load_backward_shape
stmts	246:20	247:67	9	
call	246:20	247:66	10	av_log
arg	246:27	246:35	11	s->avctx
water	246:27	0:0	12	s
op	246:28	0:0	12	->
water	246:30	0:0	12	avctx
arg	246:37	246:49	11	AV_LOG_ERROR
water	246:37	0:0	12	AV_LOG_ERROR
arg	247:27	247:66	11	"load backward shape isn't supported\n"
water	247:27	0:0	12	"load backward shape isn't supported\n"
water	247:67	0:0	10	;
water	248:12	0:0	8	}
call	249:12	249:27	6	skip_bits
arg	249:22	249:24	7	gb
water	249:22	0:0	8	gb
arg	249:26	249:27	7	2
water	249:26	0:0	8	2
water	249:28	0:0	6	;
water	250:8	0:0	6	}
water	251:4	0:0	4	}
if	255:4	260:4	2	(s -> vo_type == 0 && ctx -> vol_control_parameters == 0 && ctx -> divx_version == - 1 && s -> picture_number == 0)
cond	255:8	256:56	3	s -> vo_type == 0 && ctx -> vol_control_parameters == 0 && ctx -> divx_version == - 1 && s -> picture_number == 0
water	255:8	0:0	4	s
op	255:9	0:0	4	->
water	255:11	0:0	4	vo_type
op	255:19	0:0	4	==
water	255:22	0:0	4	0
op	255:24	0:0	4	&&
water	255:27	0:0	4	ctx
op	255:30	0:0	4	->
water	255:32	0:0	4	vol_control_parameters
op	255:55	0:0	4	==
water	255:58	0:0	4	0
op	255:60	0:0	4	&&
water	256:8	0:0	4	ctx
op	256:11	0:0	4	->
water	256:13	0:0	4	divx_version
op	256:26	0:0	4	==
op	256:29	0:0	4	-
water	256:30	0:0	4	1
op	256:32	0:0	4	&&
water	256:35	0:0	4	s
op	256:36	0:0	4	->
water	256:38	0:0	4	picture_number
op	256:53	0:0	4	==
water	256:56	0:0	4	0
stmts	256:59	260:4	3	
water	256:59	0:0	4	{
call	257:8	258:109	4	av_log
arg	257:15	257:23	5	s->avctx
water	257:15	0:0	6	s
op	257:16	0:0	6	->
water	257:18	0:0	6	avctx
arg	257:25	257:39	5	AV_LOG_WARNING
water	257:25	0:0	6	AV_LOG_WARNING
arg	258:15	258:109	5	"looks like this file was encoded with (divx4/(old)xvid/opendivx) -> forcing low_delay flag\n"
water	258:15	0:0	6	"looks like this file was encoded with (divx4/(old)xvid/opendivx) -> forcing low_delay flag\n"
water	258:110	0:0	4	;
water	259:8	0:0	4	s
op	259:9	0:0	4	->
water	259:11	0:0	4	low_delay
op	259:21	0:0	4	=
water	259:23	0:0	4	1
water	259:24	0:0	4	;
water	260:4	0:0	4	}
water	262:4	0:0	2	s
op	262:5	0:0	2	->
water	262:7	0:0	2	picture_number
op	262:21	0:0	2	++
water	262:23	0:0	2	;
water	265:4	0:0	2	s
op	265:5	0:0	2	->
water	265:7	0:0	2	y_dc_scale_table
op	265:24	0:0	2	=
water	265:26	0:0	2	ff_mpeg4_y_dc_scale_table
water	265:51	0:0	2	;
water	266:4	0:0	2	s
op	266:5	0:0	2	->
water	266:7	0:0	2	c_dc_scale_table
op	266:24	0:0	2	=
water	266:26	0:0	2	ff_mpeg4_c_dc_scale_table
water	266:51	0:0	2	;
if	268:4	271:4	2	(s -> workaround_bugs & FF_BUG_EDGE)
cond	268:8	268:29	3	s -> workaround_bugs & FF_BUG_EDGE
water	268:8	0:0	4	s
op	268:9	0:0	4	->
water	268:11	0:0	4	workaround_bugs
op	268:27	0:0	4	&
water	268:29	0:0	4	FF_BUG_EDGE
stmts	268:42	271:4	3	
water	268:42	0:0	4	{
water	269:8	0:0	4	s
op	269:9	0:0	4	->
water	269:11	0:0	4	h_edge_pos
op	269:22	0:0	4	=
water	269:24	0:0	4	s
op	269:25	0:0	4	->
water	269:27	0:0	4	width
water	269:32	0:0	4	;
water	270:8	0:0	4	s
op	270:9	0:0	4	->
water	270:11	0:0	4	v_edge_pos
op	270:22	0:0	4	=
water	270:24	0:0	4	s
op	270:25	0:0	4	->
water	270:27	0:0	4	height
water	270:33	0:0	4	;
water	271:4	0:0	4	}
return	272:4	272:12	2	0
water	272:11	0:0	3	0
