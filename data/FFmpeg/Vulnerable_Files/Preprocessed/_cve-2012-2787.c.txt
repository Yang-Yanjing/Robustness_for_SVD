func	2:0	65:0	0	static int	decode_frame
params	2:23	0:0	1	
param	2:24	2:45	2	AVCodecContext *	avctx
param	2:47	2:57	2	void *	data
param	2:59	2:73	2	int *	data_size
param	3:24	3:39	2	AVPacket *	avpkt
stmnts	0:0	64:19	1	
decl	5:4	5:43	2	IVI4DecContext	*ctx
op	5:25	0:0	2	=
water	5:27	0:0	2	avctx
op	5:32	0:0	2	->
water	5:34	0:0	2	priv_data
decl	6:4	6:38	2	const uint8_t	*buf
op	6:25	0:0	2	=
water	6:27	0:0	2	avpkt
op	6:32	0:0	2	->
water	6:34	0:0	2	data
decl	7:4	7:42	2	int	buf_size
op	7:29	0:0	2	=
water	7:31	0:0	2	avpkt
op	7:36	0:0	2	->
water	7:38	0:0	2	size
decl	8:4	8:32	2	int	result
water	8:26	0:0	2	,
decl	8:4	8:32	2	int	p
water	8:29	0:0	2	,
decl	8:4	8:32	2	int	b
call	10:4	10:45	2	init_get_bits
arg	10:18	10:26	3	&ctx->gb
op	10:18	0:0	4	&
water	10:19	0:0	4	ctx
op	10:22	0:0	4	->
water	10:24	0:0	4	gb
arg	10:28	10:31	3	buf
water	10:28	0:0	4	buf
arg	10:33	10:45	3	buf_size*8
water	10:33	0:0	4	buf_size
op	10:42	0:0	4	*
water	10:44	0:0	4	8
water	10:46	0:0	2	;
water	12:4	0:0	2	result
op	12:11	0:0	2	=
call	12:13	12:38	2	decode_pic_hdr
arg	12:28	12:31	3	ctx
water	12:28	0:0	4	ctx
arg	12:33	12:38	3	avctx
water	12:33	0:0	4	avctx
water	12:39	0:0	2	;
if	13:4	16:4	2	(result)
cond	13:8	13:8	3	result
water	13:8	0:0	4	result
stmts	13:16	16:4	3	
water	13:16	0:0	4	{
call	14:8	14:69	4	av_log
arg	14:15	14:20	5	avctx
water	14:15	0:0	6	avctx
arg	14:22	14:34	5	AV_LOG_ERROR
water	14:22	0:0	6	AV_LOG_ERROR
arg	14:36	14:69	5	"Error decoding picture header\n"
water	14:36	0:0	6	"Error decoding picture header\n"
water	14:70	0:0	4	;
return	15:8	15:21	4	result
water	15:15	0:0	5	result
water	16:4	0:0	4	}
call	18:4	18:22	2	switch_buffers
arg	18:19	18:22	3	ctx
water	18:19	0:0	4	ctx
water	18:23	0:0	2	;
if	20:4	31:4	2	(ctx -> frame_type < FRAMETYPE_NULL_FIRST)
cond	20:8	20:26	3	ctx -> frame_type < FRAMETYPE_NULL_FIRST
water	20:8	0:0	4	ctx
op	20:11	0:0	4	->
water	20:13	0:0	4	frame_type
op	20:24	0:0	4	<
water	20:26	0:0	4	FRAMETYPE_NULL_FIRST
stmts	20:48	31:4	3	
water	20:48	0:0	4	{
for	21:8	30:8	4	(p = 0 ;p < 3;p ++)
forinit	21:13	21:18	5	p = 0 ;
water	21:13	0:0	6	p
op	21:15	0:0	6	=
water	21:17	0:0	6	0
water	21:18	0:0	6	;
cond	21:20	21:24	5	p < 3
water	21:20	0:0	6	p
op	21:22	0:0	6	<
water	21:24	0:0	6	3
forexpr	21:27	21:28	5	p ++
water	21:27	0:0	6	p
op	21:28	0:0	6	++
stmts	21:32	30:8	5	
water	21:32	0:0	6	{
for	22:12	29:12	6	(b = 0 ;b < ctx -> planes [ p ] . num_bands;b ++)
forinit	22:17	22:22	7	b = 0 ;
water	22:17	0:0	8	b
op	22:19	0:0	8	=
water	22:21	0:0	8	0
water	22:22	0:0	8	;
cond	22:24	22:43	7	b < ctx -> planes [ p ] . num_bands
water	22:24	0:0	8	b
op	22:26	0:0	8	<
water	22:28	0:0	8	ctx
op	22:31	0:0	8	->
water	22:33	0:0	8	planes
op	22:39	0:0	8	[
water	22:40	0:0	8	p
op	22:41	0:0	8	]
op	22:42	0:0	8	.
water	22:43	0:0	8	num_bands
forexpr	22:54	22:55	7	b ++
water	22:54	0:0	8	b
op	22:55	0:0	8	++
stmts	22:59	29:12	7	
water	22:59	0:0	8	{
water	23:16	0:0	8	result
op	23:23	0:0	8	=
call	23:25	23:76	8	decode_band
arg	23:37	23:40	9	ctx
water	23:37	0:0	10	ctx
arg	23:42	23:43	9	p
water	23:42	0:0	10	p
arg	23:45	23:69	9	&ctx->planes[p].bands[b]
op	23:45	0:0	10	&
water	23:46	0:0	10	ctx
op	23:49	0:0	10	->
water	23:51	0:0	10	planes
op	23:57	0:0	10	[
water	23:58	0:0	10	p
op	23:59	0:0	10	]
op	23:60	0:0	10	.
water	23:61	0:0	10	bands
op	23:66	0:0	10	[
water	23:67	0:0	10	b
op	23:68	0:0	10	]
arg	23:71	23:76	9	avctx
water	23:71	0:0	10	avctx
water	23:77	0:0	8	;
if	24:16	28:16	8	(result)
cond	24:20	24:20	9	result
water	24:20	0:0	10	result
stmts	24:28	28:16	9	
water	24:28	0:0	10	{
call	25:20	26:71	10	av_log
arg	25:27	25:32	11	avctx
water	25:27	0:0	12	avctx
arg	25:34	25:46	11	AV_LOG_ERROR
water	25:34	0:0	12	AV_LOG_ERROR
arg	26:27	26:65	11	"Error decoding band: %d, plane: %d\n"
water	26:27	0:0	12	"Error decoding band: %d, plane: %d\n"
arg	26:67	26:68	11	b
water	26:67	0:0	12	b
arg	26:70	26:71	11	p
water	26:70	0:0	12	p
water	26:72	0:0	10	;
return	27:20	27:33	10	result
water	27:27	0:0	11	result
water	28:16	0:0	10	}
water	29:12	0:0	8	}
water	30:8	0:0	6	}
water	31:4	0:0	4	}
if	36:4	41:4	2	(ctx -> frame_type == FRAMETYPE_INTRA)
cond	36:8	36:27	3	ctx -> frame_type == FRAMETYPE_INTRA
water	36:8	0:0	4	ctx
op	36:11	0:0	4	->
water	36:13	0:0	4	frame_type
op	36:24	0:0	4	==
water	36:27	0:0	4	FRAMETYPE_INTRA
stmts	36:44	41:4	3	
water	36:44	0:0	4	{
while	37:8	37:37	4	(get_bits (& ctx -> gb ,8 ))
cond	37:15	37:35	5	get_bits (& ctx -> gb ,8 )
call	37:15	37:35	6	get_bits
arg	37:24	37:32	7	&ctx->gb
op	37:24	0:0	8	&
water	37:25	0:0	8	ctx
op	37:28	0:0	8	->
water	37:30	0:0	8	gb
arg	37:34	37:35	7	8
water	37:34	0:0	8	8
stmts	37:37	37:37	5	
water	37:37	0:0	6	;
call	38:8	38:35	4	skip_bits_long
arg	38:23	38:31	5	&ctx->gb
op	38:23	0:0	6	&
water	38:24	0:0	6	ctx
op	38:27	0:0	6	->
water	38:29	0:0	6	gb
arg	38:33	38:35	5	64
water	38:33	0:0	6	64
water	38:36	0:0	4	;
if	39:8	40:71	4	(get_bits_left (& ctx -> gb ) > 18 &&show_bits (& ctx -> gb ,18 ) == 0 x3FFF8)
cond	39:12	39:72	5	get_bits_left (& ctx -> gb ) > 18 &&show_bits (& ctx -> gb ,18 ) == 0 x3FFF8
call	39:12	39:34	6	get_bits_left
arg	39:26	39:34	7	&ctx->gb
op	39:26	0:0	8	&
water	39:27	0:0	8	ctx
op	39:30	0:0	8	->
water	39:32	0:0	8	gb
op	39:36	0:0	6	>
water	39:38	0:0	6	18
op	39:41	0:0	6	&&
call	39:44	39:66	6	show_bits
arg	39:54	39:62	7	&ctx->gb
op	39:54	0:0	8	&
water	39:55	0:0	8	ctx
op	39:58	0:0	8	->
water	39:60	0:0	8	gb
arg	39:64	39:66	7	18
water	39:64	0:0	8	18
op	39:68	0:0	6	==
water	39:71	0:0	6	0
water	39:72	0:0	6	x3FFF8
stmts	40:12	40:71	5	
call	40:12	40:70	6	av_log
arg	40:19	40:24	7	avctx
water	40:19	0:0	8	avctx
arg	40:26	40:38	7	AV_LOG_ERROR
water	40:26	0:0	8	AV_LOG_ERROR
arg	40:40	40:70	7	"Buffer contains IP frames!\n"
water	40:40	0:0	8	"Buffer contains IP frames!\n"
water	40:71	0:0	6	;
water	41:4	0:0	4	}
if	43:4	44:49	2	(ctx -> frame . data [ 0 ])
cond	43:8	43:25	3	ctx -> frame . data [ 0 ]
water	43:8	0:0	4	ctx
op	43:11	0:0	4	->
water	43:13	0:0	4	frame
op	43:18	0:0	4	.
water	43:19	0:0	4	data
op	43:23	0:0	4	[
water	43:24	0:0	4	0
op	43:25	0:0	4	]
stmts	44:8	44:49	3	
call	44:8	44:48	4	avctx->release_buffer
arg	44:30	44:35	5	avctx
water	44:30	0:0	6	avctx
arg	44:37	44:48	5	&ctx->frame
op	44:37	0:0	6	&
water	44:38	0:0	6	ctx
op	44:41	0:0	6	->
water	44:43	0:0	6	frame
water	44:49	0:0	4	;
water	46:4	0:0	2	ctx
op	46:7	0:0	2	->
water	46:9	0:0	2	frame
op	46:14	0:0	2	.
water	46:15	0:0	2	reference
op	46:25	0:0	2	=
water	46:27	0:0	2	0
water	46:28	0:0	2	;
if	47:4	50:4	2	(( result =avctx -> get_buffer (avctx ,& ctx -> frame ) ) < 0)
cond	47:8	47:59	3	( result =avctx -> get_buffer (avctx ,& ctx -> frame ) ) < 0
water	47:8	0:0	4	(
water	47:9	0:0	4	result
op	47:16	0:0	4	=
call	47:18	47:54	4	avctx->get_buffer
arg	47:36	47:41	5	avctx
water	47:36	0:0	6	avctx
arg	47:43	47:54	5	&ctx->frame
op	47:43	0:0	6	&
water	47:44	0:0	6	ctx
op	47:47	0:0	6	->
water	47:49	0:0	6	frame
water	47:55	0:0	4	)
op	47:57	0:0	4	<
water	47:59	0:0	4	0
stmts	47:62	50:4	3	
water	47:62	0:0	4	{
call	48:8	48:59	4	av_log
arg	48:15	48:20	5	avctx
water	48:15	0:0	6	avctx
arg	48:22	48:34	5	AV_LOG_ERROR
water	48:22	0:0	6	AV_LOG_ERROR
arg	48:36	48:59	5	"get_buffer() failed\n"
water	48:36	0:0	6	"get_buffer() failed\n"
water	48:60	0:0	4	;
return	49:8	49:21	4	result
water	49:15	0:0	5	result
water	50:4	0:0	4	}
if	52:4	54:4	2	(ctx -> is_scalable)
cond	52:8	52:13	3	ctx -> is_scalable
water	52:8	0:0	4	ctx
op	52:11	0:0	4	->
water	52:13	0:0	4	is_scalable
stmts	52:26	54:4	3	
water	52:26	0:0	4	{
call	53:8	53:92	4	ff_ivi_recompose_haar
arg	53:30	53:45	5	&ctx->planes[0]
op	53:30	0:0	6	&
water	53:31	0:0	6	ctx
op	53:34	0:0	6	->
water	53:36	0:0	6	planes
op	53:42	0:0	6	[
water	53:43	0:0	6	0
op	53:44	0:0	6	]
arg	53:47	53:65	5	ctx->frame.data[0]
water	53:47	0:0	6	ctx
op	53:50	0:0	6	->
water	53:52	0:0	6	frame
op	53:57	0:0	6	.
water	53:58	0:0	6	data
op	53:62	0:0	6	[
water	53:63	0:0	6	0
op	53:64	0:0	6	]
arg	53:67	53:89	5	ctx->frame.linesize[0]
water	53:67	0:0	6	ctx
op	53:70	0:0	6	->
water	53:72	0:0	6	frame
op	53:77	0:0	6	.
water	53:78	0:0	6	linesize
op	53:86	0:0	6	[
water	53:87	0:0	6	0
op	53:88	0:0	6	]
arg	53:91	53:92	5	4
water	53:91	0:0	6	4
water	53:93	0:0	4	;
water	54:4	0:0	4	}
else	54:6	56:4	2
stmts	54:11	56:4	3	
water	54:11	0:0	4	{
call	55:8	55:87	4	ff_ivi_output_plane
arg	55:28	55:43	5	&ctx->planes[0]
op	55:28	0:0	6	&
water	55:29	0:0	6	ctx
op	55:32	0:0	6	->
water	55:34	0:0	6	planes
op	55:40	0:0	6	[
water	55:41	0:0	6	0
op	55:42	0:0	6	]
arg	55:45	55:63	5	ctx->frame.data[0]
water	55:45	0:0	6	ctx
op	55:48	0:0	6	->
water	55:50	0:0	6	frame
op	55:55	0:0	6	.
water	55:56	0:0	6	data
op	55:60	0:0	6	[
water	55:61	0:0	6	0
op	55:62	0:0	6	]
arg	55:65	55:87	5	ctx->frame.linesize[0]
water	55:65	0:0	6	ctx
op	55:68	0:0	6	->
water	55:70	0:0	6	frame
op	55:75	0:0	6	.
water	55:76	0:0	6	linesize
op	55:84	0:0	6	[
water	55:85	0:0	6	0
op	55:86	0:0	6	]
water	55:88	0:0	4	;
water	56:4	0:0	4	}
call	58:4	58:83	2	ff_ivi_output_plane
arg	58:24	58:39	3	&ctx->planes[2]
op	58:24	0:0	4	&
water	58:25	0:0	4	ctx
op	58:28	0:0	4	->
water	58:30	0:0	4	planes
op	58:36	0:0	4	[
water	58:37	0:0	4	2
op	58:38	0:0	4	]
arg	58:41	58:59	3	ctx->frame.data[1]
water	58:41	0:0	4	ctx
op	58:44	0:0	4	->
water	58:46	0:0	4	frame
op	58:51	0:0	4	.
water	58:52	0:0	4	data
op	58:56	0:0	4	[
water	58:57	0:0	4	1
op	58:58	0:0	4	]
arg	58:61	58:83	3	ctx->frame.linesize[1]
water	58:61	0:0	4	ctx
op	58:64	0:0	4	->
water	58:66	0:0	4	frame
op	58:71	0:0	4	.
water	58:72	0:0	4	linesize
op	58:80	0:0	4	[
water	58:81	0:0	4	1
op	58:82	0:0	4	]
water	58:84	0:0	2	;
call	59:4	59:83	2	ff_ivi_output_plane
arg	59:24	59:39	3	&ctx->planes[1]
op	59:24	0:0	4	&
water	59:25	0:0	4	ctx
op	59:28	0:0	4	->
water	59:30	0:0	4	planes
op	59:36	0:0	4	[
water	59:37	0:0	4	1
op	59:38	0:0	4	]
arg	59:41	59:59	3	ctx->frame.data[2]
water	59:41	0:0	4	ctx
op	59:44	0:0	4	->
water	59:46	0:0	4	frame
op	59:51	0:0	4	.
water	59:52	0:0	4	data
op	59:56	0:0	4	[
water	59:57	0:0	4	2
op	59:58	0:0	4	]
arg	59:61	59:83	3	ctx->frame.linesize[2]
water	59:61	0:0	4	ctx
op	59:64	0:0	4	->
water	59:66	0:0	4	frame
op	59:71	0:0	4	.
water	59:72	0:0	4	linesize
op	59:80	0:0	4	[
water	59:81	0:0	4	2
op	59:82	0:0	4	]
water	59:84	0:0	2	;
op	61:4	0:0	2	*
water	61:5	0:0	2	data_size
op	61:15	0:0	2	=
op	61:17	0:0	2	sizeof
water	61:23	0:0	2	(
water	61:24	0:0	2	AVFrame
water	61:31	0:0	2	)
water	61:32	0:0	2	;
op	62:4	0:0	2	*
water	62:5	0:0	2	(
water	62:6	0:0	2	AVFrame
op	62:13	0:0	2	*
water	62:14	0:0	2	)
water	62:15	0:0	2	data
op	62:20	0:0	2	=
water	62:22	0:0	2	ctx
op	62:25	0:0	2	->
water	62:27	0:0	2	frame
water	62:32	0:0	2	;
return	64:4	64:19	2	buf_size
water	64:11	0:0	3	buf_size
