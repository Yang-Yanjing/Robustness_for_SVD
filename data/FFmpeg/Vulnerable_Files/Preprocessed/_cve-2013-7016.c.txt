func	4:0	129:0	0	static int	get_siz
params	4:18	0:0	1	
param	4:19	4:44	2	Jpeg2000DecoderContext *	s
stmnts	0:0	128:12	1	
decl	6:4	6:9	2	int	i
decl	7:4	7:19	2	int	ncomponents
decl	8:4	8:31	2	uint32_t	log2_chroma_wh
op	8:28	0:0	2	=
water	8:30	0:0	2	0
decl	9:4	9:50	2	const enum AVPixelFormat	*possible_fmts
op	9:44	0:0	2	=
water	9:46	0:0	2	NULL
decl	10:4	10:28	2	int	possible_fmts_nb
op	10:25	0:0	2	=
water	10:27	0:0	2	0
if	12:4	13:34	2	(bytestream2_get_bytes_left (& s -> g ) < 36)
cond	12:8	12:44	3	bytestream2_get_bytes_left (& s -> g ) < 36
call	12:8	12:40	4	bytestream2_get_bytes_left
arg	12:35	12:40	5	&s->g
op	12:35	0:0	6	&
water	12:36	0:0	6	s
op	12:37	0:0	6	->
water	12:39	0:0	6	g
op	12:42	0:0	4	<
water	12:44	0:0	4	36
stmts	13:8	13:34	3	
return	13:8	13:34	4	AVERROR_INVALIDDATA
water	13:15	0:0	5	AVERROR_INVALIDDATA
water	15:4	0:0	2	s
op	15:5	0:0	2	->
water	15:7	0:0	2	avctx
op	15:12	0:0	2	->
water	15:14	0:0	2	profile
op	15:22	0:0	2	=
call	15:24	15:51	2	bytestream2_get_be16u
arg	15:46	15:51	3	&s->g
op	15:46	0:0	4	&
water	15:47	0:0	4	s
op	15:48	0:0	4	->
water	15:50	0:0	4	g
water	15:52	0:0	2	;
water	16:4	0:0	2	s
op	16:5	0:0	2	->
water	16:7	0:0	2	width
op	16:22	0:0	2	=
call	16:24	16:51	2	bytestream2_get_be32u
arg	16:46	16:51	3	&s->g
op	16:46	0:0	4	&
water	16:47	0:0	4	s
op	16:48	0:0	4	->
water	16:50	0:0	4	g
water	16:52	0:0	2	;
water	17:4	0:0	2	s
op	17:5	0:0	2	->
water	17:7	0:0	2	height
op	17:22	0:0	2	=
call	17:24	17:51	2	bytestream2_get_be32u
arg	17:46	17:51	3	&s->g
op	17:46	0:0	4	&
water	17:47	0:0	4	s
op	17:48	0:0	4	->
water	17:50	0:0	4	g
water	17:52	0:0	2	;
water	18:4	0:0	2	s
op	18:5	0:0	2	->
water	18:7	0:0	2	image_offset_x
op	18:22	0:0	2	=
call	18:24	18:51	2	bytestream2_get_be32u
arg	18:46	18:51	3	&s->g
op	18:46	0:0	4	&
water	18:47	0:0	4	s
op	18:48	0:0	4	->
water	18:50	0:0	4	g
water	18:52	0:0	2	;
water	19:4	0:0	2	s
op	19:5	0:0	2	->
water	19:7	0:0	2	image_offset_y
op	19:22	0:0	2	=
call	19:24	19:51	2	bytestream2_get_be32u
arg	19:46	19:51	3	&s->g
op	19:46	0:0	4	&
water	19:47	0:0	4	s
op	19:48	0:0	4	->
water	19:50	0:0	4	g
water	19:52	0:0	2	;
water	20:4	0:0	2	s
op	20:5	0:0	2	->
water	20:7	0:0	2	tile_width
op	20:22	0:0	2	=
call	20:24	20:51	2	bytestream2_get_be32u
arg	20:46	20:51	3	&s->g
op	20:46	0:0	4	&
water	20:47	0:0	4	s
op	20:48	0:0	4	->
water	20:50	0:0	4	g
water	20:52	0:0	2	;
water	21:4	0:0	2	s
op	21:5	0:0	2	->
water	21:7	0:0	2	tile_height
op	21:22	0:0	2	=
call	21:24	21:51	2	bytestream2_get_be32u
arg	21:46	21:51	3	&s->g
op	21:46	0:0	4	&
water	21:47	0:0	4	s
op	21:48	0:0	4	->
water	21:50	0:0	4	g
water	21:52	0:0	2	;
water	22:4	0:0	2	s
op	22:5	0:0	2	->
water	22:7	0:0	2	tile_offset_x
op	22:22	0:0	2	=
call	22:24	22:51	2	bytestream2_get_be32u
arg	22:46	22:51	3	&s->g
op	22:46	0:0	4	&
water	22:47	0:0	4	s
op	22:48	0:0	4	->
water	22:50	0:0	4	g
water	22:52	0:0	2	;
water	23:4	0:0	2	s
op	23:5	0:0	2	->
water	23:7	0:0	2	tile_offset_y
op	23:22	0:0	2	=
call	23:24	23:51	2	bytestream2_get_be32u
arg	23:46	23:51	3	&s->g
op	23:46	0:0	4	&
water	23:47	0:0	4	s
op	23:48	0:0	4	->
water	23:50	0:0	4	g
water	23:52	0:0	2	;
water	24:4	0:0	2	ncomponents
op	24:22	0:0	2	=
call	24:24	24:51	2	bytestream2_get_be16u
arg	24:46	24:51	3	&s->g
op	24:46	0:0	4	&
water	24:47	0:0	4	s
op	24:48	0:0	4	->
water	24:50	0:0	4	g
water	24:52	0:0	2	;
if	26:4	30:4	2	(ncomponents <= 0)
cond	26:8	26:23	3	ncomponents <= 0
water	26:8	0:0	4	ncomponents
op	26:20	0:0	4	<=
water	26:23	0:0	4	0
stmts	26:26	30:4	3	
water	26:26	0:0	4	{
call	27:8	28:29	4	av_log
arg	27:15	27:23	5	s->avctx
water	27:15	0:0	6	s
op	27:16	0:0	6	->
water	27:18	0:0	6	avctx
arg	27:25	27:37	5	AV_LOG_ERROR
water	27:25	0:0	6	AV_LOG_ERROR
arg	27:39	27:75	5	"Invalid number of components: %d\n"
water	27:39	0:0	6	"Invalid number of components: %d\n"
arg	28:15	28:29	5	s->ncomponents
water	28:15	0:0	6	s
op	28:16	0:0	6	->
water	28:18	0:0	6	ncomponents
water	28:30	0:0	4	;
return	29:8	29:34	4	AVERROR_INVALIDDATA
water	29:15	0:0	5	AVERROR_INVALIDDATA
water	30:4	0:0	4	}
if	32:4	36:4	2	(ncomponents > 4)
cond	32:8	32:22	3	ncomponents > 4
water	32:8	0:0	4	ncomponents
op	32:20	0:0	4	>
water	32:22	0:0	4	4
stmts	32:25	36:4	3	
water	32:25	0:0	4	{
call	33:8	34:44	4	avpriv_request_sample
arg	33:30	33:38	5	s->avctx
water	33:30	0:0	6	s
op	33:31	0:0	6	->
water	33:33	0:0	6	avctx
arg	33:40	33:67	5	"Support for %d components"
water	33:40	0:0	6	"Support for %d components"
arg	34:30	34:44	5	s->ncomponents
water	34:30	0:0	6	s
op	34:31	0:0	6	->
water	34:33	0:0	6	ncomponents
water	34:45	0:0	4	;
return	35:8	35:35	4	AVERROR_PATCHWELCOME
water	35:15	0:0	5	AVERROR_PATCHWELCOME
water	36:4	0:0	4	}
water	38:4	0:0	2	s
op	38:5	0:0	2	->
water	38:7	0:0	2	ncomponents
op	38:19	0:0	2	=
water	38:21	0:0	2	ncomponents
water	38:32	0:0	2	;
if	40:4	44:4	2	(s -> tile_width <= 0 || s -> tile_height <= 0)
cond	40:8	40:48	3	s -> tile_width <= 0 || s -> tile_height <= 0
water	40:8	0:0	4	s
op	40:9	0:0	4	->
water	40:11	0:0	4	tile_width
op	40:22	0:0	4	<=
water	40:25	0:0	4	0
op	40:27	0:0	4	||
water	40:30	0:0	4	s
op	40:31	0:0	4	->
water	40:33	0:0	4	tile_height
op	40:45	0:0	4	<=
water	40:48	0:0	4	0
stmts	40:51	44:4	3	
water	40:51	0:0	4	{
call	41:8	42:44	4	av_log
arg	41:15	41:23	5	s->avctx
water	41:15	0:0	6	s
op	41:16	0:0	6	->
water	41:18	0:0	6	avctx
arg	41:25	41:37	5	AV_LOG_ERROR
water	41:25	0:0	6	AV_LOG_ERROR
arg	41:39	41:72	5	"Invalid tile dimension %dx%d.\n"
water	41:39	0:0	6	"Invalid tile dimension %dx%d.\n"
arg	42:15	42:28	5	s->tile_width
water	42:15	0:0	6	s
op	42:16	0:0	6	->
water	42:18	0:0	6	tile_width
arg	42:30	42:44	5	s->tile_height
water	42:30	0:0	6	s
op	42:31	0:0	6	->
water	42:33	0:0	6	tile_height
water	42:45	0:0	4	;
return	43:8	43:34	4	AVERROR_INVALIDDATA
water	43:15	0:0	5	AVERROR_INVALIDDATA
water	44:4	0:0	4	}
if	46:4	47:34	2	(bytestream2_get_bytes_left (& s -> g ) < 3 * s -> ncomponents)
cond	46:8	46:51	3	bytestream2_get_bytes_left (& s -> g ) < 3 * s -> ncomponents
call	46:8	46:40	4	bytestream2_get_bytes_left
arg	46:35	46:40	5	&s->g
op	46:35	0:0	6	&
water	46:36	0:0	6	s
op	46:37	0:0	6	->
water	46:39	0:0	6	g
op	46:42	0:0	4	<
water	46:44	0:0	4	3
op	46:46	0:0	4	*
water	46:48	0:0	4	s
op	46:49	0:0	4	->
water	46:51	0:0	4	ncomponents
stmts	47:8	47:34	3	
return	47:8	47:34	4	AVERROR_INVALIDDATA
water	47:15	0:0	5	AVERROR_INVALIDDATA
for	49:4	57:4	2	(i = 0 ;i < s -> ncomponents;i ++)
forinit	49:9	49:14	3	i = 0 ;
water	49:9	0:0	4	i
op	49:11	0:0	4	=
water	49:13	0:0	4	0
water	49:14	0:0	4	;
cond	49:16	49:23	3	i < s -> ncomponents
water	49:16	0:0	4	i
op	49:18	0:0	4	<
water	49:20	0:0	4	s
op	49:21	0:0	4	->
water	49:23	0:0	4	ncomponents
forexpr	49:36	49:37	3	i ++
water	49:36	0:0	4	i
op	49:37	0:0	4	++
stmts	49:41	57:4	3	
water	49:41	0:0	4	{
decl	50:8	50:51	4	uint8_t	x
op	50:21	0:0	4	=
call	50:23	50:50	5	bytestream2_get_byteu
arg	50:45	50:50	6	&s->g
op	50:45	0:0	7	&
water	50:46	0:0	7	s
op	50:47	0:0	7	->
water	50:49	0:0	7	g
water	51:8	0:0	4	s
op	51:9	0:0	4	->
water	51:11	0:0	4	cbps
op	51:15	0:0	4	[
water	51:16	0:0	4	i
op	51:17	0:0	4	]
op	51:21	0:0	4	=
water	51:23	0:0	4	(
water	51:24	0:0	4	x
op	51:26	0:0	4	&
water	51:28	0:0	4	0
water	51:29	0:0	4	x7f
water	51:32	0:0	4	)
op	51:34	0:0	4	+
water	51:36	0:0	4	1
water	51:37	0:0	4	;
water	52:8	0:0	4	s
op	52:9	0:0	4	->
water	52:11	0:0	4	precision
op	52:21	0:0	4	=
call	52:23	52:53	4	FFMAX
arg	52:29	52:39	5	s->cbps[i]
water	52:29	0:0	6	s
op	52:30	0:0	6	->
water	52:32	0:0	6	cbps
op	52:36	0:0	6	[
water	52:37	0:0	6	i
op	52:38	0:0	6	]
arg	52:41	52:53	5	s->precision
water	52:41	0:0	6	s
op	52:42	0:0	6	->
water	52:44	0:0	6	precision
water	52:54	0:0	4	;
water	53:8	0:0	4	s
op	53:9	0:0	4	->
water	53:11	0:0	4	sgnd
op	53:15	0:0	4	[
water	53:16	0:0	4	i
op	53:17	0:0	4	]
op	53:21	0:0	4	=
op	53:23	0:0	4	!
op	53:24	0:0	4	!
water	53:25	0:0	4	(
water	53:26	0:0	4	x
op	53:28	0:0	4	&
water	53:30	0:0	4	0
water	53:31	0:0	4	x80
water	53:34	0:0	4	)
water	53:35	0:0	4	;
water	54:8	0:0	4	s
op	54:9	0:0	4	->
water	54:11	0:0	4	cdx
op	54:14	0:0	4	[
water	54:15	0:0	4	i
op	54:16	0:0	4	]
op	54:21	0:0	4	=
call	54:23	54:50	4	bytestream2_get_byteu
arg	54:45	54:50	5	&s->g
op	54:45	0:0	6	&
water	54:46	0:0	6	s
op	54:47	0:0	6	->
water	54:49	0:0	6	g
water	54:51	0:0	4	;
water	55:8	0:0	4	s
op	55:9	0:0	4	->
water	55:11	0:0	4	cdy
op	55:14	0:0	4	[
water	55:15	0:0	4	i
op	55:16	0:0	4	]
op	55:21	0:0	4	=
call	55:23	55:50	4	bytestream2_get_byteu
arg	55:45	55:50	5	&s->g
op	55:45	0:0	6	&
water	55:46	0:0	6	s
op	55:47	0:0	6	->
water	55:49	0:0	6	g
water	55:51	0:0	4	;
water	56:8	0:0	4	log2_chroma_wh
op	56:23	0:0	4	|=
water	56:26	0:0	4	s
op	56:27	0:0	4	->
water	56:29	0:0	4	cdy
op	56:32	0:0	4	[
water	56:33	0:0	4	i
op	56:34	0:0	4	]
op	56:36	0:0	4	>>
water	56:39	0:0	4	1
op	56:41	0:0	4	<<
water	56:44	0:0	4	i
op	56:46	0:0	4	*
water	56:48	0:0	4	4
op	56:50	0:0	4	|
water	56:52	0:0	4	s
op	56:53	0:0	4	->
water	56:55	0:0	4	cdx
op	56:58	0:0	4	[
water	56:59	0:0	4	i
op	56:60	0:0	4	]
op	56:62	0:0	4	>>
water	56:65	0:0	4	1
op	56:67	0:0	4	<<
water	56:70	0:0	4	i
op	56:72	0:0	4	*
water	56:74	0:0	4	4
op	56:76	0:0	4	+
water	56:78	0:0	4	2
water	56:79	0:0	4	;
water	57:4	0:0	4	}
water	59:4	0:0	2	s
op	59:5	0:0	2	->
water	59:7	0:0	2	numXtiles
op	59:17	0:0	2	=
call	59:19	59:82	2	ff_jpeg2000_ceildiv
arg	59:39	59:67	3	s->width-s->tile_offset_x
water	59:39	0:0	4	s
op	59:40	0:0	4	->
water	59:42	0:0	4	width
op	59:49	0:0	4	-
water	59:51	0:0	4	s
op	59:52	0:0	4	->
water	59:54	0:0	4	tile_offset_x
arg	59:69	59:82	3	s->tile_width
water	59:69	0:0	4	s
op	59:70	0:0	4	->
water	59:72	0:0	4	tile_width
water	59:83	0:0	2	;
water	60:4	0:0	2	s
op	60:5	0:0	2	->
water	60:7	0:0	2	numYtiles
op	60:17	0:0	2	=
call	60:19	60:83	2	ff_jpeg2000_ceildiv
arg	60:39	60:67	3	s->height-s->tile_offset_y
water	60:39	0:0	4	s
op	60:40	0:0	4	->
water	60:42	0:0	4	height
op	60:49	0:0	4	-
water	60:51	0:0	4	s
op	60:52	0:0	4	->
water	60:54	0:0	4	tile_offset_y
arg	60:69	60:83	3	s->tile_height
water	60:69	0:0	4	s
op	60:70	0:0	4	->
water	60:72	0:0	4	tile_height
water	60:84	0:0	2	;
if	62:4	65:4	2	(s -> numXtiles * ( uint64_t ) s -> numYtiles > INT_MAX / sizeof ( * s -> tile ))
cond	62:8	62:71	3	s -> numXtiles * ( uint64_t ) s -> numYtiles > INT_MAX / sizeof ( * s -> tile )
water	62:8	0:0	4	s
op	62:9	0:0	4	->
water	62:11	0:0	4	numXtiles
op	62:21	0:0	4	*
water	62:23	0:0	4	(
water	62:24	0:0	4	uint64_t
water	62:32	0:0	4	)
water	62:33	0:0	4	s
op	62:34	0:0	4	->
water	62:36	0:0	4	numYtiles
op	62:46	0:0	4	>
water	62:48	0:0	4	INT_MAX
op	62:55	0:0	4	/
op	62:56	0:0	4	sizeof
water	62:62	0:0	4	(
op	62:63	0:0	4	*
water	62:64	0:0	4	s
op	62:65	0:0	4	->
water	62:67	0:0	4	tile
water	62:71	0:0	4	)
stmts	62:74	65:4	3	
water	62:74	0:0	4	{
water	63:8	0:0	4	s
op	63:9	0:0	4	->
water	63:11	0:0	4	numXtiles
op	63:21	0:0	4	=
water	63:23	0:0	4	s
op	63:24	0:0	4	->
water	63:26	0:0	4	numYtiles
op	63:36	0:0	4	=
water	63:38	0:0	4	0
water	63:39	0:0	4	;
return	64:8	64:30	4	AVERROR(EINVAL)
call	64:15	64:29	5	AVERROR
arg	64:23	64:29	6	EINVAL
water	64:23	0:0	7	EINVAL
water	65:4	0:0	4	}
water	67:4	0:0	2	s
op	67:5	0:0	2	->
water	67:7	0:0	2	tile
op	67:12	0:0	2	=
call	67:14	67:76	2	av_mallocz_array
arg	67:31	67:58	3	s->numXtiles*s->numYtiles
water	67:31	0:0	4	s
op	67:32	0:0	4	->
water	67:34	0:0	4	numXtiles
op	67:44	0:0	4	*
water	67:46	0:0	4	s
op	67:47	0:0	4	->
water	67:49	0:0	4	numYtiles
arg	67:60	67:76	3	sizeof(*s->tile)
op	67:60	0:0	4	sizeof
water	67:66	0:0	4	(
op	67:67	0:0	4	*
water	67:68	0:0	4	s
op	67:69	0:0	4	->
water	67:71	0:0	4	tile
water	67:75	0:0	4	)
water	67:77	0:0	2	;
if	68:4	71:4	2	(! s -> tile)
cond	68:8	68:12	3	! s -> tile
op	68:8	0:0	4	!
water	68:9	0:0	4	s
op	68:10	0:0	4	->
water	68:12	0:0	4	tile
stmts	68:18	71:4	3	
water	68:18	0:0	4	{
water	69:8	0:0	4	s
op	69:9	0:0	4	->
water	69:11	0:0	4	numXtiles
op	69:21	0:0	4	=
water	69:23	0:0	4	s
op	69:24	0:0	4	->
water	69:26	0:0	4	numYtiles
op	69:36	0:0	4	=
water	69:38	0:0	4	0
water	69:39	0:0	4	;
return	70:8	70:30	4	AVERROR(ENOMEM)
call	70:15	70:29	5	AVERROR
arg	70:23	70:29	6	ENOMEM
water	70:23	0:0	7	ENOMEM
water	71:4	0:0	4	}
for	73:4	79:4	2	(i = 0 ;i < s -> numXtiles * s -> numYtiles;i ++)
forinit	73:9	73:14	3	i = 0 ;
water	73:9	0:0	4	i
op	73:11	0:0	4	=
water	73:13	0:0	4	0
water	73:14	0:0	4	;
cond	73:16	73:38	3	i < s -> numXtiles * s -> numYtiles
water	73:16	0:0	4	i
op	73:18	0:0	4	<
water	73:20	0:0	4	s
op	73:21	0:0	4	->
water	73:23	0:0	4	numXtiles
op	73:33	0:0	4	*
water	73:35	0:0	4	s
op	73:36	0:0	4	->
water	73:38	0:0	4	numYtiles
forexpr	73:49	73:50	3	i ++
water	73:49	0:0	4	i
op	73:50	0:0	4	++
stmts	73:54	79:4	3	
water	73:54	0:0	4	{
decl	74:8	74:40	4	Jpeg2000Tile	*tile
op	74:27	0:0	4	=
water	74:29	0:0	4	s
op	74:30	0:0	4	->
water	74:32	0:0	4	tile
op	74:37	0:0	4	+
water	74:39	0:0	4	i
water	76:8	0:0	4	tile
op	76:12	0:0	4	->
water	76:14	0:0	4	comp
op	76:19	0:0	4	=
call	76:21	76:68	4	av_mallocz
arg	76:32	76:68	5	s->ncomponents*sizeof(*tile->comp)
water	76:32	0:0	6	s
op	76:33	0:0	6	->
water	76:35	0:0	6	ncomponents
op	76:47	0:0	6	*
op	76:49	0:0	6	sizeof
water	76:55	0:0	6	(
op	76:56	0:0	6	*
water	76:57	0:0	6	tile
op	76:61	0:0	6	->
water	76:63	0:0	6	comp
water	76:67	0:0	6	)
water	76:69	0:0	4	;
if	77:8	78:34	4	(! tile -> comp)
cond	77:12	77:19	5	! tile -> comp
op	77:12	0:0	6	!
water	77:13	0:0	6	tile
op	77:17	0:0	6	->
water	77:19	0:0	6	comp
stmts	78:12	78:34	5	
return	78:12	78:34	6	AVERROR(ENOMEM)
call	78:19	78:33	7	AVERROR
arg	78:27	78:33	8	ENOMEM
water	78:27	0:0	9	ENOMEM
water	79:4	0:0	4	}
water	82:4	0:0	2	s
op	82:5	0:0	2	->
water	82:7	0:0	2	avctx
op	82:12	0:0	2	->
water	82:14	0:0	2	width
op	82:21	0:0	2	=
call	82:23	83:66	2	ff_jpeg2000_ceildivpow2
arg	82:47	82:76	3	s->width-s->image_offset_x
water	82:47	0:0	4	s
op	82:48	0:0	4	->
water	82:50	0:0	4	width
op	82:57	0:0	4	-
water	82:59	0:0	4	s
op	82:60	0:0	4	->
water	82:62	0:0	4	image_offset_x
arg	83:47	83:66	3	s->reduction_factor
water	83:47	0:0	4	s
op	83:48	0:0	4	->
water	83:50	0:0	4	reduction_factor
water	83:67	0:0	2	;
water	84:4	0:0	2	s
op	84:5	0:0	2	->
water	84:7	0:0	2	avctx
op	84:12	0:0	2	->
water	84:14	0:0	2	height
op	84:21	0:0	2	=
call	84:23	85:66	2	ff_jpeg2000_ceildivpow2
arg	84:47	84:76	3	s->height-s->image_offset_y
water	84:47	0:0	4	s
op	84:48	0:0	4	->
water	84:50	0:0	4	height
op	84:57	0:0	4	-
water	84:59	0:0	4	s
op	84:60	0:0	4	->
water	84:62	0:0	4	image_offset_y
arg	85:47	85:66	3	s->reduction_factor
water	85:47	0:0	4	s
op	85:48	0:0	4	->
water	85:50	0:0	4	reduction_factor
water	85:67	0:0	2	;
if	87:4	91:4	2	(s -> avctx -> profile == FF_PROFILE_JPEG2000_DCINEMA_2K || s -> avctx -> profile == FF_PROFILE_JPEG2000_DCINEMA_4K)
cond	87:8	88:29	3	s -> avctx -> profile == FF_PROFILE_JPEG2000_DCINEMA_2K || s -> avctx -> profile == FF_PROFILE_JPEG2000_DCINEMA_4K
water	87:8	0:0	4	s
op	87:9	0:0	4	->
water	87:11	0:0	4	avctx
op	87:16	0:0	4	->
water	87:18	0:0	4	profile
op	87:26	0:0	4	==
water	87:29	0:0	4	FF_PROFILE_JPEG2000_DCINEMA_2K
op	87:60	0:0	4	||
water	88:8	0:0	4	s
op	88:9	0:0	4	->
water	88:11	0:0	4	avctx
op	88:16	0:0	4	->
water	88:18	0:0	4	profile
op	88:26	0:0	4	==
water	88:29	0:0	4	FF_PROFILE_JPEG2000_DCINEMA_4K
stmts	88:61	91:4	3	
water	88:61	0:0	4	{
water	89:8	0:0	4	possible_fmts
op	89:22	0:0	4	=
water	89:24	0:0	4	xyz_pix_fmts
water	89:36	0:0	4	;
water	90:8	0:0	4	possible_fmts_nb
op	90:25	0:0	4	=
call	90:27	90:54	4	FF_ARRAY_ELEMS
arg	90:42	90:54	5	xyz_pix_fmts
water	90:42	0:0	6	xyz_pix_fmts
water	90:55	0:0	4	;
water	91:4	0:0	4	}
else	91:6	110:4	2
stmts	91:11	110:4	3	
water	91:11	0:0	4	{
switch	92:8	109:8	4	(s -> colour_space)
cond	92:16	92:19	5	s -> colour_space
water	92:16	0:0	6	s
op	92:17	0:0	6	->
water	92:19	0:0	6	colour_space
stmts	92:33	109:8	5	
water	92:33	0:0	6	{
label	93:8	93:15	6	case 16 :
water	94:12	0:0	6	possible_fmts
op	94:26	0:0	6	=
water	94:28	0:0	6	rgb_pix_fmts
water	94:40	0:0	6	;
water	95:12	0:0	6	possible_fmts_nb
op	95:29	0:0	6	=
call	95:31	95:58	6	FF_ARRAY_ELEMS
arg	95:46	95:58	7	rgb_pix_fmts
water	95:46	0:0	8	rgb_pix_fmts
water	95:59	0:0	6	;
break	96:12	96:17	6	
label	97:8	97:15	6	case 17 :
water	98:12	0:0	6	possible_fmts
op	98:26	0:0	6	=
water	98:28	0:0	6	gray_pix_fmts
water	98:41	0:0	6	;
water	99:12	0:0	6	possible_fmts_nb
op	99:29	0:0	6	=
call	99:31	99:59	6	FF_ARRAY_ELEMS
arg	99:46	99:59	7	gray_pix_fmts
water	99:46	0:0	8	gray_pix_fmts
water	99:60	0:0	6	;
break	100:12	100:17	6	
label	101:8	101:15	6	case 18 :
water	102:12	0:0	6	possible_fmts
op	102:26	0:0	6	=
water	102:28	0:0	6	yuv_pix_fmts
water	102:40	0:0	6	;
water	103:12	0:0	6	possible_fmts_nb
op	103:29	0:0	6	=
call	103:31	103:58	6	FF_ARRAY_ELEMS
arg	103:46	103:58	7	yuv_pix_fmts
water	103:46	0:0	8	yuv_pix_fmts
water	103:59	0:0	6	;
break	104:12	104:17	6	
label	105:8	105:15	6	default :
water	106:12	0:0	6	possible_fmts
op	106:26	0:0	6	=
water	106:28	0:0	6	all_pix_fmts
water	106:40	0:0	6	;
water	107:12	0:0	6	possible_fmts_nb
op	107:29	0:0	6	=
call	107:31	107:58	6	FF_ARRAY_ELEMS
arg	107:46	107:58	7	all_pix_fmts
water	107:46	0:0	8	all_pix_fmts
water	107:59	0:0	6	;
break	108:12	108:17	6	
water	109:8	0:0	6	}
water	110:4	0:0	4	}
for	111:4	116:4	2	(i = 0 ;i < possible_fmts_nb;++ i)
forinit	111:9	111:14	3	i = 0 ;
water	111:9	0:0	4	i
op	111:11	0:0	4	=
water	111:13	0:0	4	0
water	111:14	0:0	4	;
cond	111:16	111:20	3	i < possible_fmts_nb
water	111:16	0:0	4	i
op	111:18	0:0	4	<
water	111:20	0:0	4	possible_fmts_nb
forexpr	111:38	111:40	3	++ i
op	111:38	0:0	4	++
water	111:40	0:0	4	i
stmts	111:43	116:4	3	
water	111:43	0:0	4	{
if	112:8	115:8	4	(pix_fmt_match (possible_fmts [ i ] ,ncomponents ,s -> precision ,log2_chroma_wh ,s -> pal8 ))
cond	112:12	112:94	5	pix_fmt_match (possible_fmts [ i ] ,ncomponents ,s -> precision ,log2_chroma_wh ,s -> pal8 )
call	112:12	112:94	6	pix_fmt_match
arg	112:26	112:42	7	possible_fmts[i]
water	112:26	0:0	8	possible_fmts
op	112:39	0:0	8	[
water	112:40	0:0	8	i
op	112:41	0:0	8	]
arg	112:44	112:55	7	ncomponents
water	112:44	0:0	8	ncomponents
arg	112:57	112:69	7	s->precision
water	112:57	0:0	8	s
op	112:58	0:0	8	->
water	112:60	0:0	8	precision
arg	112:71	112:85	7	log2_chroma_wh
water	112:71	0:0	8	log2_chroma_wh
arg	112:87	112:94	7	s->pal8
water	112:87	0:0	8	s
op	112:88	0:0	8	->
water	112:90	0:0	8	pal8
stmts	112:97	115:8	5	
water	112:97	0:0	6	{
water	113:12	0:0	6	s
op	113:13	0:0	6	->
water	113:15	0:0	6	avctx
op	113:20	0:0	6	->
water	113:22	0:0	6	pix_fmt
op	113:30	0:0	6	=
water	113:32	0:0	6	possible_fmts
op	113:45	0:0	6	[
water	113:46	0:0	6	i
op	113:47	0:0	6	]
water	113:48	0:0	6	;
break	114:12	114:17	6	
water	115:8	0:0	6	}
water	116:4	0:0	4	}
if	117:4	127:4	2	(s -> avctx -> pix_fmt == AV_PIX_FMT_NONE)
cond	117:8	117:29	3	s -> avctx -> pix_fmt == AV_PIX_FMT_NONE
water	117:8	0:0	4	s
op	117:9	0:0	4	->
water	117:11	0:0	4	avctx
op	117:16	0:0	4	->
water	117:18	0:0	4	pix_fmt
op	117:26	0:0	4	==
water	117:29	0:0	4	AV_PIX_FMT_NONE
stmts	117:46	127:4	3	
water	117:46	0:0	4	{
call	118:8	126:46	4	av_log
arg	118:15	118:23	5	s->avctx
water	118:15	0:0	6	s
op	118:16	0:0	6	->
water	118:18	0:0	6	avctx
arg	118:25	118:37	5	AV_LOG_ERROR
water	118:25	0:0	6	AV_LOG_ERROR
arg	119:15	121:65	5	"Unknown pix_fmt, profile: %d, colour_space: %d, ""components: %d, precision: %d, ""cdx[1]: %d, cdy[1]: %d, cdx[2]: %d, cdy[2]: %d\n"
water	119:15	0:0	6	"Unknown pix_fmt, profile: %d, colour_space: %d, "
water	120:15	0:0	6	"components: %d, precision: %d, "
water	121:15	0:0	6	"cdx[1]: %d, cdy[1]: %d, cdx[2]: %d, cdy[2]: %d\n"
arg	122:15	122:32	5	s->avctx->profile
water	122:15	0:0	6	s
op	122:16	0:0	6	->
water	122:18	0:0	6	avctx
op	122:23	0:0	6	->
water	122:25	0:0	6	profile
arg	122:34	122:49	5	s->colour_space
water	122:34	0:0	6	s
op	122:35	0:0	6	->
water	122:37	0:0	6	colour_space
arg	122:51	122:62	5	ncomponents
water	122:51	0:0	6	ncomponents
arg	122:64	122:76	5	s->precision
water	122:64	0:0	6	s
op	122:65	0:0	6	->
water	122:67	0:0	6	precision
arg	123:15	123:46	5	ncomponents>2?s->cdx[1]:0
water	123:15	0:0	6	ncomponents
op	123:27	0:0	6	>
water	123:29	0:0	6	2
water	123:31	0:0	6	?
water	123:33	0:0	6	s
op	123:34	0:0	6	->
water	123:36	0:0	6	cdx
op	123:39	0:0	6	[
water	123:40	0:0	6	1
op	123:41	0:0	6	]
water	123:43	0:0	6	:
water	123:45	0:0	6	0
arg	124:15	124:46	5	ncomponents>2?s->cdy[1]:0
water	124:15	0:0	6	ncomponents
op	124:27	0:0	6	>
water	124:29	0:0	6	2
water	124:31	0:0	6	?
water	124:33	0:0	6	s
op	124:34	0:0	6	->
water	124:36	0:0	6	cdy
op	124:39	0:0	6	[
water	124:40	0:0	6	1
op	124:41	0:0	6	]
water	124:43	0:0	6	:
water	124:45	0:0	6	0
arg	125:15	125:46	5	ncomponents>2?s->cdx[2]:0
water	125:15	0:0	6	ncomponents
op	125:27	0:0	6	>
water	125:29	0:0	6	2
water	125:31	0:0	6	?
water	125:33	0:0	6	s
op	125:34	0:0	6	->
water	125:36	0:0	6	cdx
op	125:39	0:0	6	[
water	125:40	0:0	6	2
op	125:41	0:0	6	]
water	125:43	0:0	6	:
water	125:45	0:0	6	0
arg	126:15	126:46	5	ncomponents>2?s->cdy[2]:0
water	126:15	0:0	6	ncomponents
op	126:27	0:0	6	>
water	126:29	0:0	6	2
water	126:31	0:0	6	?
water	126:33	0:0	6	s
op	126:34	0:0	6	->
water	126:36	0:0	6	cdy
op	126:39	0:0	6	[
water	126:40	0:0	6	2
op	126:41	0:0	6	]
water	126:43	0:0	6	:
water	126:45	0:0	6	0
water	126:47	0:0	4	;
water	127:4	0:0	4	}
return	128:4	128:12	2	0
water	128:11	0:0	3	0
