func	1:0	201:0	0	static int	read_header
params	1:22	0:0	1	
param	1:23	1:37	2	FFV1Context *	f
stmnts	0:0	200:12	1	
decl	3:4	3:31	2	uint8_t	state[CONTEXT_SIZE]
decl	4:4	4:32	2	int	i
water	4:9	0:0	2	,
decl	4:4	4:32	2	int	j
water	4:12	0:0	2	,
decl	4:4	4:32	2	int	context_count
op	4:28	0:0	2	=
op	4:30	0:0	2	-
water	4:31	0:0	2	1
water	5:4	0:0	2	RangeCoder
op	5:15	0:0	2	*
water	5:16	0:0	2	const
water	5:22	0:0	2	c
op	5:24	0:0	2	=
op	5:26	0:0	2	&
water	5:27	0:0	2	f
op	5:28	0:0	2	->
water	5:30	0:0	2	slice_context
op	5:43	0:0	2	[
water	5:44	0:0	2	0
op	5:45	0:0	2	]
op	5:46	0:0	2	->
water	5:48	0:0	2	c
water	5:49	0:0	2	;
call	7:4	7:36	2	memset
arg	7:11	7:16	3	state
water	7:11	0:0	4	state
arg	7:18	7:21	3	128
water	7:18	0:0	4	128
arg	7:23	7:36	3	sizeof(state)
op	7:23	0:0	4	sizeof
water	7:29	0:0	4	(
water	7:30	0:0	4	state
water	7:35	0:0	4	)
water	7:37	0:0	2	;
if	9:4	50:4	2	(f -> version < 2)
cond	9:8	9:21	3	f -> version < 2
water	9:8	0:0	4	f
op	9:9	0:0	4	->
water	9:11	0:0	4	version
op	9:19	0:0	4	<
water	9:21	0:0	4	2
stmts	9:24	50:4	3	
water	9:24	0:0	4	{
decl	10:8	10:104	4	int	chroma_planes
water	10:25	0:0	4	,
decl	10:8	10:104	4	int	chroma_h_shift
water	10:41	0:0	4	,
decl	10:8	10:104	4	int	chroma_v_shift
water	10:57	0:0	4	,
decl	10:8	10:104	4	int	transparency
water	10:71	0:0	4	,
decl	10:8	10:104	4	int	colorspace
water	10:83	0:0	4	,
decl	10:8	10:104	4	int	bits_per_raw_sample
water	11:8	0:0	4	unsigned
water	11:17	0:0	4	v
op	11:18	0:0	4	=
call	11:20	11:42	4	get_symbol
arg	11:31	11:32	5	c
water	11:31	0:0	6	c
arg	11:34	11:39	5	state
water	11:34	0:0	6	state
arg	11:41	11:42	5	0
water	11:41	0:0	6	0
water	11:43	0:0	4	;
if	12:8	15:8	4	(v >= 2)
cond	12:12	12:17	5	v >= 2
water	12:12	0:0	6	v
op	12:14	0:0	6	>=
water	12:17	0:0	6	2
stmts	12:20	15:8	5	
water	12:20	0:0	6	{
call	13:12	13:84	6	av_log
arg	13:19	13:27	7	f->avctx
water	13:19	0:0	8	f
op	13:20	0:0	8	->
water	13:22	0:0	8	avctx
arg	13:29	13:41	7	AV_LOG_ERROR
water	13:29	0:0	8	AV_LOG_ERROR
arg	13:43	13:81	7	"invalid version %d in ver01 header\n"
water	13:43	0:0	8	"invalid version %d in ver01 header\n"
arg	13:83	13:84	7	v
water	13:83	0:0	8	v
water	13:85	0:0	6	;
return	14:12	14:38	6	AVERROR_INVALIDDATA
water	14:19	0:0	7	AVERROR_INVALIDDATA
water	15:8	0:0	6	}
water	16:8	0:0	4	f
op	16:9	0:0	4	->
water	16:11	0:0	4	version
op	16:19	0:0	4	=
water	16:21	0:0	4	v
water	16:22	0:0	4	;
water	17:8	0:0	4	f
op	17:9	0:0	4	->
water	17:11	0:0	4	ac
op	17:19	0:0	4	=
water	17:21	0:0	4	f
op	17:22	0:0	4	->
water	17:24	0:0	4	avctx
op	17:29	0:0	4	->
water	17:31	0:0	4	coder_type
op	17:42	0:0	4	=
call	17:44	17:66	4	get_symbol
arg	17:55	17:56	5	c
water	17:55	0:0	6	c
arg	17:58	17:63	5	state
water	17:58	0:0	6	state
arg	17:65	17:66	5	0
water	17:65	0:0	6	0
water	17:67	0:0	4	;
if	18:8	21:8	4	(f -> ac > 1)
cond	18:12	18:20	5	f -> ac > 1
water	18:12	0:0	6	f
op	18:13	0:0	6	->
water	18:15	0:0	6	ac
op	18:18	0:0	6	>
water	18:20	0:0	6	1
stmts	18:23	21:8	5	
water	18:23	0:0	6	{
for	19:12	20:82	6	(i = 1 ;i < 256;i ++)
forinit	19:17	19:22	7	i = 1 ;
water	19:17	0:0	8	i
op	19:19	0:0	8	=
water	19:21	0:0	8	1
water	19:22	0:0	8	;
cond	19:24	19:28	7	i < 256
water	19:24	0:0	8	i
op	19:26	0:0	8	<
water	19:28	0:0	8	256
forexpr	19:33	19:34	7	i ++
water	19:33	0:0	8	i
op	19:34	0:0	8	++
stmts	20:16	20:82	7	
water	20:16	0:0	8	f
op	20:17	0:0	8	->
water	20:19	0:0	8	state_transition
op	20:35	0:0	8	[
water	20:36	0:0	8	i
op	20:37	0:0	8	]
op	20:39	0:0	8	=
call	20:41	20:63	8	get_symbol
arg	20:52	20:53	9	c
water	20:52	0:0	10	c
arg	20:55	20:60	9	state
water	20:55	0:0	10	state
arg	20:62	20:63	9	1
water	20:62	0:0	10	1
op	20:65	0:0	8	+
water	20:67	0:0	8	c
op	20:68	0:0	8	->
water	20:70	0:0	8	one_state
op	20:79	0:0	8	[
water	20:80	0:0	8	i
op	20:81	0:0	8	]
water	20:82	0:0	8	;
water	21:8	0:0	6	}
water	23:8	0:0	4	colorspace
op	23:23	0:0	4	=
call	23:25	23:47	4	get_symbol
arg	23:36	23:37	5	c
water	23:36	0:0	6	c
arg	23:39	23:44	5	state
water	23:39	0:0	6	state
arg	23:46	23:47	5	0
water	23:46	0:0	6	0
water	23:48	0:0	4	;
water	24:8	0:0	4	bits_per_raw_sample
op	24:28	0:0	4	=
water	24:30	0:0	4	f
op	24:31	0:0	4	->
water	24:33	0:0	4	version
op	24:41	0:0	4	>
water	24:43	0:0	4	0
water	24:45	0:0	4	?
call	24:47	24:69	4	get_symbol
arg	24:58	24:59	5	c
water	24:58	0:0	6	c
arg	24:61	24:66	5	state
water	24:61	0:0	6	state
arg	24:68	24:69	5	0
water	24:68	0:0	6	0
water	24:71	0:0	4	:
water	24:73	0:0	4	f
op	24:74	0:0	4	->
water	24:76	0:0	4	avctx
op	24:81	0:0	4	->
water	24:83	0:0	4	bits_per_raw_sample
water	24:102	0:0	4	;
water	25:8	0:0	4	chroma_planes
op	25:23	0:0	4	=
call	25:25	25:41	4	get_rac
arg	25:33	25:34	5	c
water	25:33	0:0	6	c
arg	25:36	25:41	5	state
water	25:36	0:0	6	state
water	25:42	0:0	4	;
water	26:8	0:0	4	chroma_h_shift
op	26:23	0:0	4	=
call	26:25	26:47	4	get_symbol
arg	26:36	26:37	5	c
water	26:36	0:0	6	c
arg	26:39	26:44	5	state
water	26:39	0:0	6	state
arg	26:46	26:47	5	0
water	26:46	0:0	6	0
water	26:48	0:0	4	;
water	27:8	0:0	4	chroma_v_shift
op	27:23	0:0	4	=
call	27:25	27:47	4	get_symbol
arg	27:36	27:37	5	c
water	27:36	0:0	6	c
arg	27:39	27:44	5	state
water	27:39	0:0	6	state
arg	27:46	27:47	5	0
water	27:46	0:0	6	0
water	27:48	0:0	4	;
water	28:8	0:0	4	transparency
op	28:23	0:0	4	=
call	28:25	28:41	4	get_rac
arg	28:33	28:34	5	c
water	28:33	0:0	6	c
arg	28:36	28:41	5	state
water	28:36	0:0	6	state
water	28:42	0:0	4	;
if	30:8	40:8	4	(f -> plane_count)
cond	30:12	30:15	5	f -> plane_count
water	30:12	0:0	6	f
op	30:13	0:0	6	->
water	30:15	0:0	6	plane_count
stmts	30:28	40:8	5	
water	30:28	0:0	6	{
if	31:12	39:12	6	(colorspace != f -> colorspace || bits_per_raw_sample != f -> avctx -> bits_per_raw_sample || chroma_planes != f -> chroma_planes || chroma_h_shift != f -> chroma_h_shift || chroma_v_shift != f -> chroma_v_shift || transparency != f -> transparency)
cond	31:19	36:39	7	colorspace != f -> colorspace || bits_per_raw_sample != f -> avctx -> bits_per_raw_sample || chroma_planes != f -> chroma_planes || chroma_h_shift != f -> chroma_h_shift || chroma_v_shift != f -> chroma_v_shift || transparency != f -> transparency
water	31:19	0:0	8	colorspace
op	31:33	0:0	8	!=
water	31:36	0:0	8	f
op	31:37	0:0	8	->
water	31:39	0:0	8	colorspace
op	32:16	0:0	8	||
water	32:19	0:0	8	bits_per_raw_sample
op	32:39	0:0	8	!=
water	32:42	0:0	8	f
op	32:43	0:0	8	->
water	32:45	0:0	8	avctx
op	32:50	0:0	8	->
water	32:52	0:0	8	bits_per_raw_sample
op	33:16	0:0	8	||
water	33:19	0:0	8	chroma_planes
op	33:33	0:0	8	!=
water	33:36	0:0	8	f
op	33:37	0:0	8	->
water	33:39	0:0	8	chroma_planes
op	34:16	0:0	8	||
water	34:19	0:0	8	chroma_h_shift
op	34:33	0:0	8	!=
water	34:36	0:0	8	f
op	34:37	0:0	8	->
water	34:39	0:0	8	chroma_h_shift
op	35:16	0:0	8	||
water	35:19	0:0	8	chroma_v_shift
op	35:33	0:0	8	!=
water	35:36	0:0	8	f
op	35:37	0:0	8	->
water	35:39	0:0	8	chroma_v_shift
op	36:16	0:0	8	||
water	36:19	0:0	8	transparency
op	36:33	0:0	8	!=
water	36:36	0:0	8	f
op	36:37	0:0	8	->
water	36:39	0:0	8	transparency
stmts	36:53	39:12	7	
water	36:53	0:0	8	{
call	37:16	37:86	8	av_log
arg	37:23	37:31	9	f->avctx
water	37:23	0:0	10	f
op	37:24	0:0	10	->
water	37:26	0:0	10	avctx
arg	37:33	37:45	9	AV_LOG_ERROR
water	37:33	0:0	10	AV_LOG_ERROR
arg	37:47	37:86	9	"Invalid change of global parameters\n"
water	37:47	0:0	10	"Invalid change of global parameters\n"
water	37:87	0:0	8	;
return	38:16	38:42	8	AVERROR_INVALIDDATA
water	38:23	0:0	9	AVERROR_INVALIDDATA
water	39:12	0:0	8	}
water	40:8	0:0	6	}
water	42:8	0:0	4	f
op	42:9	0:0	4	->
water	42:11	0:0	4	colorspace
op	42:26	0:0	4	=
water	42:28	0:0	4	colorspace
water	42:38	0:0	4	;
water	43:8	0:0	4	f
op	43:9	0:0	4	->
water	43:11	0:0	4	avctx
op	43:16	0:0	4	->
water	43:18	0:0	4	bits_per_raw_sample
op	43:38	0:0	4	=
water	43:40	0:0	4	bits_per_raw_sample
water	43:59	0:0	4	;
water	44:8	0:0	4	f
op	44:9	0:0	4	->
water	44:11	0:0	4	chroma_planes
op	44:26	0:0	4	=
water	44:28	0:0	4	chroma_planes
water	44:41	0:0	4	;
water	45:8	0:0	4	f
op	45:9	0:0	4	->
water	45:11	0:0	4	chroma_h_shift
op	45:26	0:0	4	=
water	45:28	0:0	4	chroma_h_shift
water	45:42	0:0	4	;
water	46:8	0:0	4	f
op	46:9	0:0	4	->
water	46:11	0:0	4	chroma_v_shift
op	46:26	0:0	4	=
water	46:28	0:0	4	chroma_v_shift
water	46:42	0:0	4	;
water	47:8	0:0	4	f
op	47:9	0:0	4	->
water	47:11	0:0	4	transparency
op	47:26	0:0	4	=
water	47:28	0:0	4	transparency
water	47:40	0:0	4	;
water	49:8	0:0	4	f
op	49:9	0:0	4	->
water	49:11	0:0	4	plane_count
op	49:26	0:0	4	=
water	49:28	0:0	4	2
op	49:30	0:0	4	+
water	49:32	0:0	4	f
op	49:33	0:0	4	->
water	49:35	0:0	4	transparency
water	49:47	0:0	4	;
water	50:4	0:0	4	}
if	52:4	94:4	2	(f -> colorspace == 0)
cond	52:8	52:25	3	f -> colorspace == 0
water	52:8	0:0	4	f
op	52:9	0:0	4	->
water	52:11	0:0	4	colorspace
op	52:22	0:0	4	==
water	52:25	0:0	4	0
stmts	52:28	94:4	3	
water	52:28	0:0	4	{
if	53:8	58:8	4	(! f -> transparency && ! f -> chroma_planes)
cond	53:12	53:36	5	! f -> transparency && ! f -> chroma_planes
op	53:12	0:0	6	!
water	53:13	0:0	6	f
op	53:14	0:0	6	->
water	53:16	0:0	6	transparency
op	53:29	0:0	6	&&
op	53:32	0:0	6	!
water	53:33	0:0	6	f
op	53:34	0:0	6	->
water	53:36	0:0	6	chroma_planes
stmts	53:51	58:8	5	
water	53:51	0:0	6	{
if	54:12	55:52	6	(f -> avctx -> bits_per_raw_sample <= 8)
cond	54:16	54:49	7	f -> avctx -> bits_per_raw_sample <= 8
water	54:16	0:0	8	f
op	54:17	0:0	8	->
water	54:19	0:0	8	avctx
op	54:24	0:0	8	->
water	54:26	0:0	8	bits_per_raw_sample
op	54:46	0:0	8	<=
water	54:49	0:0	8	8
stmts	55:16	55:52	7	
water	55:16	0:0	8	f
op	55:17	0:0	8	->
water	55:19	0:0	8	avctx
op	55:24	0:0	8	->
water	55:26	0:0	8	pix_fmt
op	55:34	0:0	8	=
water	55:36	0:0	8	AV_PIX_FMT_GRAY8
water	55:52	0:0	8	;
else	56:12	57:53	6
stmts	57:16	57:53	7	
water	57:16	0:0	8	f
op	57:17	0:0	8	->
water	57:19	0:0	8	avctx
op	57:24	0:0	8	->
water	57:26	0:0	8	pix_fmt
op	57:34	0:0	8	=
water	57:36	0:0	8	AV_PIX_FMT_GRAY16
water	57:53	0:0	8	;
water	58:8	0:0	6	}
else	58:10	67:8	4
stmts	58:15	67:8	5	
if	58:15	67:8	6	(f -> avctx -> bits_per_raw_sample <= 8 && ! f -> transparency)
cond	58:19	58:59	7	f -> avctx -> bits_per_raw_sample <= 8 && ! f -> transparency
water	58:19	0:0	8	f
op	58:20	0:0	8	->
water	58:22	0:0	8	avctx
op	58:27	0:0	8	->
water	58:29	0:0	8	bits_per_raw_sample
op	58:48	0:0	8	<=
water	58:50	0:0	8	8
op	58:52	0:0	8	&&
op	58:55	0:0	8	!
water	58:56	0:0	8	f
op	58:57	0:0	8	->
water	58:59	0:0	8	transparency
stmts	58:73	67:8	7	
water	58:73	0:0	8	{
switch	59:12	66:12	8	(16 * f -> chroma_h_shift + f -> chroma_v_shift)
cond	59:19	59:47	9	16 * f -> chroma_h_shift + f -> chroma_v_shift
water	59:19	0:0	10	16
op	59:22	0:0	10	*
water	59:24	0:0	10	f
op	59:25	0:0	10	->
water	59:27	0:0	10	chroma_h_shift
op	59:42	0:0	10	+
water	59:44	0:0	10	f
op	59:45	0:0	10	->
water	59:47	0:0	10	chroma_v_shift
stmts	59:63	66:12	9	
water	59:63	0:0	10	{
label	60:12	60:21	10	case 0 x00 :
water	60:23	0:0	10	f
op	60:24	0:0	10	->
water	60:26	0:0	10	avctx
op	60:31	0:0	10	->
water	60:33	0:0	10	pix_fmt
op	60:41	0:0	10	=
water	60:43	0:0	10	AV_PIX_FMT_YUV444P
water	60:61	0:0	10	;
break	60:63	60:68	10	
label	61:12	61:21	10	case 0 x01 :
water	61:23	0:0	10	f
op	61:24	0:0	10	->
water	61:26	0:0	10	avctx
op	61:31	0:0	10	->
water	61:33	0:0	10	pix_fmt
op	61:41	0:0	10	=
water	61:43	0:0	10	AV_PIX_FMT_YUV440P
water	61:61	0:0	10	;
break	61:63	61:68	10	
label	62:12	62:21	10	case 0 x10 :
water	62:23	0:0	10	f
op	62:24	0:0	10	->
water	62:26	0:0	10	avctx
op	62:31	0:0	10	->
water	62:33	0:0	10	pix_fmt
op	62:41	0:0	10	=
water	62:43	0:0	10	AV_PIX_FMT_YUV422P
water	62:61	0:0	10	;
break	62:63	62:68	10	
label	63:12	63:21	10	case 0 x11 :
water	63:23	0:0	10	f
op	63:24	0:0	10	->
water	63:26	0:0	10	avctx
op	63:31	0:0	10	->
water	63:33	0:0	10	pix_fmt
op	63:41	0:0	10	=
water	63:43	0:0	10	AV_PIX_FMT_YUV420P
water	63:61	0:0	10	;
break	63:63	63:68	10	
label	64:12	64:21	10	case 0 x20 :
water	64:23	0:0	10	f
op	64:24	0:0	10	->
water	64:26	0:0	10	avctx
op	64:31	0:0	10	->
water	64:33	0:0	10	pix_fmt
op	64:41	0:0	10	=
water	64:43	0:0	10	AV_PIX_FMT_YUV411P
water	64:61	0:0	10	;
break	64:63	64:68	10	
label	65:12	65:21	10	case 0 x22 :
water	65:23	0:0	10	f
op	65:24	0:0	10	->
water	65:26	0:0	10	avctx
op	65:31	0:0	10	->
water	65:33	0:0	10	pix_fmt
op	65:41	0:0	10	=
water	65:43	0:0	10	AV_PIX_FMT_YUV410P
water	65:61	0:0	10	;
break	65:63	65:68	10	
water	66:12	0:0	10	}
water	67:8	0:0	8	}
else	67:10	73:8	4
stmts	67:15	73:8	5	
if	67:15	73:8	6	(f -> avctx -> bits_per_raw_sample <= 8 && f -> transparency)
cond	67:19	67:60	7	f -> avctx -> bits_per_raw_sample <= 8 && f -> transparency
water	67:19	0:0	8	f
op	67:20	0:0	8	->
water	67:22	0:0	8	avctx
op	67:27	0:0	8	->
water	67:29	0:0	8	bits_per_raw_sample
op	67:49	0:0	8	<=
water	67:52	0:0	8	8
op	67:54	0:0	8	&&
water	67:57	0:0	8	f
op	67:58	0:0	8	->
water	67:60	0:0	8	transparency
stmts	67:74	73:8	7	
water	67:74	0:0	8	{
switch	68:12	72:12	8	(16 * f -> chroma_h_shift + f -> chroma_v_shift)
cond	68:19	68:45	9	16 * f -> chroma_h_shift + f -> chroma_v_shift
water	68:19	0:0	10	16
op	68:21	0:0	10	*
water	68:22	0:0	10	f
op	68:23	0:0	10	->
water	68:25	0:0	10	chroma_h_shift
op	68:40	0:0	10	+
water	68:42	0:0	10	f
op	68:43	0:0	10	->
water	68:45	0:0	10	chroma_v_shift
stmts	68:61	72:12	9	
water	68:61	0:0	10	{
label	69:12	69:21	10	case 0 x00 :
water	69:23	0:0	10	f
op	69:24	0:0	10	->
water	69:26	0:0	10	avctx
op	69:31	0:0	10	->
water	69:33	0:0	10	pix_fmt
op	69:41	0:0	10	=
water	69:43	0:0	10	AV_PIX_FMT_YUVA444P
water	69:62	0:0	10	;
break	69:64	69:69	10	
label	70:12	70:21	10	case 0 x10 :
water	70:23	0:0	10	f
op	70:24	0:0	10	->
water	70:26	0:0	10	avctx
op	70:31	0:0	10	->
water	70:33	0:0	10	pix_fmt
op	70:41	0:0	10	=
water	70:43	0:0	10	AV_PIX_FMT_YUVA422P
water	70:62	0:0	10	;
break	70:64	70:69	10	
label	71:12	71:21	10	case 0 x11 :
water	71:23	0:0	10	f
op	71:24	0:0	10	->
water	71:26	0:0	10	avctx
op	71:31	0:0	10	->
water	71:33	0:0	10	pix_fmt
op	71:41	0:0	10	=
water	71:43	0:0	10	AV_PIX_FMT_YUVA420P
water	71:62	0:0	10	;
break	71:64	71:69	10	
water	72:12	0:0	10	}
water	73:8	0:0	8	}
else	73:10	80:8	4
stmts	73:15	80:8	5	
if	73:15	80:8	6	(f -> avctx -> bits_per_raw_sample == 9 && ! f -> transparency)
cond	73:19	73:61	7	f -> avctx -> bits_per_raw_sample == 9 && ! f -> transparency
water	73:19	0:0	8	f
op	73:20	0:0	8	->
water	73:22	0:0	8	avctx
op	73:27	0:0	8	->
water	73:29	0:0	8	bits_per_raw_sample
op	73:49	0:0	8	==
water	73:52	0:0	8	9
op	73:54	0:0	8	&&
op	73:57	0:0	8	!
water	73:58	0:0	8	f
op	73:59	0:0	8	->
water	73:61	0:0	8	transparency
stmts	73:75	80:8	7	
water	73:75	0:0	8	{
water	74:12	0:0	8	f
op	74:13	0:0	8	->
water	74:15	0:0	8	packed_at_lsb
op	74:29	0:0	8	=
water	74:31	0:0	8	1
water	74:32	0:0	8	;
switch	75:12	79:12	8	(16 * f -> chroma_h_shift + f -> chroma_v_shift)
cond	75:19	75:47	9	16 * f -> chroma_h_shift + f -> chroma_v_shift
water	75:19	0:0	10	16
op	75:22	0:0	10	*
water	75:24	0:0	10	f
op	75:25	0:0	10	->
water	75:27	0:0	10	chroma_h_shift
op	75:42	0:0	10	+
water	75:44	0:0	10	f
op	75:45	0:0	10	->
water	75:47	0:0	10	chroma_v_shift
stmts	75:63	79:12	9	
water	75:63	0:0	10	{
label	76:12	76:21	10	case 0 x00 :
water	76:23	0:0	10	f
op	76:24	0:0	10	->
water	76:26	0:0	10	avctx
op	76:31	0:0	10	->
water	76:33	0:0	10	pix_fmt
op	76:41	0:0	10	=
water	76:43	0:0	10	AV_PIX_FMT_YUV444P9
water	76:62	0:0	10	;
break	76:64	76:69	10	
label	77:12	77:21	10	case 0 x10 :
water	77:23	0:0	10	f
op	77:24	0:0	10	->
water	77:26	0:0	10	avctx
op	77:31	0:0	10	->
water	77:33	0:0	10	pix_fmt
op	77:41	0:0	10	=
water	77:43	0:0	10	AV_PIX_FMT_YUV422P9
water	77:62	0:0	10	;
break	77:64	77:69	10	
label	78:12	78:21	10	case 0 x11 :
water	78:23	0:0	10	f
op	78:24	0:0	10	->
water	78:26	0:0	10	avctx
op	78:31	0:0	10	->
water	78:33	0:0	10	pix_fmt
op	78:41	0:0	10	=
water	78:43	0:0	10	AV_PIX_FMT_YUV420P9
water	78:62	0:0	10	;
break	78:64	78:69	10	
water	79:12	0:0	10	}
water	80:8	0:0	8	}
else	80:10	87:8	4
stmts	80:15	87:8	5	
if	80:15	87:8	6	(f -> avctx -> bits_per_raw_sample == 10 && ! f -> transparency)
cond	80:19	80:62	7	f -> avctx -> bits_per_raw_sample == 10 && ! f -> transparency
water	80:19	0:0	8	f
op	80:20	0:0	8	->
water	80:22	0:0	8	avctx
op	80:27	0:0	8	->
water	80:29	0:0	8	bits_per_raw_sample
op	80:49	0:0	8	==
water	80:52	0:0	8	10
op	80:55	0:0	8	&&
op	80:58	0:0	8	!
water	80:59	0:0	8	f
op	80:60	0:0	8	->
water	80:62	0:0	8	transparency
stmts	80:76	87:8	7	
water	80:76	0:0	8	{
water	81:12	0:0	8	f
op	81:13	0:0	8	->
water	81:15	0:0	8	packed_at_lsb
op	81:29	0:0	8	=
water	81:31	0:0	8	1
water	81:32	0:0	8	;
switch	82:12	86:12	8	(16 * f -> chroma_h_shift + f -> chroma_v_shift)
cond	82:19	82:47	9	16 * f -> chroma_h_shift + f -> chroma_v_shift
water	82:19	0:0	10	16
op	82:22	0:0	10	*
water	82:24	0:0	10	f
op	82:25	0:0	10	->
water	82:27	0:0	10	chroma_h_shift
op	82:42	0:0	10	+
water	82:44	0:0	10	f
op	82:45	0:0	10	->
water	82:47	0:0	10	chroma_v_shift
stmts	82:63	86:12	9	
water	82:63	0:0	10	{
label	83:12	83:21	10	case 0 x00 :
water	83:23	0:0	10	f
op	83:24	0:0	10	->
water	83:26	0:0	10	avctx
op	83:31	0:0	10	->
water	83:33	0:0	10	pix_fmt
op	83:41	0:0	10	=
water	83:43	0:0	10	AV_PIX_FMT_YUV444P10
water	83:63	0:0	10	;
break	83:65	83:70	10	
label	84:12	84:21	10	case 0 x10 :
water	84:23	0:0	10	f
op	84:24	0:0	10	->
water	84:26	0:0	10	avctx
op	84:31	0:0	10	->
water	84:33	0:0	10	pix_fmt
op	84:41	0:0	10	=
water	84:43	0:0	10	AV_PIX_FMT_YUV422P10
water	84:63	0:0	10	;
break	84:65	84:70	10	
label	85:12	85:21	10	case 0 x11 :
water	85:23	0:0	10	f
op	85:24	0:0	10	->
water	85:26	0:0	10	avctx
op	85:31	0:0	10	->
water	85:33	0:0	10	pix_fmt
op	85:41	0:0	10	=
water	85:43	0:0	10	AV_PIX_FMT_YUV420P10
water	85:63	0:0	10	;
break	85:65	85:70	10	
water	86:12	0:0	10	}
water	87:8	0:0	8	}
else	87:10	93:8	4
stmts	87:15	93:8	5	
if	87:15	93:8	6	(f -> avctx -> bits_per_raw_sample == 16 && ! f -> transparency)
cond	87:19	87:62	7	f -> avctx -> bits_per_raw_sample == 16 && ! f -> transparency
water	87:19	0:0	8	f
op	87:20	0:0	8	->
water	87:22	0:0	8	avctx
op	87:27	0:0	8	->
water	87:29	0:0	8	bits_per_raw_sample
op	87:49	0:0	8	==
water	87:52	0:0	8	16
op	87:55	0:0	8	&&
op	87:58	0:0	8	!
water	87:59	0:0	8	f
op	87:60	0:0	8	->
water	87:62	0:0	8	transparency
stmts	87:75	93:8	7	
water	87:75	0:0	8	{
switch	88:12	92:12	8	(16 * f -> chroma_h_shift + f -> chroma_v_shift)
cond	88:19	88:47	9	16 * f -> chroma_h_shift + f -> chroma_v_shift
water	88:19	0:0	10	16
op	88:22	0:0	10	*
water	88:24	0:0	10	f
op	88:25	0:0	10	->
water	88:27	0:0	10	chroma_h_shift
op	88:42	0:0	10	+
water	88:44	0:0	10	f
op	88:45	0:0	10	->
water	88:47	0:0	10	chroma_v_shift
stmts	88:63	92:12	9	
water	88:63	0:0	10	{
label	89:12	89:21	10	case 0 x00 :
water	89:23	0:0	10	f
op	89:24	0:0	10	->
water	89:26	0:0	10	avctx
op	89:31	0:0	10	->
water	89:33	0:0	10	pix_fmt
op	89:41	0:0	10	=
water	89:43	0:0	10	AV_PIX_FMT_YUV444P16
water	89:63	0:0	10	;
break	89:65	89:70	10	
label	90:12	90:21	10	case 0 x10 :
water	90:23	0:0	10	f
op	90:24	0:0	10	->
water	90:26	0:0	10	avctx
op	90:31	0:0	10	->
water	90:33	0:0	10	pix_fmt
op	90:41	0:0	10	=
water	90:43	0:0	10	AV_PIX_FMT_YUV422P16
water	90:63	0:0	10	;
break	90:65	90:70	10	
label	91:12	91:21	10	case 0 x11 :
water	91:23	0:0	10	f
op	91:24	0:0	10	->
water	91:26	0:0	10	avctx
op	91:31	0:0	10	->
water	91:33	0:0	10	pix_fmt
op	91:41	0:0	10	=
water	91:43	0:0	10	AV_PIX_FMT_YUV420P16
water	91:63	0:0	10	;
break	91:65	91:70	10	
water	92:12	0:0	10	}
water	93:8	0:0	8	}
water	94:4	0:0	4	}
else	94:6	111:4	2
stmts	94:11	111:4	3	
if	94:11	111:4	4	(f -> colorspace == 1)
cond	94:15	94:32	5	f -> colorspace == 1
water	94:15	0:0	6	f
op	94:16	0:0	6	->
water	94:18	0:0	6	colorspace
op	94:29	0:0	6	==
water	94:32	0:0	6	1
stmts	94:35	111:4	5	
water	94:35	0:0	6	{
if	95:8	99:8	6	(f -> chroma_h_shift || f -> chroma_v_shift)
cond	95:12	95:36	7	f -> chroma_h_shift || f -> chroma_v_shift
water	95:12	0:0	8	f
op	95:13	0:0	8	->
water	95:15	0:0	8	chroma_h_shift
op	95:30	0:0	8	||
water	95:33	0:0	8	f
op	95:34	0:0	8	->
water	95:36	0:0	8	chroma_v_shift
stmts	95:52	99:8	7	
water	95:52	0:0	8	{
call	96:12	97:74	8	av_log
arg	96:19	96:27	9	f->avctx
water	96:19	0:0	10	f
op	96:20	0:0	10	->
water	96:22	0:0	10	avctx
arg	96:29	96:41	9	AV_LOG_ERROR
water	96:29	0:0	10	AV_LOG_ERROR
arg	97:19	97:74	9	"chroma subsampling not supported in this colorspace\n"
water	97:19	0:0	10	"chroma subsampling not supported in this colorspace\n"
water	97:75	0:0	8	;
return	98:12	98:34	8	AVERROR(ENOSYS)
call	98:19	98:33	9	AVERROR
arg	98:27	98:33	10	ENOSYS
water	98:27	0:0	11	ENOSYS
water	99:8	0:0	8	}
if	100:8	101:48	6	(f -> avctx -> bits_per_raw_sample == 9)
cond	100:17	100:51	7	f -> avctx -> bits_per_raw_sample == 9
water	100:17	0:0	8	f
op	100:18	0:0	8	->
water	100:20	0:0	8	avctx
op	100:25	0:0	8	->
water	100:27	0:0	8	bits_per_raw_sample
op	100:47	0:0	8	==
water	100:51	0:0	8	9
stmts	101:12	101:48	7	
water	101:12	0:0	8	f
op	101:13	0:0	8	->
water	101:15	0:0	8	avctx
op	101:20	0:0	8	->
water	101:22	0:0	8	pix_fmt
op	101:30	0:0	8	=
water	101:32	0:0	8	AV_PIX_FMT_GBRP9
water	101:48	0:0	8	;
else	102:8	103:49	6
stmts	102:13	103:49	7	
if	102:13	103:49	8	(f -> avctx -> bits_per_raw_sample == 10)
cond	102:17	102:50	9	f -> avctx -> bits_per_raw_sample == 10
water	102:17	0:0	10	f
op	102:18	0:0	10	->
water	102:20	0:0	10	avctx
op	102:25	0:0	10	->
water	102:27	0:0	10	bits_per_raw_sample
op	102:47	0:0	10	==
water	102:50	0:0	10	10
stmts	103:12	103:49	9	
water	103:12	0:0	10	f
op	103:13	0:0	10	->
water	103:15	0:0	10	avctx
op	103:20	0:0	10	->
water	103:22	0:0	10	pix_fmt
op	103:30	0:0	10	=
water	103:32	0:0	10	AV_PIX_FMT_GBRP10
water	103:49	0:0	10	;
else	104:8	105:49	6
stmts	104:13	105:49	7	
if	104:13	105:49	8	(f -> avctx -> bits_per_raw_sample == 12)
cond	104:17	104:50	9	f -> avctx -> bits_per_raw_sample == 12
water	104:17	0:0	10	f
op	104:18	0:0	10	->
water	104:20	0:0	10	avctx
op	104:25	0:0	10	->
water	104:27	0:0	10	bits_per_raw_sample
op	104:47	0:0	10	==
water	104:50	0:0	10	12
stmts	105:12	105:49	9	
water	105:12	0:0	10	f
op	105:13	0:0	10	->
water	105:15	0:0	10	avctx
op	105:20	0:0	10	->
water	105:22	0:0	10	pix_fmt
op	105:30	0:0	10	=
water	105:32	0:0	10	AV_PIX_FMT_GBRP12
water	105:49	0:0	10	;
else	106:8	107:49	6
stmts	106:13	107:49	7	
if	106:13	107:49	8	(f -> avctx -> bits_per_raw_sample == 14)
cond	106:17	106:50	9	f -> avctx -> bits_per_raw_sample == 14
water	106:17	0:0	10	f
op	106:18	0:0	10	->
water	106:20	0:0	10	avctx
op	106:25	0:0	10	->
water	106:27	0:0	10	bits_per_raw_sample
op	106:47	0:0	10	==
water	106:50	0:0	10	14
stmts	107:12	107:49	9	
water	107:12	0:0	10	f
op	107:13	0:0	10	->
water	107:15	0:0	10	avctx
op	107:20	0:0	10	->
water	107:22	0:0	10	pix_fmt
op	107:30	0:0	10	=
water	107:32	0:0	10	AV_PIX_FMT_GBRP14
water	107:49	0:0	10	;
else	108:8	109:65	6
stmts	109:8	109:65	7	
if	109:8	109:65	8	(f -> transparency)
cond	109:12	109:15	9	f -> transparency
water	109:12	0:0	10	f
op	109:13	0:0	10	->
water	109:15	0:0	10	transparency
stmts	109:29	109:65	9	
water	109:29	0:0	10	f
op	109:30	0:0	10	->
water	109:32	0:0	10	avctx
op	109:37	0:0	10	->
water	109:39	0:0	10	pix_fmt
op	109:47	0:0	10	=
water	109:49	0:0	10	AV_PIX_FMT_RGB32
water	109:65	0:0	10	;
else	110:8	110:66	6
stmts	110:29	110:66	7	
water	110:29	0:0	8	f
op	110:30	0:0	8	->
water	110:32	0:0	8	avctx
op	110:37	0:0	8	->
water	110:39	0:0	8	pix_fmt
op	110:47	0:0	8	=
water	110:49	0:0	8	AV_PIX_FMT_0RGB32
water	110:66	0:0	8	;
water	111:4	0:0	6	}
else	111:6	114:4	2
stmts	111:11	114:4	3	
water	111:11	0:0	4	{
call	112:8	112:67	4	av_log
arg	112:15	112:23	5	f->avctx
water	112:15	0:0	6	f
op	112:16	0:0	6	->
water	112:18	0:0	6	avctx
arg	112:25	112:37	5	AV_LOG_ERROR
water	112:25	0:0	6	AV_LOG_ERROR
arg	112:39	112:67	5	"colorspace not supported\n"
water	112:39	0:0	6	"colorspace not supported\n"
water	112:68	0:0	4	;
return	113:8	113:30	4	AVERROR(ENOSYS)
call	113:15	113:29	5	AVERROR
arg	113:23	113:29	6	ENOSYS
water	113:23	0:0	7	ENOSYS
water	114:4	0:0	4	}
if	115:4	118:4	2	(f -> avctx -> pix_fmt == AV_PIX_FMT_NONE)
cond	115:8	115:29	3	f -> avctx -> pix_fmt == AV_PIX_FMT_NONE
water	115:8	0:0	4	f
op	115:9	0:0	4	->
water	115:11	0:0	4	avctx
op	115:16	0:0	4	->
water	115:18	0:0	4	pix_fmt
op	115:26	0:0	4	==
water	115:29	0:0	4	AV_PIX_FMT_NONE
stmts	115:46	118:4	3	
water	115:46	0:0	4	{
call	116:8	116:63	4	av_log
arg	116:15	116:23	5	f->avctx
water	116:15	0:0	6	f
op	116:16	0:0	6	->
water	116:18	0:0	6	avctx
arg	116:25	116:37	5	AV_LOG_ERROR
water	116:25	0:0	6	AV_LOG_ERROR
arg	116:39	116:63	5	"format not supported\n"
water	116:39	0:0	6	"format not supported\n"
water	116:64	0:0	4	;
return	117:8	117:30	4	AVERROR(ENOSYS)
call	117:15	117:29	5	AVERROR
arg	117:23	117:29	6	ENOSYS
water	117:23	0:0	7	ENOSYS
water	118:4	0:0	4	}
call	120:4	121:67	2	av_dlog
arg	120:12	120:20	3	f->avctx
water	120:12	0:0	4	f
op	120:13	0:0	4	->
water	120:15	0:0	4	avctx
arg	120:22	120:34	3	"%d %d %d\n"
water	120:22	0:0	4	"%d %d %d\n"
arg	121:12	121:29	3	f->chroma_h_shift
water	121:12	0:0	4	f
op	121:13	0:0	4	->
water	121:15	0:0	4	chroma_h_shift
arg	121:31	121:48	3	f->chroma_v_shift
water	121:31	0:0	4	f
op	121:32	0:0	4	->
water	121:34	0:0	4	chroma_v_shift
arg	121:50	121:67	3	f->avctx->pix_fmt
water	121:50	0:0	4	f
op	121:51	0:0	4	->
water	121:53	0:0	4	avctx
op	121:58	0:0	4	->
water	121:60	0:0	4	pix_fmt
water	121:68	0:0	2	;
if	122:4	128:4	2	(f -> version < 2)
cond	122:8	122:21	3	f -> version < 2
water	122:8	0:0	4	f
op	122:9	0:0	4	->
water	122:11	0:0	4	version
op	122:19	0:0	4	<
water	122:21	0:0	4	2
stmts	122:24	128:4	3	
water	122:24	0:0	4	{
water	123:8	0:0	4	context_count
op	123:22	0:0	4	=
call	123:24	123:59	4	read_quant_tables
arg	123:42	123:43	5	c
water	123:42	0:0	6	c
arg	123:45	123:59	5	f->quant_table
water	123:45	0:0	6	f
op	123:46	0:0	6	->
water	123:48	0:0	6	quant_table
water	123:60	0:0	4	;
if	124:8	127:8	4	(context_count < 0)
cond	124:12	124:28	5	context_count < 0
water	124:12	0:0	6	context_count
op	124:26	0:0	6	<
water	124:28	0:0	6	0
stmts	124:31	127:8	5	
water	124:31	0:0	6	{
call	125:12	125:69	6	av_log
arg	125:19	125:27	7	f->avctx
water	125:19	0:0	8	f
op	125:20	0:0	8	->
water	125:22	0:0	8	avctx
arg	125:29	125:41	7	AV_LOG_ERROR
water	125:29	0:0	8	AV_LOG_ERROR
arg	125:43	125:69	7	"read_quant_table error\n"
water	125:43	0:0	8	"read_quant_table error\n"
water	125:70	0:0	6	;
return	126:12	126:38	6	AVERROR_INVALIDDATA
water	126:19	0:0	7	AVERROR_INVALIDDATA
water	127:8	0:0	6	}
water	128:4	0:0	4	}
else	128:6	130:4	2
stmts	128:11	130:4	3	
if	128:11	130:4	4	(f -> version < 3)
cond	128:15	128:28	5	f -> version < 3
water	128:15	0:0	6	f
op	128:16	0:0	6	->
water	128:18	0:0	6	version
op	128:26	0:0	6	<
water	128:28	0:0	6	3
stmts	128:31	130:4	5	
water	128:31	0:0	6	{
water	129:8	0:0	6	f
op	129:9	0:0	6	->
water	129:11	0:0	6	slice_count
op	129:23	0:0	6	=
call	129:25	129:47	6	get_symbol
arg	129:36	129:37	7	c
water	129:36	0:0	8	c
arg	129:39	129:44	7	state
water	129:39	0:0	8	state
arg	129:46	129:47	7	0
water	129:46	0:0	8	0
water	129:48	0:0	6	;
water	130:4	0:0	6	}
else	130:6	141:4	2
stmts	130:11	141:4	3	
water	130:11	0:0	4	{
decl	131:8	131:44	4	const uint8_t	*p
op	131:25	0:0	4	=
water	131:27	0:0	4	c
op	131:28	0:0	4	->
water	131:30	0:0	4	bytestream_end
for	132:8	140:8	4	(f -> slice_count = 0 ;f -> slice_count < MAX_SLICES && 3 < p - c -> bytestream_start;f -> slice_count ++)
forinit	132:13	132:31	5	f -> slice_count = 0 ;
water	132:13	0:0	6	f
op	132:14	0:0	6	->
water	132:16	0:0	6	slice_count
op	132:28	0:0	6	=
water	132:30	0:0	6	0
water	132:31	0:0	6	;
cond	133:13	133:55	5	f -> slice_count < MAX_SLICES && 3 < p - c -> bytestream_start
water	133:13	0:0	6	f
op	133:14	0:0	6	->
water	133:16	0:0	6	slice_count
op	133:28	0:0	6	<
water	133:30	0:0	6	MAX_SLICES
op	133:41	0:0	6	&&
water	133:44	0:0	6	3
op	133:46	0:0	6	<
water	133:48	0:0	6	p
op	133:50	0:0	6	-
water	133:52	0:0	6	c
op	133:53	0:0	6	->
water	133:55	0:0	6	bytestream_start
forexpr	134:13	134:27	5	f -> slice_count ++
water	134:13	0:0	6	f
op	134:14	0:0	6	->
water	134:16	0:0	6	slice_count
op	134:27	0:0	6	++
stmts	134:31	140:8	5	
water	134:31	0:0	6	{
decl	135:12	135:39	6	int	trailer
op	135:24	0:0	6	=
water	135:26	0:0	6	3
op	135:28	0:0	6	+
water	135:30	0:0	6	5
op	135:31	0:0	6	*
op	135:32	0:0	6	!
op	135:33	0:0	6	!
water	135:34	0:0	6	f
op	135:35	0:0	6	->
water	135:37	0:0	6	ec
decl	136:12	136:41	6	int	size
op	136:21	0:0	6	=
call	136:23	136:40	7	AV_RB24
arg	136:31	136:40	8	p-trailer
water	136:31	0:0	9	p
op	136:32	0:0	9	-
water	136:33	0:0	9	trailer
if	137:12	138:21	6	(size + trailer > p - c -> bytestream_start)
cond	137:16	137:40	7	size + trailer > p - c -> bytestream_start
water	137:16	0:0	8	size
op	137:21	0:0	8	+
water	137:23	0:0	8	trailer
op	137:31	0:0	8	>
water	137:33	0:0	8	p
op	137:35	0:0	8	-
water	137:37	0:0	8	c
op	137:38	0:0	8	->
water	137:40	0:0	8	bytestream_start
stmts	138:16	138:21	7	
break	138:16	138:21	8	
water	139:12	0:0	6	p
op	139:14	0:0	6	-=
water	139:17	0:0	6	size
op	139:22	0:0	6	+
water	139:24	0:0	6	trailer
water	139:31	0:0	6	;
water	140:8	0:0	6	}
water	141:4	0:0	4	}
if	142:4	145:4	2	(f -> slice_count > ( unsigned ) MAX_SLICES || f -> slice_count <= 0)
cond	142:8	142:67	3	f -> slice_count > ( unsigned ) MAX_SLICES || f -> slice_count <= 0
water	142:8	0:0	4	f
op	142:9	0:0	4	->
water	142:11	0:0	4	slice_count
op	142:23	0:0	4	>
water	142:25	0:0	4	(
water	142:26	0:0	4	unsigned
water	142:34	0:0	4	)
water	142:35	0:0	4	MAX_SLICES
op	142:46	0:0	4	||
water	142:49	0:0	4	f
op	142:50	0:0	4	->
water	142:52	0:0	4	slice_count
op	142:64	0:0	4	<=
water	142:67	0:0	4	0
stmts	142:70	145:4	3	
water	142:70	0:0	4	{
call	143:8	143:84	4	av_log
arg	143:15	143:23	5	f->avctx
water	143:15	0:0	6	f
op	143:16	0:0	6	->
water	143:18	0:0	6	avctx
arg	143:25	143:37	5	AV_LOG_ERROR
water	143:25	0:0	6	AV_LOG_ERROR
arg	143:39	143:68	5	"slice count %d is invalid\n"
water	143:39	0:0	6	"slice count %d is invalid\n"
arg	143:70	143:84	5	f->slice_count
water	143:70	0:0	6	f
op	143:71	0:0	6	->
water	143:73	0:0	6	slice_count
water	143:85	0:0	4	;
return	144:8	144:34	4	AVERROR_INVALIDDATA
water	144:15	0:0	5	AVERROR_INVALIDDATA
water	145:4	0:0	4	}
for	147:4	199:4	2	(j = 0 ;j < f -> slice_count;j ++)
forinit	147:9	147:14	3	j = 0 ;
water	147:9	0:0	4	j
op	147:11	0:0	4	=
water	147:13	0:0	4	0
water	147:14	0:0	4	;
cond	147:16	147:23	3	j < f -> slice_count
water	147:16	0:0	4	j
op	147:18	0:0	4	<
water	147:20	0:0	4	f
op	147:21	0:0	4	->
water	147:23	0:0	4	slice_count
forexpr	147:36	147:37	3	j ++
water	147:36	0:0	4	j
op	147:37	0:0	4	++
stmts	147:41	199:4	3	
water	147:41	0:0	4	{
decl	148:8	148:45	4	FFV1Context	*fs
op	148:24	0:0	4	=
water	148:26	0:0	4	f
op	148:27	0:0	4	->
water	148:29	0:0	4	slice_context
op	148:42	0:0	4	[
water	148:43	0:0	4	j
op	148:44	0:0	4	]
water	149:8	0:0	4	fs
op	149:10	0:0	4	->
water	149:12	0:0	4	ac
op	149:26	0:0	4	=
water	149:28	0:0	4	f
op	149:29	0:0	4	->
water	149:31	0:0	4	ac
water	149:33	0:0	4	;
water	150:8	0:0	4	fs
op	150:10	0:0	4	->
water	150:12	0:0	4	packed_at_lsb
op	150:26	0:0	4	=
water	150:28	0:0	4	f
op	150:29	0:0	4	->
water	150:31	0:0	4	packed_at_lsb
water	150:44	0:0	4	;
water	152:8	0:0	4	fs
op	152:10	0:0	4	->
water	152:12	0:0	4	slice_damaged
op	152:26	0:0	4	=
water	152:28	0:0	4	0
water	152:29	0:0	4	;
if	154:8	170:8	4	(f -> version == 2)
cond	154:12	154:26	5	f -> version == 2
water	154:12	0:0	6	f
op	154:13	0:0	6	->
water	154:15	0:0	6	version
op	154:23	0:0	6	==
water	154:26	0:0	6	2
stmts	154:29	170:8	5	
water	154:29	0:0	6	{
water	155:12	0:0	6	fs
op	155:14	0:0	6	->
water	155:16	0:0	6	slice_x
op	155:29	0:0	6	=
call	155:32	155:54	6	get_symbol
arg	155:43	155:44	7	c
water	155:43	0:0	8	c
arg	155:46	155:51	7	state
water	155:46	0:0	8	state
arg	155:53	155:54	7	0
water	155:53	0:0	8	0
op	155:61	0:0	6	*
water	155:63	0:0	6	f
op	155:64	0:0	6	->
water	155:66	0:0	6	width
water	155:72	0:0	6	;
water	156:12	0:0	6	fs
op	156:14	0:0	6	->
water	156:16	0:0	6	slice_y
op	156:29	0:0	6	=
call	156:32	156:54	6	get_symbol
arg	156:43	156:44	7	c
water	156:43	0:0	8	c
arg	156:46	156:51	7	state
water	156:46	0:0	8	state
arg	156:53	156:54	7	0
water	156:53	0:0	8	0
op	156:61	0:0	6	*
water	156:63	0:0	6	f
op	156:64	0:0	6	->
water	156:66	0:0	6	height
water	156:72	0:0	6	;
water	157:12	0:0	6	fs
op	157:14	0:0	6	->
water	157:16	0:0	6	slice_width
op	157:29	0:0	6	=
water	157:31	0:0	6	(
call	157:32	157:54	6	get_symbol
arg	157:43	157:44	7	c
water	157:43	0:0	8	c
arg	157:46	157:51	7	state
water	157:46	0:0	8	state
arg	157:53	157:54	7	0
water	157:53	0:0	8	0
op	157:56	0:0	6	+
water	157:58	0:0	6	1
water	157:59	0:0	6	)
op	157:61	0:0	6	*
water	157:63	0:0	6	f
op	157:64	0:0	6	->
water	157:66	0:0	6	width
op	157:73	0:0	6	+
water	157:75	0:0	6	fs
op	157:77	0:0	6	->
water	157:79	0:0	6	slice_x
water	157:86	0:0	6	;
water	158:12	0:0	6	fs
op	158:14	0:0	6	->
water	158:16	0:0	6	slice_height
op	158:29	0:0	6	=
water	158:31	0:0	6	(
call	158:32	158:54	6	get_symbol
arg	158:43	158:44	7	c
water	158:43	0:0	8	c
arg	158:46	158:51	7	state
water	158:46	0:0	8	state
arg	158:53	158:54	7	0
water	158:53	0:0	8	0
op	158:56	0:0	6	+
water	158:58	0:0	6	1
water	158:59	0:0	6	)
op	158:61	0:0	6	*
water	158:63	0:0	6	f
op	158:64	0:0	6	->
water	158:66	0:0	6	height
op	158:73	0:0	6	+
water	158:75	0:0	6	fs
op	158:77	0:0	6	->
water	158:79	0:0	6	slice_y
water	158:86	0:0	6	;
water	160:12	0:0	6	fs
op	160:14	0:0	6	->
water	160:16	0:0	6	slice_x
op	160:28	0:0	6	/=
water	160:31	0:0	6	f
op	160:32	0:0	6	->
water	160:34	0:0	6	num_h_slices
water	160:46	0:0	6	;
water	161:12	0:0	6	fs
op	161:14	0:0	6	->
water	161:16	0:0	6	slice_y
op	161:28	0:0	6	/=
water	161:31	0:0	6	f
op	161:32	0:0	6	->
water	161:34	0:0	6	num_v_slices
water	161:46	0:0	6	;
water	162:12	0:0	6	fs
op	162:14	0:0	6	->
water	162:16	0:0	6	slice_width
op	162:29	0:0	6	=
water	162:31	0:0	6	fs
op	162:33	0:0	6	->
water	162:35	0:0	6	slice_width
op	162:48	0:0	6	/
water	162:50	0:0	6	f
op	162:51	0:0	6	->
water	162:53	0:0	6	num_h_slices
op	162:66	0:0	6	-
water	162:68	0:0	6	fs
op	162:70	0:0	6	->
water	162:72	0:0	6	slice_x
water	162:79	0:0	6	;
water	163:12	0:0	6	fs
op	163:14	0:0	6	->
water	163:16	0:0	6	slice_height
op	163:29	0:0	6	=
water	163:31	0:0	6	fs
op	163:33	0:0	6	->
water	163:35	0:0	6	slice_height
op	163:48	0:0	6	/
water	163:50	0:0	6	f
op	163:51	0:0	6	->
water	163:53	0:0	6	num_v_slices
op	163:66	0:0	6	-
water	163:68	0:0	6	fs
op	163:70	0:0	6	->
water	163:72	0:0	6	slice_y
water	163:79	0:0	6	;
if	164:12	166:42	6	(( unsigned ) fs -> slice_width > f -> width || ( unsigned ) fs -> slice_height > f -> height)
cond	164:16	165:48	7	( unsigned ) fs -> slice_width > f -> width || ( unsigned ) fs -> slice_height > f -> height
water	164:16	0:0	8	(
water	164:17	0:0	8	unsigned
water	164:25	0:0	8	)
water	164:26	0:0	8	fs
op	164:28	0:0	8	->
water	164:30	0:0	8	slice_width
op	164:43	0:0	8	>
water	164:45	0:0	8	f
op	164:46	0:0	8	->
water	164:48	0:0	8	width
op	164:54	0:0	8	||
water	165:16	0:0	8	(
water	165:17	0:0	8	unsigned
water	165:25	0:0	8	)
water	165:26	0:0	8	fs
op	165:28	0:0	8	->
water	165:30	0:0	8	slice_height
op	165:43	0:0	8	>
water	165:45	0:0	8	f
op	165:46	0:0	8	->
water	165:48	0:0	8	height
stmts	166:16	166:42	7	
return	166:16	166:42	8	AVERROR_INVALIDDATA
water	166:23	0:0	9	AVERROR_INVALIDDATA
if	167:12	169:42	6	(( unsigned ) fs -> slice_x + ( uint64_t ) fs -> slice_width > f -> width || ( unsigned ) fs -> slice_y + ( uint64_t ) fs -> slice_height > f -> height)
cond	167:19	168:75	7	( unsigned ) fs -> slice_x + ( uint64_t ) fs -> slice_width > f -> width || ( unsigned ) fs -> slice_y + ( uint64_t ) fs -> slice_height > f -> height
water	167:19	0:0	8	(
water	167:20	0:0	8	unsigned
water	167:28	0:0	8	)
water	167:29	0:0	8	fs
op	167:31	0:0	8	->
water	167:33	0:0	8	slice_x
op	167:41	0:0	8	+
water	167:43	0:0	8	(
water	167:44	0:0	8	uint64_t
water	167:52	0:0	8	)
water	167:53	0:0	8	fs
op	167:55	0:0	8	->
water	167:57	0:0	8	slice_width
op	167:70	0:0	8	>
water	167:72	0:0	8	f
op	167:73	0:0	8	->
water	167:75	0:0	8	width
op	168:16	0:0	8	||
water	168:19	0:0	8	(
water	168:20	0:0	8	unsigned
water	168:28	0:0	8	)
water	168:29	0:0	8	fs
op	168:31	0:0	8	->
water	168:33	0:0	8	slice_y
op	168:41	0:0	8	+
water	168:43	0:0	8	(
water	168:44	0:0	8	uint64_t
water	168:52	0:0	8	)
water	168:53	0:0	8	fs
op	168:55	0:0	8	->
water	168:57	0:0	8	slice_height
op	168:70	0:0	8	>
water	168:72	0:0	8	f
op	168:73	0:0	8	->
water	168:75	0:0	8	height
stmts	169:16	169:42	7	
return	169:16	169:42	8	AVERROR_INVALIDDATA
water	169:23	0:0	9	AVERROR_INVALIDDATA
water	170:8	0:0	6	}
for	172:8	198:8	4	(i = 0 ;i < f -> plane_count;i ++)
forinit	172:13	172:18	5	i = 0 ;
water	172:13	0:0	6	i
op	172:15	0:0	6	=
water	172:17	0:0	6	0
water	172:18	0:0	6	;
cond	172:20	172:27	5	i < f -> plane_count
water	172:20	0:0	6	i
op	172:22	0:0	6	<
water	172:24	0:0	6	f
op	172:25	0:0	6	->
water	172:27	0:0	6	plane_count
forexpr	172:40	172:41	5	i ++
water	172:40	0:0	6	i
op	172:41	0:0	6	++
stmts	172:45	198:8	5	
water	172:45	0:0	6	{
water	173:12	0:0	6	PlaneContext
op	173:25	0:0	6	*
water	173:26	0:0	6	const
water	173:32	0:0	6	p
op	173:34	0:0	6	=
op	173:36	0:0	6	&
water	173:37	0:0	6	fs
op	173:39	0:0	6	->
water	173:41	0:0	6	plane
op	173:46	0:0	6	[
water	173:47	0:0	6	i
op	173:48	0:0	6	]
water	173:49	0:0	6	;
if	175:12	186:12	6	(f -> version == 2)
cond	175:16	175:30	7	f -> version == 2
water	175:16	0:0	8	f
op	175:17	0:0	8	->
water	175:19	0:0	8	version
op	175:27	0:0	8	==
water	175:30	0:0	8	2
stmts	175:33	186:12	7	
water	175:33	0:0	8	{
decl	176:16	176:49	8	int	idx
op	176:24	0:0	8	=
call	176:26	176:48	9	get_symbol
arg	176:37	176:38	10	c
water	176:37	0:0	11	c
arg	176:40	176:45	10	state
water	176:40	0:0	11	state
arg	176:47	176:48	10	0
water	176:47	0:0	11	0
if	177:16	181:16	8	(idx > ( unsigned ) f -> quant_table_count)
cond	177:20	177:39	9	idx > ( unsigned ) f -> quant_table_count
water	177:20	0:0	10	idx
op	177:24	0:0	10	>
water	177:26	0:0	10	(
water	177:27	0:0	10	unsigned
water	177:35	0:0	10	)
water	177:36	0:0	10	f
op	177:37	0:0	10	->
water	177:39	0:0	10	quant_table_count
stmts	177:58	181:16	9	
water	177:58	0:0	10	{
call	178:20	179:61	10	av_log
arg	178:27	178:35	11	f->avctx
water	178:27	0:0	12	f
op	178:28	0:0	12	->
water	178:30	0:0	12	avctx
arg	178:37	178:49	11	AV_LOG_ERROR
water	178:37	0:0	12	AV_LOG_ERROR
arg	179:27	179:61	11	"quant_table_index out of range\n"
water	179:27	0:0	12	"quant_table_index out of range\n"
water	179:62	0:0	10	;
return	180:20	180:46	10	AVERROR_INVALIDDATA
water	180:27	0:0	11	AVERROR_INVALIDDATA
water	181:16	0:0	10	}
water	182:16	0:0	8	p
op	182:17	0:0	8	->
water	182:19	0:0	8	quant_table_index
op	182:37	0:0	8	=
water	182:39	0:0	8	idx
water	182:42	0:0	8	;
call	183:16	184:45	8	memcpy
arg	183:23	183:37	9	p->quant_table
water	183:23	0:0	10	p
op	183:24	0:0	10	->
water	183:26	0:0	10	quant_table
arg	183:39	183:59	9	f->quant_tables[idx]
water	183:39	0:0	10	f
op	183:40	0:0	10	->
water	183:42	0:0	10	quant_tables
op	183:54	0:0	10	[
water	183:55	0:0	10	idx
op	183:58	0:0	10	]
arg	184:23	184:45	9	sizeof(p->quant_table)
op	184:23	0:0	10	sizeof
water	184:29	0:0	10	(
water	184:30	0:0	10	p
op	184:31	0:0	10	->
water	184:33	0:0	10	quant_table
water	184:44	0:0	10	)
water	184:46	0:0	8	;
water	185:16	0:0	8	context_count
op	185:30	0:0	8	=
water	185:32	0:0	8	f
op	185:33	0:0	8	->
water	185:35	0:0	8	context_count
op	185:48	0:0	8	[
water	185:49	0:0	8	idx
op	185:52	0:0	8	]
water	185:53	0:0	8	;
water	186:12	0:0	8	}
else	186:14	188:12	6
stmts	186:19	188:12	7	
water	186:19	0:0	8	{
call	187:16	187:77	8	memcpy
arg	187:23	187:37	9	p->quant_table
water	187:23	0:0	10	p
op	187:24	0:0	10	->
water	187:26	0:0	10	quant_table
arg	187:39	187:53	9	f->quant_table
water	187:39	0:0	10	f
op	187:40	0:0	10	->
water	187:42	0:0	10	quant_table
arg	187:55	187:77	9	sizeof(p->quant_table)
op	187:55	0:0	10	sizeof
water	187:61	0:0	10	(
water	187:62	0:0	10	p
op	187:63	0:0	10	->
water	187:65	0:0	10	quant_table
water	187:76	0:0	10	)
water	187:78	0:0	8	;
water	188:12	0:0	8	}
if	190:12	197:12	6	(f -> version <= 2)
cond	190:16	190:30	7	f -> version <= 2
water	190:16	0:0	8	f
op	190:17	0:0	8	->
water	190:19	0:0	8	version
op	190:27	0:0	8	<=
water	190:30	0:0	8	2
stmts	190:33	197:12	7	
water	190:33	0:0	8	{
call	191:16	191:45	8	av_assert0
arg	191:27	191:45	9	context_count>=0
water	191:27	0:0	10	context_count
op	191:41	0:0	10	>=
water	191:44	0:0	10	0
water	191:46	0:0	8	;
if	192:16	195:16	8	(p -> context_count < context_count)
cond	192:20	192:39	9	p -> context_count < context_count
water	192:20	0:0	10	p
op	192:21	0:0	10	->
water	192:23	0:0	10	context_count
op	192:37	0:0	10	<
water	192:39	0:0	10	context_count
stmts	192:54	195:16	9	
water	192:54	0:0	10	{
call	193:20	193:38	10	av_freep
arg	193:29	193:38	11	&p->state
op	193:29	0:0	12	&
water	193:30	0:0	12	p
op	193:31	0:0	12	->
water	193:33	0:0	12	state
water	193:39	0:0	10	;
call	194:20	194:42	10	av_freep
arg	194:29	194:42	11	&p->vlc_state
op	194:29	0:0	12	&
water	194:30	0:0	12	p
op	194:31	0:0	12	->
water	194:33	0:0	12	vlc_state
water	194:43	0:0	10	;
water	195:16	0:0	10	}
water	196:16	0:0	8	p
op	196:17	0:0	8	->
water	196:19	0:0	8	context_count
op	196:33	0:0	8	=
water	196:35	0:0	8	context_count
water	196:48	0:0	8	;
water	197:12	0:0	8	}
water	198:8	0:0	6	}
water	199:4	0:0	4	}
return	200:4	200:12	2	0
water	200:11	0:0	3	0
