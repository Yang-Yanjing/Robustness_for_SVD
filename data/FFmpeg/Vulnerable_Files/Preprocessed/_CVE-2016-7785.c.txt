func	1:0	117:0	0	static int	avi_read_seek
params	1:24	0:0	1	
param	1:25	1:43	2	AVFormatContext *	s
param	1:45	1:61	2	int	stream_index
param	2:25	2:42	2	int64_t	timestamp
param	2:44	2:53	2	int	flags
stmnts	0:0	116:12	1	
decl	4:4	4:34	2	AVIContext	*avi
op	4:20	0:0	2	=
water	4:22	0:0	2	s
op	4:23	0:0	2	->
water	4:25	0:0	2	priv_data
decl	5:4	5:16	2	AVStream	*st
decl	6:4	6:16	2	int	i
water	6:9	0:0	2	,
decl	6:4	6:16	2	int	index
decl	7:4	7:24	2	int64_t	pos
water	7:15	0:0	2	,
decl	7:4	7:24	2	int64_t	pos_min
decl	8:4	8:18	2	AVIStream	*ast
if	13:4	14:24	2	(avi -> dv_demux)
cond	13:8	13:13	3	avi -> dv_demux
water	13:8	0:0	4	avi
op	13:11	0:0	4	->
water	13:13	0:0	4	dv_demux
stmts	14:8	14:24	3	
water	14:8	0:0	4	stream_index
op	14:21	0:0	4	=
water	14:23	0:0	4	0
water	14:24	0:0	4	;
if	16:4	20:4	2	(! avi -> index_loaded)
cond	16:8	16:14	3	! avi -> index_loaded
op	16:8	0:0	4	!
water	16:9	0:0	4	avi
op	16:12	0:0	4	->
water	16:14	0:0	4	index_loaded
stmts	16:28	20:4	3	
water	16:28	0:0	4	{
call	18:8	18:24	4	avi_load_index
arg	18:23	18:24	5	s
water	18:23	0:0	6	s
water	18:25	0:0	4	;
water	19:8	0:0	4	avi
op	19:11	0:0	4	->
water	19:13	0:0	4	index_loaded
op	19:26	0:0	4	|=
water	19:29	0:0	4	1
water	19:30	0:0	4	;
water	20:4	0:0	4	}
call	21:4	21:32	2	av_assert0
arg	21:15	21:32	3	stream_index>=0
water	21:15	0:0	4	stream_index
op	21:28	0:0	4	>=
water	21:31	0:0	4	0
water	21:33	0:0	2	;
water	23:4	0:0	2	st
op	23:10	0:0	2	=
water	23:12	0:0	2	s
op	23:13	0:0	2	->
water	23:15	0:0	2	streams
op	23:22	0:0	2	[
water	23:23	0:0	2	stream_index
op	23:35	0:0	2	]
water	23:36	0:0	2	;
water	24:4	0:0	2	ast
op	24:10	0:0	2	=
water	24:12	0:0	2	st
op	24:14	0:0	2	->
water	24:16	0:0	2	priv_data
water	24:25	0:0	2	;
water	25:4	0:0	2	index
op	25:10	0:0	2	=
call	25:12	27:43	2	av_index_search_timestamp
arg	25:38	25:40	3	st
water	25:38	0:0	4	st
arg	26:38	26:76	3	timestamp*FFMAX(ast->sample_size,1)
water	26:38	0:0	4	timestamp
call	26:48	26:75	4	*FFMAX
arg	26:56	26:72	5	ast->sample_size
water	26:56	0:0	6	ast
op	26:59	0:0	6	->
water	26:61	0:0	6	sample_size
arg	26:74	26:75	5	1
water	26:74	0:0	6	1
arg	27:38	27:43	3	flags
water	27:38	0:0	4	flags
water	27:44	0:0	2	;
if	28:4	35:4	2	(index < 0)
cond	28:8	28:16	3	index < 0
water	28:8	0:0	4	index
op	28:14	0:0	4	<
water	28:16	0:0	4	0
stmts	28:19	35:4	3	
water	28:19	0:0	4	{
if	29:8	33:73	4	(st -> nb_index_entries > 0)
cond	29:12	29:35	5	st -> nb_index_entries > 0
water	29:12	0:0	6	st
op	29:14	0:0	6	->
water	29:16	0:0	6	nb_index_entries
op	29:33	0:0	6	>
water	29:35	0:0	6	0
stmts	30:12	33:73	5	
call	30:12	33:72	6	av_log
arg	30:19	30:20	7	s
water	30:19	0:0	8	s
arg	30:22	30:34	7	AV_LOG_DEBUG
water	30:22	0:0	8	AV_LOG_DEBUG
arg	30:36	30:109	7	"Failed to find timestamp %"PRId64" in index %"PRId64" .. %"PRId64"\n"
water	30:36	0:0	8	"Failed to find timestamp %"
water	30:64	0:0	8	PRId64
water	30:71	0:0	8	" in index %"
water	30:84	0:0	8	PRId64
water	30:91	0:0	8	" .. %"
water	30:98	0:0	8	PRId64
water	30:105	0:0	8	"\n"
arg	31:19	31:57	7	timestamp*FFMAX(ast->sample_size,1)
water	31:19	0:0	8	timestamp
call	31:29	31:56	8	*FFMAX
arg	31:37	31:53	9	ast->sample_size
water	31:37	0:0	10	ast
op	31:40	0:0	10	->
water	31:42	0:0	10	sample_size
arg	31:55	31:56	9	1
water	31:55	0:0	10	1
arg	32:19	32:49	7	st->index_entries[0].timestamp
water	32:19	0:0	8	st
op	32:21	0:0	8	->
water	32:23	0:0	8	index_entries
op	32:36	0:0	8	[
water	32:37	0:0	8	0
op	32:38	0:0	8	]
op	32:39	0:0	8	.
water	32:40	0:0	8	timestamp
arg	33:19	33:72	7	st->index_entries[st->nb_index_entries-1].timestamp
water	33:19	0:0	8	st
op	33:21	0:0	8	->
water	33:23	0:0	8	index_entries
op	33:36	0:0	8	[
water	33:37	0:0	8	st
op	33:39	0:0	8	->
water	33:41	0:0	8	nb_index_entries
op	33:58	0:0	8	-
water	33:60	0:0	8	1
op	33:61	0:0	8	]
op	33:62	0:0	8	.
water	33:63	0:0	8	timestamp
water	33:73	0:0	6	;
return	34:8	34:34	4	AVERROR_INVALIDDATA
water	34:15	0:0	5	AVERROR_INVALIDDATA
water	35:4	0:0	4	}
water	38:4	0:0	2	pos
op	38:14	0:0	2	=
water	38:16	0:0	2	st
op	38:18	0:0	2	->
water	38:20	0:0	2	index_entries
op	38:33	0:0	2	[
water	38:34	0:0	2	index
op	38:39	0:0	2	]
op	38:40	0:0	2	.
water	38:41	0:0	2	pos
water	38:44	0:0	2	;
water	39:4	0:0	2	timestamp
op	39:14	0:0	2	=
water	39:16	0:0	2	st
op	39:18	0:0	2	->
water	39:20	0:0	2	index_entries
op	39:33	0:0	2	[
water	39:34	0:0	2	index
op	39:39	0:0	2	]
op	39:40	0:0	2	.
water	39:41	0:0	2	timestamp
op	39:51	0:0	2	/
call	39:53	39:78	2	FFMAX
arg	39:59	39:75	3	ast->sample_size
water	39:59	0:0	4	ast
op	39:62	0:0	4	->
water	39:64	0:0	4	sample_size
arg	39:77	39:78	3	1
water	39:77	0:0	4	1
water	39:79	0:0	2	;
call	41:4	42:64	2	av_log
arg	41:11	41:12	3	s
water	41:11	0:0	4	s
arg	41:14	41:26	3	AV_LOG_TRACE
water	41:14	0:0	4	AV_LOG_TRACE
arg	41:28	41:57	3	"XX %"PRId64" %d %"PRId64"\n"
water	41:28	0:0	4	"XX %"
water	41:34	0:0	4	PRId64
water	41:40	0:0	4	" %d %"
water	41:47	0:0	4	PRId64
water	41:53	0:0	4	"\n"
arg	42:12	42:21	3	timestamp
water	42:12	0:0	4	timestamp
arg	42:23	42:28	3	index
water	42:23	0:0	4	index
arg	42:30	42:64	3	st->index_entries[index].timestamp
water	42:30	0:0	4	st
op	42:32	0:0	4	->
water	42:34	0:0	4	index_entries
op	42:47	0:0	4	[
water	42:48	0:0	4	index
op	42:53	0:0	4	]
op	42:54	0:0	4	.
water	42:55	0:0	4	timestamp
water	42:65	0:0	2	;
if	44:4	58:4	2	(CONFIG_DV_DEMUXER && avi -> dv_demux)
cond	44:8	44:34	3	CONFIG_DV_DEMUXER && avi -> dv_demux
water	44:8	0:0	4	CONFIG_DV_DEMUXER
op	44:26	0:0	4	&&
water	44:29	0:0	4	avi
op	44:32	0:0	4	->
water	44:34	0:0	4	dv_demux
stmts	44:44	58:4	3	
water	44:44	0:0	4	{
if	49:8	50:21	4	(avio_seek (s -> pb ,pos ,SEEK_SET ) < 0)
cond	49:12	49:46	5	avio_seek (s -> pb ,pos ,SEEK_SET ) < 0
call	49:12	49:42	6	avio_seek
arg	49:22	49:27	7	s->pb
water	49:22	0:0	8	s
op	49:23	0:0	8	->
water	49:25	0:0	8	pb
arg	49:29	49:32	7	pos
water	49:29	0:0	8	pos
arg	49:34	49:42	7	SEEK_SET
water	49:34	0:0	8	SEEK_SET
op	49:44	0:0	6	<
water	49:46	0:0	6	0
stmts	50:12	50:21	5	
return	50:12	50:21	6	-1
op	50:19	0:0	7	-
water	50:20	0:0	7	1
call	54:8	54:51	4	ff_dv_offset_reset
arg	54:27	54:40	5	avi->dv_demux
water	54:27	0:0	6	avi
op	54:30	0:0	6	->
water	54:32	0:0	6	dv_demux
arg	54:42	54:51	5	timestamp
water	54:42	0:0	6	timestamp
water	54:52	0:0	4	;
water	56:8	0:0	4	avi
op	56:11	0:0	4	->
water	56:13	0:0	4	stream_index
op	56:26	0:0	4	=
op	56:28	0:0	4	-
water	56:29	0:0	4	1
water	56:30	0:0	4	;
return	57:8	57:16	4	0
water	57:15	0:0	5	0
water	58:4	0:0	4	}
water	60:4	0:0	2	pos_min
op	60:12	0:0	2	=
water	60:14	0:0	2	pos
water	60:17	0:0	2	;
for	61:4	90:4	2	(i = 0 ;i < s -> nb_streams;i ++)
forinit	61:9	61:14	3	i = 0 ;
water	61:9	0:0	4	i
op	61:11	0:0	4	=
water	61:13	0:0	4	0
water	61:14	0:0	4	;
cond	61:16	61:23	3	i < s -> nb_streams
water	61:16	0:0	4	i
op	61:18	0:0	4	<
water	61:20	0:0	4	s
op	61:21	0:0	4	->
water	61:23	0:0	4	nb_streams
forexpr	61:35	61:36	3	i ++
water	61:35	0:0	4	i
op	61:36	0:0	4	++
stmts	61:40	90:4	3	
water	61:40	0:0	4	{
decl	62:8	62:39	4	AVStream	*st2
op	62:24	0:0	4	=
water	62:26	0:0	4	s
op	62:27	0:0	4	->
water	62:29	0:0	4	streams
op	62:36	0:0	4	[
water	62:37	0:0	4	i
op	62:38	0:0	4	]
decl	63:8	63:40	4	AVIStream	*ast2
op	63:24	0:0	4	=
water	63:26	0:0	4	st2
op	63:29	0:0	4	->
water	63:31	0:0	4	priv_data
water	65:8	0:0	4	ast2
op	65:12	0:0	4	->
water	65:14	0:0	4	packet_size
op	65:26	0:0	4	=
water	66:8	0:0	4	ast2
op	66:12	0:0	4	->
water	66:14	0:0	4	remaining
op	66:26	0:0	4	=
water	66:28	0:0	4	0
water	66:29	0:0	4	;
if	68:8	71:8	4	(ast2 -> sub_ctx)
cond	68:12	68:18	5	ast2 -> sub_ctx
water	68:12	0:0	6	ast2
op	68:16	0:0	6	->
water	68:18	0:0	6	sub_ctx
stmts	68:27	71:8	5	
water	68:27	0:0	6	{
call	69:12	69:44	6	seek_subtitle
arg	69:26	69:28	7	st
water	69:26	0:0	8	st
arg	69:30	69:33	7	st2
water	69:30	0:0	8	st2
arg	69:35	69:44	7	timestamp
water	69:35	0:0	8	timestamp
water	69:45	0:0	6	;
continue	70:12	70:20	6	
water	71:8	0:0	6	}
if	73:8	74:20	4	(st2 -> nb_index_entries <= 0)
cond	73:12	73:37	5	st2 -> nb_index_entries <= 0
water	73:12	0:0	6	st2
op	73:15	0:0	6	->
water	73:17	0:0	6	nb_index_entries
op	73:34	0:0	6	<=
water	73:37	0:0	6	0
stmts	74:12	74:20	5	
continue	74:12	74:20	6	
call	77:8	77:120	4	av_assert0
arg	77:19	77:120	5	fabs(av_q2d(st2->time_base)-ast2->scale/(double)ast2->rate)<av_q2d(st2->time_base)*0.00000001
call	77:19	77:81	6	fabs
arg	77:24	77:81	7	av_q2d(st2->time_base)-ast2->scale/(double)ast2->rate
call	77:24	77:45	8	av_q2d
arg	77:31	77:45	9	st2->time_base
water	77:31	0:0	10	st2
op	77:34	0:0	10	->
water	77:36	0:0	10	time_base
op	77:47	0:0	8	-
water	77:49	0:0	8	ast2
op	77:53	0:0	8	->
water	77:55	0:0	8	scale
op	77:61	0:0	8	/
water	77:63	0:0	8	(
water	77:64	0:0	8	double
water	77:70	0:0	8	)
water	77:71	0:0	8	ast2
op	77:75	0:0	8	->
water	77:77	0:0	8	rate
op	77:83	0:0	6	<
call	77:85	77:106	6	av_q2d
arg	77:92	77:106	7	st2->time_base
water	77:92	0:0	8	st2
op	77:95	0:0	8	->
water	77:97	0:0	8	time_base
op	77:108	0:0	6	*
water	77:110	0:0	6	0
op	77:111	0:0	6	.
water	77:112	0:0	6	00000001
water	77:121	0:0	4	;
water	78:8	0:0	4	index
op	78:14	0:0	4	=
call	78:16	85:110	4	av_index_search_timestamp
arg	78:42	78:45	5	st2
water	78:42	0:0	6	st2
arg	79:42	82:69	5	av_rescale_q(timestamp,st->time_base,st2->time_base)*FFMAX(ast2->sample_size,1)
call	79:42	81:69	6	av_rescale_q
arg	79:55	79:64	7	timestamp
water	79:55	0:0	8	timestamp
arg	80:55	80:68	7	st->time_base
water	80:55	0:0	8	st
op	80:57	0:0	8	->
water	80:59	0:0	8	time_base
arg	81:55	81:69	7	st2->time_base
water	81:55	0:0	8	st2
op	81:58	0:0	8	->
water	81:60	0:0	8	time_base
call	81:71	82:68	6	*FFMAX
arg	82:48	82:65	7	ast2->sample_size
water	82:48	0:0	8	ast2
op	82:52	0:0	8	->
water	82:54	0:0	8	sample_size
arg	82:67	82:68	7	1
water	82:67	0:0	8	1
arg	83:42	85:110	5	flags|AVSEEK_FLAG_BACKWARD|(st2->codec->codec_type!=AVMEDIA_TYPE_VIDEO?AVSEEK_FLAG_ANY:0)
water	83:42	0:0	6	flags
op	83:48	0:0	6	|
water	84:42	0:0	6	AVSEEK_FLAG_BACKWARD
op	84:63	0:0	6	|
water	85:42	0:0	6	(
water	85:43	0:0	6	st2
op	85:46	0:0	6	->
water	85:48	0:0	6	codec
op	85:53	0:0	6	->
water	85:55	0:0	6	codec_type
op	85:66	0:0	6	!=
water	85:69	0:0	6	AVMEDIA_TYPE_VIDEO
water	85:88	0:0	6	?
water	85:90	0:0	6	AVSEEK_FLAG_ANY
water	85:106	0:0	6	:
water	85:108	0:0	6	0
water	85:109	0:0	6	)
water	85:111	0:0	4	;
if	86:8	87:21	4	(index < 0)
cond	86:12	86:20	5	index < 0
water	86:12	0:0	6	index
op	86:18	0:0	6	<
water	86:20	0:0	6	0
stmts	87:12	87:21	5	
water	87:12	0:0	6	index
op	87:18	0:0	6	=
water	87:20	0:0	6	0
water	87:21	0:0	6	;
water	88:8	0:0	4	ast2
op	88:12	0:0	4	->
water	88:14	0:0	4	seek_pos
op	88:23	0:0	4	=
water	88:25	0:0	4	st2
op	88:28	0:0	4	->
water	88:30	0:0	4	index_entries
op	88:43	0:0	4	[
water	88:44	0:0	4	index
op	88:49	0:0	4	]
op	88:50	0:0	4	.
water	88:51	0:0	4	pos
water	88:54	0:0	4	;
water	89:8	0:0	4	pos_min
op	89:16	0:0	4	=
call	89:18	89:46	4	FFMIN
arg	89:24	89:31	5	pos_min
water	89:24	0:0	6	pos_min
arg	89:32	89:46	5	ast2->seek_pos
water	89:32	0:0	6	ast2
op	89:36	0:0	6	->
water	89:38	0:0	6	seek_pos
water	89:47	0:0	4	;
water	90:4	0:0	4	}
for	91:4	107:4	2	(i = 0 ;i < s -> nb_streams;i ++)
forinit	91:9	91:14	3	i = 0 ;
water	91:9	0:0	4	i
op	91:11	0:0	4	=
water	91:13	0:0	4	0
water	91:14	0:0	4	;
cond	91:16	91:23	3	i < s -> nb_streams
water	91:16	0:0	4	i
op	91:18	0:0	4	<
water	91:20	0:0	4	s
op	91:21	0:0	4	->
water	91:23	0:0	4	nb_streams
forexpr	91:35	91:36	3	i ++
water	91:35	0:0	4	i
op	91:36	0:0	4	++
stmts	91:40	107:4	3	
water	91:40	0:0	4	{
decl	92:8	92:37	4	AVStream	*st2
op	92:22	0:0	4	=
water	92:24	0:0	4	s
op	92:25	0:0	4	->
water	92:27	0:0	4	streams
op	92:34	0:0	4	[
water	92:35	0:0	4	i
op	92:36	0:0	4	]
decl	93:8	93:40	4	AVIStream	*ast2
op	93:24	0:0	4	=
water	93:26	0:0	4	st2
op	93:29	0:0	4	->
water	93:31	0:0	4	priv_data
if	95:8	96:20	4	(ast2 -> sub_ctx || st2 -> nb_index_entries <= 0)
cond	95:12	95:54	5	ast2 -> sub_ctx || st2 -> nb_index_entries <= 0
water	95:12	0:0	6	ast2
op	95:16	0:0	6	->
water	95:18	0:0	6	sub_ctx
op	95:26	0:0	6	||
water	95:29	0:0	6	st2
op	95:32	0:0	6	->
water	95:34	0:0	6	nb_index_entries
op	95:51	0:0	6	<=
water	95:54	0:0	6	0
stmts	96:12	96:20	5	
continue	96:12	96:20	6	
water	98:8	0:0	4	index
op	98:14	0:0	4	=
call	98:16	101:115	4	av_index_search_timestamp
arg	99:16	99:19	5	st2
water	99:16	0:0	6	st2
arg	100:16	100:100	5	av_rescale_q(timestamp,st->time_base,st2->time_base)*FFMAX(ast2->sample_size,1)
call	100:16	100:69	6	av_rescale_q
arg	100:29	100:38	7	timestamp
water	100:29	0:0	8	timestamp
arg	100:40	100:53	7	st->time_base
water	100:40	0:0	8	st
op	100:42	0:0	8	->
water	100:44	0:0	8	time_base
arg	100:55	100:69	7	st2->time_base
water	100:55	0:0	8	st2
op	100:58	0:0	8	->
water	100:60	0:0	8	time_base
call	100:71	100:99	6	*FFMAX
arg	100:79	100:96	7	ast2->sample_size
water	100:79	0:0	8	ast2
op	100:83	0:0	8	->
water	100:85	0:0	8	sample_size
arg	100:98	100:99	7	1
water	100:98	0:0	8	1
arg	101:16	101:115	5	flags|AVSEEK_FLAG_BACKWARD|(st2->codec->codec_type!=AVMEDIA_TYPE_VIDEO?AVSEEK_FLAG_ANY:0)
water	101:16	0:0	6	flags
op	101:22	0:0	6	|
water	101:24	0:0	6	AVSEEK_FLAG_BACKWARD
op	101:45	0:0	6	|
water	101:47	0:0	6	(
water	101:48	0:0	6	st2
op	101:51	0:0	6	->
water	101:53	0:0	6	codec
op	101:58	0:0	6	->
water	101:60	0:0	6	codec_type
op	101:71	0:0	6	!=
water	101:74	0:0	6	AVMEDIA_TYPE_VIDEO
water	101:93	0:0	6	?
water	101:95	0:0	6	AVSEEK_FLAG_ANY
water	101:111	0:0	6	:
water	101:113	0:0	6	0
water	101:114	0:0	6	)
water	101:116	0:0	4	;
if	102:8	103:21	4	(index < 0)
cond	102:12	102:20	5	index < 0
water	102:12	0:0	6	index
op	102:18	0:0	6	<
water	102:20	0:0	6	0
stmts	103:12	103:21	5	
water	103:12	0:0	6	index
op	103:18	0:0	6	=
water	103:20	0:0	6	0
water	103:21	0:0	6	;
while	104:8	105:19	4	(! avi -> non_interleaved && index > 0 && st2 -> index_entries [ index - 1 ] . pos >= pos_min)
cond	104:15	104:86	5	! avi -> non_interleaved && index > 0 && st2 -> index_entries [ index - 1 ] . pos >= pos_min
op	104:15	0:0	6	!
water	104:16	0:0	6	avi
op	104:19	0:0	6	->
water	104:21	0:0	6	non_interleaved
op	104:37	0:0	6	&&
water	104:40	0:0	6	index
op	104:45	0:0	6	>
water	104:46	0:0	6	0
op	104:48	0:0	6	&&
water	104:51	0:0	6	st2
op	104:54	0:0	6	->
water	104:56	0:0	6	index_entries
op	104:69	0:0	6	[
water	104:70	0:0	6	index
op	104:75	0:0	6	-
water	104:76	0:0	6	1
op	104:77	0:0	6	]
op	104:78	0:0	6	.
water	104:79	0:0	6	pos
op	104:83	0:0	6	>=
water	104:86	0:0	6	pos_min
stmts	105:12	105:19	5	
water	105:12	0:0	6	index
op	105:17	0:0	6	--
water	105:19	0:0	6	;
water	106:8	0:0	4	ast2
op	106:12	0:0	4	->
water	106:14	0:0	4	frame_offset
op	106:27	0:0	4	=
water	106:29	0:0	4	st2
op	106:32	0:0	4	->
water	106:34	0:0	4	index_entries
op	106:47	0:0	4	[
water	106:48	0:0	4	index
op	106:53	0:0	4	]
op	106:54	0:0	4	.
water	106:55	0:0	4	timestamp
water	106:64	0:0	4	;
water	107:4	0:0	4	}
if	110:4	113:4	2	(avio_seek (s -> pb ,pos_min ,SEEK_SET ) < 0)
cond	110:8	110:46	3	avio_seek (s -> pb ,pos_min ,SEEK_SET ) < 0
call	110:8	110:42	4	avio_seek
arg	110:18	110:23	5	s->pb
water	110:18	0:0	6	s
op	110:19	0:0	6	->
water	110:21	0:0	6	pb
arg	110:25	110:32	5	pos_min
water	110:25	0:0	6	pos_min
arg	110:34	110:42	5	SEEK_SET
water	110:34	0:0	6	SEEK_SET
op	110:44	0:0	4	<
water	110:46	0:0	4	0
stmts	110:49	113:4	3	
water	110:49	0:0	4	{
call	111:8	111:47	4	av_log
arg	111:15	111:16	5	s
water	111:15	0:0	6	s
arg	111:18	111:30	5	AV_LOG_ERROR
water	111:18	0:0	6	AV_LOG_ERROR
arg	111:32	111:47	5	"Seek failed\n"
water	111:32	0:0	6	"Seek failed\n"
water	111:48	0:0	4	;
return	112:8	112:17	4	-1
op	112:15	0:0	5	-
water	112:16	0:0	5	1
water	113:4	0:0	4	}
water	114:4	0:0	2	avi
op	114:7	0:0	2	->
water	114:9	0:0	2	stream_index
op	114:22	0:0	2	=
op	114:24	0:0	2	-
water	114:25	0:0	2	1
water	114:26	0:0	2	;
water	115:4	0:0	2	avi
op	115:7	0:0	2	->
water	115:9	0:0	2	dts_max
op	115:22	0:0	2	=
water	115:24	0:0	2	INT_MIN
water	115:31	0:0	2	;
return	116:4	116:12	2	0
water	116:11	0:0	3	0
