func	1:0	261:0	0	static int	read_header
params	1:22	0:0	1	
param	1:23	1:37	2	FFV1Context *	f
stmnts	0:0	260:12	1	
decl	3:4	3:31	2	uint8_t	state[CONTEXT_SIZE]
decl	4:4	4:32	2	int	i
water	4:9	0:0	2	,
decl	4:4	4:32	2	int	j
water	4:12	0:0	2	,
decl	4:4	4:32	2	int	context_count
op	4:28	0:0	2	=
op	4:30	0:0	2	-
water	4:31	0:0	2	1
water	5:4	0:0	2	RangeCoder
op	5:15	0:0	2	*
water	5:16	0:0	2	const
water	5:22	0:0	2	c
op	5:24	0:0	2	=
op	5:26	0:0	2	&
water	5:27	0:0	2	f
op	5:28	0:0	2	->
water	5:30	0:0	2	slice_context
op	5:43	0:0	2	[
water	5:44	0:0	2	0
op	5:45	0:0	2	]
op	5:46	0:0	2	->
water	5:48	0:0	2	c
water	5:49	0:0	2	;
call	7:4	7:36	2	memset
arg	7:11	7:16	3	state
water	7:11	0:0	4	state
arg	7:18	7:21	3	128
water	7:18	0:0	4	128
arg	7:23	7:36	3	sizeof(state)
op	7:23	0:0	4	sizeof
water	7:29	0:0	4	(
water	7:30	0:0	4	state
water	7:35	0:0	4	)
water	7:37	0:0	2	;
if	9:4	59:4	2	(f -> version < 2)
cond	9:8	9:21	3	f -> version < 2
water	9:8	0:0	4	f
op	9:9	0:0	4	->
water	9:11	0:0	4	version
op	9:19	0:0	4	<
water	9:21	0:0	4	2
stmts	9:24	59:4	3	
water	9:24	0:0	4	{
decl	10:8	10:104	4	int	chroma_planes
water	10:25	0:0	4	,
decl	10:8	10:104	4	int	chroma_h_shift
water	10:41	0:0	4	,
decl	10:8	10:104	4	int	chroma_v_shift
water	10:57	0:0	4	,
decl	10:8	10:104	4	int	transparency
water	10:71	0:0	4	,
decl	10:8	10:104	4	int	colorspace
water	10:83	0:0	4	,
decl	10:8	10:104	4	int	bits_per_raw_sample
water	11:8	0:0	4	unsigned
water	11:17	0:0	4	v
op	11:18	0:0	4	=
call	11:20	11:42	4	get_symbol
arg	11:31	11:32	5	c
water	11:31	0:0	6	c
arg	11:34	11:39	5	state
water	11:34	0:0	6	state
arg	11:41	11:42	5	0
water	11:41	0:0	6	0
water	11:43	0:0	4	;
if	12:8	15:8	4	(v >= 2)
cond	12:12	12:17	5	v >= 2
water	12:12	0:0	6	v
op	12:14	0:0	6	>=
water	12:17	0:0	6	2
stmts	12:20	15:8	5	
water	12:20	0:0	6	{
call	13:12	13:84	6	av_log
arg	13:19	13:27	7	f->avctx
water	13:19	0:0	8	f
op	13:20	0:0	8	->
water	13:22	0:0	8	avctx
arg	13:29	13:41	7	AV_LOG_ERROR
water	13:29	0:0	8	AV_LOG_ERROR
arg	13:43	13:81	7	"invalid version %d in ver01 header\n"
water	13:43	0:0	8	"invalid version %d in ver01 header\n"
arg	13:83	13:84	7	v
water	13:83	0:0	8	v
water	13:85	0:0	6	;
return	14:12	14:38	6	AVERROR_INVALIDDATA
water	14:19	0:0	7	AVERROR_INVALIDDATA
water	15:8	0:0	6	}
water	16:8	0:0	4	f
op	16:9	0:0	4	->
water	16:11	0:0	4	version
op	16:19	0:0	4	=
water	16:21	0:0	4	v
water	16:22	0:0	4	;
water	17:8	0:0	4	f
op	17:9	0:0	4	->
water	17:11	0:0	4	ac
op	17:14	0:0	4	=
call	17:16	17:38	4	get_symbol
arg	17:27	17:28	5	c
water	17:27	0:0	6	c
arg	17:30	17:35	5	state
water	17:30	0:0	6	state
arg	17:37	17:38	5	0
water	17:37	0:0	6	0
water	17:39	0:0	4	;
if	19:8	22:8	4	(f -> ac == AC_RANGE_CUSTOM_TAB)
cond	19:12	19:21	5	f -> ac == AC_RANGE_CUSTOM_TAB
water	19:12	0:0	6	f
op	19:13	0:0	6	->
water	19:15	0:0	6	ac
op	19:18	0:0	6	==
water	19:21	0:0	6	AC_RANGE_CUSTOM_TAB
stmts	19:42	22:8	5	
water	19:42	0:0	6	{
for	20:12	21:82	6	(i = 1 ;i < 256;i ++)
forinit	20:17	20:22	7	i = 1 ;
water	20:17	0:0	8	i
op	20:19	0:0	8	=
water	20:21	0:0	8	1
water	20:22	0:0	8	;
cond	20:24	20:28	7	i < 256
water	20:24	0:0	8	i
op	20:26	0:0	8	<
water	20:28	0:0	8	256
forexpr	20:33	20:34	7	i ++
water	20:33	0:0	8	i
op	20:34	0:0	8	++
stmts	21:16	21:82	7	
water	21:16	0:0	8	f
op	21:17	0:0	8	->
water	21:19	0:0	8	state_transition
op	21:35	0:0	8	[
water	21:36	0:0	8	i
op	21:37	0:0	8	]
op	21:39	0:0	8	=
call	21:41	21:63	8	get_symbol
arg	21:52	21:53	9	c
water	21:52	0:0	10	c
arg	21:55	21:60	9	state
water	21:55	0:0	10	state
arg	21:62	21:63	9	1
water	21:62	0:0	10	1
op	21:65	0:0	8	+
water	21:67	0:0	8	c
op	21:68	0:0	8	->
water	21:70	0:0	8	one_state
op	21:79	0:0	8	[
water	21:80	0:0	8	i
op	21:81	0:0	8	]
water	21:82	0:0	8	;
water	22:8	0:0	6	}
water	24:8	0:0	4	colorspace
op	24:28	0:0	4	=
call	24:30	24:52	4	get_symbol
arg	24:41	24:42	5	c
water	24:41	0:0	6	c
arg	24:44	24:49	5	state
water	24:44	0:0	6	state
arg	24:51	24:52	5	0
water	24:51	0:0	6	0
water	24:53	0:0	4	;
water	25:8	0:0	4	bits_per_raw_sample
op	25:28	0:0	4	=
water	25:30	0:0	4	f
op	25:31	0:0	4	->
water	25:33	0:0	4	version
op	25:41	0:0	4	>
water	25:43	0:0	4	0
water	25:45	0:0	4	?
call	25:47	25:69	4	get_symbol
arg	25:58	25:59	5	c
water	25:58	0:0	6	c
arg	25:61	25:66	5	state
water	25:61	0:0	6	state
arg	25:68	25:69	5	0
water	25:68	0:0	6	0
water	25:71	0:0	4	:
water	25:73	0:0	4	f
op	25:74	0:0	4	->
water	25:76	0:0	4	avctx
op	25:81	0:0	4	->
water	25:83	0:0	4	bits_per_raw_sample
water	25:102	0:0	4	;
water	26:8	0:0	4	chroma_planes
op	26:28	0:0	4	=
call	26:30	26:46	4	get_rac
arg	26:38	26:39	5	c
water	26:38	0:0	6	c
arg	26:41	26:46	5	state
water	26:41	0:0	6	state
water	26:47	0:0	4	;
water	27:8	0:0	4	chroma_h_shift
op	27:28	0:0	4	=
call	27:30	27:52	4	get_symbol
arg	27:41	27:42	5	c
water	27:41	0:0	6	c
arg	27:44	27:49	5	state
water	27:44	0:0	6	state
arg	27:51	27:52	5	0
water	27:51	0:0	6	0
water	27:53	0:0	4	;
water	28:8	0:0	4	chroma_v_shift
op	28:28	0:0	4	=
call	28:30	28:52	4	get_symbol
arg	28:41	28:42	5	c
water	28:41	0:0	6	c
arg	28:44	28:49	5	state
water	28:44	0:0	6	state
arg	28:51	28:52	5	0
water	28:51	0:0	6	0
water	28:53	0:0	4	;
water	29:8	0:0	4	transparency
op	29:28	0:0	4	=
call	29:30	29:46	4	get_rac
arg	29:38	29:39	5	c
water	29:38	0:0	6	c
arg	29:41	29:46	5	state
water	29:41	0:0	6	state
water	29:47	0:0	4	;
if	30:8	31:28	4	(colorspace == 0 && f -> avctx -> skip_alpha)
cond	30:12	30:41	5	colorspace == 0 && f -> avctx -> skip_alpha
water	30:12	0:0	6	colorspace
op	30:23	0:0	6	==
water	30:26	0:0	6	0
op	30:28	0:0	6	&&
water	30:31	0:0	6	f
op	30:32	0:0	6	->
water	30:34	0:0	6	avctx
op	30:39	0:0	6	->
water	30:41	0:0	6	skip_alpha
stmts	31:12	31:28	5	
water	31:12	0:0	6	transparency
op	31:25	0:0	6	=
water	31:27	0:0	6	0
water	31:28	0:0	6	;
if	33:8	43:8	4	(f -> plane_count)
cond	33:12	33:15	5	f -> plane_count
water	33:12	0:0	6	f
op	33:13	0:0	6	->
water	33:15	0:0	6	plane_count
stmts	33:28	43:8	5	
water	33:28	0:0	6	{
if	34:12	42:12	6	(colorspace != f -> colorspace || bits_per_raw_sample != f -> avctx -> bits_per_raw_sample || chroma_planes != f -> chroma_planes || chroma_h_shift != f -> chroma_h_shift || chroma_v_shift != f -> chroma_v_shift || transparency != f -> transparency)
cond	34:16	39:42	7	colorspace != f -> colorspace || bits_per_raw_sample != f -> avctx -> bits_per_raw_sample || chroma_planes != f -> chroma_planes || chroma_h_shift != f -> chroma_h_shift || chroma_v_shift != f -> chroma_v_shift || transparency != f -> transparency
water	34:16	0:0	8	colorspace
op	34:36	0:0	8	!=
water	34:39	0:0	8	f
op	34:40	0:0	8	->
water	34:42	0:0	8	colorspace
op	34:69	0:0	8	||
water	35:16	0:0	8	bits_per_raw_sample
op	35:36	0:0	8	!=
water	35:39	0:0	8	f
op	35:40	0:0	8	->
water	35:42	0:0	8	avctx
op	35:47	0:0	8	->
water	35:49	0:0	8	bits_per_raw_sample
op	35:69	0:0	8	||
water	36:16	0:0	8	chroma_planes
op	36:36	0:0	8	!=
water	36:39	0:0	8	f
op	36:40	0:0	8	->
water	36:42	0:0	8	chroma_planes
op	36:69	0:0	8	||
water	37:16	0:0	8	chroma_h_shift
op	37:36	0:0	8	!=
water	37:39	0:0	8	f
op	37:40	0:0	8	->
water	37:42	0:0	8	chroma_h_shift
op	37:69	0:0	8	||
water	38:16	0:0	8	chroma_v_shift
op	38:36	0:0	8	!=
water	38:39	0:0	8	f
op	38:40	0:0	8	->
water	38:42	0:0	8	chroma_v_shift
op	38:69	0:0	8	||
water	39:16	0:0	8	transparency
op	39:36	0:0	8	!=
water	39:39	0:0	8	f
op	39:40	0:0	8	->
water	39:42	0:0	8	transparency
stmts	39:56	42:12	7	
water	39:56	0:0	8	{
call	40:16	40:86	8	av_log
arg	40:23	40:31	9	f->avctx
water	40:23	0:0	10	f
op	40:24	0:0	10	->
water	40:26	0:0	10	avctx
arg	40:33	40:45	9	AV_LOG_ERROR
water	40:33	0:0	10	AV_LOG_ERROR
arg	40:47	40:86	9	"Invalid change of global parameters\n"
water	40:47	0:0	10	"Invalid change of global parameters\n"
water	40:87	0:0	8	;
return	41:16	41:42	8	AVERROR_INVALIDDATA
water	41:23	0:0	9	AVERROR_INVALIDDATA
water	42:12	0:0	8	}
water	43:8	0:0	6	}
if	45:8	49:8	4	(chroma_h_shift > 4 U || chroma_v_shift > 4 U)
cond	45:12	45:53	5	chroma_h_shift > 4 U || chroma_v_shift > 4 U
water	45:12	0:0	6	chroma_h_shift
op	45:27	0:0	6	>
water	45:29	0:0	6	4
water	45:30	0:0	6	U
op	45:32	0:0	6	||
water	45:35	0:0	6	chroma_v_shift
op	45:50	0:0	6	>
water	45:52	0:0	6	4
water	45:53	0:0	6	U
stmts	45:56	49:8	5	
water	45:56	0:0	6	{
call	46:12	47:49	6	av_log
arg	46:19	46:27	7	f->avctx
water	46:19	0:0	8	f
op	46:20	0:0	8	->
water	46:22	0:0	8	avctx
arg	46:29	46:41	7	AV_LOG_ERROR
water	46:29	0:0	8	AV_LOG_ERROR
arg	46:43	46:88	7	"chroma shift parameters %d %d are invalid\n"
water	46:43	0:0	8	"chroma shift parameters %d %d are invalid\n"
arg	47:19	47:33	7	chroma_h_shift
water	47:19	0:0	8	chroma_h_shift
arg	47:35	47:49	7	chroma_v_shift
water	47:35	0:0	8	chroma_v_shift
water	47:50	0:0	6	;
return	48:12	48:38	6	AVERROR_INVALIDDATA
water	48:19	0:0	7	AVERROR_INVALIDDATA
water	49:8	0:0	6	}
water	51:8	0:0	4	f
op	51:9	0:0	4	->
water	51:11	0:0	4	colorspace
op	51:38	0:0	4	=
water	51:40	0:0	4	colorspace
water	51:50	0:0	4	;
water	52:8	0:0	4	f
op	52:9	0:0	4	->
water	52:11	0:0	4	avctx
op	52:16	0:0	4	->
water	52:18	0:0	4	bits_per_raw_sample
op	52:38	0:0	4	=
water	52:40	0:0	4	bits_per_raw_sample
water	52:59	0:0	4	;
water	53:8	0:0	4	f
op	53:9	0:0	4	->
water	53:11	0:0	4	chroma_planes
op	53:38	0:0	4	=
water	53:40	0:0	4	chroma_planes
water	53:53	0:0	4	;
water	54:8	0:0	4	f
op	54:9	0:0	4	->
water	54:11	0:0	4	chroma_h_shift
op	54:38	0:0	4	=
water	54:40	0:0	4	chroma_h_shift
water	54:54	0:0	4	;
water	55:8	0:0	4	f
op	55:9	0:0	4	->
water	55:11	0:0	4	chroma_v_shift
op	55:38	0:0	4	=
water	55:40	0:0	4	chroma_v_shift
water	55:54	0:0	4	;
water	56:8	0:0	4	f
op	56:9	0:0	4	->
water	56:11	0:0	4	transparency
op	56:38	0:0	4	=
water	56:40	0:0	4	transparency
water	56:52	0:0	4	;
water	58:8	0:0	4	f
op	58:9	0:0	4	->
water	58:11	0:0	4	plane_count
op	58:26	0:0	4	=
water	58:28	0:0	4	2
op	58:30	0:0	4	+
water	58:32	0:0	4	f
op	58:33	0:0	4	->
water	58:35	0:0	4	transparency
water	58:47	0:0	4	;
water	59:4	0:0	4	}
if	61:4	148:4	2	(f -> colorspace == 0)
cond	61:8	61:25	3	f -> colorspace == 0
water	61:8	0:0	4	f
op	61:9	0:0	4	->
water	61:11	0:0	4	colorspace
op	61:22	0:0	4	==
water	61:25	0:0	4	0
stmts	61:28	148:4	3	
water	61:28	0:0	4	{
if	62:8	78:8	4	(! f -> transparency && ! f -> chroma_planes)
cond	62:12	62:36	5	! f -> transparency && ! f -> chroma_planes
op	62:12	0:0	6	!
water	62:13	0:0	6	f
op	62:14	0:0	6	->
water	62:16	0:0	6	transparency
op	62:29	0:0	6	&&
op	62:32	0:0	6	!
water	62:33	0:0	6	f
op	62:34	0:0	6	->
water	62:36	0:0	6	chroma_planes
stmts	62:51	78:8	5	
water	62:51	0:0	6	{
if	63:12	64:52	6	(f -> avctx -> bits_per_raw_sample <= 8)
cond	63:16	63:49	7	f -> avctx -> bits_per_raw_sample <= 8
water	63:16	0:0	8	f
op	63:17	0:0	8	->
water	63:19	0:0	8	avctx
op	63:24	0:0	8	->
water	63:26	0:0	8	bits_per_raw_sample
op	63:46	0:0	8	<=
water	63:49	0:0	8	8
stmts	64:16	64:52	7	
water	64:16	0:0	8	f
op	64:17	0:0	8	->
water	64:19	0:0	8	avctx
op	64:24	0:0	8	->
water	64:26	0:0	8	pix_fmt
op	64:34	0:0	8	=
water	64:36	0:0	8	AV_PIX_FMT_GRAY8
water	64:52	0:0	8	;
else	65:12	68:12	6
stmts	65:17	68:12	7	
if	65:17	68:12	8	(f -> avctx -> bits_per_raw_sample == 10)
cond	65:21	65:54	9	f -> avctx -> bits_per_raw_sample == 10
water	65:21	0:0	10	f
op	65:22	0:0	10	->
water	65:24	0:0	10	avctx
op	65:29	0:0	10	->
water	65:31	0:0	10	bits_per_raw_sample
op	65:51	0:0	10	==
water	65:54	0:0	10	10
stmts	65:58	68:12	9	
water	65:58	0:0	10	{
water	66:16	0:0	10	f
op	66:17	0:0	10	->
water	66:19	0:0	10	packed_at_lsb
op	66:33	0:0	10	=
water	66:35	0:0	10	1
water	66:36	0:0	10	;
water	67:16	0:0	10	f
op	67:17	0:0	10	->
water	67:19	0:0	10	avctx
op	67:24	0:0	10	->
water	67:26	0:0	10	pix_fmt
op	67:34	0:0	10	=
water	67:36	0:0	10	AV_PIX_FMT_GRAY10
water	67:53	0:0	10	;
water	68:12	0:0	10	}
else	68:14	71:12	6
stmts	68:19	71:12	7	
if	68:19	71:12	8	(f -> avctx -> bits_per_raw_sample == 12)
cond	68:23	68:56	9	f -> avctx -> bits_per_raw_sample == 12
water	68:23	0:0	10	f
op	68:24	0:0	10	->
water	68:26	0:0	10	avctx
op	68:31	0:0	10	->
water	68:33	0:0	10	bits_per_raw_sample
op	68:53	0:0	10	==
water	68:56	0:0	10	12
stmts	68:60	71:12	9	
water	68:60	0:0	10	{
water	69:16	0:0	10	f
op	69:17	0:0	10	->
water	69:19	0:0	10	packed_at_lsb
op	69:33	0:0	10	=
water	69:35	0:0	10	1
water	69:36	0:0	10	;
water	70:16	0:0	10	f
op	70:17	0:0	10	->
water	70:19	0:0	10	avctx
op	70:24	0:0	10	->
water	70:26	0:0	10	pix_fmt
op	70:34	0:0	10	=
water	70:36	0:0	10	AV_PIX_FMT_GRAY12
water	70:53	0:0	10	;
water	71:12	0:0	10	}
else	71:14	74:12	6
stmts	71:19	74:12	7	
if	71:19	74:12	8	(f -> avctx -> bits_per_raw_sample == 16)
cond	71:23	71:56	9	f -> avctx -> bits_per_raw_sample == 16
water	71:23	0:0	10	f
op	71:24	0:0	10	->
water	71:26	0:0	10	avctx
op	71:31	0:0	10	->
water	71:33	0:0	10	bits_per_raw_sample
op	71:53	0:0	10	==
water	71:56	0:0	10	16
stmts	71:60	74:12	9	
water	71:60	0:0	10	{
water	72:16	0:0	10	f
op	72:17	0:0	10	->
water	72:19	0:0	10	packed_at_lsb
op	72:33	0:0	10	=
water	72:35	0:0	10	1
water	72:36	0:0	10	;
water	73:16	0:0	10	f
op	73:17	0:0	10	->
water	73:19	0:0	10	avctx
op	73:24	0:0	10	->
water	73:26	0:0	10	pix_fmt
op	73:34	0:0	10	=
water	73:36	0:0	10	AV_PIX_FMT_GRAY16
water	73:53	0:0	10	;
water	74:12	0:0	10	}
else	74:14	76:12	6
stmts	74:19	76:12	7	
if	74:19	76:12	8	(f -> avctx -> bits_per_raw_sample < 16)
cond	74:23	74:55	9	f -> avctx -> bits_per_raw_sample < 16
water	74:23	0:0	10	f
op	74:24	0:0	10	->
water	74:26	0:0	10	avctx
op	74:31	0:0	10	->
water	74:33	0:0	10	bits_per_raw_sample
op	74:53	0:0	10	<
water	74:55	0:0	10	16
stmts	74:59	76:12	9	
water	74:59	0:0	10	{
water	75:16	0:0	10	f
op	75:17	0:0	10	->
water	75:19	0:0	10	avctx
op	75:24	0:0	10	->
water	75:26	0:0	10	pix_fmt
op	75:34	0:0	10	=
water	75:36	0:0	10	AV_PIX_FMT_GRAY16
water	75:53	0:0	10	;
water	76:12	0:0	10	}
else	76:14	77:38	6
stmts	77:16	77:38	7	
return	77:16	77:38	8	AVERROR(ENOSYS)
call	77:23	77:37	9	AVERROR
arg	77:31	77:37	10	ENOSYS
water	77:31	0:0	11	ENOSYS
water	78:8	0:0	6	}
else	78:10	83:8	4
stmts	78:15	83:8	5	
if	78:15	83:8	6	(f -> transparency && ! f -> chroma_planes)
cond	78:19	78:42	7	f -> transparency && ! f -> chroma_planes
water	78:19	0:0	8	f
op	78:20	0:0	8	->
water	78:22	0:0	8	transparency
op	78:35	0:0	8	&&
op	78:38	0:0	8	!
water	78:39	0:0	8	f
op	78:40	0:0	8	->
water	78:42	0:0	8	chroma_planes
stmts	78:57	83:8	7	
water	78:57	0:0	8	{
if	79:12	80:50	8	(f -> avctx -> bits_per_raw_sample <= 8)
cond	79:16	79:49	9	f -> avctx -> bits_per_raw_sample <= 8
water	79:16	0:0	10	f
op	79:17	0:0	10	->
water	79:19	0:0	10	avctx
op	79:24	0:0	10	->
water	79:26	0:0	10	bits_per_raw_sample
op	79:46	0:0	10	<=
water	79:49	0:0	10	8
stmts	80:16	80:50	9	
water	80:16	0:0	10	f
op	80:17	0:0	10	->
water	80:19	0:0	10	avctx
op	80:24	0:0	10	->
water	80:26	0:0	10	pix_fmt
op	80:34	0:0	10	=
water	80:36	0:0	10	AV_PIX_FMT_YA8
water	80:50	0:0	10	;
else	81:12	82:38	8
stmts	82:16	82:38	9	
return	82:16	82:38	10	AVERROR(ENOSYS)
call	82:23	82:37	11	AVERROR
arg	82:31	82:37	12	ENOSYS
water	82:31	0:0	13	ENOSYS
water	83:8	0:0	8	}
else	83:10	92:8	4
stmts	83:15	92:8	5	
if	83:15	92:8	6	(f -> avctx -> bits_per_raw_sample <= 8 && ! f -> transparency)
cond	83:19	83:59	7	f -> avctx -> bits_per_raw_sample <= 8 && ! f -> transparency
water	83:19	0:0	8	f
op	83:20	0:0	8	->
water	83:22	0:0	8	avctx
op	83:27	0:0	8	->
water	83:29	0:0	8	bits_per_raw_sample
op	83:48	0:0	8	<=
water	83:50	0:0	8	8
op	83:52	0:0	8	&&
op	83:55	0:0	8	!
water	83:56	0:0	8	f
op	83:57	0:0	8	->
water	83:59	0:0	8	transparency
stmts	83:73	92:8	7	
water	83:73	0:0	8	{
switch	84:12	91:12	8	(16 * f -> chroma_h_shift + f -> chroma_v_shift)
cond	84:19	84:47	9	16 * f -> chroma_h_shift + f -> chroma_v_shift
water	84:19	0:0	10	16
op	84:22	0:0	10	*
water	84:24	0:0	10	f
op	84:25	0:0	10	->
water	84:27	0:0	10	chroma_h_shift
op	84:42	0:0	10	+
water	84:44	0:0	10	f
op	84:45	0:0	10	->
water	84:47	0:0	10	chroma_v_shift
stmts	84:63	91:12	9	
water	84:63	0:0	10	{
label	85:12	85:21	10	case 0 x00 :
water	85:23	0:0	10	f
op	85:24	0:0	10	->
water	85:26	0:0	10	avctx
op	85:31	0:0	10	->
water	85:33	0:0	10	pix_fmt
op	85:41	0:0	10	=
water	85:43	0:0	10	AV_PIX_FMT_YUV444P
water	85:61	0:0	10	;
break	85:63	85:68	10	
label	86:12	86:21	10	case 0 x01 :
water	86:23	0:0	10	f
op	86:24	0:0	10	->
water	86:26	0:0	10	avctx
op	86:31	0:0	10	->
water	86:33	0:0	10	pix_fmt
op	86:41	0:0	10	=
water	86:43	0:0	10	AV_PIX_FMT_YUV440P
water	86:61	0:0	10	;
break	86:63	86:68	10	
label	87:12	87:21	10	case 0 x10 :
water	87:23	0:0	10	f
op	87:24	0:0	10	->
water	87:26	0:0	10	avctx
op	87:31	0:0	10	->
water	87:33	0:0	10	pix_fmt
op	87:41	0:0	10	=
water	87:43	0:0	10	AV_PIX_FMT_YUV422P
water	87:61	0:0	10	;
break	87:63	87:68	10	
label	88:12	88:21	10	case 0 x11 :
water	88:23	0:0	10	f
op	88:24	0:0	10	->
water	88:26	0:0	10	avctx
op	88:31	0:0	10	->
water	88:33	0:0	10	pix_fmt
op	88:41	0:0	10	=
water	88:43	0:0	10	AV_PIX_FMT_YUV420P
water	88:61	0:0	10	;
break	88:63	88:68	10	
label	89:12	89:21	10	case 0 x20 :
water	89:23	0:0	10	f
op	89:24	0:0	10	->
water	89:26	0:0	10	avctx
op	89:31	0:0	10	->
water	89:33	0:0	10	pix_fmt
op	89:41	0:0	10	=
water	89:43	0:0	10	AV_PIX_FMT_YUV411P
water	89:61	0:0	10	;
break	89:63	89:68	10	
label	90:12	90:21	10	case 0 x22 :
water	90:23	0:0	10	f
op	90:24	0:0	10	->
water	90:26	0:0	10	avctx
op	90:31	0:0	10	->
water	90:33	0:0	10	pix_fmt
op	90:41	0:0	10	=
water	90:43	0:0	10	AV_PIX_FMT_YUV410P
water	90:61	0:0	10	;
break	90:63	90:68	10	
water	91:12	0:0	10	}
water	92:8	0:0	8	}
else	92:10	98:8	4
stmts	92:15	98:8	5	
if	92:15	98:8	6	(f -> avctx -> bits_per_raw_sample <= 8 && f -> transparency)
cond	92:19	92:60	7	f -> avctx -> bits_per_raw_sample <= 8 && f -> transparency
water	92:19	0:0	8	f
op	92:20	0:0	8	->
water	92:22	0:0	8	avctx
op	92:27	0:0	8	->
water	92:29	0:0	8	bits_per_raw_sample
op	92:49	0:0	8	<=
water	92:52	0:0	8	8
op	92:54	0:0	8	&&
water	92:57	0:0	8	f
op	92:58	0:0	8	->
water	92:60	0:0	8	transparency
stmts	92:74	98:8	7	
water	92:74	0:0	8	{
switch	93:12	97:12	8	(16 * f -> chroma_h_shift + f -> chroma_v_shift)
cond	93:19	93:45	9	16 * f -> chroma_h_shift + f -> chroma_v_shift
water	93:19	0:0	10	16
op	93:21	0:0	10	*
water	93:22	0:0	10	f
op	93:23	0:0	10	->
water	93:25	0:0	10	chroma_h_shift
op	93:40	0:0	10	+
water	93:42	0:0	10	f
op	93:43	0:0	10	->
water	93:45	0:0	10	chroma_v_shift
stmts	93:61	97:12	9	
water	93:61	0:0	10	{
label	94:12	94:21	10	case 0 x00 :
water	94:23	0:0	10	f
op	94:24	0:0	10	->
water	94:26	0:0	10	avctx
op	94:31	0:0	10	->
water	94:33	0:0	10	pix_fmt
op	94:41	0:0	10	=
water	94:43	0:0	10	AV_PIX_FMT_YUVA444P
water	94:62	0:0	10	;
break	94:64	94:69	10	
label	95:12	95:21	10	case 0 x10 :
water	95:23	0:0	10	f
op	95:24	0:0	10	->
water	95:26	0:0	10	avctx
op	95:31	0:0	10	->
water	95:33	0:0	10	pix_fmt
op	95:41	0:0	10	=
water	95:43	0:0	10	AV_PIX_FMT_YUVA422P
water	95:62	0:0	10	;
break	95:64	95:69	10	
label	96:12	96:21	10	case 0 x11 :
water	96:23	0:0	10	f
op	96:24	0:0	10	->
water	96:26	0:0	10	avctx
op	96:31	0:0	10	->
water	96:33	0:0	10	pix_fmt
op	96:41	0:0	10	=
water	96:43	0:0	10	AV_PIX_FMT_YUVA420P
water	96:62	0:0	10	;
break	96:64	96:69	10	
water	97:12	0:0	10	}
water	98:8	0:0	8	}
else	98:10	105:8	4
stmts	98:15	105:8	5	
if	98:15	105:8	6	(f -> avctx -> bits_per_raw_sample == 9 && ! f -> transparency)
cond	98:19	98:61	7	f -> avctx -> bits_per_raw_sample == 9 && ! f -> transparency
water	98:19	0:0	8	f
op	98:20	0:0	8	->
water	98:22	0:0	8	avctx
op	98:27	0:0	8	->
water	98:29	0:0	8	bits_per_raw_sample
op	98:49	0:0	8	==
water	98:52	0:0	8	9
op	98:54	0:0	8	&&
op	98:57	0:0	8	!
water	98:58	0:0	8	f
op	98:59	0:0	8	->
water	98:61	0:0	8	transparency
stmts	98:75	105:8	7	
water	98:75	0:0	8	{
water	99:12	0:0	8	f
op	99:13	0:0	8	->
water	99:15	0:0	8	packed_at_lsb
op	99:29	0:0	8	=
water	99:31	0:0	8	1
water	99:32	0:0	8	;
switch	100:12	104:12	8	(16 * f -> chroma_h_shift + f -> chroma_v_shift)
cond	100:19	100:47	9	16 * f -> chroma_h_shift + f -> chroma_v_shift
water	100:19	0:0	10	16
op	100:22	0:0	10	*
water	100:24	0:0	10	f
op	100:25	0:0	10	->
water	100:27	0:0	10	chroma_h_shift
op	100:42	0:0	10	+
water	100:44	0:0	10	f
op	100:45	0:0	10	->
water	100:47	0:0	10	chroma_v_shift
stmts	100:63	104:12	9	
water	100:63	0:0	10	{
label	101:12	101:21	10	case 0 x00 :
water	101:23	0:0	10	f
op	101:24	0:0	10	->
water	101:26	0:0	10	avctx
op	101:31	0:0	10	->
water	101:33	0:0	10	pix_fmt
op	101:41	0:0	10	=
water	101:43	0:0	10	AV_PIX_FMT_YUV444P9
water	101:62	0:0	10	;
break	101:64	101:69	10	
label	102:12	102:21	10	case 0 x10 :
water	102:23	0:0	10	f
op	102:24	0:0	10	->
water	102:26	0:0	10	avctx
op	102:31	0:0	10	->
water	102:33	0:0	10	pix_fmt
op	102:41	0:0	10	=
water	102:43	0:0	10	AV_PIX_FMT_YUV422P9
water	102:62	0:0	10	;
break	102:64	102:69	10	
label	103:12	103:21	10	case 0 x11 :
water	103:23	0:0	10	f
op	103:24	0:0	10	->
water	103:26	0:0	10	avctx
op	103:31	0:0	10	->
water	103:33	0:0	10	pix_fmt
op	103:41	0:0	10	=
water	103:43	0:0	10	AV_PIX_FMT_YUV420P9
water	103:62	0:0	10	;
break	103:64	103:69	10	
water	104:12	0:0	10	}
water	105:8	0:0	8	}
else	105:10	112:8	4
stmts	105:15	112:8	5	
if	105:15	112:8	6	(f -> avctx -> bits_per_raw_sample == 9 && f -> transparency)
cond	105:19	105:60	7	f -> avctx -> bits_per_raw_sample == 9 && f -> transparency
water	105:19	0:0	8	f
op	105:20	0:0	8	->
water	105:22	0:0	8	avctx
op	105:27	0:0	8	->
water	105:29	0:0	8	bits_per_raw_sample
op	105:49	0:0	8	==
water	105:52	0:0	8	9
op	105:54	0:0	8	&&
water	105:57	0:0	8	f
op	105:58	0:0	8	->
water	105:60	0:0	8	transparency
stmts	105:74	112:8	7	
water	105:74	0:0	8	{
water	106:12	0:0	8	f
op	106:13	0:0	8	->
water	106:15	0:0	8	packed_at_lsb
op	106:29	0:0	8	=
water	106:31	0:0	8	1
water	106:32	0:0	8	;
switch	107:12	111:12	8	(16 * f -> chroma_h_shift + f -> chroma_v_shift)
cond	107:19	107:47	9	16 * f -> chroma_h_shift + f -> chroma_v_shift
water	107:19	0:0	10	16
op	107:22	0:0	10	*
water	107:24	0:0	10	f
op	107:25	0:0	10	->
water	107:27	0:0	10	chroma_h_shift
op	107:42	0:0	10	+
water	107:44	0:0	10	f
op	107:45	0:0	10	->
water	107:47	0:0	10	chroma_v_shift
stmts	107:63	111:12	9	
water	107:63	0:0	10	{
label	108:12	108:21	10	case 0 x00 :
water	108:23	0:0	10	f
op	108:24	0:0	10	->
water	108:26	0:0	10	avctx
op	108:31	0:0	10	->
water	108:33	0:0	10	pix_fmt
op	108:41	0:0	10	=
water	108:43	0:0	10	AV_PIX_FMT_YUVA444P9
water	108:63	0:0	10	;
break	108:65	108:70	10	
label	109:12	109:21	10	case 0 x10 :
water	109:23	0:0	10	f
op	109:24	0:0	10	->
water	109:26	0:0	10	avctx
op	109:31	0:0	10	->
water	109:33	0:0	10	pix_fmt
op	109:41	0:0	10	=
water	109:43	0:0	10	AV_PIX_FMT_YUVA422P9
water	109:63	0:0	10	;
break	109:65	109:70	10	
label	110:12	110:21	10	case 0 x11 :
water	110:23	0:0	10	f
op	110:24	0:0	10	->
water	110:26	0:0	10	avctx
op	110:31	0:0	10	->
water	110:33	0:0	10	pix_fmt
op	110:41	0:0	10	=
water	110:43	0:0	10	AV_PIX_FMT_YUVA420P9
water	110:63	0:0	10	;
break	110:65	110:70	10	
water	111:12	0:0	10	}
water	112:8	0:0	8	}
else	112:10	119:8	4
stmts	112:15	119:8	5	
if	112:15	119:8	6	(f -> avctx -> bits_per_raw_sample == 10 && ! f -> transparency)
cond	112:19	112:62	7	f -> avctx -> bits_per_raw_sample == 10 && ! f -> transparency
water	112:19	0:0	8	f
op	112:20	0:0	8	->
water	112:22	0:0	8	avctx
op	112:27	0:0	8	->
water	112:29	0:0	8	bits_per_raw_sample
op	112:49	0:0	8	==
water	112:52	0:0	8	10
op	112:55	0:0	8	&&
op	112:58	0:0	8	!
water	112:59	0:0	8	f
op	112:60	0:0	8	->
water	112:62	0:0	8	transparency
stmts	112:76	119:8	7	
water	112:76	0:0	8	{
water	113:12	0:0	8	f
op	113:13	0:0	8	->
water	113:15	0:0	8	packed_at_lsb
op	113:29	0:0	8	=
water	113:31	0:0	8	1
water	113:32	0:0	8	;
switch	114:12	118:12	8	(16 * f -> chroma_h_shift + f -> chroma_v_shift)
cond	114:19	114:47	9	16 * f -> chroma_h_shift + f -> chroma_v_shift
water	114:19	0:0	10	16
op	114:22	0:0	10	*
water	114:24	0:0	10	f
op	114:25	0:0	10	->
water	114:27	0:0	10	chroma_h_shift
op	114:42	0:0	10	+
water	114:44	0:0	10	f
op	114:45	0:0	10	->
water	114:47	0:0	10	chroma_v_shift
stmts	114:63	118:12	9	
water	114:63	0:0	10	{
label	115:12	115:21	10	case 0 x00 :
water	115:23	0:0	10	f
op	115:24	0:0	10	->
water	115:26	0:0	10	avctx
op	115:31	0:0	10	->
water	115:33	0:0	10	pix_fmt
op	115:41	0:0	10	=
water	115:43	0:0	10	AV_PIX_FMT_YUV444P10
water	115:63	0:0	10	;
break	115:65	115:70	10	
label	116:12	116:21	10	case 0 x10 :
water	116:23	0:0	10	f
op	116:24	0:0	10	->
water	116:26	0:0	10	avctx
op	116:31	0:0	10	->
water	116:33	0:0	10	pix_fmt
op	116:41	0:0	10	=
water	116:43	0:0	10	AV_PIX_FMT_YUV422P10
water	116:63	0:0	10	;
break	116:65	116:70	10	
label	117:12	117:21	10	case 0 x11 :
water	117:23	0:0	10	f
op	117:24	0:0	10	->
water	117:26	0:0	10	avctx
op	117:31	0:0	10	->
water	117:33	0:0	10	pix_fmt
op	117:41	0:0	10	=
water	117:43	0:0	10	AV_PIX_FMT_YUV420P10
water	117:63	0:0	10	;
break	117:65	117:70	10	
water	118:12	0:0	10	}
water	119:8	0:0	8	}
else	119:10	126:8	4
stmts	119:15	126:8	5	
if	119:15	126:8	6	(f -> avctx -> bits_per_raw_sample == 10 && f -> transparency)
cond	119:19	119:61	7	f -> avctx -> bits_per_raw_sample == 10 && f -> transparency
water	119:19	0:0	8	f
op	119:20	0:0	8	->
water	119:22	0:0	8	avctx
op	119:27	0:0	8	->
water	119:29	0:0	8	bits_per_raw_sample
op	119:49	0:0	8	==
water	119:52	0:0	8	10
op	119:55	0:0	8	&&
water	119:58	0:0	8	f
op	119:59	0:0	8	->
water	119:61	0:0	8	transparency
stmts	119:75	126:8	7	
water	119:75	0:0	8	{
water	120:12	0:0	8	f
op	120:13	0:0	8	->
water	120:15	0:0	8	packed_at_lsb
op	120:29	0:0	8	=
water	120:31	0:0	8	1
water	120:32	0:0	8	;
switch	121:12	125:12	8	(16 * f -> chroma_h_shift + f -> chroma_v_shift)
cond	121:19	121:47	9	16 * f -> chroma_h_shift + f -> chroma_v_shift
water	121:19	0:0	10	16
op	121:22	0:0	10	*
water	121:24	0:0	10	f
op	121:25	0:0	10	->
water	121:27	0:0	10	chroma_h_shift
op	121:42	0:0	10	+
water	121:44	0:0	10	f
op	121:45	0:0	10	->
water	121:47	0:0	10	chroma_v_shift
stmts	121:63	125:12	9	
water	121:63	0:0	10	{
label	122:12	122:21	10	case 0 x00 :
water	122:23	0:0	10	f
op	122:24	0:0	10	->
water	122:26	0:0	10	avctx
op	122:31	0:0	10	->
water	122:33	0:0	10	pix_fmt
op	122:41	0:0	10	=
water	122:43	0:0	10	AV_PIX_FMT_YUVA444P10
water	122:64	0:0	10	;
break	122:66	122:71	10	
label	123:12	123:21	10	case 0 x10 :
water	123:23	0:0	10	f
op	123:24	0:0	10	->
water	123:26	0:0	10	avctx
op	123:31	0:0	10	->
water	123:33	0:0	10	pix_fmt
op	123:41	0:0	10	=
water	123:43	0:0	10	AV_PIX_FMT_YUVA422P10
water	123:64	0:0	10	;
break	123:66	123:71	10	
label	124:12	124:21	10	case 0 x11 :
water	124:23	0:0	10	f
op	124:24	0:0	10	->
water	124:26	0:0	10	avctx
op	124:31	0:0	10	->
water	124:33	0:0	10	pix_fmt
op	124:41	0:0	10	=
water	124:43	0:0	10	AV_PIX_FMT_YUVA420P10
water	124:64	0:0	10	;
break	124:66	124:71	10	
water	125:12	0:0	10	}
water	126:8	0:0	8	}
else	126:10	133:8	4
stmts	126:15	133:8	5	
if	126:15	133:8	6	(f -> avctx -> bits_per_raw_sample == 12 && ! f -> transparency)
cond	126:19	126:62	7	f -> avctx -> bits_per_raw_sample == 12 && ! f -> transparency
water	126:19	0:0	8	f
op	126:20	0:0	8	->
water	126:22	0:0	8	avctx
op	126:27	0:0	8	->
water	126:29	0:0	8	bits_per_raw_sample
op	126:49	0:0	8	==
water	126:52	0:0	8	12
op	126:55	0:0	8	&&
op	126:58	0:0	8	!
water	126:59	0:0	8	f
op	126:60	0:0	8	->
water	126:62	0:0	8	transparency
stmts	126:76	133:8	7	
water	126:76	0:0	8	{
water	127:12	0:0	8	f
op	127:13	0:0	8	->
water	127:15	0:0	8	packed_at_lsb
op	127:29	0:0	8	=
water	127:31	0:0	8	1
water	127:32	0:0	8	;
switch	128:12	132:12	8	(16 * f -> chroma_h_shift + f -> chroma_v_shift)
cond	128:19	128:47	9	16 * f -> chroma_h_shift + f -> chroma_v_shift
water	128:19	0:0	10	16
op	128:22	0:0	10	*
water	128:24	0:0	10	f
op	128:25	0:0	10	->
water	128:27	0:0	10	chroma_h_shift
op	128:42	0:0	10	+
water	128:44	0:0	10	f
op	128:45	0:0	10	->
water	128:47	0:0	10	chroma_v_shift
stmts	128:63	132:12	9	
water	128:63	0:0	10	{
label	129:12	129:21	10	case 0 x00 :
water	129:23	0:0	10	f
op	129:24	0:0	10	->
water	129:26	0:0	10	avctx
op	129:31	0:0	10	->
water	129:33	0:0	10	pix_fmt
op	129:41	0:0	10	=
water	129:43	0:0	10	AV_PIX_FMT_YUV444P12
water	129:63	0:0	10	;
break	129:65	129:70	10	
label	130:12	130:21	10	case 0 x10 :
water	130:23	0:0	10	f
op	130:24	0:0	10	->
water	130:26	0:0	10	avctx
op	130:31	0:0	10	->
water	130:33	0:0	10	pix_fmt
op	130:41	0:0	10	=
water	130:43	0:0	10	AV_PIX_FMT_YUV422P12
water	130:63	0:0	10	;
break	130:65	130:70	10	
label	131:12	131:21	10	case 0 x11 :
water	131:23	0:0	10	f
op	131:24	0:0	10	->
water	131:26	0:0	10	avctx
op	131:31	0:0	10	->
water	131:33	0:0	10	pix_fmt
op	131:41	0:0	10	=
water	131:43	0:0	10	AV_PIX_FMT_YUV420P12
water	131:63	0:0	10	;
break	131:65	131:70	10	
water	132:12	0:0	10	}
water	133:8	0:0	8	}
else	133:10	140:8	4
stmts	133:15	140:8	5	
if	133:15	140:8	6	(f -> avctx -> bits_per_raw_sample == 16 && ! f -> transparency)
cond	133:19	133:62	7	f -> avctx -> bits_per_raw_sample == 16 && ! f -> transparency
water	133:19	0:0	8	f
op	133:20	0:0	8	->
water	133:22	0:0	8	avctx
op	133:27	0:0	8	->
water	133:29	0:0	8	bits_per_raw_sample
op	133:49	0:0	8	==
water	133:52	0:0	8	16
op	133:55	0:0	8	&&
op	133:58	0:0	8	!
water	133:59	0:0	8	f
op	133:60	0:0	8	->
water	133:62	0:0	8	transparency
stmts	133:75	140:8	7	
water	133:75	0:0	8	{
water	134:12	0:0	8	f
op	134:13	0:0	8	->
water	134:15	0:0	8	packed_at_lsb
op	134:29	0:0	8	=
water	134:31	0:0	8	1
water	134:32	0:0	8	;
switch	135:12	139:12	8	(16 * f -> chroma_h_shift + f -> chroma_v_shift)
cond	135:19	135:47	9	16 * f -> chroma_h_shift + f -> chroma_v_shift
water	135:19	0:0	10	16
op	135:22	0:0	10	*
water	135:24	0:0	10	f
op	135:25	0:0	10	->
water	135:27	0:0	10	chroma_h_shift
op	135:42	0:0	10	+
water	135:44	0:0	10	f
op	135:45	0:0	10	->
water	135:47	0:0	10	chroma_v_shift
stmts	135:63	139:12	9	
water	135:63	0:0	10	{
label	136:12	136:21	10	case 0 x00 :
water	136:23	0:0	10	f
op	136:24	0:0	10	->
water	136:26	0:0	10	avctx
op	136:31	0:0	10	->
water	136:33	0:0	10	pix_fmt
op	136:41	0:0	10	=
water	136:43	0:0	10	AV_PIX_FMT_YUV444P16
water	136:63	0:0	10	;
break	136:65	136:70	10	
label	137:12	137:21	10	case 0 x10 :
water	137:23	0:0	10	f
op	137:24	0:0	10	->
water	137:26	0:0	10	avctx
op	137:31	0:0	10	->
water	137:33	0:0	10	pix_fmt
op	137:41	0:0	10	=
water	137:43	0:0	10	AV_PIX_FMT_YUV422P16
water	137:63	0:0	10	;
break	137:65	137:70	10	
label	138:12	138:21	10	case 0 x11 :
water	138:23	0:0	10	f
op	138:24	0:0	10	->
water	138:26	0:0	10	avctx
op	138:31	0:0	10	->
water	138:33	0:0	10	pix_fmt
op	138:41	0:0	10	=
water	138:43	0:0	10	AV_PIX_FMT_YUV420P16
water	138:63	0:0	10	;
break	138:65	138:70	10	
water	139:12	0:0	10	}
water	140:8	0:0	8	}
else	140:10	147:8	4
stmts	140:15	147:8	5	
if	140:15	147:8	6	(f -> avctx -> bits_per_raw_sample == 16 && f -> transparency)
cond	140:19	140:61	7	f -> avctx -> bits_per_raw_sample == 16 && f -> transparency
water	140:19	0:0	8	f
op	140:20	0:0	8	->
water	140:22	0:0	8	avctx
op	140:27	0:0	8	->
water	140:29	0:0	8	bits_per_raw_sample
op	140:49	0:0	8	==
water	140:52	0:0	8	16
op	140:55	0:0	8	&&
water	140:58	0:0	8	f
op	140:59	0:0	8	->
water	140:61	0:0	8	transparency
stmts	140:74	147:8	7	
water	140:74	0:0	8	{
water	141:12	0:0	8	f
op	141:13	0:0	8	->
water	141:15	0:0	8	packed_at_lsb
op	141:29	0:0	8	=
water	141:31	0:0	8	1
water	141:32	0:0	8	;
switch	142:12	146:12	8	(16 * f -> chroma_h_shift + f -> chroma_v_shift)
cond	142:19	142:47	9	16 * f -> chroma_h_shift + f -> chroma_v_shift
water	142:19	0:0	10	16
op	142:22	0:0	10	*
water	142:24	0:0	10	f
op	142:25	0:0	10	->
water	142:27	0:0	10	chroma_h_shift
op	142:42	0:0	10	+
water	142:44	0:0	10	f
op	142:45	0:0	10	->
water	142:47	0:0	10	chroma_v_shift
stmts	142:63	146:12	9	
water	142:63	0:0	10	{
label	143:12	143:21	10	case 0 x00 :
water	143:23	0:0	10	f
op	143:24	0:0	10	->
water	143:26	0:0	10	avctx
op	143:31	0:0	10	->
water	143:33	0:0	10	pix_fmt
op	143:41	0:0	10	=
water	143:43	0:0	10	AV_PIX_FMT_YUVA444P16
water	143:64	0:0	10	;
break	143:66	143:71	10	
label	144:12	144:21	10	case 0 x10 :
water	144:23	0:0	10	f
op	144:24	0:0	10	->
water	144:26	0:0	10	avctx
op	144:31	0:0	10	->
water	144:33	0:0	10	pix_fmt
op	144:41	0:0	10	=
water	144:43	0:0	10	AV_PIX_FMT_YUVA422P16
water	144:64	0:0	10	;
break	144:66	144:71	10	
label	145:12	145:21	10	case 0 x11 :
water	145:23	0:0	10	f
op	145:24	0:0	10	->
water	145:26	0:0	10	avctx
op	145:31	0:0	10	->
water	145:33	0:0	10	pix_fmt
op	145:41	0:0	10	=
water	145:43	0:0	10	AV_PIX_FMT_YUVA420P16
water	145:64	0:0	10	;
break	145:66	145:71	10	
water	146:12	0:0	10	}
water	147:8	0:0	8	}
water	148:4	0:0	4	}
else	148:6	170:4	2
stmts	148:11	170:4	3	
if	148:11	170:4	4	(f -> colorspace == 1)
cond	148:15	148:32	5	f -> colorspace == 1
water	148:15	0:0	6	f
op	148:16	0:0	6	->
water	148:18	0:0	6	colorspace
op	148:29	0:0	6	==
water	148:32	0:0	6	1
stmts	148:35	170:4	5	
water	148:35	0:0	6	{
if	149:8	153:8	6	(f -> chroma_h_shift || f -> chroma_v_shift)
cond	149:12	149:36	7	f -> chroma_h_shift || f -> chroma_v_shift
water	149:12	0:0	8	f
op	149:13	0:0	8	->
water	149:15	0:0	8	chroma_h_shift
op	149:30	0:0	8	||
water	149:33	0:0	8	f
op	149:34	0:0	8	->
water	149:36	0:0	8	chroma_v_shift
stmts	149:52	153:8	7	
water	149:52	0:0	8	{
call	150:12	151:74	8	av_log
arg	150:19	150:27	9	f->avctx
water	150:19	0:0	10	f
op	150:20	0:0	10	->
water	150:22	0:0	10	avctx
arg	150:29	150:41	9	AV_LOG_ERROR
water	150:29	0:0	10	AV_LOG_ERROR
arg	151:19	151:74	9	"chroma subsampling not supported in this colorspace\n"
water	151:19	0:0	10	"chroma subsampling not supported in this colorspace\n"
water	151:75	0:0	8	;
return	152:12	152:34	8	AVERROR(ENOSYS)
call	152:19	152:33	9	AVERROR
arg	152:27	152:33	10	ENOSYS
water	152:27	0:0	11	ENOSYS
water	153:8	0:0	8	}
if	154:8	155:49	6	(f -> avctx -> bits_per_raw_sample <= 8 && ! f -> transparency)
cond	154:17	154:60	7	f -> avctx -> bits_per_raw_sample <= 8 && ! f -> transparency
water	154:17	0:0	8	f
op	154:18	0:0	8	->
water	154:20	0:0	8	avctx
op	154:25	0:0	8	->
water	154:27	0:0	8	bits_per_raw_sample
op	154:47	0:0	8	<=
water	154:51	0:0	8	8
op	154:53	0:0	8	&&
op	154:56	0:0	8	!
water	154:57	0:0	8	f
op	154:58	0:0	8	->
water	154:60	0:0	8	transparency
stmts	155:12	155:49	7	
water	155:12	0:0	8	f
op	155:13	0:0	8	->
water	155:15	0:0	8	avctx
op	155:20	0:0	8	->
water	155:22	0:0	8	pix_fmt
op	155:30	0:0	8	=
water	155:32	0:0	8	AV_PIX_FMT_0RGB32
water	155:49	0:0	8	;
else	156:8	157:48	6
stmts	156:13	157:48	7	
if	156:13	157:48	8	(f -> avctx -> bits_per_raw_sample <= 8 && f -> transparency)
cond	156:17	156:59	9	f -> avctx -> bits_per_raw_sample <= 8 && f -> transparency
water	156:17	0:0	10	f
op	156:18	0:0	10	->
water	156:20	0:0	10	avctx
op	156:25	0:0	10	->
water	156:27	0:0	10	bits_per_raw_sample
op	156:47	0:0	10	<=
water	156:51	0:0	10	8
op	156:53	0:0	10	&&
water	156:56	0:0	10	f
op	156:57	0:0	10	->
water	156:59	0:0	10	transparency
stmts	157:12	157:48	9	
water	157:12	0:0	10	f
op	157:13	0:0	10	->
water	157:15	0:0	10	avctx
op	157:20	0:0	10	->
water	157:22	0:0	10	pix_fmt
op	157:30	0:0	10	=
water	157:32	0:0	10	AV_PIX_FMT_RGB32
water	157:48	0:0	10	;
else	158:8	159:48	6
stmts	158:13	159:48	7	
if	158:13	159:48	8	(f -> avctx -> bits_per_raw_sample == 9 && ! f -> transparency)
cond	158:17	158:60	9	f -> avctx -> bits_per_raw_sample == 9 && ! f -> transparency
water	158:17	0:0	10	f
op	158:18	0:0	10	->
water	158:20	0:0	10	avctx
op	158:25	0:0	10	->
water	158:27	0:0	10	bits_per_raw_sample
op	158:47	0:0	10	==
water	158:51	0:0	10	9
op	158:53	0:0	10	&&
op	158:56	0:0	10	!
water	158:57	0:0	10	f
op	158:58	0:0	10	->
water	158:60	0:0	10	transparency
stmts	159:12	159:48	9	
water	159:12	0:0	10	f
op	159:13	0:0	10	->
water	159:15	0:0	10	avctx
op	159:20	0:0	10	->
water	159:22	0:0	10	pix_fmt
op	159:30	0:0	10	=
water	159:32	0:0	10	AV_PIX_FMT_GBRP9
water	159:48	0:0	10	;
else	160:8	161:49	6
stmts	160:13	161:49	7	
if	160:13	161:49	8	(f -> avctx -> bits_per_raw_sample == 10 && ! f -> transparency)
cond	160:17	160:60	9	f -> avctx -> bits_per_raw_sample == 10 && ! f -> transparency
water	160:17	0:0	10	f
op	160:18	0:0	10	->
water	160:20	0:0	10	avctx
op	160:25	0:0	10	->
water	160:27	0:0	10	bits_per_raw_sample
op	160:47	0:0	10	==
water	160:50	0:0	10	10
op	160:53	0:0	10	&&
op	160:56	0:0	10	!
water	160:57	0:0	10	f
op	160:58	0:0	10	->
water	160:60	0:0	10	transparency
stmts	161:12	161:49	9	
water	161:12	0:0	10	f
op	161:13	0:0	10	->
water	161:15	0:0	10	avctx
op	161:20	0:0	10	->
water	161:22	0:0	10	pix_fmt
op	161:30	0:0	10	=
water	161:32	0:0	10	AV_PIX_FMT_GBRP10
water	161:49	0:0	10	;
else	162:8	163:49	6
stmts	162:13	163:49	7	
if	162:13	163:49	8	(f -> avctx -> bits_per_raw_sample == 12 && ! f -> transparency)
cond	162:17	162:60	9	f -> avctx -> bits_per_raw_sample == 12 && ! f -> transparency
water	162:17	0:0	10	f
op	162:18	0:0	10	->
water	162:20	0:0	10	avctx
op	162:25	0:0	10	->
water	162:27	0:0	10	bits_per_raw_sample
op	162:47	0:0	10	==
water	162:50	0:0	10	12
op	162:53	0:0	10	&&
op	162:56	0:0	10	!
water	162:57	0:0	10	f
op	162:58	0:0	10	->
water	162:60	0:0	10	transparency
stmts	163:12	163:49	9	
water	163:12	0:0	10	f
op	163:13	0:0	10	->
water	163:15	0:0	10	avctx
op	163:20	0:0	10	->
water	163:22	0:0	10	pix_fmt
op	163:30	0:0	10	=
water	163:32	0:0	10	AV_PIX_FMT_GBRP12
water	163:49	0:0	10	;
else	164:8	165:49	6
stmts	164:13	165:49	7	
if	164:13	165:49	8	(f -> avctx -> bits_per_raw_sample == 14 && ! f -> transparency)
cond	164:17	164:60	9	f -> avctx -> bits_per_raw_sample == 14 && ! f -> transparency
water	164:17	0:0	10	f
op	164:18	0:0	10	->
water	164:20	0:0	10	avctx
op	164:25	0:0	10	->
water	164:27	0:0	10	bits_per_raw_sample
op	164:47	0:0	10	==
water	164:50	0:0	10	14
op	164:53	0:0	10	&&
op	164:56	0:0	10	!
water	164:57	0:0	10	f
op	164:58	0:0	10	->
water	164:60	0:0	10	transparency
stmts	165:12	165:49	9	
water	165:12	0:0	10	f
op	165:13	0:0	10	->
water	165:15	0:0	10	avctx
op	165:20	0:0	10	->
water	165:22	0:0	10	pix_fmt
op	165:30	0:0	10	=
water	165:32	0:0	10	AV_PIX_FMT_GBRP14
water	165:49	0:0	10	;
else	166:8	169:8	6
stmts	166:13	169:8	7	
if	166:13	169:8	8	(f -> avctx -> bits_per_raw_sample == 16 && ! f -> transparency)
cond	166:17	166:60	9	f -> avctx -> bits_per_raw_sample == 16 && ! f -> transparency
water	166:17	0:0	10	f
op	166:18	0:0	10	->
water	166:20	0:0	10	avctx
op	166:25	0:0	10	->
water	166:27	0:0	10	bits_per_raw_sample
op	166:47	0:0	10	==
water	166:50	0:0	10	16
op	166:53	0:0	10	&&
op	166:56	0:0	10	!
water	166:57	0:0	10	f
op	166:58	0:0	10	->
water	166:60	0:0	10	transparency
stmts	166:74	169:8	9	
water	166:74	0:0	10	{
water	167:12	0:0	10	f
op	167:13	0:0	10	->
water	167:15	0:0	10	avctx
op	167:20	0:0	10	->
water	167:22	0:0	10	pix_fmt
op	167:30	0:0	10	=
water	167:32	0:0	10	AV_PIX_FMT_GBRP16
water	167:49	0:0	10	;
water	168:12	0:0	10	f
op	168:13	0:0	10	->
water	168:15	0:0	10	use32bit
op	168:24	0:0	10	=
water	168:26	0:0	10	1
water	168:27	0:0	10	;
water	169:8	0:0	10	}
water	170:4	0:0	6	}
else	170:6	173:4	2
stmts	170:11	173:4	3	
water	170:11	0:0	4	{
call	171:8	171:67	4	av_log
arg	171:15	171:23	5	f->avctx
water	171:15	0:0	6	f
op	171:16	0:0	6	->
water	171:18	0:0	6	avctx
arg	171:25	171:37	5	AV_LOG_ERROR
water	171:25	0:0	6	AV_LOG_ERROR
arg	171:39	171:67	5	"colorspace not supported\n"
water	171:39	0:0	6	"colorspace not supported\n"
water	171:68	0:0	4	;
return	172:8	172:30	4	AVERROR(ENOSYS)
call	172:15	172:29	5	AVERROR
arg	172:23	172:29	6	ENOSYS
water	172:23	0:0	7	ENOSYS
water	173:4	0:0	4	}
if	174:4	177:4	2	(f -> avctx -> pix_fmt == AV_PIX_FMT_NONE)
cond	174:8	174:29	3	f -> avctx -> pix_fmt == AV_PIX_FMT_NONE
water	174:8	0:0	4	f
op	174:9	0:0	4	->
water	174:11	0:0	4	avctx
op	174:16	0:0	4	->
water	174:18	0:0	4	pix_fmt
op	174:26	0:0	4	==
water	174:29	0:0	4	AV_PIX_FMT_NONE
stmts	174:46	177:4	3	
water	174:46	0:0	4	{
call	175:8	175:63	4	av_log
arg	175:15	175:23	5	f->avctx
water	175:15	0:0	6	f
op	175:16	0:0	6	->
water	175:18	0:0	6	avctx
arg	175:25	175:37	5	AV_LOG_ERROR
water	175:25	0:0	6	AV_LOG_ERROR
arg	175:39	175:63	5	"format not supported\n"
water	175:39	0:0	6	"format not supported\n"
water	175:64	0:0	4	;
return	176:8	176:30	4	AVERROR(ENOSYS)
call	176:15	176:29	5	AVERROR
arg	176:23	176:29	6	ENOSYS
water	176:23	0:0	7	ENOSYS
water	177:4	0:0	4	}
call	179:4	180:67	2	ff_dlog
arg	179:12	179:20	3	f->avctx
water	179:12	0:0	4	f
op	179:13	0:0	4	->
water	179:15	0:0	4	avctx
arg	179:22	179:34	3	"%d %d %d\n"
water	179:22	0:0	4	"%d %d %d\n"
arg	180:12	180:29	3	f->chroma_h_shift
water	180:12	0:0	4	f
op	180:13	0:0	4	->
water	180:15	0:0	4	chroma_h_shift
arg	180:31	180:48	3	f->chroma_v_shift
water	180:31	0:0	4	f
op	180:32	0:0	4	->
water	180:34	0:0	4	chroma_v_shift
arg	180:50	180:67	3	f->avctx->pix_fmt
water	180:50	0:0	4	f
op	180:51	0:0	4	->
water	180:53	0:0	4	avctx
op	180:58	0:0	4	->
water	180:60	0:0	4	pix_fmt
water	180:68	0:0	2	;
if	181:4	188:4	2	(f -> version < 2)
cond	181:8	181:21	3	f -> version < 2
water	181:8	0:0	4	f
op	181:9	0:0	4	->
water	181:11	0:0	4	version
op	181:19	0:0	4	<
water	181:21	0:0	4	2
stmts	181:24	188:4	3	
water	181:24	0:0	4	{
water	182:8	0:0	4	context_count
op	182:22	0:0	4	=
call	182:24	182:59	4	read_quant_tables
arg	182:42	182:43	5	c
water	182:42	0:0	6	c
arg	182:45	182:59	5	f->quant_table
water	182:45	0:0	6	f
op	182:46	0:0	6	->
water	182:48	0:0	6	quant_table
water	182:60	0:0	4	;
if	183:8	186:8	4	(context_count < 0)
cond	183:12	183:28	5	context_count < 0
water	183:12	0:0	6	context_count
op	183:26	0:0	6	<
water	183:28	0:0	6	0
stmts	183:31	186:8	5	
water	183:31	0:0	6	{
call	184:12	184:69	6	av_log
arg	184:19	184:27	7	f->avctx
water	184:19	0:0	8	f
op	184:20	0:0	8	->
water	184:22	0:0	8	avctx
arg	184:29	184:41	7	AV_LOG_ERROR
water	184:29	0:0	8	AV_LOG_ERROR
arg	184:43	184:69	7	"read_quant_table error\n"
water	184:43	0:0	8	"read_quant_table error\n"
water	184:70	0:0	6	;
return	185:12	185:38	6	AVERROR_INVALIDDATA
water	185:19	0:0	7	AVERROR_INVALIDDATA
water	186:8	0:0	6	}
water	187:8	0:0	4	f
op	187:9	0:0	4	->
water	187:11	0:0	4	slice_count
op	187:23	0:0	4	=
water	187:25	0:0	4	f
op	187:26	0:0	4	->
water	187:28	0:0	4	max_slice_count
water	187:43	0:0	4	;
water	188:4	0:0	4	}
else	188:6	190:4	2
stmts	188:11	190:4	3	
if	188:11	190:4	4	(f -> version < 3)
cond	188:15	188:28	5	f -> version < 3
water	188:15	0:0	6	f
op	188:16	0:0	6	->
water	188:18	0:0	6	version
op	188:26	0:0	6	<
water	188:28	0:0	6	3
stmts	188:31	190:4	5	
water	188:31	0:0	6	{
water	189:8	0:0	6	f
op	189:9	0:0	6	->
water	189:11	0:0	6	slice_count
op	189:23	0:0	6	=
call	189:25	189:47	6	get_symbol
arg	189:36	189:37	7	c
water	189:36	0:0	8	c
arg	189:39	189:44	7	state
water	189:39	0:0	8	state
arg	189:46	189:47	7	0
water	189:46	0:0	8	0
water	189:48	0:0	6	;
water	190:4	0:0	6	}
else	190:6	201:4	2
stmts	190:11	201:4	3	
water	190:11	0:0	4	{
decl	191:8	191:44	4	const uint8_t	*p
op	191:25	0:0	4	=
water	191:27	0:0	4	c
op	191:28	0:0	4	->
water	191:30	0:0	4	bytestream_end
for	192:8	200:8	4	(f -> slice_count = 0 ;f -> slice_count < MAX_SLICES && 3 < p - c -> bytestream_start;f -> slice_count ++)
forinit	192:13	192:31	5	f -> slice_count = 0 ;
water	192:13	0:0	6	f
op	192:14	0:0	6	->
water	192:16	0:0	6	slice_count
op	192:28	0:0	6	=
water	192:30	0:0	6	0
water	192:31	0:0	6	;
cond	193:13	193:55	5	f -> slice_count < MAX_SLICES && 3 < p - c -> bytestream_start
water	193:13	0:0	6	f
op	193:14	0:0	6	->
water	193:16	0:0	6	slice_count
op	193:28	0:0	6	<
water	193:30	0:0	6	MAX_SLICES
op	193:41	0:0	6	&&
water	193:44	0:0	6	3
op	193:46	0:0	6	<
water	193:48	0:0	6	p
op	193:50	0:0	6	-
water	193:52	0:0	6	c
op	193:53	0:0	6	->
water	193:55	0:0	6	bytestream_start
forexpr	194:13	194:27	5	f -> slice_count ++
water	194:13	0:0	6	f
op	194:14	0:0	6	->
water	194:16	0:0	6	slice_count
op	194:27	0:0	6	++
stmts	194:31	200:8	5	
water	194:31	0:0	6	{
decl	195:12	195:39	6	int	trailer
op	195:24	0:0	6	=
water	195:26	0:0	6	3
op	195:28	0:0	6	+
water	195:30	0:0	6	5
op	195:31	0:0	6	*
op	195:32	0:0	6	!
op	195:33	0:0	6	!
water	195:34	0:0	6	f
op	195:35	0:0	6	->
water	195:37	0:0	6	ec
decl	196:12	196:41	6	int	size
op	196:21	0:0	6	=
call	196:23	196:40	7	AV_RB24
arg	196:31	196:40	8	p-trailer
water	196:31	0:0	9	p
op	196:32	0:0	9	-
water	196:33	0:0	9	trailer
if	197:12	198:21	6	(size + trailer > p - c -> bytestream_start)
cond	197:16	197:40	7	size + trailer > p - c -> bytestream_start
water	197:16	0:0	8	size
op	197:21	0:0	8	+
water	197:23	0:0	8	trailer
op	197:31	0:0	8	>
water	197:33	0:0	8	p
op	197:35	0:0	8	-
water	197:37	0:0	8	c
op	197:38	0:0	8	->
water	197:40	0:0	8	bytestream_start
stmts	198:16	198:21	7	
break	198:16	198:21	8	
water	199:12	0:0	6	p
op	199:14	0:0	6	-=
water	199:17	0:0	6	size
op	199:22	0:0	6	+
water	199:24	0:0	6	trailer
water	199:31	0:0	6	;
water	200:8	0:0	6	}
water	201:4	0:0	4	}
if	202:4	205:4	2	(f -> slice_count > ( unsigned ) MAX_SLICES || f -> slice_count <= 0 || f -> slice_count > f -> max_slice_count)
cond	202:8	202:92	3	f -> slice_count > ( unsigned ) MAX_SLICES || f -> slice_count <= 0 || f -> slice_count > f -> max_slice_count
water	202:8	0:0	4	f
op	202:9	0:0	4	->
water	202:11	0:0	4	slice_count
op	202:23	0:0	4	>
water	202:25	0:0	4	(
water	202:26	0:0	4	unsigned
water	202:34	0:0	4	)
water	202:35	0:0	4	MAX_SLICES
op	202:46	0:0	4	||
water	202:49	0:0	4	f
op	202:50	0:0	4	->
water	202:52	0:0	4	slice_count
op	202:64	0:0	4	<=
water	202:67	0:0	4	0
op	202:69	0:0	4	||
water	202:72	0:0	4	f
op	202:73	0:0	4	->
water	202:75	0:0	4	slice_count
op	202:87	0:0	4	>
water	202:89	0:0	4	f
op	202:90	0:0	4	->
water	202:92	0:0	4	max_slice_count
stmts	202:109	205:4	3	
water	202:109	0:0	4	{
call	203:8	203:113	4	av_log
arg	203:15	203:23	5	f->avctx
water	203:15	0:0	6	f
op	203:16	0:0	6	->
water	203:18	0:0	6	avctx
arg	203:25	203:37	5	AV_LOG_ERROR
water	203:25	0:0	6	AV_LOG_ERROR
arg	203:39	203:77	5	"slice count %d is invalid (max=%d)\n"
water	203:39	0:0	6	"slice count %d is invalid (max=%d)\n"
arg	203:79	203:93	5	f->slice_count
water	203:79	0:0	6	f
op	203:80	0:0	6	->
water	203:82	0:0	6	slice_count
arg	203:95	203:113	5	f->max_slice_count
water	203:95	0:0	6	f
op	203:96	0:0	6	->
water	203:98	0:0	6	max_slice_count
water	203:114	0:0	4	;
return	204:8	204:34	4	AVERROR_INVALIDDATA
water	204:15	0:0	5	AVERROR_INVALIDDATA
water	205:4	0:0	4	}
for	207:4	259:4	2	(j = 0 ;j < f -> slice_count;j ++)
forinit	207:9	207:14	3	j = 0 ;
water	207:9	0:0	4	j
op	207:11	0:0	4	=
water	207:13	0:0	4	0
water	207:14	0:0	4	;
cond	207:16	207:23	3	j < f -> slice_count
water	207:16	0:0	4	j
op	207:18	0:0	4	<
water	207:20	0:0	4	f
op	207:21	0:0	4	->
water	207:23	0:0	4	slice_count
forexpr	207:36	207:37	3	j ++
water	207:36	0:0	4	j
op	207:37	0:0	4	++
stmts	207:41	259:4	3	
water	207:41	0:0	4	{
decl	208:8	208:45	4	FFV1Context	*fs
op	208:24	0:0	4	=
water	208:26	0:0	4	f
op	208:27	0:0	4	->
water	208:29	0:0	4	slice_context
op	208:42	0:0	4	[
water	208:43	0:0	4	j
op	208:44	0:0	4	]
water	209:8	0:0	4	fs
op	209:10	0:0	4	->
water	209:12	0:0	4	ac
op	209:26	0:0	4	=
water	209:28	0:0	4	f
op	209:29	0:0	4	->
water	209:31	0:0	4	ac
water	209:33	0:0	4	;
water	210:8	0:0	4	fs
op	210:10	0:0	4	->
water	210:12	0:0	4	packed_at_lsb
op	210:26	0:0	4	=
water	210:28	0:0	4	f
op	210:29	0:0	4	->
water	210:31	0:0	4	packed_at_lsb
water	210:44	0:0	4	;
water	212:8	0:0	4	fs
op	212:10	0:0	4	->
water	212:12	0:0	4	slice_damaged
op	212:26	0:0	4	=
water	212:28	0:0	4	0
water	212:29	0:0	4	;
if	214:8	230:8	4	(f -> version == 2)
cond	214:12	214:26	5	f -> version == 2
water	214:12	0:0	6	f
op	214:13	0:0	6	->
water	214:15	0:0	6	version
op	214:23	0:0	6	==
water	214:26	0:0	6	2
stmts	214:29	230:8	5	
water	214:29	0:0	6	{
water	215:12	0:0	6	fs
op	215:14	0:0	6	->
water	215:16	0:0	6	slice_x
op	215:29	0:0	6	=
call	215:32	215:54	6	get_symbol
arg	215:43	215:44	7	c
water	215:43	0:0	8	c
arg	215:46	215:51	7	state
water	215:46	0:0	8	state
arg	215:53	215:54	7	0
water	215:53	0:0	8	0
op	215:61	0:0	6	*
water	215:63	0:0	6	f
op	215:64	0:0	6	->
water	215:66	0:0	6	width
water	215:72	0:0	6	;
water	216:12	0:0	6	fs
op	216:14	0:0	6	->
water	216:16	0:0	6	slice_y
op	216:29	0:0	6	=
call	216:32	216:54	6	get_symbol
arg	216:43	216:44	7	c
water	216:43	0:0	8	c
arg	216:46	216:51	7	state
water	216:46	0:0	8	state
arg	216:53	216:54	7	0
water	216:53	0:0	8	0
op	216:61	0:0	6	*
water	216:63	0:0	6	f
op	216:64	0:0	6	->
water	216:66	0:0	6	height
water	216:72	0:0	6	;
water	217:12	0:0	6	fs
op	217:14	0:0	6	->
water	217:16	0:0	6	slice_width
op	217:29	0:0	6	=
water	217:31	0:0	6	(
call	217:32	217:54	6	get_symbol
arg	217:43	217:44	7	c
water	217:43	0:0	8	c
arg	217:46	217:51	7	state
water	217:46	0:0	8	state
arg	217:53	217:54	7	0
water	217:53	0:0	8	0
op	217:56	0:0	6	+
water	217:58	0:0	6	1
water	217:59	0:0	6	)
op	217:61	0:0	6	*
water	217:63	0:0	6	f
op	217:64	0:0	6	->
water	217:66	0:0	6	width
op	217:73	0:0	6	+
water	217:75	0:0	6	fs
op	217:77	0:0	6	->
water	217:79	0:0	6	slice_x
water	217:86	0:0	6	;
water	218:12	0:0	6	fs
op	218:14	0:0	6	->
water	218:16	0:0	6	slice_height
op	218:29	0:0	6	=
water	218:31	0:0	6	(
call	218:32	218:54	6	get_symbol
arg	218:43	218:44	7	c
water	218:43	0:0	8	c
arg	218:46	218:51	7	state
water	218:46	0:0	8	state
arg	218:53	218:54	7	0
water	218:53	0:0	8	0
op	218:56	0:0	6	+
water	218:58	0:0	6	1
water	218:59	0:0	6	)
op	218:61	0:0	6	*
water	218:63	0:0	6	f
op	218:64	0:0	6	->
water	218:66	0:0	6	height
op	218:73	0:0	6	+
water	218:75	0:0	6	fs
op	218:77	0:0	6	->
water	218:79	0:0	6	slice_y
water	218:86	0:0	6	;
water	220:12	0:0	6	fs
op	220:14	0:0	6	->
water	220:16	0:0	6	slice_x
op	220:28	0:0	6	/=
water	220:31	0:0	6	f
op	220:32	0:0	6	->
water	220:34	0:0	6	num_h_slices
water	220:46	0:0	6	;
water	221:12	0:0	6	fs
op	221:14	0:0	6	->
water	221:16	0:0	6	slice_y
op	221:28	0:0	6	/=
water	221:31	0:0	6	f
op	221:32	0:0	6	->
water	221:34	0:0	6	num_v_slices
water	221:46	0:0	6	;
water	222:12	0:0	6	fs
op	222:14	0:0	6	->
water	222:16	0:0	6	slice_width
op	222:29	0:0	6	=
water	222:31	0:0	6	fs
op	222:33	0:0	6	->
water	222:35	0:0	6	slice_width
op	222:48	0:0	6	/
water	222:50	0:0	6	f
op	222:51	0:0	6	->
water	222:53	0:0	6	num_h_slices
op	222:66	0:0	6	-
water	222:68	0:0	6	fs
op	222:70	0:0	6	->
water	222:72	0:0	6	slice_x
water	222:79	0:0	6	;
water	223:12	0:0	6	fs
op	223:14	0:0	6	->
water	223:16	0:0	6	slice_height
op	223:29	0:0	6	=
water	223:31	0:0	6	fs
op	223:33	0:0	6	->
water	223:35	0:0	6	slice_height
op	223:48	0:0	6	/
water	223:50	0:0	6	f
op	223:51	0:0	6	->
water	223:53	0:0	6	num_v_slices
op	223:66	0:0	6	-
water	223:68	0:0	6	fs
op	223:70	0:0	6	->
water	223:72	0:0	6	slice_y
water	223:79	0:0	6	;
if	224:12	226:42	6	(( unsigned ) fs -> slice_width > f -> width || ( unsigned ) fs -> slice_height > f -> height)
cond	224:16	225:48	7	( unsigned ) fs -> slice_width > f -> width || ( unsigned ) fs -> slice_height > f -> height
water	224:16	0:0	8	(
water	224:17	0:0	8	unsigned
water	224:25	0:0	8	)
water	224:26	0:0	8	fs
op	224:28	0:0	8	->
water	224:30	0:0	8	slice_width
op	224:43	0:0	8	>
water	224:45	0:0	8	f
op	224:46	0:0	8	->
water	224:48	0:0	8	width
op	224:54	0:0	8	||
water	225:16	0:0	8	(
water	225:17	0:0	8	unsigned
water	225:25	0:0	8	)
water	225:26	0:0	8	fs
op	225:28	0:0	8	->
water	225:30	0:0	8	slice_height
op	225:43	0:0	8	>
water	225:45	0:0	8	f
op	225:46	0:0	8	->
water	225:48	0:0	8	height
stmts	226:16	226:42	7	
return	226:16	226:42	8	AVERROR_INVALIDDATA
water	226:23	0:0	9	AVERROR_INVALIDDATA
if	227:12	229:42	6	(( unsigned ) fs -> slice_x + ( uint64_t ) fs -> slice_width > f -> width || ( unsigned ) fs -> slice_y + ( uint64_t ) fs -> slice_height > f -> height)
cond	227:19	228:75	7	( unsigned ) fs -> slice_x + ( uint64_t ) fs -> slice_width > f -> width || ( unsigned ) fs -> slice_y + ( uint64_t ) fs -> slice_height > f -> height
water	227:19	0:0	8	(
water	227:20	0:0	8	unsigned
water	227:28	0:0	8	)
water	227:29	0:0	8	fs
op	227:31	0:0	8	->
water	227:33	0:0	8	slice_x
op	227:41	0:0	8	+
water	227:43	0:0	8	(
water	227:44	0:0	8	uint64_t
water	227:52	0:0	8	)
water	227:53	0:0	8	fs
op	227:55	0:0	8	->
water	227:57	0:0	8	slice_width
op	227:70	0:0	8	>
water	227:72	0:0	8	f
op	227:73	0:0	8	->
water	227:75	0:0	8	width
op	228:16	0:0	8	||
water	228:19	0:0	8	(
water	228:20	0:0	8	unsigned
water	228:28	0:0	8	)
water	228:29	0:0	8	fs
op	228:31	0:0	8	->
water	228:33	0:0	8	slice_y
op	228:41	0:0	8	+
water	228:43	0:0	8	(
water	228:44	0:0	8	uint64_t
water	228:52	0:0	8	)
water	228:53	0:0	8	fs
op	228:55	0:0	8	->
water	228:57	0:0	8	slice_height
op	228:70	0:0	8	>
water	228:72	0:0	8	f
op	228:73	0:0	8	->
water	228:75	0:0	8	height
stmts	229:16	229:42	7	
return	229:16	229:42	8	AVERROR_INVALIDDATA
water	229:23	0:0	9	AVERROR_INVALIDDATA
water	230:8	0:0	6	}
for	232:8	258:8	4	(i = 0 ;i < f -> plane_count;i ++)
forinit	232:13	232:18	5	i = 0 ;
water	232:13	0:0	6	i
op	232:15	0:0	6	=
water	232:17	0:0	6	0
water	232:18	0:0	6	;
cond	232:20	232:27	5	i < f -> plane_count
water	232:20	0:0	6	i
op	232:22	0:0	6	<
water	232:24	0:0	6	f
op	232:25	0:0	6	->
water	232:27	0:0	6	plane_count
forexpr	232:40	232:41	5	i ++
water	232:40	0:0	6	i
op	232:41	0:0	6	++
stmts	232:45	258:8	5	
water	232:45	0:0	6	{
water	233:12	0:0	6	PlaneContext
op	233:25	0:0	6	*
water	233:26	0:0	6	const
water	233:32	0:0	6	p
op	233:34	0:0	6	=
op	233:36	0:0	6	&
water	233:37	0:0	6	fs
op	233:39	0:0	6	->
water	233:41	0:0	6	plane
op	233:46	0:0	6	[
water	233:47	0:0	6	i
op	233:48	0:0	6	]
water	233:49	0:0	6	;
if	235:12	246:12	6	(f -> version == 2)
cond	235:16	235:30	7	f -> version == 2
water	235:16	0:0	8	f
op	235:17	0:0	8	->
water	235:19	0:0	8	version
op	235:27	0:0	8	==
water	235:30	0:0	8	2
stmts	235:33	246:12	7	
water	235:33	0:0	8	{
decl	236:16	236:49	8	int	idx
op	236:24	0:0	8	=
call	236:26	236:48	9	get_symbol
arg	236:37	236:38	10	c
water	236:37	0:0	11	c
arg	236:40	236:45	10	state
water	236:40	0:0	11	state
arg	236:47	236:48	10	0
water	236:47	0:0	11	0
if	237:16	241:16	8	(idx > ( unsigned ) f -> quant_table_count)
cond	237:20	237:39	9	idx > ( unsigned ) f -> quant_table_count
water	237:20	0:0	10	idx
op	237:24	0:0	10	>
water	237:26	0:0	10	(
water	237:27	0:0	10	unsigned
water	237:35	0:0	10	)
water	237:36	0:0	10	f
op	237:37	0:0	10	->
water	237:39	0:0	10	quant_table_count
stmts	237:58	241:16	9	
water	237:58	0:0	10	{
call	238:20	239:61	10	av_log
arg	238:27	238:35	11	f->avctx
water	238:27	0:0	12	f
op	238:28	0:0	12	->
water	238:30	0:0	12	avctx
arg	238:37	238:49	11	AV_LOG_ERROR
water	238:37	0:0	12	AV_LOG_ERROR
arg	239:27	239:61	11	"quant_table_index out of range\n"
water	239:27	0:0	12	"quant_table_index out of range\n"
water	239:62	0:0	10	;
return	240:20	240:46	10	AVERROR_INVALIDDATA
water	240:27	0:0	11	AVERROR_INVALIDDATA
water	241:16	0:0	10	}
water	242:16	0:0	8	p
op	242:17	0:0	8	->
water	242:19	0:0	8	quant_table_index
op	242:37	0:0	8	=
water	242:39	0:0	8	idx
water	242:42	0:0	8	;
call	243:16	244:45	8	memcpy
arg	243:23	243:37	9	p->quant_table
water	243:23	0:0	10	p
op	243:24	0:0	10	->
water	243:26	0:0	10	quant_table
arg	243:39	243:59	9	f->quant_tables[idx]
water	243:39	0:0	10	f
op	243:40	0:0	10	->
water	243:42	0:0	10	quant_tables
op	243:54	0:0	10	[
water	243:55	0:0	10	idx
op	243:58	0:0	10	]
arg	244:23	244:45	9	sizeof(p->quant_table)
op	244:23	0:0	10	sizeof
water	244:29	0:0	10	(
water	244:30	0:0	10	p
op	244:31	0:0	10	->
water	244:33	0:0	10	quant_table
water	244:44	0:0	10	)
water	244:46	0:0	8	;
water	245:16	0:0	8	context_count
op	245:30	0:0	8	=
water	245:32	0:0	8	f
op	245:33	0:0	8	->
water	245:35	0:0	8	context_count
op	245:48	0:0	8	[
water	245:49	0:0	8	idx
op	245:52	0:0	8	]
water	245:53	0:0	8	;
water	246:12	0:0	8	}
else	246:14	248:12	6
stmts	246:19	248:12	7	
water	246:19	0:0	8	{
call	247:16	247:77	8	memcpy
arg	247:23	247:37	9	p->quant_table
water	247:23	0:0	10	p
op	247:24	0:0	10	->
water	247:26	0:0	10	quant_table
arg	247:39	247:53	9	f->quant_table
water	247:39	0:0	10	f
op	247:40	0:0	10	->
water	247:42	0:0	10	quant_table
arg	247:55	247:77	9	sizeof(p->quant_table)
op	247:55	0:0	10	sizeof
water	247:61	0:0	10	(
water	247:62	0:0	10	p
op	247:63	0:0	10	->
water	247:65	0:0	10	quant_table
water	247:76	0:0	10	)
water	247:78	0:0	8	;
water	248:12	0:0	8	}
if	250:12	257:12	6	(f -> version <= 2)
cond	250:16	250:30	7	f -> version <= 2
water	250:16	0:0	8	f
op	250:17	0:0	8	->
water	250:19	0:0	8	version
op	250:27	0:0	8	<=
water	250:30	0:0	8	2
stmts	250:33	257:12	7	
water	250:33	0:0	8	{
call	251:16	251:45	8	av_assert0
arg	251:27	251:45	9	context_count>=0
water	251:27	0:0	10	context_count
op	251:41	0:0	10	>=
water	251:44	0:0	10	0
water	251:46	0:0	8	;
if	252:16	255:16	8	(p -> context_count < context_count)
cond	252:20	252:39	9	p -> context_count < context_count
water	252:20	0:0	10	p
op	252:21	0:0	10	->
water	252:23	0:0	10	context_count
op	252:37	0:0	10	<
water	252:39	0:0	10	context_count
stmts	252:54	255:16	9	
water	252:54	0:0	10	{
call	253:20	253:38	10	av_freep
arg	253:29	253:38	11	&p->state
op	253:29	0:0	12	&
water	253:30	0:0	12	p
op	253:31	0:0	12	->
water	253:33	0:0	12	state
water	253:39	0:0	10	;
call	254:20	254:42	10	av_freep
arg	254:29	254:42	11	&p->vlc_state
op	254:29	0:0	12	&
water	254:30	0:0	12	p
op	254:31	0:0	12	->
water	254:33	0:0	12	vlc_state
water	254:43	0:0	10	;
water	255:16	0:0	10	}
water	256:16	0:0	8	p
op	256:17	0:0	8	->
water	256:19	0:0	8	context_count
op	256:33	0:0	8	=
water	256:35	0:0	8	context_count
water	256:48	0:0	8	;
water	257:12	0:0	8	}
water	258:8	0:0	6	}
water	259:4	0:0	4	}
return	260:4	260:12	2	0
water	260:11	0:0	3	0
