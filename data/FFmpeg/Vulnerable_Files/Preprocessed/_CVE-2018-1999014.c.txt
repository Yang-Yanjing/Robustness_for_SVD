func	1:0	391:0	0	static int	mxf_parse_structural_metadata
params	1:40	0:0	1	
param	1:41	1:56	2	MXFContext *	mxf
stmnts	0:0	390:14	1	
decl	3:4	3:39	2	MXFPackage	*material_package
op	3:33	0:0	2	=
water	3:35	0:0	2	NULL
decl	4:4	4:20	2	int	i
water	4:9	0:0	2	,
decl	4:4	4:20	2	int	j
water	4:12	0:0	2	,
decl	4:4	4:20	2	int	k
water	4:15	0:0	2	,
decl	4:4	4:20	2	int	ret
call	6:4	6:86	2	av_log
arg	6:11	6:18	3	mxf->fc
water	6:11	0:0	4	mxf
op	6:14	0:0	4	->
water	6:16	0:0	4	fc
arg	6:20	6:32	3	AV_LOG_TRACE
water	6:20	0:0	4	AV_LOG_TRACE
arg	6:34	6:60	3	"metadata sets count %d\n"
water	6:34	0:0	4	"metadata sets count %d\n"
arg	6:62	6:86	3	mxf->metadata_sets_count
water	6:62	0:0	4	mxf
op	6:65	0:0	4	->
water	6:67	0:0	4	metadata_sets_count
water	6:87	0:0	2	;
for	8:4	11:4	2	(i = 0 ;i < mxf -> packages_count;i ++)
forinit	8:9	8:14	3	i = 0 ;
water	8:9	0:0	4	i
op	8:11	0:0	4	=
water	8:13	0:0	4	0
water	8:14	0:0	4	;
cond	8:16	8:25	3	i < mxf -> packages_count
water	8:16	0:0	4	i
op	8:18	0:0	4	<
water	8:20	0:0	4	mxf
op	8:23	0:0	4	->
water	8:25	0:0	4	packages_count
forexpr	8:41	8:42	3	i ++
water	8:41	0:0	4	i
op	8:42	0:0	4	++
stmts	8:46	11:4	3	
water	8:46	0:0	4	{
water	9:8	0:0	4	material_package
op	9:25	0:0	4	=
call	9:27	9:94	4	mxf_resolve_strong_ref
arg	9:50	9:53	5	mxf
water	9:50	0:0	6	mxf
arg	9:55	9:77	5	&mxf->packages_refs[i]
op	9:55	0:0	6	&
water	9:56	0:0	6	mxf
op	9:59	0:0	6	->
water	9:61	0:0	6	packages_refs
op	9:74	0:0	6	[
water	9:75	0:0	6	i
op	9:76	0:0	6	]
arg	9:79	9:94	5	MaterialPackage
water	9:79	0:0	6	MaterialPackage
water	9:95	0:0	4	;
if	10:8	10:35	4	(material_package)
cond	10:12	10:12	5	material_package
water	10:12	0:0	6	material_package
stmts	10:30	10:35	5	
break	10:30	10:35	6	
water	11:4	0:0	4	}
if	12:4	15:4	2	(! material_package)
cond	12:8	12:9	3	! material_package
op	12:8	0:0	4	!
water	12:9	0:0	4	material_package
stmts	12:27	15:4	3	
water	12:27	0:0	4	{
call	13:8	13:67	4	av_log
arg	13:15	13:22	5	mxf->fc
water	13:15	0:0	6	mxf
op	13:18	0:0	6	->
water	13:20	0:0	6	fc
arg	13:24	13:36	5	AV_LOG_ERROR
water	13:24	0:0	6	AV_LOG_ERROR
arg	13:38	13:67	5	"no material package found\n"
water	13:38	0:0	6	"no material package found\n"
water	13:68	0:0	4	;
return	14:8	14:34	4	AVERROR_INVALIDDATA
water	14:15	0:0	5	AVERROR_INVALIDDATA
water	15:4	0:0	4	}
call	17:4	17:87	2	mxf_add_umid_metadata
arg	17:26	17:44	3	&mxf->fc->metadata
op	17:26	0:0	4	&
water	17:27	0:0	4	mxf
op	17:30	0:0	4	->
water	17:32	0:0	4	fc
op	17:34	0:0	4	->
water	17:36	0:0	4	metadata
arg	17:46	17:69	3	"material_package_umid"
water	17:46	0:0	4	"material_package_umid"
arg	17:71	17:87	3	material_package
water	17:71	0:0	4	material_package
water	17:88	0:0	2	;
if	18:4	19:91	2	(material_package -> name && material_package -> name [ 0 ])
cond	18:8	18:58	3	material_package -> name && material_package -> name [ 0 ]
water	18:8	0:0	4	material_package
op	18:24	0:0	4	->
water	18:26	0:0	4	name
op	18:31	0:0	4	&&
water	18:34	0:0	4	material_package
op	18:50	0:0	4	->
water	18:52	0:0	4	name
op	18:56	0:0	4	[
water	18:57	0:0	4	0
op	18:58	0:0	4	]
stmts	19:8	19:91	3	
call	19:8	19:90	4	av_dict_set
arg	19:20	19:38	5	&mxf->fc->metadata
op	19:20	0:0	6	&
water	19:21	0:0	6	mxf
op	19:24	0:0	6	->
water	19:26	0:0	6	fc
op	19:28	0:0	6	->
water	19:30	0:0	6	metadata
arg	19:40	19:63	5	"material_package_name"
water	19:40	0:0	6	"material_package_name"
arg	19:65	19:87	5	material_package->name
water	19:65	0:0	6	material_package
op	19:81	0:0	6	->
water	19:83	0:0	6	name
arg	19:89	19:90	5	0
water	19:89	0:0	6	0
water	19:91	0:0	4	;
call	20:4	20:72	2	mxf_parse_package_comments
arg	20:31	20:34	3	mxf
water	20:31	0:0	4	mxf
arg	20:36	20:54	3	&mxf->fc->metadata
op	20:36	0:0	4	&
water	20:37	0:0	4	mxf
op	20:40	0:0	4	->
water	20:42	0:0	4	fc
op	20:44	0:0	4	->
water	20:46	0:0	4	metadata
arg	20:56	20:72	3	material_package
water	20:56	0:0	4	material_package
water	20:73	0:0	2	;
for	22:4	386:4	2	(i = 0 ;i < material_package -> tracks_count;i ++)
forinit	22:9	22:14	3	i = 0 ;
water	22:9	0:0	4	i
op	22:11	0:0	4	=
water	22:13	0:0	4	0
water	22:14	0:0	4	;
cond	22:16	22:38	3	i < material_package -> tracks_count
water	22:16	0:0	4	i
op	22:18	0:0	4	<
water	22:20	0:0	4	material_package
op	22:36	0:0	4	->
water	22:38	0:0	4	tracks_count
forexpr	22:52	22:53	3	i ++
water	22:52	0:0	4	i
op	22:53	0:0	4	++
stmts	22:57	386:4	3	
water	22:57	0:0	4	{
decl	23:8	23:41	4	MXFPackage	*source_package
op	23:35	0:0	4	=
water	23:37	0:0	4	NULL
decl	24:8	24:39	4	MXFTrack	*material_track
op	24:33	0:0	4	=
water	24:35	0:0	4	NULL
decl	25:8	25:37	4	MXFTrack	*source_track
op	25:31	0:0	4	=
water	25:33	0:0	4	NULL
decl	26:8	26:35	4	MXFTrack	*temp_track
op	26:29	0:0	4	=
water	26:31	0:0	4	NULL
decl	27:8	27:40	4	MXFDescriptor	*descriptor
op	27:34	0:0	4	=
water	27:36	0:0	4	NULL
decl	28:8	28:48	4	MXFStructuralComponent	*component
op	28:42	0:0	4	=
water	28:44	0:0	4	NULL
decl	29:8	29:43	4	MXFTimecodeComponent	*mxf_tc
op	29:37	0:0	4	=
water	29:39	0:0	4	NULL
decl	30:8	30:40	4	UID	*essence_container_ul
op	30:34	0:0	4	=
water	30:36	0:0	4	NULL
decl	31:8	31:41	4	const MXFCodecUL	*codec_ul
op	31:35	0:0	4	=
water	31:37	0:0	4	NULL
decl	32:8	32:45	4	const MXFCodecUL	*container_ul
op	32:39	0:0	4	=
water	32:41	0:0	4	NULL
decl	33:8	33:43	4	const MXFCodecUL	*pix_fmt_ul
op	33:37	0:0	4	=
water	33:39	0:0	4	NULL
decl	34:8	34:20	4	AVStream	*st
decl	35:8	35:21	4	AVTimecode	tc
decl	36:8	36:17	4	int	flags
if	38:8	41:8	4	(! ( material_track =mxf_resolve_strong_ref (mxf ,& material_package -> tracks_refs [ i ] ,Track ) ))
cond	38:12	38:100	5	! ( material_track =mxf_resolve_strong_ref (mxf ,& material_package -> tracks_refs [ i ] ,Track ) )
op	38:12	0:0	6	!
water	38:13	0:0	6	(
water	38:14	0:0	6	material_track
op	38:29	0:0	6	=
call	38:31	38:99	6	mxf_resolve_strong_ref
arg	38:54	38:57	7	mxf
water	38:54	0:0	8	mxf
arg	38:59	38:92	7	&material_package->tracks_refs[i]
op	38:59	0:0	8	&
water	38:60	0:0	8	material_package
op	38:76	0:0	8	->
water	38:78	0:0	8	tracks_refs
op	38:89	0:0	8	[
water	38:90	0:0	8	i
op	38:91	0:0	8	]
arg	38:94	38:99	7	Track
water	38:94	0:0	8	Track
water	38:100	0:0	6	)
stmts	38:103	41:8	5	
water	38:103	0:0	6	{
call	39:12	39:89	6	av_log
arg	39:19	39:26	7	mxf->fc
water	39:19	0:0	8	mxf
op	39:22	0:0	8	->
water	39:24	0:0	8	fc
arg	39:28	39:40	7	AV_LOG_ERROR
water	39:28	0:0	8	AV_LOG_ERROR
arg	39:42	39:89	7	"could not resolve material track strong ref\n"
water	39:42	0:0	8	"could not resolve material track strong ref\n"
water	39:90	0:0	6	;
continue	40:12	40:20	6	
water	41:8	0:0	6	}
if	43:8	49:8	4	(( component =mxf_resolve_strong_ref (mxf ,& material_track -> sequence_ref ,TimecodeComponent ) ))
cond	43:12	43:102	5	( component =mxf_resolve_strong_ref (mxf ,& material_track -> sequence_ref ,TimecodeComponent ) )
water	43:12	0:0	6	(
water	43:13	0:0	6	component
op	43:23	0:0	6	=
call	43:25	43:101	6	mxf_resolve_strong_ref
arg	43:48	43:51	7	mxf
water	43:48	0:0	8	mxf
arg	43:53	43:82	7	&material_track->sequence_ref
op	43:53	0:0	8	&
water	43:54	0:0	8	material_track
op	43:68	0:0	8	->
water	43:70	0:0	8	sequence_ref
arg	43:84	43:101	7	TimecodeComponent
water	43:84	0:0	8	TimecodeComponent
water	43:102	0:0	6	)
stmts	43:105	49:8	5	
water	43:105	0:0	6	{
water	44:12	0:0	6	mxf_tc
op	44:19	0:0	6	=
water	44:21	0:0	6	(
water	44:22	0:0	6	MXFTimecodeComponent
op	44:42	0:0	6	*
water	44:43	0:0	6	)
water	44:44	0:0	6	component
water	44:53	0:0	6	;
water	45:12	0:0	6	flags
op	45:18	0:0	6	=
water	45:20	0:0	6	mxf_tc
op	45:26	0:0	6	->
water	45:28	0:0	6	drop_frame
op	45:39	0:0	6	==
water	45:42	0:0	6	1
water	45:44	0:0	6	?
water	45:46	0:0	6	AV_TIMECODE_FLAG_DROPFRAME
water	45:73	0:0	6	:
water	45:75	0:0	6	0
water	45:76	0:0	6	;
if	46:12	48:12	6	(av_timecode_init (& tc ,mxf_tc -> rate ,flags ,mxf_tc -> start_frame ,mxf -> fc ) == 0)
cond	46:16	46:92	7	av_timecode_init (& tc ,mxf_tc -> rate ,flags ,mxf_tc -> start_frame ,mxf -> fc ) == 0
call	46:16	46:87	8	av_timecode_init
arg	46:33	46:36	9	&tc
op	46:33	0:0	10	&
water	46:34	0:0	10	tc
arg	46:38	46:50	9	mxf_tc->rate
water	46:38	0:0	10	mxf_tc
op	46:44	0:0	10	->
water	46:46	0:0	10	rate
arg	46:52	46:57	9	flags
water	46:52	0:0	10	flags
arg	46:59	46:78	9	mxf_tc->start_frame
water	46:59	0:0	10	mxf_tc
op	46:65	0:0	10	->
water	46:67	0:0	10	start_frame
arg	46:80	46:87	9	mxf->fc
water	46:80	0:0	10	mxf
op	46:83	0:0	10	->
water	46:85	0:0	10	fc
op	46:89	0:0	8	==
water	46:92	0:0	8	0
stmts	46:95	48:12	7	
water	46:95	0:0	8	{
call	47:16	47:77	8	mxf_add_timecode_metadata
arg	47:42	47:60	9	&mxf->fc->metadata
op	47:42	0:0	10	&
water	47:43	0:0	10	mxf
op	47:46	0:0	10	->
water	47:48	0:0	10	fc
op	47:50	0:0	10	->
water	47:52	0:0	10	metadata
arg	47:62	47:72	9	"timecode"
water	47:62	0:0	10	"timecode"
arg	47:74	47:77	9	&tc
op	47:74	0:0	10	&
water	47:75	0:0	10	tc
water	47:78	0:0	8	;
water	48:12	0:0	8	}
water	49:8	0:0	6	}
if	51:8	54:8	4	(! ( material_track -> sequence =mxf_resolve_strong_ref (mxf ,& material_track -> sequence_ref ,Sequence ) ))
cond	51:12	51:109	5	! ( material_track -> sequence =mxf_resolve_strong_ref (mxf ,& material_track -> sequence_ref ,Sequence ) )
op	51:12	0:0	6	!
water	51:13	0:0	6	(
water	51:14	0:0	6	material_track
op	51:28	0:0	6	->
water	51:30	0:0	6	sequence
op	51:39	0:0	6	=
call	51:41	51:108	6	mxf_resolve_strong_ref
arg	51:64	51:67	7	mxf
water	51:64	0:0	8	mxf
arg	51:69	51:98	7	&material_track->sequence_ref
op	51:69	0:0	8	&
water	51:70	0:0	8	material_track
op	51:84	0:0	8	->
water	51:86	0:0	8	sequence_ref
arg	51:100	51:108	7	Sequence
water	51:100	0:0	8	Sequence
water	51:109	0:0	6	)
stmts	51:112	54:8	5	
water	51:112	0:0	6	{
call	52:12	52:98	6	av_log
arg	52:19	52:26	7	mxf->fc
water	52:19	0:0	8	mxf
op	52:22	0:0	8	->
water	52:24	0:0	8	fc
arg	52:28	52:40	7	AV_LOG_ERROR
water	52:28	0:0	8	AV_LOG_ERROR
arg	52:42	52:98	7	"could not resolve material track sequence strong ref\n"
water	52:42	0:0	8	"could not resolve material track sequence strong ref\n"
water	52:99	0:0	6	;
continue	53:12	53:20	6	
water	54:8	0:0	6	}
for	56:8	67:8	4	(j = 0 ;j < material_track -> sequence -> structural_components_count;j ++)
forinit	56:13	56:18	5	j = 0 ;
water	56:13	0:0	6	j
op	56:15	0:0	6	=
water	56:17	0:0	6	0
water	56:18	0:0	6	;
cond	56:20	56:50	5	j < material_track -> sequence -> structural_components_count
water	56:20	0:0	6	j
op	56:22	0:0	6	<
water	56:24	0:0	6	material_track
op	56:38	0:0	6	->
water	56:40	0:0	6	sequence
op	56:48	0:0	6	->
water	56:50	0:0	6	structural_components_count
forexpr	56:79	56:80	5	j ++
water	56:79	0:0	6	j
op	56:80	0:0	6	++
stmts	56:84	67:8	5	
water	56:84	0:0	6	{
water	57:12	0:0	6	component
op	57:22	0:0	6	=
call	57:24	57:127	6	mxf_resolve_strong_ref
arg	57:47	57:50	7	mxf
water	57:47	0:0	8	mxf
arg	57:52	57:108	7	&material_track->sequence->structural_components_refs[j]
op	57:52	0:0	8	&
water	57:53	0:0	8	material_track
op	57:67	0:0	8	->
water	57:69	0:0	8	sequence
op	57:77	0:0	8	->
water	57:79	0:0	8	structural_components_refs
op	57:105	0:0	8	[
water	57:106	0:0	8	j
op	57:107	0:0	8	]
arg	57:110	57:127	7	TimecodeComponent
water	57:110	0:0	8	TimecodeComponent
water	57:128	0:0	6	;
if	58:12	59:24	6	(! component)
cond	58:16	58:17	7	! component
op	58:16	0:0	8	!
water	58:17	0:0	8	component
stmts	59:16	59:24	7	
continue	59:16	59:24	8	
water	61:12	0:0	6	mxf_tc
op	61:19	0:0	6	=
water	61:21	0:0	6	(
water	61:22	0:0	6	MXFTimecodeComponent
op	61:42	0:0	6	*
water	61:43	0:0	6	)
water	61:44	0:0	6	component
water	61:53	0:0	6	;
water	62:12	0:0	6	flags
op	62:18	0:0	6	=
water	62:20	0:0	6	mxf_tc
op	62:26	0:0	6	->
water	62:28	0:0	6	drop_frame
op	62:39	0:0	6	==
water	62:42	0:0	6	1
water	62:44	0:0	6	?
water	62:46	0:0	6	AV_TIMECODE_FLAG_DROPFRAME
water	62:73	0:0	6	:
water	62:75	0:0	6	0
water	62:76	0:0	6	;
if	63:12	66:12	6	(av_timecode_init (& tc ,mxf_tc -> rate ,flags ,mxf_tc -> start_frame ,mxf -> fc ) == 0)
cond	63:16	63:92	7	av_timecode_init (& tc ,mxf_tc -> rate ,flags ,mxf_tc -> start_frame ,mxf -> fc ) == 0
call	63:16	63:87	8	av_timecode_init
arg	63:33	63:36	9	&tc
op	63:33	0:0	10	&
water	63:34	0:0	10	tc
arg	63:38	63:50	9	mxf_tc->rate
water	63:38	0:0	10	mxf_tc
op	63:44	0:0	10	->
water	63:46	0:0	10	rate
arg	63:52	63:57	9	flags
water	63:52	0:0	10	flags
arg	63:59	63:78	9	mxf_tc->start_frame
water	63:59	0:0	10	mxf_tc
op	63:65	0:0	10	->
water	63:67	0:0	10	start_frame
arg	63:80	63:87	9	mxf->fc
water	63:80	0:0	10	mxf
op	63:83	0:0	10	->
water	63:85	0:0	10	fc
op	63:89	0:0	8	==
water	63:92	0:0	8	0
stmts	63:95	66:12	7	
water	63:95	0:0	8	{
call	64:16	64:77	8	mxf_add_timecode_metadata
arg	64:42	64:60	9	&mxf->fc->metadata
op	64:42	0:0	10	&
water	64:43	0:0	10	mxf
op	64:46	0:0	10	->
water	64:48	0:0	10	fc
op	64:50	0:0	10	->
water	64:52	0:0	10	metadata
arg	64:62	64:72	9	"timecode"
water	64:62	0:0	10	"timecode"
arg	64:74	64:77	9	&tc
op	64:74	0:0	10	&
water	64:75	0:0	10	tc
water	64:78	0:0	8	;
break	65:16	65:21	8	
water	66:12	0:0	8	}
water	67:8	0:0	6	}
if	70:8	72:103	4	(material_track -> sequence -> structural_components_count > 1)
cond	70:11	70:67	5	material_track -> sequence -> structural_components_count > 1
water	70:11	0:0	6	material_track
op	70:25	0:0	6	->
water	70:27	0:0	6	sequence
op	70:35	0:0	6	->
water	70:37	0:0	6	structural_components_count
op	70:65	0:0	6	>
water	70:67	0:0	6	1
stmts	71:12	72:103	5	
call	71:12	72:102	6	av_log
arg	71:19	71:26	7	mxf->fc
water	71:19	0:0	8	mxf
op	71:22	0:0	8	->
water	71:24	0:0	8	fc
arg	71:28	71:42	7	AV_LOG_WARNING
water	71:28	0:0	8	AV_LOG_WARNING
arg	71:44	71:84	7	"material track %d: has %d components\n"
water	71:44	0:0	8	"material track %d: has %d components\n"
arg	72:23	72:47	7	material_track->track_id
water	72:23	0:0	8	material_track
op	72:37	0:0	8	->
water	72:39	0:0	8	track_id
arg	72:49	72:102	7	material_track->sequence->structural_components_count
water	72:49	0:0	8	material_track
op	72:63	0:0	8	->
water	72:65	0:0	8	sequence
op	72:73	0:0	8	->
water	72:75	0:0	8	structural_components_count
water	72:103	0:0	6	;
for	74:8	116:8	4	(j = 0 ;j < material_track -> sequence -> structural_components_count;j ++)
forinit	74:13	74:18	5	j = 0 ;
water	74:13	0:0	6	j
op	74:15	0:0	6	=
water	74:17	0:0	6	0
water	74:18	0:0	6	;
cond	74:20	74:50	5	j < material_track -> sequence -> structural_components_count
water	74:20	0:0	6	j
op	74:22	0:0	6	<
water	74:24	0:0	6	material_track
op	74:38	0:0	6	->
water	74:40	0:0	6	sequence
op	74:48	0:0	6	->
water	74:50	0:0	6	structural_components_count
forexpr	74:79	74:80	5	j ++
water	74:79	0:0	6	j
op	74:80	0:0	6	++
stmts	74:84	116:8	5	
water	74:84	0:0	6	{
water	75:12	0:0	6	component
op	75:22	0:0	6	=
call	75:24	75:108	6	mxf_resolve_sourceclip
arg	75:47	75:50	7	mxf
water	75:47	0:0	8	mxf
arg	75:52	75:108	7	&material_track->sequence->structural_components_refs[j]
op	75:52	0:0	8	&
water	75:53	0:0	8	material_track
op	75:67	0:0	8	->
water	75:69	0:0	8	sequence
op	75:77	0:0	8	->
water	75:79	0:0	8	structural_components_refs
op	75:105	0:0	8	[
water	75:106	0:0	8	j
op	75:107	0:0	8	]
water	75:109	0:0	6	;
if	76:12	77:24	6	(! component)
cond	76:16	76:17	7	! component
op	76:16	0:0	8	!
water	76:17	0:0	8	component
stmts	77:16	77:24	7	
continue	77:16	77:24	8	
water	79:12	0:0	6	source_package
op	79:27	0:0	6	=
call	79:29	79:120	6	mxf_resolve_source_package
arg	79:56	79:59	7	mxf
water	79:56	0:0	8	mxf
arg	79:61	79:89	7	component->source_package_ul
water	79:61	0:0	8	component
op	79:70	0:0	8	->
water	79:72	0:0	8	source_package_ul
arg	79:91	79:120	7	component->source_package_uid
water	79:91	0:0	8	component
op	79:100	0:0	8	->
water	79:102	0:0	8	source_package_uid
water	79:121	0:0	6	;
if	80:12	83:12	6	(! source_package)
cond	80:16	80:17	7	! source_package
op	80:16	0:0	8	!
water	80:17	0:0	8	source_package
stmts	80:33	83:12	7	
water	80:33	0:0	8	{
call	81:16	81:132	8	av_log
arg	81:23	81:30	9	mxf->fc
water	81:23	0:0	10	mxf
op	81:26	0:0	10	->
water	81:28	0:0	10	fc
arg	81:32	81:44	9	AV_LOG_TRACE
water	81:32	0:0	10	AV_LOG_TRACE
arg	81:46	81:106	9	"material track %d: no corresponding source package found\n"
water	81:46	0:0	10	"material track %d: no corresponding source package found\n"
arg	81:108	81:132	9	material_track->track_id
water	81:108	0:0	10	material_track
op	81:122	0:0	10	->
water	81:124	0:0	10	track_id
water	81:133	0:0	8	;
continue	82:16	82:24	8	
water	83:12	0:0	8	}
for	84:12	94:12	6	(k = 0 ;k < source_package -> tracks_count;k ++)
forinit	84:17	84:22	7	k = 0 ;
water	84:17	0:0	8	k
op	84:19	0:0	8	=
water	84:21	0:0	8	0
water	84:22	0:0	8	;
cond	84:24	84:44	7	k < source_package -> tracks_count
water	84:24	0:0	8	k
op	84:26	0:0	8	<
water	84:28	0:0	8	source_package
op	84:42	0:0	8	->
water	84:44	0:0	8	tracks_count
forexpr	84:58	84:59	7	k ++
water	84:58	0:0	8	k
op	84:59	0:0	8	++
stmts	84:63	94:12	7	
water	84:63	0:0	8	{
if	85:16	89:16	8	(! ( temp_track =mxf_resolve_strong_ref (mxf ,& source_package -> tracks_refs [ k ] ,Track ) ))
cond	85:20	85:102	9	! ( temp_track =mxf_resolve_strong_ref (mxf ,& source_package -> tracks_refs [ k ] ,Track ) )
op	85:20	0:0	10	!
water	85:21	0:0	10	(
water	85:22	0:0	10	temp_track
op	85:33	0:0	10	=
call	85:35	85:101	10	mxf_resolve_strong_ref
arg	85:58	85:61	11	mxf
water	85:58	0:0	12	mxf
arg	85:63	85:94	11	&source_package->tracks_refs[k]
op	85:63	0:0	12	&
water	85:64	0:0	12	source_package
op	85:78	0:0	12	->
water	85:80	0:0	12	tracks_refs
op	85:91	0:0	12	[
water	85:92	0:0	12	k
op	85:93	0:0	12	]
arg	85:96	85:101	11	Track
water	85:96	0:0	12	Track
water	85:102	0:0	10	)
stmts	85:105	89:16	9	
water	85:105	0:0	10	{
call	86:20	86:95	10	av_log
arg	86:27	86:34	11	mxf->fc
water	86:27	0:0	12	mxf
op	86:30	0:0	12	->
water	86:32	0:0	12	fc
arg	86:36	86:48	11	AV_LOG_ERROR
water	86:36	0:0	12	AV_LOG_ERROR
arg	86:50	86:95	11	"could not resolve source track strong ref\n"
water	86:50	0:0	12	"could not resolve source track strong ref\n"
water	86:96	0:0	10	;
water	87:20	0:0	10	ret
op	87:24	0:0	10	=
water	87:26	0:0	10	AVERROR_INVALIDDATA
water	87:45	0:0	10	;
goto	88:20	88:38	10	fail_and_free
water	88:25	0:0	11	fail_and_free
water	89:16	0:0	10	}
if	90:16	93:16	8	(temp_track -> track_id == component -> source_track_id)
cond	90:20	90:55	9	temp_track -> track_id == component -> source_track_id
water	90:20	0:0	10	temp_track
op	90:30	0:0	10	->
water	90:32	0:0	10	track_id
op	90:41	0:0	10	==
water	90:44	0:0	10	component
op	90:53	0:0	10	->
water	90:55	0:0	10	source_track_id
stmts	90:72	93:16	9	
water	90:72	0:0	10	{
water	91:20	0:0	10	source_track
op	91:33	0:0	10	=
water	91:35	0:0	10	temp_track
water	91:45	0:0	10	;
break	92:20	92:25	10	
water	93:16	0:0	10	}
water	94:12	0:0	8	}
if	95:12	98:12	6	(! source_track)
cond	95:16	95:17	7	! source_track
op	95:16	0:0	8	!
water	95:17	0:0	8	source_track
stmts	95:31	98:12	7	
water	95:31	0:0	8	{
call	96:16	96:130	8	av_log
arg	96:23	96:30	9	mxf->fc
water	96:23	0:0	10	mxf
op	96:26	0:0	10	->
water	96:28	0:0	10	fc
arg	96:32	96:44	9	AV_LOG_ERROR
water	96:32	0:0	10	AV_LOG_ERROR
arg	96:46	96:104	9	"material track %d: no corresponding source track found\n"
water	96:46	0:0	10	"material track %d: no corresponding source track found\n"
arg	96:106	96:130	9	material_track->track_id
water	96:106	0:0	10	material_track
op	96:120	0:0	10	->
water	96:122	0:0	10	track_id
water	96:131	0:0	8	;
break	97:16	97:21	8	
water	98:12	0:0	8	}
for	100:12	112:12	6	(k = 0 ;k < mxf -> essence_container_data_count;k ++)
forinit	100:17	100:22	7	k = 0 ;
water	100:17	0:0	8	k
op	100:19	0:0	8	=
water	100:21	0:0	8	0
water	100:22	0:0	8	;
cond	100:24	100:33	7	k < mxf -> essence_container_data_count
water	100:24	0:0	8	k
op	100:26	0:0	8	<
water	100:28	0:0	8	mxf
op	100:31	0:0	8	->
water	100:33	0:0	8	essence_container_data_count
forexpr	100:63	100:64	7	k ++
water	100:63	0:0	8	k
op	100:64	0:0	8	++
stmts	100:68	112:12	7	
water	100:68	0:0	8	{
decl	101:16	101:53	8	MXFEssenceContainerData	*essence_data
if	103:16	106:16	8	(! ( essence_data =mxf_resolve_strong_ref (mxf ,& mxf -> essence_container_data_refs [ k ] ,EssenceContainerData ) ))
cond	103:20	103:124	9	! ( essence_data =mxf_resolve_strong_ref (mxf ,& mxf -> essence_container_data_refs [ k ] ,EssenceContainerData ) )
op	103:20	0:0	10	!
water	103:21	0:0	10	(
water	103:22	0:0	10	essence_data
op	103:35	0:0	10	=
call	103:37	103:123	10	mxf_resolve_strong_ref
arg	103:60	103:63	11	mxf
water	103:60	0:0	12	mxf
arg	103:65	103:101	11	&mxf->essence_container_data_refs[k]
op	103:65	0:0	12	&
water	103:66	0:0	12	mxf
op	103:69	0:0	12	->
water	103:71	0:0	12	essence_container_data_refs
op	103:98	0:0	12	[
water	103:99	0:0	12	k
op	103:100	0:0	12	]
arg	103:103	103:123	11	EssenceContainerData
water	103:103	0:0	12	EssenceContainerData
water	103:124	0:0	10	)
stmts	103:127	106:16	9	
water	103:127	0:0	10	{
call	104:20	104:101	10	av_log
arg	104:27	104:30	11	mxf
water	104:27	0:0	12	mxf
arg	104:32	104:44	11	AV_LOG_TRACE
water	104:32	0:0	12	AV_LOG_TRACE
arg	104:46	104:101	11	"could not resolve essence container data strong ref\n"
water	104:46	0:0	12	"could not resolve essence container data strong ref\n"
water	104:102	0:0	10	;
continue	105:20	105:28	10	
water	106:16	0:0	10	}
if	107:16	111:16	8	(!memcmp (component -> source_package_ul ,essence_data -> package_ul ,sizeof ( UID ) ) && !memcmp (component -> source_package_uid ,essence_data -> package_uid ,sizeof ( UID ) ))
cond	107:20	107:177	9	!memcmp (component -> source_package_ul ,essence_data -> package_ul ,sizeof ( UID ) ) && !memcmp (component -> source_package_uid ,essence_data -> package_uid ,sizeof ( UID ) )
op	107:20	0:0	10	!
call	107:21	107:95	10	memcmp
arg	107:28	107:56	11	component->source_package_ul
water	107:28	0:0	12	component
op	107:37	0:0	12	->
water	107:39	0:0	12	source_package_ul
arg	107:58	107:82	11	essence_data->package_ul
water	107:58	0:0	12	essence_data
op	107:70	0:0	12	->
water	107:72	0:0	12	package_ul
arg	107:84	107:95	11	sizeof(UID)
op	107:84	0:0	12	sizeof
water	107:90	0:0	12	(
water	107:91	0:0	12	UID
water	107:94	0:0	12	)
op	107:97	0:0	10	&&
op	107:100	0:0	10	!
call	107:101	107:177	10	memcmp
arg	107:108	107:137	11	component->source_package_uid
water	107:108	0:0	12	component
op	107:117	0:0	12	->
water	107:119	0:0	12	source_package_uid
arg	107:139	107:164	11	essence_data->package_uid
water	107:139	0:0	12	essence_data
op	107:151	0:0	12	->
water	107:153	0:0	12	package_uid
arg	107:166	107:177	11	sizeof(UID)
op	107:166	0:0	12	sizeof
water	107:172	0:0	12	(
water	107:173	0:0	12	UID
water	107:176	0:0	12	)
stmts	107:180	111:16	9	
water	107:180	0:0	10	{
water	108:20	0:0	10	source_track
op	108:32	0:0	10	->
water	108:34	0:0	10	body_sid
op	108:43	0:0	10	=
water	108:45	0:0	10	essence_data
op	108:57	0:0	10	->
water	108:59	0:0	10	body_sid
water	108:67	0:0	10	;
water	109:20	0:0	10	source_track
op	109:32	0:0	10	->
water	109:34	0:0	10	index_sid
op	109:44	0:0	10	=
water	109:46	0:0	10	essence_data
op	109:58	0:0	10	->
water	109:60	0:0	10	index_sid
water	109:69	0:0	10	;
break	110:20	110:25	10	
water	111:16	0:0	10	}
water	112:12	0:0	8	}
if	114:12	115:21	6	(source_track && component)
cond	114:15	114:31	7	source_track && component
water	114:15	0:0	8	source_track
op	114:28	0:0	8	&&
water	114:31	0:0	8	component
stmts	115:16	115:21	7	
break	115:16	115:21	8	
water	116:8	0:0	6	}
if	117:8	121:8	4	(! source_track || ! component || ! source_package)
cond	117:12	117:44	5	! source_track || ! component || ! source_package
op	117:12	0:0	6	!
water	117:13	0:0	6	source_track
op	117:26	0:0	6	||
op	117:29	0:0	6	!
water	117:30	0:0	6	component
op	117:40	0:0	6	||
op	117:43	0:0	6	!
water	117:44	0:0	6	source_package
stmts	117:60	121:8	5	
water	117:60	0:0	6	{
if	118:12	119:34	6	(( ret =mxf_add_metadata_stream (mxf ,material_track ) ))
cond	118:15	118:66	7	( ret =mxf_add_metadata_stream (mxf ,material_track ) )
water	118:15	0:0	8	(
water	118:16	0:0	8	ret
op	118:20	0:0	8	=
call	118:22	118:65	8	mxf_add_metadata_stream
arg	118:46	118:49	9	mxf
water	118:46	0:0	10	mxf
arg	118:51	118:65	9	material_track
water	118:51	0:0	10	material_track
water	118:66	0:0	8	)
stmts	119:16	119:34	7	
goto	119:16	119:34	8	fail_and_free
water	119:21	0:0	9	fail_and_free
continue	120:12	120:20	6	
water	121:8	0:0	6	}
if	123:8	127:8	4	(! ( source_track -> sequence =mxf_resolve_strong_ref (mxf ,& source_track -> sequence_ref ,Sequence ) ))
cond	123:12	123:105	5	! ( source_track -> sequence =mxf_resolve_strong_ref (mxf ,& source_track -> sequence_ref ,Sequence ) )
op	123:12	0:0	6	!
water	123:13	0:0	6	(
water	123:14	0:0	6	source_track
op	123:26	0:0	6	->
water	123:28	0:0	6	sequence
op	123:37	0:0	6	=
call	123:39	123:104	6	mxf_resolve_strong_ref
arg	123:62	123:65	7	mxf
water	123:62	0:0	8	mxf
arg	123:67	123:94	7	&source_track->sequence_ref
op	123:67	0:0	8	&
water	123:68	0:0	8	source_track
op	123:80	0:0	8	->
water	123:82	0:0	8	sequence_ref
arg	123:96	123:104	7	Sequence
water	123:96	0:0	8	Sequence
water	123:105	0:0	6	)
stmts	123:108	127:8	5	
water	123:108	0:0	6	{
call	124:12	124:96	6	av_log
arg	124:19	124:26	7	mxf->fc
water	124:19	0:0	8	mxf
op	124:22	0:0	8	->
water	124:24	0:0	8	fc
arg	124:28	124:40	7	AV_LOG_ERROR
water	124:28	0:0	8	AV_LOG_ERROR
arg	124:42	124:96	7	"could not resolve source track sequence strong ref\n"
water	124:42	0:0	8	"could not resolve source track sequence strong ref\n"
water	124:97	0:0	6	;
water	125:12	0:0	6	ret
op	125:16	0:0	6	=
water	125:18	0:0	6	AVERROR_INVALIDDATA
water	125:37	0:0	6	;
goto	126:12	126:30	6	fail_and_free
water	126:17	0:0	7	fail_and_free
water	127:8	0:0	6	}
if	131:8	134:8	4	(memcmp (material_track -> sequence -> data_definition_ul ,source_track -> sequence -> data_definition_ul ,16 ))
cond	131:12	131:111	5	memcmp (material_track -> sequence -> data_definition_ul ,source_track -> sequence -> data_definition_ul ,16 )
call	131:12	131:111	6	memcmp
arg	131:19	131:63	7	material_track->sequence->data_definition_ul
water	131:19	0:0	8	material_track
op	131:33	0:0	8	->
water	131:35	0:0	8	sequence
op	131:43	0:0	8	->
water	131:45	0:0	8	data_definition_ul
arg	131:65	131:107	7	source_track->sequence->data_definition_ul
water	131:65	0:0	8	source_track
op	131:77	0:0	8	->
water	131:79	0:0	8	sequence
op	131:87	0:0	8	->
water	131:89	0:0	8	data_definition_ul
arg	131:109	131:111	7	16
water	131:109	0:0	8	16
stmts	131:114	134:8	5	
water	131:114	0:0	6	{
call	132:12	132:114	6	av_log
arg	132:19	132:26	7	mxf->fc
water	132:19	0:0	8	mxf
op	132:22	0:0	8	->
water	132:24	0:0	8	fc
arg	132:28	132:40	7	AV_LOG_ERROR
water	132:28	0:0	8	AV_LOG_ERROR
arg	132:42	132:88	7	"material track %d: DataDefinition mismatch\n"
water	132:42	0:0	8	"material track %d: DataDefinition mismatch\n"
arg	132:90	132:114	7	material_track->track_id
water	132:90	0:0	8	material_track
op	132:104	0:0	8	->
water	132:106	0:0	8	track_id
water	132:115	0:0	6	;
continue	133:12	133:20	6	
water	134:8	0:0	6	}
water	136:8	0:0	4	st
op	136:11	0:0	4	=
call	136:13	136:46	4	avformat_new_stream
arg	136:33	136:40	5	mxf->fc
water	136:33	0:0	6	mxf
op	136:36	0:0	6	->
water	136:38	0:0	6	fc
arg	136:42	136:46	5	NULL
water	136:42	0:0	6	NULL
water	136:47	0:0	4	;
if	137:8	141:8	4	(! st)
cond	137:12	137:13	5	! st
op	137:12	0:0	6	!
water	137:13	0:0	6	st
stmts	137:17	141:8	5	
water	137:17	0:0	6	{
call	138:12	138:71	6	av_log
arg	138:19	138:26	7	mxf->fc
water	138:19	0:0	8	mxf
op	138:22	0:0	8	->
water	138:24	0:0	8	fc
arg	138:28	138:40	7	AV_LOG_ERROR
water	138:28	0:0	8	AV_LOG_ERROR
arg	138:42	138:71	7	"could not allocate stream\n"
water	138:42	0:0	8	"could not allocate stream\n"
water	138:72	0:0	6	;
water	139:12	0:0	6	ret
op	139:16	0:0	6	=
call	139:18	139:32	6	AVERROR
arg	139:26	139:32	7	ENOMEM
water	139:26	0:0	8	ENOMEM
water	139:33	0:0	6	;
goto	140:12	140:30	6	fail_and_free
water	140:17	0:0	7	fail_and_free
water	141:8	0:0	6	}
water	142:8	0:0	4	st
op	142:10	0:0	4	->
water	142:12	0:0	4	id
op	142:15	0:0	4	=
water	142:17	0:0	4	material_track
op	142:31	0:0	4	->
water	142:33	0:0	4	track_id
water	142:41	0:0	4	;
water	143:8	0:0	4	st
op	143:10	0:0	4	->
water	143:12	0:0	4	priv_data
op	143:22	0:0	4	=
water	143:24	0:0	4	source_track
water	143:36	0:0	4	;
water	145:8	0:0	4	source_package
op	145:22	0:0	4	->
water	145:24	0:0	4	descriptor
op	145:35	0:0	4	=
call	145:37	145:105	4	mxf_resolve_strong_ref
arg	145:60	145:63	5	mxf
water	145:60	0:0	6	mxf
arg	145:65	145:96	5	&source_package->descriptor_ref
op	145:65	0:0	6	&
water	145:66	0:0	6	source_package
op	145:80	0:0	6	->
water	145:82	0:0	6	descriptor_ref
arg	145:98	145:105	5	AnyType
water	145:98	0:0	6	AnyType
water	145:106	0:0	4	;
water	146:8	0:0	4	descriptor
op	146:19	0:0	4	=
call	146:21	146:104	4	mxf_resolve_multidescriptor
arg	146:49	146:52	5	mxf
water	146:49	0:0	6	mxf
arg	146:54	146:80	5	source_package->descriptor
water	146:54	0:0	6	source_package
op	146:68	0:0	6	->
water	146:70	0:0	6	descriptor
arg	146:82	146:104	5	source_track->track_id
water	146:82	0:0	6	source_track
op	146:94	0:0	6	->
water	146:96	0:0	6	track_id
water	146:105	0:0	4	;
if	150:8	151:109	4	(descriptor && descriptor -> duration != AV_NOPTS_VALUE)
cond	150:12	150:50	5	descriptor && descriptor -> duration != AV_NOPTS_VALUE
water	150:12	0:0	6	descriptor
op	150:23	0:0	6	&&
water	150:26	0:0	6	descriptor
op	150:36	0:0	6	->
water	150:38	0:0	6	duration
op	150:47	0:0	6	!=
water	150:50	0:0	6	AV_NOPTS_VALUE
stmts	151:12	151:109	5	
water	151:12	0:0	6	source_track
op	151:24	0:0	6	->
water	151:26	0:0	6	original_duration
op	151:44	0:0	6	=
water	151:46	0:0	6	st
op	151:48	0:0	6	->
water	151:50	0:0	6	duration
op	151:59	0:0	6	=
call	151:61	151:108	6	FFMIN
arg	151:67	151:87	7	descriptor->duration
water	151:67	0:0	8	descriptor
op	151:77	0:0	8	->
water	151:79	0:0	8	duration
arg	151:89	151:108	7	component->duration
water	151:89	0:0	8	component
op	151:98	0:0	8	->
water	151:100	0:0	8	duration
water	151:109	0:0	6	;
else	152:8	153:80	4
stmts	153:12	153:80	5	
water	153:12	0:0	6	source_track
op	153:24	0:0	6	->
water	153:26	0:0	6	original_duration
op	153:44	0:0	6	=
water	153:46	0:0	6	st
op	153:48	0:0	6	->
water	153:50	0:0	6	duration
op	153:59	0:0	6	=
water	153:61	0:0	6	component
op	153:70	0:0	6	->
water	153:72	0:0	6	duration
water	153:80	0:0	6	;
if	155:8	156:41	4	(st -> duration == - 1)
cond	155:12	155:29	5	st -> duration == - 1
water	155:12	0:0	6	st
op	155:14	0:0	6	->
water	155:16	0:0	6	duration
op	155:25	0:0	6	==
op	155:28	0:0	6	-
water	155:29	0:0	6	1
stmts	156:12	156:41	5	
water	156:12	0:0	6	st
op	156:14	0:0	6	->
water	156:16	0:0	6	duration
op	156:25	0:0	6	=
water	156:27	0:0	6	AV_NOPTS_VALUE
water	156:41	0:0	6	;
water	157:8	0:0	4	st
op	157:10	0:0	4	->
water	157:12	0:0	4	start_time
op	157:23	0:0	4	=
water	157:25	0:0	4	component
op	157:34	0:0	4	->
water	157:36	0:0	4	start_position
water	157:50	0:0	4	;
if	158:8	166:8	4	(material_track -> edit_rate . num <= 0 || material_track -> edit_rate . den <= 0)
cond	158:12	159:45	5	material_track -> edit_rate . num <= 0 || material_track -> edit_rate . den <= 0
water	158:12	0:0	6	material_track
op	158:26	0:0	6	->
water	158:28	0:0	6	edit_rate
op	158:37	0:0	6	.
water	158:38	0:0	6	num
op	158:42	0:0	6	<=
water	158:45	0:0	6	0
op	158:47	0:0	6	||
water	159:12	0:0	6	material_track
op	159:26	0:0	6	->
water	159:28	0:0	6	edit_rate
op	159:37	0:0	6	.
water	159:38	0:0	6	den
op	159:42	0:0	6	<=
water	159:45	0:0	6	0
stmts	159:48	166:8	5	
water	159:48	0:0	6	{
call	160:12	164:59	6	av_log
arg	160:19	160:26	7	mxf->fc
water	160:19	0:0	8	mxf
op	160:22	0:0	8	->
water	160:24	0:0	8	fc
arg	160:28	160:42	7	AV_LOG_WARNING
water	160:28	0:0	8	AV_LOG_WARNING
arg	161:19	162:41	7	"Invalid edit rate (%d/%d) found on stream #%d, ""defaulting to 25/1\n"
water	161:19	0:0	8	"Invalid edit rate (%d/%d) found on stream #%d, "
water	162:19	0:0	8	"defaulting to 25/1\n"
arg	163:19	163:48	7	material_track->edit_rate.num
water	163:19	0:0	8	material_track
op	163:33	0:0	8	->
water	163:35	0:0	8	edit_rate
op	163:44	0:0	8	.
water	163:45	0:0	8	num
arg	164:19	164:48	7	material_track->edit_rate.den
water	164:19	0:0	8	material_track
op	164:33	0:0	8	->
water	164:35	0:0	8	edit_rate
op	164:44	0:0	8	.
water	164:45	0:0	8	den
arg	164:50	164:59	7	st->index
water	164:50	0:0	8	st
op	164:52	0:0	8	->
water	164:54	0:0	8	index
water	164:60	0:0	6	;
water	165:12	0:0	6	material_track
op	165:26	0:0	6	->
water	165:28	0:0	6	edit_rate
op	165:38	0:0	6	=
water	165:40	0:0	6	(
water	165:41	0:0	6	AVRational
water	165:51	0:0	6	)
water	165:52	0:0	6	{
water	165:53	0:0	6	25
water	165:55	0:0	6	,
water	165:57	0:0	6	1
water	165:58	0:0	6	}
water	165:59	0:0	6	;
water	166:8	0:0	6	}
call	167:8	167:96	4	avpriv_set_pts_info
arg	167:28	167:30	5	st
water	167:28	0:0	6	st
arg	167:32	167:34	5	64
water	167:32	0:0	6	64
arg	167:36	167:65	5	material_track->edit_rate.den
water	167:36	0:0	6	material_track
op	167:50	0:0	6	->
water	167:52	0:0	6	edit_rate
op	167:61	0:0	6	.
water	167:62	0:0	6	den
arg	167:67	167:96	5	material_track->edit_rate.num
water	167:67	0:0	6	material_track
op	167:81	0:0	6	->
water	167:83	0:0	6	edit_rate
op	167:92	0:0	6	.
water	167:93	0:0	6	num
water	167:97	0:0	4	;
water	171:8	0:0	4	source_track
op	171:20	0:0	4	->
water	171:22	0:0	4	edit_rate
op	171:32	0:0	4	=
water	171:34	0:0	4	material_track
op	171:48	0:0	4	->
water	171:50	0:0	4	edit_rate
water	171:59	0:0	4	;
call	173:8	173:93	4	PRINT_KEY
arg	173:18	173:25	5	mxf->fc
water	173:18	0:0	6	mxf
op	173:21	0:0	6	->
water	173:23	0:0	6	fc
arg	173:27	173:49	5	"data definition   ul"
water	173:27	0:0	6	"data definition   ul"
arg	173:51	173:93	5	source_track->sequence->data_definition_ul
water	173:51	0:0	6	source_track
op	173:63	0:0	6	->
water	173:65	0:0	6	sequence
op	173:73	0:0	6	->
water	173:75	0:0	6	data_definition_ul
water	173:94	0:0	4	;
water	174:8	0:0	4	codec_ul
op	174:17	0:0	4	=
call	174:19	174:107	4	mxf_get_codec_ul
arg	174:36	174:62	5	ff_mxf_data_definition_uls
water	174:36	0:0	6	ff_mxf_data_definition_uls
arg	174:64	174:107	5	&source_track->sequence->data_definition_ul
op	174:64	0:0	6	&
water	174:65	0:0	6	source_track
op	174:77	0:0	6	->
water	174:79	0:0	6	sequence
op	174:87	0:0	6	->
water	174:89	0:0	6	data_definition_ul
water	174:108	0:0	4	;
water	175:8	0:0	4	st
op	175:10	0:0	4	->
water	175:12	0:0	4	codecpar
op	175:20	0:0	4	->
water	175:22	0:0	4	codec_type
op	175:33	0:0	4	=
water	175:35	0:0	4	codec_ul
op	175:43	0:0	4	->
water	175:45	0:0	4	id
water	175:47	0:0	4	;
if	177:8	180:8	4	(! descriptor)
cond	177:12	177:13	5	! descriptor
op	177:12	0:0	6	!
water	177:13	0:0	6	descriptor
stmts	177:25	180:8	5	
water	177:25	0:0	6	{
call	178:12	178:127	6	av_log
arg	178:19	178:26	7	mxf->fc
water	178:19	0:0	8	mxf
op	178:22	0:0	8	->
water	178:24	0:0	8	fc
arg	178:28	178:39	7	AV_LOG_INFO
water	178:28	0:0	8	AV_LOG_INFO
arg	178:41	178:92	7	"source track %d: stream %d, no descriptor found\n"
water	178:41	0:0	8	"source track %d: stream %d, no descriptor found\n"
arg	178:94	178:116	7	source_track->track_id
water	178:94	0:0	8	source_track
op	178:106	0:0	8	->
water	178:108	0:0	8	track_id
arg	178:118	178:127	7	st->index
water	178:118	0:0	8	st
op	178:120	0:0	8	->
water	178:122	0:0	8	index
water	178:128	0:0	6	;
continue	179:12	179:20	6	
water	180:8	0:0	6	}
call	181:8	181:79	4	PRINT_KEY
arg	181:18	181:25	5	mxf->fc
water	181:18	0:0	6	mxf
op	181:21	0:0	6	->
water	181:23	0:0	6	fc
arg	181:27	181:49	5	"essence codec     ul"
water	181:27	0:0	6	"essence codec     ul"
arg	181:51	181:79	5	descriptor->essence_codec_ul
water	181:51	0:0	6	descriptor
op	181:61	0:0	6	->
water	181:63	0:0	6	essence_codec_ul
water	181:80	0:0	4	;
call	182:8	182:83	4	PRINT_KEY
arg	182:18	182:25	5	mxf->fc
water	182:18	0:0	6	mxf
op	182:21	0:0	6	->
water	182:23	0:0	6	fc
arg	182:27	182:49	5	"essence container ul"
water	182:27	0:0	6	"essence container ul"
arg	182:51	182:83	5	descriptor->essence_container_ul
water	182:51	0:0	6	descriptor
op	182:61	0:0	6	->
water	182:63	0:0	6	essence_container_ul
water	182:84	0:0	4	;
water	183:8	0:0	4	essence_container_ul
op	183:29	0:0	4	=
op	183:31	0:0	4	&
water	183:32	0:0	4	descriptor
op	183:42	0:0	4	->
water	183:44	0:0	4	essence_container_ul
water	183:64	0:0	4	;
if	186:8	195:8	4	(IS_KLV_KEY (essence_container_ul ,mxf_encrypted_essence_container ))
cond	186:12	186:76	5	IS_KLV_KEY (essence_container_ul ,mxf_encrypted_essence_container )
call	186:12	186:76	6	IS_KLV_KEY
arg	186:23	186:43	7	essence_container_ul
water	186:23	0:0	8	essence_container_ul
arg	186:45	186:76	7	mxf_encrypted_essence_container
water	186:45	0:0	8	mxf_encrypted_essence_container
stmts	186:79	195:8	5	
water	186:79	0:0	6	{
call	187:12	187:70	6	av_log
arg	187:19	187:26	7	mxf->fc
water	187:19	0:0	8	mxf
op	187:22	0:0	8	->
water	187:24	0:0	8	fc
arg	187:28	187:39	7	AV_LOG_INFO
water	187:28	0:0	8	AV_LOG_INFO
arg	187:41	187:70	7	"broken encrypted mxf file\n"
water	187:41	0:0	8	"broken encrypted mxf file\n"
water	187:71	0:0	6	;
for	188:12	194:12	6	(k = 0 ;k < mxf -> metadata_sets_count;k ++)
forinit	188:17	188:22	7	k = 0 ;
water	188:17	0:0	8	k
op	188:19	0:0	8	=
water	188:21	0:0	8	0
water	188:22	0:0	8	;
cond	188:24	188:33	7	k < mxf -> metadata_sets_count
water	188:24	0:0	8	k
op	188:26	0:0	8	<
water	188:28	0:0	8	mxf
op	188:31	0:0	8	->
water	188:33	0:0	8	metadata_sets_count
forexpr	188:54	188:55	7	k ++
water	188:54	0:0	8	k
op	188:55	0:0	8	++
stmts	188:59	194:12	7	
water	188:59	0:0	8	{
decl	189:16	189:64	8	MXFMetadataSet	*metadata
op	189:41	0:0	8	=
water	189:43	0:0	8	mxf
op	189:46	0:0	8	->
water	189:48	0:0	8	metadata_sets
op	189:61	0:0	8	[
water	189:62	0:0	8	k
op	189:63	0:0	8	]
if	190:16	193:16	8	(metadata -> type == CryptoContext)
cond	190:20	190:38	9	metadata -> type == CryptoContext
water	190:20	0:0	10	metadata
op	190:28	0:0	10	->
water	190:30	0:0	10	type
op	190:35	0:0	10	==
water	190:38	0:0	10	CryptoContext
stmts	190:53	193:16	9	
water	190:53	0:0	10	{
water	191:20	0:0	10	essence_container_ul
op	191:41	0:0	10	=
op	191:43	0:0	10	&
water	191:44	0:0	10	(
water	191:45	0:0	10	(
water	191:46	0:0	10	MXFCryptoContext
op	191:63	0:0	10	*
water	191:64	0:0	10	)
water	191:65	0:0	10	metadata
water	191:73	0:0	10	)
op	191:74	0:0	10	->
water	191:76	0:0	10	source_container_ul
water	191:95	0:0	10	;
break	192:20	192:25	10	
water	193:16	0:0	10	}
water	194:12	0:0	8	}
water	195:8	0:0	6	}
water	198:8	0:0	4	codec_ul
op	198:17	0:0	4	=
call	198:19	198:83	4	mxf_get_codec_ul
arg	198:36	198:52	5	ff_mxf_codec_uls
water	198:36	0:0	6	ff_mxf_codec_uls
arg	198:54	198:83	5	&descriptor->essence_codec_ul
op	198:54	0:0	6	&
water	198:55	0:0	6	descriptor
op	198:65	0:0	6	->
water	198:67	0:0	6	essence_codec_ul
water	198:84	0:0	4	;
water	199:8	0:0	4	st
op	199:10	0:0	4	->
water	199:12	0:0	4	codecpar
op	199:20	0:0	4	->
water	199:22	0:0	4	codec_id
op	199:31	0:0	4	=
water	199:33	0:0	4	(
water	199:34	0:0	4	enum
water	199:39	0:0	4	AVCodecID
water	199:48	0:0	4	)
water	199:49	0:0	4	codec_ul
op	199:57	0:0	4	->
water	199:59	0:0	4	id
water	199:61	0:0	4	;
if	200:8	203:8	4	(st -> codecpar -> codec_id == AV_CODEC_ID_NONE)
cond	200:12	200:38	5	st -> codecpar -> codec_id == AV_CODEC_ID_NONE
water	200:12	0:0	6	st
op	200:14	0:0	6	->
water	200:16	0:0	6	codecpar
op	200:24	0:0	6	->
water	200:26	0:0	6	codec_id
op	200:35	0:0	6	==
water	200:38	0:0	6	AV_CODEC_ID_NONE
stmts	200:56	203:8	5	
water	200:56	0:0	6	{
water	201:12	0:0	6	codec_ul
op	201:21	0:0	6	=
call	201:23	201:79	6	mxf_get_codec_ul
arg	201:40	201:56	7	ff_mxf_codec_uls
water	201:40	0:0	8	ff_mxf_codec_uls
arg	201:58	201:79	7	&descriptor->codec_ul
op	201:58	0:0	8	&
water	201:59	0:0	8	descriptor
op	201:69	0:0	8	->
water	201:71	0:0	8	codec_ul
water	201:80	0:0	6	;
water	202:12	0:0	6	st
op	202:14	0:0	6	->
water	202:16	0:0	6	codecpar
op	202:24	0:0	6	->
water	202:26	0:0	6	codec_id
op	202:35	0:0	6	=
water	202:37	0:0	6	(
water	202:38	0:0	6	enum
water	202:43	0:0	6	AVCodecID
water	202:52	0:0	6	)
water	202:53	0:0	6	codec_ul
op	202:61	0:0	6	->
water	202:63	0:0	6	id
water	202:65	0:0	6	;
water	203:8	0:0	6	}
call	205:8	206:55	4	av_log
arg	205:15	205:22	5	mxf->fc
water	205:15	0:0	6	mxf
op	205:18	0:0	6	->
water	205:20	0:0	6	fc
arg	205:24	205:38	5	AV_LOG_VERBOSE
water	205:24	0:0	6	AV_LOG_VERBOSE
arg	205:40	205:63	5	"%s: Universal Label: "
water	205:40	0:0	6	"%s: Universal Label: "
arg	206:15	206:55	5	avcodec_get_name(st->codecpar->codec_id)
call	206:15	206:54	6	avcodec_get_name
arg	206:32	206:54	7	st->codecpar->codec_id
water	206:32	0:0	8	st
op	206:34	0:0	8	->
water	206:36	0:0	8	codecpar
op	206:44	0:0	8	->
water	206:46	0:0	8	codec_id
water	206:56	0:0	4	;
for	207:8	212:8	4	(k = 0 ;k < 16;k ++)
forinit	207:13	207:18	5	k = 0 ;
water	207:13	0:0	6	k
op	207:15	0:0	6	=
water	207:17	0:0	6	0
water	207:18	0:0	6	;
cond	207:20	207:24	5	k < 16
water	207:20	0:0	6	k
op	207:22	0:0	6	<
water	207:24	0:0	6	16
forexpr	207:28	207:29	5	k ++
water	207:28	0:0	6	k
op	207:29	0:0	6	++
stmts	207:33	212:8	5	
water	207:33	0:0	6	{
call	208:12	209:50	6	av_log
arg	208:19	208:26	7	mxf->fc
water	208:19	0:0	8	mxf
op	208:22	0:0	8	->
water	208:24	0:0	8	fc
arg	208:28	208:42	7	AV_LOG_VERBOSE
water	208:28	0:0	8	AV_LOG_VERBOSE
arg	208:44	208:50	7	"%.2x"
water	208:44	0:0	8	"%.2x"
arg	209:19	209:50	7	descriptor->essence_codec_ul[k]
water	209:19	0:0	8	descriptor
op	209:29	0:0	8	->
water	209:31	0:0	8	essence_codec_ul
op	209:47	0:0	8	[
water	209:48	0:0	8	k
op	209:49	0:0	8	]
water	209:51	0:0	6	;
if	210:12	211:52	6	(! ( k + 1 & 19 ) || k == 5)
cond	210:16	210:36	7	! ( k + 1 & 19 ) || k == 5
op	210:16	0:0	8	!
water	210:17	0:0	8	(
water	210:18	0:0	8	k
op	210:19	0:0	8	+
water	210:20	0:0	8	1
op	210:22	0:0	8	&
water	210:24	0:0	8	19
water	210:26	0:0	8	)
op	210:28	0:0	8	||
water	210:31	0:0	8	k
op	210:33	0:0	8	==
water	210:36	0:0	8	5
stmts	211:16	211:52	7	
call	211:16	211:51	8	av_log
arg	211:23	211:30	9	mxf->fc
water	211:23	0:0	10	mxf
op	211:26	0:0	10	->
water	211:28	0:0	10	fc
arg	211:32	211:46	9	AV_LOG_VERBOSE
water	211:32	0:0	10	AV_LOG_VERBOSE
arg	211:48	211:51	9	"."
water	211:48	0:0	10	"."
water	211:52	0:0	8	;
water	212:8	0:0	6	}
call	213:8	213:44	4	av_log
arg	213:15	213:22	5	mxf->fc
water	213:15	0:0	6	mxf
op	213:18	0:0	6	->
water	213:20	0:0	6	fc
arg	213:24	213:38	5	AV_LOG_VERBOSE
water	213:24	0:0	6	AV_LOG_VERBOSE
arg	213:40	213:44	5	"\n"
water	213:40	0:0	6	"\n"
water	213:45	0:0	4	;
call	215:8	215:80	4	mxf_add_umid_metadata
arg	215:30	215:43	5	&st->metadata
op	215:30	0:0	6	&
water	215:31	0:0	6	st
op	215:33	0:0	6	->
water	215:35	0:0	6	metadata
arg	215:45	215:64	5	"file_package_umid"
water	215:45	0:0	6	"file_package_umid"
arg	215:66	215:80	5	source_package
water	215:66	0:0	6	source_package
water	215:81	0:0	4	;
if	216:8	217:84	4	(source_package -> name && source_package -> name [ 0 ])
cond	216:12	216:58	5	source_package -> name && source_package -> name [ 0 ]
water	216:12	0:0	6	source_package
op	216:26	0:0	6	->
water	216:28	0:0	6	name
op	216:33	0:0	6	&&
water	216:36	0:0	6	source_package
op	216:50	0:0	6	->
water	216:52	0:0	6	name
op	216:56	0:0	6	[
water	216:57	0:0	6	0
op	216:58	0:0	6	]
stmts	217:12	217:84	5	
call	217:12	217:83	6	av_dict_set
arg	217:24	217:37	7	&st->metadata
op	217:24	0:0	8	&
water	217:25	0:0	8	st
op	217:27	0:0	8	->
water	217:29	0:0	8	metadata
arg	217:39	217:58	7	"file_package_name"
water	217:39	0:0	8	"file_package_name"
arg	217:60	217:80	7	source_package->name
water	217:60	0:0	8	source_package
op	217:74	0:0	8	->
water	217:76	0:0	8	name
arg	217:82	217:83	7	0
water	217:82	0:0	8	0
water	217:84	0:0	6	;
if	218:8	219:77	4	(material_track -> name && material_track -> name [ 0 ])
cond	218:12	218:58	5	material_track -> name && material_track -> name [ 0 ]
water	218:12	0:0	6	material_track
op	218:26	0:0	6	->
water	218:28	0:0	6	name
op	218:33	0:0	6	&&
water	218:36	0:0	6	material_track
op	218:50	0:0	6	->
water	218:52	0:0	6	name
op	218:56	0:0	6	[
water	218:57	0:0	6	0
op	218:58	0:0	6	]
stmts	219:12	219:77	5	
call	219:12	219:76	6	av_dict_set
arg	219:24	219:37	7	&st->metadata
op	219:24	0:0	8	&
water	219:25	0:0	8	st
op	219:27	0:0	8	->
water	219:29	0:0	8	metadata
arg	219:39	219:51	7	"track_name"
water	219:39	0:0	8	"track_name"
arg	219:53	219:73	7	material_track->name
water	219:53	0:0	8	material_track
op	219:67	0:0	8	->
water	219:69	0:0	8	name
arg	219:75	219:76	7	0
water	219:75	0:0	8	0
water	219:77	0:0	6	;
call	221:8	221:63	4	mxf_parse_physical_source_package
arg	221:42	221:45	5	mxf
water	221:42	0:0	6	mxf
arg	221:47	221:59	5	source_track
water	221:47	0:0	6	source_track
arg	221:61	221:63	5	st
water	221:61	0:0	6	st
water	221:64	0:0	4	;
if	223:8	321:8	4	(st -> codecpar -> codec_type == AVMEDIA_TYPE_VIDEO)
cond	223:12	223:40	5	st -> codecpar -> codec_type == AVMEDIA_TYPE_VIDEO
water	223:12	0:0	6	st
op	223:14	0:0	6	->
water	223:16	0:0	6	codecpar
op	223:24	0:0	6	->
water	223:26	0:0	6	codec_type
op	223:37	0:0	6	==
water	223:40	0:0	6	AVMEDIA_TYPE_VIDEO
stmts	223:60	321:8	5	
water	223:60	0:0	6	{
water	224:12	0:0	6	source_track
op	224:24	0:0	6	->
water	224:26	0:0	6	intra_only
op	224:37	0:0	6	=
call	224:39	224:67	6	mxf_is_intra_only
arg	224:57	224:67	7	descriptor
water	224:57	0:0	8	descriptor
water	224:68	0:0	6	;
water	225:12	0:0	6	container_ul
op	225:25	0:0	6	=
call	225:27	225:99	6	mxf_get_codec_ul
arg	225:44	225:77	7	mxf_picture_essence_container_uls
water	225:44	0:0	8	mxf_picture_essence_container_uls
arg	225:79	225:99	7	essence_container_ul
water	225:79	0:0	8	essence_container_ul
water	225:100	0:0	6	;
if	226:12	227:57	6	(st -> codecpar -> codec_id == AV_CODEC_ID_NONE)
cond	226:16	226:42	7	st -> codecpar -> codec_id == AV_CODEC_ID_NONE
water	226:16	0:0	8	st
op	226:18	0:0	8	->
water	226:20	0:0	8	codecpar
op	226:28	0:0	8	->
water	226:30	0:0	8	codec_id
op	226:39	0:0	8	==
water	226:42	0:0	8	AV_CODEC_ID_NONE
stmts	227:16	227:57	7	
water	227:16	0:0	8	st
op	227:18	0:0	8	->
water	227:20	0:0	8	codecpar
op	227:28	0:0	8	->
water	227:30	0:0	8	codec_id
op	227:39	0:0	8	=
water	227:41	0:0	8	container_ul
op	227:53	0:0	8	->
water	227:55	0:0	8	id
water	227:57	0:0	8	;
water	228:12	0:0	6	st
op	228:14	0:0	6	->
water	228:16	0:0	6	codecpar
op	228:24	0:0	6	->
water	228:26	0:0	6	width
op	228:32	0:0	6	=
water	228:34	0:0	6	descriptor
op	228:44	0:0	6	->
water	228:46	0:0	6	width
water	228:51	0:0	6	;
water	229:12	0:0	6	st
op	229:14	0:0	6	->
water	229:16	0:0	6	codecpar
op	229:24	0:0	6	->
water	229:26	0:0	6	height
op	229:33	0:0	6	=
water	229:35	0:0	6	descriptor
op	229:45	0:0	6	->
water	229:47	0:0	6	height
water	229:53	0:0	6	;
switch	230:12	290:12	6	(descriptor -> frame_layout)
cond	230:20	230:32	7	descriptor -> frame_layout
water	230:20	0:0	8	descriptor
op	230:30	0:0	8	->
water	230:32	0:0	8	frame_layout
stmts	230:46	290:12	7	
water	230:46	0:0	8	{
label	231:16	231:30	8	case FullFrame :
water	232:20	0:0	8	st
op	232:22	0:0	8	->
water	232:24	0:0	8	codecpar
op	232:32	0:0	8	->
water	232:34	0:0	8	field_order
op	232:46	0:0	8	=
water	232:48	0:0	8	AV_FIELD_PROGRESSIVE
water	232:68	0:0	8	;
break	233:20	233:25	8	
label	234:16	234:29	8	case OneField :
call	236:20	236:100	8	av_log
arg	236:27	236:34	9	mxf->fc
water	236:27	0:0	10	mxf
op	236:30	0:0	10	->
water	236:32	0:0	10	fc
arg	236:36	236:47	9	AV_LOG_INFO
water	236:36	0:0	10	AV_LOG_INFO
arg	236:49	236:100	9	"OneField frame layout isn't currently supported\n"
water	236:49	0:0	10	"OneField frame layout isn't currently supported\n"
water	236:101	0:0	8	;
break	237:20	237:25	8	
label	240:16	240:32	8	case MixedFields :
break	241:20	241:25	8	
label	242:16	242:35	8	case SegmentedFrame :
water	243:20	0:0	8	st
op	243:22	0:0	8	->
water	243:24	0:0	8	codecpar
op	243:32	0:0	8	->
water	243:34	0:0	8	field_order
op	243:46	0:0	8	=
water	243:48	0:0	8	AV_FIELD_PROGRESSIVE
water	243:68	0:0	8	;
label	244:16	244:35	8	case SeparateFields :
call	245:20	247:54	8	av_log
arg	245:27	245:34	9	mxf->fc
water	245:27	0:0	10	mxf
op	245:30	0:0	10	->
water	245:32	0:0	10	fc
arg	245:36	245:48	9	AV_LOG_DEBUG
water	245:36	0:0	10	AV_LOG_DEBUG
arg	245:50	245:99	9	"video_line_map: (%d, %d), field_dominance: %d\n"
water	245:50	0:0	10	"video_line_map: (%d, %d), field_dominance: %d\n"
arg	246:27	246:56	9	descriptor->video_line_map[0]
water	246:27	0:0	10	descriptor
op	246:37	0:0	10	->
water	246:39	0:0	10	video_line_map
op	246:53	0:0	10	[
water	246:54	0:0	10	0
op	246:55	0:0	10	]
arg	246:58	246:87	9	descriptor->video_line_map[1]
water	246:58	0:0	10	descriptor
op	246:68	0:0	10	->
water	246:70	0:0	10	video_line_map
op	246:84	0:0	10	[
water	246:85	0:0	10	1
op	246:86	0:0	10	]
arg	247:27	247:54	9	descriptor->field_dominance
water	247:27	0:0	10	descriptor
op	247:37	0:0	10	->
water	247:39	0:0	10	field_dominance
water	247:55	0:0	8	;
if	248:20	284:20	8	(( descriptor -> video_line_map [ 0 ] > 0 ) && ( descriptor -> video_line_map [ 1 ] > 0 ))
cond	248:24	248:97	9	( descriptor -> video_line_map [ 0 ] > 0 ) && ( descriptor -> video_line_map [ 1 ] > 0 )
water	248:24	0:0	10	(
water	248:25	0:0	10	descriptor
op	248:35	0:0	10	->
water	248:37	0:0	10	video_line_map
op	248:51	0:0	10	[
water	248:52	0:0	10	0
op	248:53	0:0	10	]
op	248:55	0:0	10	>
water	248:57	0:0	10	0
water	248:58	0:0	10	)
op	248:60	0:0	10	&&
water	248:63	0:0	10	(
water	248:64	0:0	10	descriptor
op	248:74	0:0	10	->
water	248:76	0:0	10	video_line_map
op	248:90	0:0	10	[
water	248:91	0:0	10	1
op	248:92	0:0	10	]
op	248:94	0:0	10	>
water	248:96	0:0	10	0
water	248:97	0:0	10	)
stmts	248:100	284:20	9	
water	248:100	0:0	10	{
if	255:24	269:24	10	(( descriptor -> video_line_map [ 0 ] + descriptor -> video_line_map [ 1 ] ) % 2)
cond	255:28	255:94	11	( descriptor -> video_line_map [ 0 ] + descriptor -> video_line_map [ 1 ] ) % 2
water	255:28	0:0	12	(
water	255:29	0:0	12	descriptor
op	255:39	0:0	12	->
water	255:41	0:0	12	video_line_map
op	255:55	0:0	12	[
water	255:56	0:0	12	0
op	255:57	0:0	12	]
op	255:59	0:0	12	+
water	255:61	0:0	12	descriptor
op	255:71	0:0	12	->
water	255:73	0:0	12	video_line_map
op	255:87	0:0	12	[
water	255:88	0:0	12	1
op	255:89	0:0	12	]
water	255:90	0:0	12	)
op	255:92	0:0	12	%
water	255:94	0:0	12	2
stmts	255:97	269:24	11	
water	255:97	0:0	12	{
switch	256:28	268:28	12	(descriptor -> field_dominance)
cond	256:36	256:48	13	descriptor -> field_dominance
water	256:36	0:0	14	descriptor
op	256:46	0:0	14	->
water	256:48	0:0	14	field_dominance
stmts	256:65	268:28	13	
water	256:65	0:0	14	{
label	257:32	257:64	14	case MXF_FIELD_DOMINANCE_DEFAULT :
label	258:32	258:59	14	case MXF_FIELD_DOMINANCE_FF :
water	259:36	0:0	14	st
op	259:38	0:0	14	->
water	259:40	0:0	14	codecpar
op	259:48	0:0	14	->
water	259:50	0:0	14	field_order
op	259:62	0:0	14	=
water	259:64	0:0	14	AV_FIELD_TT
water	259:75	0:0	14	;
break	260:36	260:41	14	
label	261:32	261:59	14	case MXF_FIELD_DOMINANCE_FL :
water	262:36	0:0	14	st
op	262:38	0:0	14	->
water	262:40	0:0	14	codecpar
op	262:48	0:0	14	->
water	262:50	0:0	14	field_order
op	262:62	0:0	14	=
water	262:64	0:0	14	AV_FIELD_TB
water	262:75	0:0	14	;
break	263:36	263:41	14	
label	264:32	264:39	14	default :
call	265:36	267:85	14	avpriv_request_sample
arg	265:58	265:65	15	mxf->fc
water	265:58	0:0	16	mxf
op	265:61	0:0	16	->
water	265:63	0:0	16	fc
arg	266:58	266:86	15	"Field dominance %d support"
water	266:58	0:0	16	"Field dominance %d support"
arg	267:58	267:85	15	descriptor->field_dominance
water	267:58	0:0	16	descriptor
op	267:68	0:0	16	->
water	267:70	0:0	16	field_dominance
water	267:86	0:0	14	;
water	268:28	0:0	14	}
water	269:24	0:0	12	}
else	269:26	283:24	10
stmts	269:31	283:24	11	
water	269:31	0:0	12	{
switch	270:28	282:28	12	(descriptor -> field_dominance)
cond	270:36	270:48	13	descriptor -> field_dominance
water	270:36	0:0	14	descriptor
op	270:46	0:0	14	->
water	270:48	0:0	14	field_dominance
stmts	270:65	282:28	13	
water	270:65	0:0	14	{
label	271:32	271:64	14	case MXF_FIELD_DOMINANCE_DEFAULT :
label	272:32	272:59	14	case MXF_FIELD_DOMINANCE_FF :
water	273:36	0:0	14	st
op	273:38	0:0	14	->
water	273:40	0:0	14	codecpar
op	273:48	0:0	14	->
water	273:50	0:0	14	field_order
op	273:62	0:0	14	=
water	273:64	0:0	14	AV_FIELD_BB
water	273:75	0:0	14	;
break	274:36	274:41	14	
label	275:32	275:59	14	case MXF_FIELD_DOMINANCE_FL :
water	276:36	0:0	14	st
op	276:38	0:0	14	->
water	276:40	0:0	14	codecpar
op	276:48	0:0	14	->
water	276:50	0:0	14	field_order
op	276:62	0:0	14	=
water	276:64	0:0	14	AV_FIELD_BT
water	276:75	0:0	14	;
break	277:36	277:41	14	
label	278:32	278:39	14	default :
call	279:36	281:85	14	avpriv_request_sample
arg	279:58	279:65	15	mxf->fc
water	279:58	0:0	16	mxf
op	279:61	0:0	16	->
water	279:63	0:0	16	fc
arg	280:58	280:86	15	"Field dominance %d support"
water	280:58	0:0	16	"Field dominance %d support"
arg	281:58	281:85	15	descriptor->field_dominance
water	281:58	0:0	16	descriptor
op	281:68	0:0	16	->
water	281:70	0:0	16	field_dominance
water	281:86	0:0	14	;
water	282:28	0:0	14	}
water	283:24	0:0	12	}
water	284:20	0:0	10	}
water	286:20	0:0	8	st
op	286:22	0:0	8	->
water	286:24	0:0	8	codecpar
op	286:32	0:0	8	->
water	286:34	0:0	8	height
op	286:41	0:0	8	*=
water	286:44	0:0	8	2
water	286:45	0:0	8	;
break	287:20	287:25	8	
label	288:16	288:23	8	default :
call	289:20	289:108	8	av_log
arg	289:27	289:34	9	mxf->fc
water	289:27	0:0	10	mxf
op	289:30	0:0	10	->
water	289:32	0:0	10	fc
arg	289:36	289:47	9	AV_LOG_INFO
water	289:36	0:0	10	AV_LOG_INFO
arg	289:49	289:82	9	"Unknown frame layout type: %d\n"
water	289:49	0:0	10	"Unknown frame layout type: %d\n"
arg	289:84	289:108	9	descriptor->frame_layout
water	289:84	0:0	10	descriptor
op	289:94	0:0	10	->
water	289:96	0:0	10	frame_layout
water	289:109	0:0	8	;
water	290:12	0:0	8	}
if	291:12	311:12	6	(st -> codecpar -> codec_id == AV_CODEC_ID_RAWVIDEO)
cond	291:16	291:42	7	st -> codecpar -> codec_id == AV_CODEC_ID_RAWVIDEO
water	291:16	0:0	8	st
op	291:18	0:0	8	->
water	291:20	0:0	8	codecpar
op	291:28	0:0	8	->
water	291:30	0:0	8	codec_id
op	291:39	0:0	8	==
water	291:42	0:0	8	AV_CODEC_ID_RAWVIDEO
stmts	291:64	311:12	7	
water	291:64	0:0	8	{
water	292:16	0:0	8	st
op	292:18	0:0	8	->
water	292:20	0:0	8	codecpar
op	292:28	0:0	8	->
water	292:30	0:0	8	format
op	292:37	0:0	8	=
water	292:39	0:0	8	descriptor
op	292:49	0:0	8	->
water	292:51	0:0	8	pix_fmt
water	292:58	0:0	8	;
if	293:16	310:16	8	(st -> codecpar -> format == AV_PIX_FMT_NONE)
cond	293:20	293:44	9	st -> codecpar -> format == AV_PIX_FMT_NONE
water	293:20	0:0	10	st
op	293:22	0:0	10	->
water	293:24	0:0	10	codecpar
op	293:32	0:0	10	->
water	293:34	0:0	10	format
op	293:41	0:0	10	==
water	293:44	0:0	10	AV_PIX_FMT_NONE
stmts	293:61	310:16	9	
water	293:61	0:0	10	{
water	294:20	0:0	10	pix_fmt_ul
op	294:31	0:0	10	=
call	294:33	295:79	10	mxf_get_codec_ul
arg	294:50	294:73	11	ff_mxf_pixel_format_uls
water	294:50	0:0	12	ff_mxf_pixel_format_uls
arg	295:50	295:79	11	&descriptor->essence_codec_ul
op	295:50	0:0	12	&
water	295:51	0:0	12	descriptor
op	295:61	0:0	12	->
water	295:63	0:0	12	essence_codec_ul
water	295:80	0:0	10	;
water	296:20	0:0	10	st
op	296:22	0:0	10	->
water	296:24	0:0	10	codecpar
op	296:32	0:0	10	->
water	296:34	0:0	10	format
op	296:41	0:0	10	=
water	296:43	0:0	10	(
water	296:44	0:0	10	enum
water	296:49	0:0	10	AVPixelFormat
water	296:62	0:0	10	)
water	296:63	0:0	10	pix_fmt_ul
op	296:73	0:0	10	->
water	296:75	0:0	10	id
water	296:77	0:0	10	;
if	297:20	309:20	10	(st -> codecpar -> format == AV_PIX_FMT_NONE)
cond	297:24	297:47	11	st -> codecpar -> format == AV_PIX_FMT_NONE
water	297:24	0:0	12	st
op	297:26	0:0	12	->
water	297:28	0:0	12	codecpar
op	297:36	0:0	12	->
water	297:38	0:0	12	format
op	297:44	0:0	12	==
water	297:47	0:0	12	AV_PIX_FMT_NONE
stmts	297:64	309:20	11	
water	297:64	0:0	12	{
water	298:24	0:0	12	st
op	298:26	0:0	12	->
water	298:28	0:0	12	codecpar
op	298:36	0:0	12	->
water	298:38	0:0	12	codec_tag
op	298:48	0:0	12	=
call	298:50	299:96	12	mxf_get_codec_ul
arg	298:67	298:87	13	ff_mxf_codec_tag_uls
water	298:67	0:0	14	ff_mxf_codec_tag_uls
arg	299:67	299:96	13	&descriptor->essence_codec_ul
op	299:67	0:0	14	&
water	299:68	0:0	14	descriptor
op	299:78	0:0	14	->
water	299:80	0:0	14	essence_codec_ul
op	299:97	0:0	12	->
water	299:99	0:0	12	id
water	299:101	0:0	12	;
if	300:24	308:24	12	(! st -> codecpar -> codec_tag)
cond	300:28	300:43	13	! st -> codecpar -> codec_tag
op	300:28	0:0	14	!
water	300:29	0:0	14	st
op	300:31	0:0	14	->
water	300:33	0:0	14	codecpar
op	300:41	0:0	14	->
water	300:43	0:0	14	codec_tag
stmts	300:54	308:24	13	
water	300:54	0:0	14	{
if	303:28	307:28	14	(descriptor -> horiz_subsampling == 2 && descriptor -> vert_subsampling == 1 && descriptor -> component_depth == 8)
cond	303:32	305:63	15	descriptor -> horiz_subsampling == 2 && descriptor -> vert_subsampling == 1 && descriptor -> component_depth == 8
water	303:32	0:0	16	descriptor
op	303:42	0:0	16	->
water	303:44	0:0	16	horiz_subsampling
op	303:62	0:0	16	==
water	303:65	0:0	16	2
op	303:67	0:0	16	&&
water	304:32	0:0	16	descriptor
op	304:42	0:0	16	->
water	304:44	0:0	16	vert_subsampling
op	304:61	0:0	16	==
water	304:64	0:0	16	1
op	304:66	0:0	16	&&
water	305:32	0:0	16	descriptor
op	305:42	0:0	16	->
water	305:44	0:0	16	component_depth
op	305:60	0:0	16	==
water	305:63	0:0	16	8
stmts	305:66	307:28	15	
water	305:66	0:0	16	{
water	306:32	0:0	16	st
op	306:34	0:0	16	->
water	306:36	0:0	16	codecpar
op	306:44	0:0	16	->
water	306:46	0:0	16	format
op	306:53	0:0	16	=
water	306:55	0:0	16	AV_PIX_FMT_UYVY422
water	306:73	0:0	16	;
water	307:28	0:0	16	}
water	308:24	0:0	14	}
water	309:20	0:0	12	}
water	310:16	0:0	10	}
water	311:12	0:0	8	}
water	312:12	0:0	6	st
op	312:14	0:0	6	->
water	312:16	0:0	6	need_parsing
op	312:29	0:0	6	=
water	312:31	0:0	6	AVSTREAM_PARSE_HEADERS
water	312:53	0:0	6	;
if	313:12	315:12	6	(material_track -> sequence -> origin)
cond	313:16	313:42	7	material_track -> sequence -> origin
water	313:16	0:0	8	material_track
op	313:30	0:0	8	->
water	313:32	0:0	8	sequence
op	313:40	0:0	8	->
water	313:42	0:0	8	origin
stmts	313:50	315:12	7	
water	313:50	0:0	8	{
call	314:16	314:107	8	av_dict_set_int
arg	314:32	314:45	9	&st->metadata
op	314:32	0:0	10	&
water	314:33	0:0	10	st
op	314:35	0:0	10	->
water	314:37	0:0	10	metadata
arg	314:47	314:70	9	"material_track_origin"
water	314:47	0:0	10	"material_track_origin"
arg	314:72	314:104	9	material_track->sequence->origin
water	314:72	0:0	10	material_track
op	314:86	0:0	10	->
water	314:88	0:0	10	sequence
op	314:96	0:0	10	->
water	314:98	0:0	10	origin
arg	314:106	314:107	9	0
water	314:106	0:0	10	0
water	314:108	0:0	8	;
water	315:12	0:0	8	}
if	316:12	318:12	6	(source_track -> sequence -> origin)
cond	316:16	316:40	7	source_track -> sequence -> origin
water	316:16	0:0	8	source_track
op	316:28	0:0	8	->
water	316:30	0:0	8	sequence
op	316:38	0:0	8	->
water	316:40	0:0	8	origin
stmts	316:48	318:12	7	
water	316:48	0:0	8	{
call	317:16	317:103	8	av_dict_set_int
arg	317:32	317:45	9	&st->metadata
op	317:32	0:0	10	&
water	317:33	0:0	10	st
op	317:35	0:0	10	->
water	317:37	0:0	10	metadata
arg	317:47	317:68	9	"source_track_origin"
water	317:47	0:0	10	"source_track_origin"
arg	317:70	317:100	9	source_track->sequence->origin
water	317:70	0:0	10	source_track
op	317:82	0:0	10	->
water	317:84	0:0	10	sequence
op	317:92	0:0	10	->
water	317:94	0:0	10	origin
arg	317:102	317:103	9	0
water	317:102	0:0	10	0
water	317:104	0:0	8	;
water	318:12	0:0	8	}
if	319:12	320:67	6	(descriptor -> aspect_ratio . num && descriptor -> aspect_ratio . den)
cond	319:16	319:73	7	descriptor -> aspect_ratio . num && descriptor -> aspect_ratio . den
water	319:16	0:0	8	descriptor
op	319:26	0:0	8	->
water	319:28	0:0	8	aspect_ratio
op	319:40	0:0	8	.
water	319:41	0:0	8	num
op	319:45	0:0	8	&&
water	319:48	0:0	8	descriptor
op	319:58	0:0	8	->
water	319:60	0:0	8	aspect_ratio
op	319:72	0:0	8	.
water	319:73	0:0	8	den
stmts	320:16	320:67	7	
water	320:16	0:0	8	st
op	320:18	0:0	8	->
water	320:20	0:0	8	display_aspect_ratio
op	320:41	0:0	8	=
water	320:43	0:0	8	descriptor
op	320:53	0:0	8	->
water	320:55	0:0	8	aspect_ratio
water	320:67	0:0	8	;
water	321:8	0:0	6	}
else	321:10	360:8	4
stmts	321:15	360:8	5	
if	321:15	360:8	6	(st -> codecpar -> codec_type == AVMEDIA_TYPE_AUDIO)
cond	321:19	321:47	7	st -> codecpar -> codec_type == AVMEDIA_TYPE_AUDIO
water	321:19	0:0	8	st
op	321:21	0:0	8	->
water	321:23	0:0	8	codecpar
op	321:31	0:0	8	->
water	321:33	0:0	8	codec_type
op	321:44	0:0	8	==
water	321:47	0:0	8	AVMEDIA_TYPE_AUDIO
stmts	321:67	360:8	7	
water	321:67	0:0	8	{
water	322:12	0:0	8	container_ul
op	322:25	0:0	8	=
call	322:27	322:97	8	mxf_get_codec_ul
arg	322:44	322:75	9	mxf_sound_essence_container_uls
water	322:44	0:0	10	mxf_sound_essence_container_uls
arg	322:77	322:97	9	essence_container_ul
water	322:77	0:0	10	essence_container_ul
water	322:98	0:0	8	;
if	324:12	325:73	8	(st -> codecpar -> codec_id == AV_CODEC_ID_NONE || ( st -> codecpar -> codec_id == AV_CODEC_ID_PCM_ALAW && ( enum AVCodecID ) container_ul -> id != AV_CODEC_ID_NONE ))
cond	324:16	324:165	9	st -> codecpar -> codec_id == AV_CODEC_ID_NONE || ( st -> codecpar -> codec_id == AV_CODEC_ID_PCM_ALAW && ( enum AVCodecID ) container_ul -> id != AV_CODEC_ID_NONE )
water	324:16	0:0	10	st
op	324:18	0:0	10	->
water	324:20	0:0	10	codecpar
op	324:28	0:0	10	->
water	324:30	0:0	10	codec_id
op	324:39	0:0	10	==
water	324:42	0:0	10	AV_CODEC_ID_NONE
op	324:59	0:0	10	||
water	324:62	0:0	10	(
water	324:63	0:0	10	st
op	324:65	0:0	10	->
water	324:67	0:0	10	codecpar
op	324:75	0:0	10	->
water	324:77	0:0	10	codec_id
op	324:86	0:0	10	==
water	324:89	0:0	10	AV_CODEC_ID_PCM_ALAW
op	324:110	0:0	10	&&
water	324:113	0:0	10	(
water	324:114	0:0	10	enum
water	324:119	0:0	10	AVCodecID
water	324:128	0:0	10	)
water	324:129	0:0	10	container_ul
op	324:141	0:0	10	->
water	324:143	0:0	10	id
op	324:146	0:0	10	!=
water	324:149	0:0	10	AV_CODEC_ID_NONE
water	324:165	0:0	10	)
stmts	325:16	325:73	9	
water	325:16	0:0	10	st
op	325:18	0:0	10	->
water	325:20	0:0	10	codecpar
op	325:28	0:0	10	->
water	325:30	0:0	10	codec_id
op	325:39	0:0	10	=
water	325:41	0:0	10	(
water	325:42	0:0	10	enum
water	325:47	0:0	10	AVCodecID
water	325:56	0:0	10	)
water	325:57	0:0	10	container_ul
op	325:69	0:0	10	->
water	325:71	0:0	10	id
water	325:73	0:0	10	;
water	326:12	0:0	8	st
op	326:14	0:0	8	->
water	326:16	0:0	8	codecpar
op	326:24	0:0	8	->
water	326:26	0:0	8	channels
op	326:35	0:0	8	=
water	326:37	0:0	8	descriptor
op	326:47	0:0	8	->
water	326:49	0:0	8	channels
water	326:57	0:0	8	;
water	327:12	0:0	8	st
op	327:14	0:0	8	->
water	327:16	0:0	8	codecpar
op	327:24	0:0	8	->
water	327:26	0:0	8	bits_per_coded_sample
op	327:48	0:0	8	=
water	327:50	0:0	8	descriptor
op	327:60	0:0	8	->
water	327:62	0:0	8	bits_per_sample
water	327:77	0:0	8	;
if	329:12	332:12	8	(descriptor -> sample_rate . den > 0)
cond	329:16	329:46	9	descriptor -> sample_rate . den > 0
water	329:16	0:0	10	descriptor
op	329:26	0:0	10	->
water	329:28	0:0	10	sample_rate
op	329:39	0:0	10	.
water	329:40	0:0	10	den
op	329:44	0:0	10	>
water	329:46	0:0	10	0
stmts	329:49	332:12	9	
water	329:49	0:0	10	{
water	330:16	0:0	10	st
op	330:18	0:0	10	->
water	330:20	0:0	10	codecpar
op	330:28	0:0	10	->
water	330:30	0:0	10	sample_rate
op	330:42	0:0	10	=
water	330:44	0:0	10	descriptor
op	330:54	0:0	10	->
water	330:56	0:0	10	sample_rate
op	330:67	0:0	10	.
water	330:68	0:0	10	num
op	330:72	0:0	10	/
water	330:74	0:0	10	descriptor
op	330:84	0:0	10	->
water	330:86	0:0	10	sample_rate
op	330:97	0:0	10	.
water	330:98	0:0	10	den
water	330:101	0:0	10	;
call	331:16	331:100	10	avpriv_set_pts_info
arg	331:36	331:38	11	st
water	331:36	0:0	12	st
arg	331:40	331:42	11	64
water	331:40	0:0	12	64
arg	331:44	331:71	11	descriptor->sample_rate.den
water	331:44	0:0	12	descriptor
op	331:54	0:0	12	->
water	331:56	0:0	12	sample_rate
op	331:67	0:0	12	.
water	331:68	0:0	12	den
arg	331:73	331:100	11	descriptor->sample_rate.num
water	331:73	0:0	12	descriptor
op	331:83	0:0	12	->
water	331:85	0:0	12	sample_rate
op	331:96	0:0	12	.
water	331:97	0:0	12	num
water	331:101	0:0	10	;
water	332:12	0:0	10	}
else	332:14	338:12	8
stmts	332:19	338:12	9	
water	332:19	0:0	10	{
call	333:16	336:32	10	av_log
arg	333:23	333:30	11	mxf->fc
water	333:23	0:0	12	mxf
op	333:26	0:0	12	->
water	333:28	0:0	12	fc
arg	333:32	333:46	11	AV_LOG_WARNING
water	333:32	0:0	12	AV_LOG_WARNING
arg	333:48	334:76	11	"invalid sample rate (%d/%d) ""found for stream #%d, time base forced to 1/48000\n"
water	333:48	0:0	12	"invalid sample rate (%d/%d) "
water	334:23	0:0	12	"found for stream #%d, time base forced to 1/48000\n"
arg	335:23	335:50	11	descriptor->sample_rate.num
water	335:23	0:0	12	descriptor
op	335:33	0:0	12	->
water	335:35	0:0	12	sample_rate
op	335:46	0:0	12	.
water	335:47	0:0	12	num
arg	335:52	335:79	11	descriptor->sample_rate.den
water	335:52	0:0	12	descriptor
op	335:62	0:0	12	->
water	335:64	0:0	12	sample_rate
op	335:75	0:0	12	.
water	335:76	0:0	12	den
arg	336:23	336:32	11	st->index
water	336:23	0:0	12	st
op	336:25	0:0	12	->
water	336:27	0:0	12	index
water	336:33	0:0	10	;
call	337:16	337:52	10	avpriv_set_pts_info
arg	337:36	337:38	11	st
water	337:36	0:0	12	st
arg	337:40	337:42	11	64
water	337:40	0:0	12	64
arg	337:44	337:45	11	1
water	337:44	0:0	12	1
arg	337:47	337:52	11	48000
water	337:47	0:0	12	48000
water	337:53	0:0	10	;
water	338:12	0:0	10	}
if	341:12	344:58	8	(st -> duration != AV_NOPTS_VALUE)
cond	341:16	341:32	9	st -> duration != AV_NOPTS_VALUE
water	341:16	0:0	10	st
op	341:18	0:0	10	->
water	341:20	0:0	10	duration
op	341:29	0:0	10	!=
water	341:32	0:0	10	AV_NOPTS_VALUE
stmts	342:16	344:58	9	
water	342:16	0:0	10	st
op	342:18	0:0	10	->
water	342:20	0:0	10	duration
op	342:29	0:0	10	=
call	342:31	344:57	10	av_rescale_q
arg	342:44	342:56	11	st->duration
water	342:44	0:0	12	st
op	342:46	0:0	12	->
water	342:48	0:0	12	duration
arg	343:44	343:79	11	av_inv_q(material_track->edit_rate)
call	343:44	343:78	12	av_inv_q
arg	343:53	343:78	13	material_track->edit_rate
water	343:53	0:0	14	material_track
op	343:67	0:0	14	->
water	343:69	0:0	14	edit_rate
arg	344:44	344:57	11	st->time_base
water	344:44	0:0	12	st
op	344:46	0:0	12	->
water	344:48	0:0	12	time_base
water	344:58	0:0	10	;
if	347:12	352:12	8	(st -> codecpar -> codec_id == AV_CODEC_ID_PCM_S16LE)
cond	347:16	347:42	9	st -> codecpar -> codec_id == AV_CODEC_ID_PCM_S16LE
water	347:16	0:0	10	st
op	347:18	0:0	10	->
water	347:20	0:0	10	codecpar
op	347:28	0:0	10	->
water	347:30	0:0	10	codec_id
op	347:39	0:0	10	==
water	347:42	0:0	10	AV_CODEC_ID_PCM_S16LE
stmts	347:65	352:12	9	
water	347:65	0:0	10	{
if	348:16	349:66	10	(descriptor -> bits_per_sample > 16 && descriptor -> bits_per_sample <= 24)
cond	348:20	348:87	11	descriptor -> bits_per_sample > 16 && descriptor -> bits_per_sample <= 24
water	348:20	0:0	12	descriptor
op	348:30	0:0	12	->
water	348:32	0:0	12	bits_per_sample
op	348:48	0:0	12	>
water	348:50	0:0	12	16
op	348:53	0:0	12	&&
water	348:56	0:0	12	descriptor
op	348:66	0:0	12	->
water	348:68	0:0	12	bits_per_sample
op	348:84	0:0	12	<=
water	348:87	0:0	12	24
stmts	349:20	349:66	11	
water	349:20	0:0	12	st
op	349:22	0:0	12	->
water	349:24	0:0	12	codecpar
op	349:32	0:0	12	->
water	349:34	0:0	12	codec_id
op	349:43	0:0	12	=
water	349:45	0:0	12	AV_CODEC_ID_PCM_S24LE
water	349:66	0:0	12	;
else	350:16	351:66	10
stmts	350:21	351:66	11	
if	350:21	351:66	12	(descriptor -> bits_per_sample == 32)
cond	350:25	350:56	13	descriptor -> bits_per_sample == 32
water	350:25	0:0	14	descriptor
op	350:35	0:0	14	->
water	350:37	0:0	14	bits_per_sample
op	350:53	0:0	14	==
water	350:56	0:0	14	32
stmts	351:20	351:66	13	
water	351:20	0:0	14	st
op	351:22	0:0	14	->
water	351:24	0:0	14	codecpar
op	351:32	0:0	14	->
water	351:34	0:0	14	codec_id
op	351:43	0:0	14	=
water	351:45	0:0	14	AV_CODEC_ID_PCM_S32LE
water	351:66	0:0	14	;
water	352:12	0:0	10	}
else	352:14	357:12	8
stmts	352:19	357:12	9	
if	352:19	357:12	10	(st -> codecpar -> codec_id == AV_CODEC_ID_PCM_S16BE)
cond	352:23	352:49	11	st -> codecpar -> codec_id == AV_CODEC_ID_PCM_S16BE
water	352:23	0:0	12	st
op	352:25	0:0	12	->
water	352:27	0:0	12	codecpar
op	352:35	0:0	12	->
water	352:37	0:0	12	codec_id
op	352:46	0:0	12	==
water	352:49	0:0	12	AV_CODEC_ID_PCM_S16BE
stmts	352:72	357:12	11	
water	352:72	0:0	12	{
if	353:16	354:66	12	(descriptor -> bits_per_sample > 16 && descriptor -> bits_per_sample <= 24)
cond	353:20	353:87	13	descriptor -> bits_per_sample > 16 && descriptor -> bits_per_sample <= 24
water	353:20	0:0	14	descriptor
op	353:30	0:0	14	->
water	353:32	0:0	14	bits_per_sample
op	353:48	0:0	14	>
water	353:50	0:0	14	16
op	353:53	0:0	14	&&
water	353:56	0:0	14	descriptor
op	353:66	0:0	14	->
water	353:68	0:0	14	bits_per_sample
op	353:84	0:0	14	<=
water	353:87	0:0	14	24
stmts	354:20	354:66	13	
water	354:20	0:0	14	st
op	354:22	0:0	14	->
water	354:24	0:0	14	codecpar
op	354:32	0:0	14	->
water	354:34	0:0	14	codec_id
op	354:43	0:0	14	=
water	354:45	0:0	14	AV_CODEC_ID_PCM_S24BE
water	354:66	0:0	14	;
else	355:16	356:66	12
stmts	355:21	356:66	13	
if	355:21	356:66	14	(descriptor -> bits_per_sample == 32)
cond	355:25	355:56	15	descriptor -> bits_per_sample == 32
water	355:25	0:0	16	descriptor
op	355:35	0:0	16	->
water	355:37	0:0	16	bits_per_sample
op	355:53	0:0	16	==
water	355:56	0:0	16	32
stmts	356:20	356:66	15	
water	356:20	0:0	16	st
op	356:22	0:0	16	->
water	356:24	0:0	16	codecpar
op	356:32	0:0	16	->
water	356:34	0:0	16	codec_id
op	356:43	0:0	16	=
water	356:45	0:0	16	AV_CODEC_ID_PCM_S32BE
water	356:66	0:0	16	;
water	357:12	0:0	12	}
else	357:14	359:12	8
stmts	357:19	359:12	9	
if	357:19	359:12	10	(st -> codecpar -> codec_id == AV_CODEC_ID_MP2)
cond	357:23	357:49	11	st -> codecpar -> codec_id == AV_CODEC_ID_MP2
water	357:23	0:0	12	st
op	357:25	0:0	12	->
water	357:27	0:0	12	codecpar
op	357:35	0:0	12	->
water	357:37	0:0	12	codec_id
op	357:46	0:0	12	==
water	357:49	0:0	12	AV_CODEC_ID_MP2
stmts	357:66	359:12	11	
water	357:66	0:0	12	{
water	358:16	0:0	12	st
op	358:18	0:0	12	->
water	358:20	0:0	12	need_parsing
op	358:33	0:0	12	=
water	358:35	0:0	12	AVSTREAM_PARSE_FULL
water	358:54	0:0	12	;
water	359:12	0:0	12	}
water	360:8	0:0	8	}
else	360:10	368:8	4
stmts	360:15	368:8	5	
if	360:15	368:8	6	(st -> codecpar -> codec_type == AVMEDIA_TYPE_DATA)
cond	360:19	360:47	7	st -> codecpar -> codec_type == AVMEDIA_TYPE_DATA
water	360:19	0:0	8	st
op	360:21	0:0	8	->
water	360:23	0:0	8	codecpar
op	360:31	0:0	8	->
water	360:33	0:0	8	codec_type
op	360:44	0:0	8	==
water	360:47	0:0	8	AVMEDIA_TYPE_DATA
stmts	360:66	368:8	7	
water	360:66	0:0	8	{
decl	361:12	362:69	8	int	codec_id
op	361:25	0:0	8	=
call	361:27	362:64	9	mxf_get_codec_ul
arg	361:44	361:74	10	mxf_data_essence_container_uls
water	361:44	0:0	11	mxf_data_essence_container_uls
arg	362:44	362:64	10	essence_container_ul
water	362:44	0:0	11	essence_container_ul
op	362:65	0:0	8	->
water	362:67	0:0	8	id
if	363:12	367:12	8	(codec_id >= 0 && codec_id <FF_ARRAY_ELEMS (mxf_data_essence_descriptor ))
cond	363:16	364:69	9	codec_id >= 0 && codec_id <FF_ARRAY_ELEMS (mxf_data_essence_descriptor )
water	363:16	0:0	10	codec_id
op	363:25	0:0	10	>=
water	363:28	0:0	10	0
op	363:30	0:0	10	&&
water	364:16	0:0	10	codec_id
op	364:25	0:0	10	<
call	364:27	364:69	10	FF_ARRAY_ELEMS
arg	364:42	364:69	11	mxf_data_essence_descriptor
water	364:42	0:0	12	mxf_data_essence_descriptor
stmts	364:72	367:12	9	
water	364:72	0:0	10	{
call	365:16	366:68	10	av_dict_set
arg	365:28	365:41	11	&st->metadata
op	365:28	0:0	12	&
water	365:29	0:0	12	st
op	365:31	0:0	12	->
water	365:33	0:0	12	metadata
arg	365:43	365:54	11	"data_type"
water	365:43	0:0	12	"data_type"
arg	366:28	366:65	11	mxf_data_essence_descriptor[codec_id]
water	366:28	0:0	12	mxf_data_essence_descriptor
op	366:55	0:0	12	[
water	366:56	0:0	12	codec_id
op	366:64	0:0	12	]
arg	366:67	366:68	11	0
water	366:67	0:0	12	0
water	366:69	0:0	10	;
water	367:12	0:0	10	}
water	368:8	0:0	8	}
if	369:8	373:8	4	(descriptor -> extradata)
cond	369:12	369:24	5	descriptor -> extradata
water	369:12	0:0	6	descriptor
op	369:22	0:0	6	->
water	369:24	0:0	6	extradata
stmts	369:35	373:8	5	
water	369:35	0:0	6	{
if	370:12	372:12	6	(!ff_alloc_extradata (st -> codecpar ,descriptor -> extradata_size ))
cond	370:16	370:76	7	!ff_alloc_extradata (st -> codecpar ,descriptor -> extradata_size )
op	370:16	0:0	8	!
call	370:17	370:76	8	ff_alloc_extradata
arg	370:36	370:48	9	st->codecpar
water	370:36	0:0	10	st
op	370:38	0:0	10	->
water	370:40	0:0	10	codecpar
arg	370:50	370:76	9	descriptor->extradata_size
water	370:50	0:0	10	descriptor
op	370:60	0:0	10	->
water	370:62	0:0	10	extradata_size
stmts	370:79	372:12	7	
water	370:79	0:0	8	{
call	371:16	371:97	8	memcpy
arg	371:23	371:46	9	st->codecpar->extradata
water	371:23	0:0	10	st
op	371:25	0:0	10	->
water	371:27	0:0	10	codecpar
op	371:35	0:0	10	->
water	371:37	0:0	10	extradata
arg	371:48	371:69	9	descriptor->extradata
water	371:48	0:0	10	descriptor
op	371:58	0:0	10	->
water	371:60	0:0	10	extradata
arg	371:71	371:97	9	descriptor->extradata_size
water	371:71	0:0	10	descriptor
op	371:81	0:0	10	->
water	371:83	0:0	10	extradata_size
water	371:98	0:0	8	;
water	372:12	0:0	8	}
water	373:8	0:0	6	}
else	373:10	381:8	4
stmts	373:15	381:8	5	
if	373:15	381:8	6	(st -> codecpar -> codec_id == AV_CODEC_ID_H264)
cond	373:19	373:45	7	st -> codecpar -> codec_id == AV_CODEC_ID_H264
water	373:19	0:0	8	st
op	373:21	0:0	8	->
water	373:23	0:0	8	codecpar
op	373:31	0:0	8	->
water	373:33	0:0	8	codec_id
op	373:42	0:0	8	==
water	373:45	0:0	8	AV_CODEC_ID_H264
stmts	373:63	381:8	7	
water	373:63	0:0	8	{
decl	374:12	375:81	8	int	coded_width
op	374:28	0:0	8	=
call	374:30	375:76	9	mxf_get_codec_ul
arg	374:47	374:81	10	mxf_intra_only_picture_coded_width
water	374:47	0:0	11	mxf_intra_only_picture_coded_width
arg	375:47	375:76	10	&descriptor->essence_codec_ul
op	375:47	0:0	11	&
water	375:48	0:0	11	descriptor
op	375:58	0:0	11	->
water	375:60	0:0	11	essence_codec_ul
op	375:77	0:0	8	->
water	375:79	0:0	8	id
if	376:12	377:49	8	(coded_width)
cond	376:16	376:16	9	coded_width
water	376:16	0:0	10	coded_width
stmts	377:16	377:49	9	
water	377:16	0:0	10	st
op	377:18	0:0	10	->
water	377:20	0:0	10	codecpar
op	377:28	0:0	10	->
water	377:30	0:0	10	width
op	377:36	0:0	10	=
water	377:38	0:0	10	coded_width
water	377:49	0:0	10	;
water	378:12	0:0	8	ret
op	378:16	0:0	8	=
call	378:18	378:47	8	ff_generate_avci_extradata
arg	378:45	378:47	9	st
water	378:45	0:0	10	st
water	378:48	0:0	8	;
if	379:12	380:26	8	(ret < 0)
cond	379:16	379:22	9	ret < 0
water	379:16	0:0	10	ret
op	379:20	0:0	10	<
water	379:22	0:0	10	0
stmts	380:16	380:26	9	
return	380:16	380:26	10	ret
water	380:23	0:0	11	ret
water	381:8	0:0	8	}
if	382:8	385:8	4	(st -> codecpar -> codec_type != AVMEDIA_TYPE_DATA && ( * essence_container_ul ) [ 15 ] > 0 x01)
cond	382:12	382:92	5	st -> codecpar -> codec_type != AVMEDIA_TYPE_DATA && ( * essence_container_ul ) [ 15 ] > 0 x01
water	382:12	0:0	6	st
op	382:14	0:0	6	->
water	382:16	0:0	6	codecpar
op	382:24	0:0	6	->
water	382:26	0:0	6	codec_type
op	382:37	0:0	6	!=
water	382:40	0:0	6	AVMEDIA_TYPE_DATA
op	382:58	0:0	6	&&
water	382:61	0:0	6	(
op	382:62	0:0	6	*
water	382:63	0:0	6	essence_container_ul
water	382:83	0:0	6	)
op	382:84	0:0	6	[
water	382:85	0:0	6	15
op	382:87	0:0	6	]
op	382:89	0:0	6	>
water	382:91	0:0	6	0
water	382:92	0:0	6	x01
stmts	382:97	385:8	5	
water	382:97	0:0	6	{
water	384:12	0:0	6	st
op	384:14	0:0	6	->
water	384:16	0:0	6	need_parsing
op	384:29	0:0	6	=
water	384:31	0:0	6	AVSTREAM_PARSE_TIMESTAMPS
water	384:56	0:0	6	;
water	385:8	0:0	6	}
water	386:4	0:0	4	}
water	388:4	0:0	2	ret
op	388:8	0:0	2	=
water	388:10	0:0	2	0
water	388:11	0:0	2	;
label	389:0	389:13	2	fail_and_free :
return	390:4	390:14	2	ret
water	390:11	0:0	3	ret
