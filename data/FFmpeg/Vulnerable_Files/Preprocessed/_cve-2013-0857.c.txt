func	2:0	118:0	0	static int	decode_frame_ilbm
params	2:28	0:0	1	
param	2:29	2:50	2	AVCodecContext *	avctx
param	3:28	3:38	2	void *	data
param	3:40	3:54	2	int *	data_size
param	4:28	4:43	2	AVPacket *	avpkt
stmnts	0:0	117:19	1	
decl	6:4	6:36	2	IffContext	*s
op	6:18	0:0	2	=
water	6:20	0:0	2	avctx
op	6:25	0:0	2	->
water	6:27	0:0	2	priv_data
decl	7:4	7:85	2	const uint8_t	*buf
op	7:23	0:0	2	=
water	7:25	0:0	2	avpkt
op	7:30	0:0	2	->
water	7:32	0:0	2	size
op	7:37	0:0	2	>=
water	7:40	0:0	2	2
water	7:42	0:0	2	?
water	7:44	0:0	2	avpkt
op	7:49	0:0	2	->
water	7:51	0:0	2	data
op	7:56	0:0	2	+
call	7:58	7:77	3	AV_RB16
arg	7:66	7:77	4	avpkt->data
water	7:66	0:0	5	avpkt
op	7:71	0:0	5	->
water	7:73	0:0	5	data
water	7:79	0:0	2	:
water	7:81	0:0	2	NULL
decl	8:4	8:82	2	const int	buf_size
op	8:23	0:0	2	=
water	8:25	0:0	2	avpkt
op	8:30	0:0	2	->
water	8:32	0:0	2	size
op	8:37	0:0	2	>=
water	8:40	0:0	2	2
water	8:42	0:0	2	?
water	8:44	0:0	2	avpkt
op	8:49	0:0	2	->
water	8:51	0:0	2	size
op	8:56	0:0	2	-
call	8:58	8:77	3	AV_RB16
arg	8:66	8:77	4	avpkt->data
water	8:66	0:0	5	avpkt
op	8:71	0:0	5	->
water	8:73	0:0	5	data
water	8:79	0:0	2	:
water	8:81	0:0	2	0
decl	9:4	9:41	2	const uint8_t	*buf_end
op	9:27	0:0	2	=
water	9:29	0:0	2	buf
op	9:32	0:0	2	+
water	9:33	0:0	2	buf_size
decl	10:4	10:21	2	int	y
water	10:9	0:0	2	,
decl	10:4	10:21	2	int	plane
water	10:16	0:0	2	,
decl	10:4	10:21	2	int	res
if	12:4	13:18	2	(( res =extract_header (avctx ,avpkt ) ) < 0)
cond	12:8	12:47	3	( res =extract_header (avctx ,avpkt ) ) < 0
water	12:8	0:0	4	(
water	12:9	0:0	4	res
op	12:13	0:0	4	=
call	12:15	12:42	4	extract_header
arg	12:30	12:35	5	avctx
water	12:30	0:0	6	avctx
arg	12:37	12:42	5	avpkt
water	12:37	0:0	6	avpkt
water	12:43	0:0	4	)
op	12:45	0:0	4	<
water	12:47	0:0	4	0
stmts	13:8	13:18	3	
return	13:8	13:18	4	res
water	13:15	0:0	5	res
if	15:4	20:4	2	(s -> init)
cond	15:8	15:11	3	s -> init
water	15:8	0:0	4	s
op	15:9	0:0	4	->
water	15:11	0:0	4	init
stmts	15:17	20:4	3	
water	15:17	0:0	4	{
if	16:8	19:8	4	(( res =avctx -> reget_buffer (avctx ,& s -> frame ) ) < 0)
cond	16:12	16:60	5	( res =avctx -> reget_buffer (avctx ,& s -> frame ) ) < 0
water	16:12	0:0	6	(
water	16:13	0:0	6	res
op	16:17	0:0	6	=
call	16:19	16:55	6	avctx->reget_buffer
arg	16:39	16:44	7	avctx
water	16:39	0:0	8	avctx
arg	16:46	16:55	7	&s->frame
op	16:46	0:0	8	&
water	16:47	0:0	8	s
op	16:48	0:0	8	->
water	16:50	0:0	8	frame
water	16:56	0:0	6	)
op	16:58	0:0	6	<
water	16:60	0:0	6	0
stmts	16:63	19:8	5	
water	16:63	0:0	6	{
call	17:12	17:65	6	av_log
arg	17:19	17:24	7	avctx
water	17:19	0:0	8	avctx
arg	17:26	17:38	7	AV_LOG_ERROR
water	17:26	0:0	8	AV_LOG_ERROR
arg	17:40	17:65	7	"reget_buffer() failed\n"
water	17:40	0:0	8	"reget_buffer() failed\n"
water	17:66	0:0	6	;
return	18:12	18:22	6	res
water	18:19	0:0	7	res
water	19:8	0:0	6	}
water	20:4	0:0	4	}
else	20:6	23:4	2
stmts	20:11	23:4	3	
if	20:11	23:4	4	(( res =avctx -> get_buffer (avctx ,& s -> frame ) ) < 0)
cond	20:15	20:61	5	( res =avctx -> get_buffer (avctx ,& s -> frame ) ) < 0
water	20:15	0:0	6	(
water	20:16	0:0	6	res
op	20:20	0:0	6	=
call	20:22	20:56	6	avctx->get_buffer
arg	20:40	20:45	7	avctx
water	20:40	0:0	8	avctx
arg	20:47	20:56	7	&s->frame
op	20:47	0:0	8	&
water	20:48	0:0	8	s
op	20:49	0:0	8	->
water	20:51	0:0	8	frame
water	20:57	0:0	6	)
op	20:59	0:0	6	<
water	20:61	0:0	6	0
stmts	20:64	23:4	5	
water	20:64	0:0	6	{
call	21:8	21:59	6	av_log
arg	21:15	21:20	7	avctx
water	21:15	0:0	8	avctx
arg	21:22	21:34	7	AV_LOG_ERROR
water	21:22	0:0	8	AV_LOG_ERROR
arg	21:36	21:59	7	"get_buffer() failed\n"
water	21:36	0:0	8	"get_buffer() failed\n"
water	21:60	0:0	6	;
return	22:8	22:18	6	res
water	22:15	0:0	7	res
water	23:4	0:0	6	}
else	23:6	26:4	2
stmts	23:11	26:4	3	
if	23:11	26:4	4	(avctx -> bits_per_coded_sample <= 8 && avctx -> pix_fmt == PIX_FMT_PAL8)
cond	23:15	23:70	5	avctx -> bits_per_coded_sample <= 8 && avctx -> pix_fmt == PIX_FMT_PAL8
water	23:15	0:0	6	avctx
op	23:20	0:0	6	->
water	23:22	0:0	6	bits_per_coded_sample
op	23:44	0:0	6	<=
water	23:47	0:0	6	8
op	23:49	0:0	6	&&
water	23:52	0:0	6	avctx
op	23:57	0:0	6	->
water	23:59	0:0	6	pix_fmt
op	23:67	0:0	6	==
water	23:70	0:0	6	PIX_FMT_PAL8
stmts	23:84	26:4	5	
water	23:84	0:0	6	{
if	24:8	25:22	6	(( res =ff_cmap_read_palette (avctx ,( uint32_t * ) s -> frame . data [ 1 ] ) ) < 0)
cond	24:12	24:79	7	( res =ff_cmap_read_palette (avctx ,( uint32_t * ) s -> frame . data [ 1 ] ) ) < 0
water	24:12	0:0	8	(
water	24:13	0:0	8	res
op	24:17	0:0	8	=
call	24:19	24:74	8	ff_cmap_read_palette
arg	24:40	24:45	9	avctx
water	24:40	0:0	10	avctx
arg	24:47	24:74	9	(uint32_t*)s->frame.data[1]
water	24:47	0:0	10	(
water	24:48	0:0	10	uint32_t
op	24:56	0:0	10	*
water	24:57	0:0	10	)
water	24:58	0:0	10	s
op	24:59	0:0	10	->
water	24:61	0:0	10	frame
op	24:66	0:0	10	.
water	24:67	0:0	10	data
op	24:71	0:0	10	[
water	24:72	0:0	10	1
op	24:73	0:0	10	]
water	24:75	0:0	8	)
op	24:77	0:0	8	<
water	24:79	0:0	8	0
stmts	25:12	25:22	7	
return	25:12	25:22	8	res
water	25:19	0:0	9	res
water	26:4	0:0	6	}
water	27:4	0:0	2	s
op	27:5	0:0	2	->
water	27:7	0:0	2	init
op	27:12	0:0	2	=
water	27:14	0:0	2	1
water	27:15	0:0	2	;
if	29:4	53:4	2	(avctx -> codec_tag ==MKTAG ('A' ,'C' ,'B' ,'M' ))
cond	29:8	29:49	3	avctx -> codec_tag ==MKTAG ('A' ,'C' ,'B' ,'M' )
water	29:8	0:0	4	avctx
op	29:13	0:0	4	->
water	29:15	0:0	4	codec_tag
op	29:25	0:0	4	==
call	29:28	29:49	4	MKTAG
arg	29:34	29:37	5	'A'
water	29:34	0:0	6	'A'
arg	29:38	29:41	5	'C'
water	29:38	0:0	6	'C'
arg	29:42	29:45	5	'B'
water	29:42	0:0	6	'B'
arg	29:46	29:49	5	'M'
water	29:46	0:0	6	'M'
stmts	29:52	53:4	3	
water	29:52	0:0	4	{
if	30:8	39:8	4	(avctx -> pix_fmt == PIX_FMT_PAL8 || avctx -> pix_fmt == PIX_FMT_GRAY8)
cond	30:12	30:64	5	avctx -> pix_fmt == PIX_FMT_PAL8 || avctx -> pix_fmt == PIX_FMT_GRAY8
water	30:12	0:0	6	avctx
op	30:17	0:0	6	->
water	30:19	0:0	6	pix_fmt
op	30:27	0:0	6	==
water	30:30	0:0	6	PIX_FMT_PAL8
op	30:43	0:0	6	||
water	30:46	0:0	6	avctx
op	30:51	0:0	6	->
water	30:53	0:0	6	pix_fmt
op	30:61	0:0	6	==
water	30:64	0:0	6	PIX_FMT_GRAY8
stmts	30:79	39:8	5	
water	30:79	0:0	6	{
call	31:12	31:76	6	memset
arg	31:19	31:35	7	s->frame.data[0]
water	31:19	0:0	8	s
op	31:20	0:0	8	->
water	31:22	0:0	8	frame
op	31:27	0:0	8	.
water	31:28	0:0	8	data
op	31:32	0:0	8	[
water	31:33	0:0	8	0
op	31:34	0:0	8	]
arg	31:37	31:38	7	0
water	31:37	0:0	8	0
arg	31:40	31:76	7	avctx->height*s->frame.linesize[0]
water	31:40	0:0	8	avctx
op	31:45	0:0	8	->
water	31:47	0:0	8	height
op	31:54	0:0	8	*
water	31:56	0:0	8	s
op	31:57	0:0	8	->
water	31:59	0:0	8	frame
op	31:64	0:0	8	.
water	31:65	0:0	8	linesize
op	31:73	0:0	8	[
water	31:74	0:0	8	0
op	31:75	0:0	8	]
water	31:77	0:0	6	;
for	32:12	38:12	6	(plane = 0 ;plane < s -> bpp;plane ++)
forinit	32:17	32:26	7	plane = 0 ;
water	32:17	0:0	8	plane
op	32:23	0:0	8	=
water	32:25	0:0	8	0
water	32:26	0:0	8	;
cond	32:28	32:39	7	plane < s -> bpp
water	32:28	0:0	8	plane
op	32:34	0:0	8	<
water	32:36	0:0	8	s
op	32:37	0:0	8	->
water	32:39	0:0	8	bpp
forexpr	32:44	32:49	7	plane ++
water	32:44	0:0	8	plane
op	32:49	0:0	8	++
stmts	32:53	38:12	7	
water	32:53	0:0	8	{
for	33:16	37:16	8	(y = 0 ;y < avctx -> height && buf < buf_end;y ++)
forinit	33:20	33:25	9	y = 0 ;
water	33:20	0:0	10	y
op	33:22	0:0	10	=
water	33:24	0:0	10	0
water	33:25	0:0	10	;
cond	33:27	33:54	9	y < avctx -> height && buf < buf_end
water	33:27	0:0	10	y
op	33:29	0:0	10	<
water	33:31	0:0	10	avctx
op	33:36	0:0	10	->
water	33:38	0:0	10	height
op	33:45	0:0	10	&&
water	33:48	0:0	10	buf
op	33:52	0:0	10	<
water	33:54	0:0	10	buf_end
forexpr	33:63	33:64	9	y ++
water	33:63	0:0	10	y
op	33:64	0:0	10	++
stmts	33:69	37:16	9	
water	33:69	0:0	10	{
decl	34:20	34:78	10	uint8_t	*row
op	34:33	0:0	10	=
op	34:35	0:0	10	&
water	34:36	0:0	10	s
op	34:37	0:0	10	->
water	34:39	0:0	10	frame
op	34:44	0:0	10	.
water	34:45	0:0	10	data
op	34:49	0:0	10	[
water	34:50	0:0	10	0
op	34:51	0:0	10	]
op	34:52	0:0	10	[
water	34:54	0:0	10	y
op	34:55	0:0	10	*
water	34:56	0:0	10	s
op	34:57	0:0	10	->
water	34:59	0:0	10	frame
op	34:64	0:0	10	.
water	34:65	0:0	10	linesize
op	34:73	0:0	10	[
water	34:74	0:0	10	0
op	34:75	0:0	10	]
op	34:77	0:0	10	]
call	35:20	35:84	10	decodeplane8
arg	35:33	35:36	11	row
water	35:33	0:0	12	row
arg	35:38	35:41	11	buf
water	35:38	0:0	12	buf
arg	35:43	35:77	11	FFMIN(s->planesize,buf_end-buf)
call	35:43	35:76	12	FFMIN
arg	35:49	35:61	13	s->planesize
water	35:49	0:0	14	s
op	35:50	0:0	14	->
water	35:52	0:0	14	planesize
arg	35:63	35:76	13	buf_end-buf
water	35:63	0:0	14	buf_end
op	35:71	0:0	14	-
water	35:73	0:0	14	buf
arg	35:79	35:84	11	plane
water	35:79	0:0	12	plane
water	35:85	0:0	10	;
water	36:20	0:0	10	buf
op	36:24	0:0	10	+=
water	36:27	0:0	10	s
op	36:28	0:0	10	->
water	36:30	0:0	10	planesize
water	36:39	0:0	10	;
water	37:16	0:0	10	}
water	38:12	0:0	8	}
water	39:8	0:0	6	}
else	39:10	52:8	4
stmts	39:15	52:8	5	
if	39:15	52:8	6	(s -> ham)
cond	39:19	39:22	7	s -> ham
water	39:19	0:0	8	s
op	39:20	0:0	8	->
water	39:22	0:0	8	ham
stmts	39:27	52:8	7	
water	39:27	0:0	8	{
call	40:12	40:76	8	memset
arg	40:19	40:35	9	s->frame.data[0]
water	40:19	0:0	10	s
op	40:20	0:0	10	->
water	40:22	0:0	10	frame
op	40:27	0:0	10	.
water	40:28	0:0	10	data
op	40:32	0:0	10	[
water	40:33	0:0	10	0
op	40:34	0:0	10	]
arg	40:37	40:38	9	0
water	40:37	0:0	10	0
arg	40:40	40:76	9	avctx->height*s->frame.linesize[0]
water	40:40	0:0	10	avctx
op	40:45	0:0	10	->
water	40:47	0:0	10	height
op	40:54	0:0	10	*
water	40:56	0:0	10	s
op	40:57	0:0	10	->
water	40:59	0:0	10	frame
op	40:64	0:0	10	.
water	40:65	0:0	10	linesize
op	40:73	0:0	10	[
water	40:74	0:0	10	0
op	40:75	0:0	10	]
water	40:77	0:0	8	;
for	41:12	51:12	8	(y = 0 ;y < avctx -> height;y ++)
forinit	41:16	41:21	9	y = 0 ;
water	41:16	0:0	10	y
op	41:18	0:0	10	=
water	41:20	0:0	10	0
water	41:21	0:0	10	;
cond	41:23	41:34	9	y < avctx -> height
water	41:23	0:0	10	y
op	41:25	0:0	10	<
water	41:27	0:0	10	avctx
op	41:32	0:0	10	->
water	41:34	0:0	10	height
forexpr	41:42	41:43	9	y ++
water	41:42	0:0	10	y
op	41:43	0:0	10	++
stmts	41:47	51:12	9	
water	41:47	0:0	10	{
decl	42:16	42:74	10	uint8_t	*row
op	42:29	0:0	10	=
op	42:31	0:0	10	&
water	42:32	0:0	10	s
op	42:33	0:0	10	->
water	42:35	0:0	10	frame
op	42:40	0:0	10	.
water	42:41	0:0	10	data
op	42:45	0:0	10	[
water	42:46	0:0	10	0
op	42:47	0:0	10	]
op	42:48	0:0	10	[
water	42:49	0:0	10	y
op	42:51	0:0	10	*
water	42:53	0:0	10	s
op	42:54	0:0	10	->
water	42:56	0:0	10	frame
op	42:61	0:0	10	.
water	42:62	0:0	10	linesize
op	42:70	0:0	10	[
water	42:71	0:0	10	0
op	42:72	0:0	10	]
op	42:73	0:0	10	]
call	43:16	43:54	10	memset
arg	43:23	43:33	11	s->ham_buf
water	43:23	0:0	12	s
op	43:24	0:0	12	->
water	43:26	0:0	12	ham_buf
arg	43:35	43:36	11	0
water	43:35	0:0	12	0
arg	43:38	43:54	11	s->planesize*8
water	43:38	0:0	12	s
op	43:39	0:0	12	->
water	43:41	0:0	12	planesize
op	43:51	0:0	12	*
water	43:53	0:0	12	8
water	43:55	0:0	10	;
for	44:16	49:16	10	(plane = 0 ;plane < s -> bpp;plane ++)
forinit	44:21	44:30	11	plane = 0 ;
water	44:21	0:0	12	plane
op	44:27	0:0	12	=
water	44:29	0:0	12	0
water	44:30	0:0	12	;
cond	44:32	44:43	11	plane < s -> bpp
water	44:32	0:0	12	plane
op	44:38	0:0	12	<
water	44:40	0:0	12	s
op	44:41	0:0	12	->
water	44:43	0:0	12	bpp
forexpr	44:48	44:53	11	plane ++
water	44:48	0:0	12	plane
op	44:53	0:0	12	++
stmts	44:57	49:16	11	
water	44:57	0:0	12	{
decl	45:20	45:92	12	const uint8_t	*start
op	45:42	0:0	12	=
water	45:44	0:0	12	buf
op	45:48	0:0	12	+
water	45:50	0:0	12	(
water	45:51	0:0	12	plane
op	45:57	0:0	12	*
water	45:59	0:0	12	avctx
op	45:64	0:0	12	->
water	45:66	0:0	12	height
op	45:73	0:0	12	+
water	45:75	0:0	12	y
water	45:76	0:0	12	)
op	45:78	0:0	12	*
water	45:80	0:0	12	s
op	45:81	0:0	12	->
water	45:83	0:0	12	planesize
if	46:20	47:29	12	(start >= buf_end)
cond	46:24	46:33	13	start >= buf_end
water	46:24	0:0	14	start
op	46:30	0:0	14	>=
water	46:33	0:0	14	buf_end
stmts	47:24	47:29	13	
break	47:24	47:29	14	
call	48:20	48:95	12	decodeplane8
arg	48:33	48:43	13	s->ham_buf
water	48:33	0:0	14	s
op	48:34	0:0	14	->
water	48:36	0:0	14	ham_buf
arg	48:45	48:50	13	start
water	48:45	0:0	14	start
arg	48:52	48:88	13	FFMIN(s->planesize,buf_end-start)
call	48:52	48:87	14	FFMIN
arg	48:58	48:70	15	s->planesize
water	48:58	0:0	16	s
op	48:59	0:0	16	->
water	48:61	0:0	16	planesize
arg	48:72	48:87	15	buf_end-start
water	48:72	0:0	16	buf_end
op	48:80	0:0	16	-
water	48:82	0:0	16	start
arg	48:90	48:95	13	plane
water	48:90	0:0	14	plane
water	48:96	0:0	12	;
water	49:16	0:0	12	}
call	50:16	50:92	10	decode_ham_plane32
arg	50:35	50:51	11	(uint32_t*)row
water	50:35	0:0	12	(
water	50:36	0:0	12	uint32_t
op	50:45	0:0	12	*
water	50:46	0:0	12	)
water	50:48	0:0	12	row
arg	50:53	50:63	11	s->ham_buf
water	50:53	0:0	12	s
op	50:54	0:0	12	->
water	50:56	0:0	12	ham_buf
arg	50:65	50:78	11	s->ham_palbuf
water	50:65	0:0	12	s
op	50:66	0:0	12	->
water	50:68	0:0	12	ham_palbuf
arg	50:80	50:92	11	s->planesize
water	50:80	0:0	12	s
op	50:81	0:0	12	->
water	50:83	0:0	12	planesize
water	50:93	0:0	10	;
water	51:12	0:0	10	}
water	52:8	0:0	8	}
water	53:4	0:0	4	}
else	53:6	65:4	2
stmts	53:11	65:4	3	
if	53:11	65:4	4	(avctx -> codec_tag ==MKTAG ('D' ,'E' ,'E' ,'P' ))
cond	53:15	53:56	5	avctx -> codec_tag ==MKTAG ('D' ,'E' ,'E' ,'P' )
water	53:15	0:0	6	avctx
op	53:20	0:0	6	->
water	53:22	0:0	6	codec_tag
op	53:32	0:0	6	==
call	53:35	53:56	6	MKTAG
arg	53:41	53:44	7	'D'
water	53:41	0:0	8	'D'
arg	53:45	53:48	7	'E'
water	53:45	0:0	8	'E'
arg	53:49	53:52	7	'E'
water	53:49	0:0	8	'E'
arg	53:53	53:56	7	'P'
water	53:53	0:0	8	'P'
stmts	53:59	65:4	5	
water	53:59	0:0	6	{
decl	54:8	54:108	6	int	raw_width
op	54:22	0:0	6	=
water	54:24	0:0	6	avctx
op	54:29	0:0	6	->
water	54:31	0:0	6	width
op	54:37	0:0	6	*
water	54:39	0:0	6	(
call	54:40	54:101	7	av_get_bits_per_pixel
arg	54:62	54:101	8	&av_pix_fmt_descriptors[avctx->pix_fmt]
op	54:62	0:0	9	&
water	54:63	0:0	9	av_pix_fmt_descriptors
op	54:85	0:0	9	[
water	54:86	0:0	9	avctx
op	54:91	0:0	9	->
water	54:93	0:0	9	pix_fmt
op	54:100	0:0	9	]
op	54:103	0:0	6	>>
water	54:106	0:0	6	3
water	54:107	0:0	6	)
decl	55:8	55:13	6	int	x
for	56:8	64:8	6	(y = 0 ;y < avctx -> height && buf < buf_end;y ++)
forinit	56:12	56:17	7	y = 0 ;
water	56:12	0:0	8	y
op	56:14	0:0	8	=
water	56:16	0:0	8	0
water	56:17	0:0	8	;
cond	56:19	56:46	7	y < avctx -> height && buf < buf_end
water	56:19	0:0	8	y
op	56:21	0:0	8	<
water	56:23	0:0	8	avctx
op	56:28	0:0	8	->
water	56:30	0:0	8	height
op	56:37	0:0	8	&&
water	56:40	0:0	8	buf
op	56:44	0:0	8	<
water	56:46	0:0	8	buf_end
forexpr	56:55	56:56	7	y ++
water	56:55	0:0	8	y
op	56:56	0:0	8	++
stmts	56:61	64:8	7	
water	56:61	0:0	8	{
decl	57:12	57:70	8	uint8_t	*row
op	57:25	0:0	8	=
op	57:27	0:0	8	&
water	57:28	0:0	8	s
op	57:29	0:0	8	->
water	57:31	0:0	8	frame
op	57:36	0:0	8	.
water	57:37	0:0	8	data
op	57:41	0:0	8	[
water	57:42	0:0	8	0
op	57:43	0:0	8	]
op	57:44	0:0	8	[
water	57:45	0:0	8	y
op	57:47	0:0	8	*
water	57:49	0:0	8	s
op	57:50	0:0	8	->
water	57:52	0:0	8	frame
op	57:57	0:0	8	.
water	57:58	0:0	8	linesize
op	57:66	0:0	8	[
water	57:67	0:0	8	0
op	57:68	0:0	8	]
op	57:69	0:0	8	]
call	58:12	58:60	8	memcpy
arg	58:19	58:22	9	row
water	58:19	0:0	10	row
arg	58:24	58:27	9	buf
water	58:24	0:0	10	buf
arg	58:29	58:60	9	FFMIN(raw_width,buf_end-buf)
call	58:29	58:59	10	FFMIN
arg	58:35	58:44	11	raw_width
water	58:35	0:0	12	raw_width
arg	58:46	58:59	11	buf_end-buf
water	58:46	0:0	12	buf_end
op	58:54	0:0	12	-
water	58:56	0:0	12	buf
water	58:61	0:0	8	;
water	59:12	0:0	8	buf
op	59:16	0:0	8	+=
water	59:19	0:0	8	raw_width
water	59:28	0:0	8	;
if	60:12	63:12	8	(avctx -> pix_fmt == PIX_FMT_BGR32)
cond	60:16	60:34	9	avctx -> pix_fmt == PIX_FMT_BGR32
water	60:16	0:0	10	avctx
op	60:21	0:0	10	->
water	60:23	0:0	10	pix_fmt
op	60:31	0:0	10	==
water	60:34	0:0	10	PIX_FMT_BGR32
stmts	60:49	63:12	9	
water	60:49	0:0	10	{
for	61:16	62:82	10	(x = 0 ;x < avctx -> width;x ++)
forinit	61:20	61:25	11	x = 0 ;
water	61:20	0:0	12	x
op	61:22	0:0	12	=
water	61:24	0:0	12	0
water	61:25	0:0	12	;
cond	61:27	61:38	11	x < avctx -> width
water	61:27	0:0	12	x
op	61:29	0:0	12	<
water	61:31	0:0	12	avctx
op	61:36	0:0	12	->
water	61:38	0:0	12	width
forexpr	61:45	61:46	11	x ++
water	61:45	0:0	12	x
op	61:46	0:0	12	++
stmts	62:20	62:82	11	
water	62:20	0:0	12	row
op	62:23	0:0	12	[
water	62:24	0:0	12	4
op	62:26	0:0	12	*
water	62:28	0:0	12	x
op	62:30	0:0	12	+
water	62:32	0:0	12	3
op	62:33	0:0	12	]
op	62:35	0:0	12	=
water	62:37	0:0	12	row
op	62:40	0:0	12	[
water	62:41	0:0	12	4
op	62:43	0:0	12	*
water	62:45	0:0	12	x
op	62:47	0:0	12	+
water	62:49	0:0	12	3
op	62:50	0:0	12	]
op	62:52	0:0	12	&
water	62:54	0:0	12	0
water	62:55	0:0	12	xF0
op	62:59	0:0	12	|
water	62:61	0:0	12	(
water	62:62	0:0	12	row
op	62:65	0:0	12	[
water	62:66	0:0	12	4
op	62:68	0:0	12	*
water	62:70	0:0	12	x
op	62:72	0:0	12	+
water	62:74	0:0	12	3
op	62:75	0:0	12	]
op	62:77	0:0	12	>>
water	62:80	0:0	12	4
water	62:81	0:0	12	)
water	62:82	0:0	12	;
water	63:12	0:0	10	}
water	64:8	0:0	8	}
water	65:4	0:0	6	}
else	65:6	95:4	2
stmts	65:11	95:4	3	
if	65:11	95:4	4	(avctx -> codec_tag ==MKTAG ('I' ,'L' ,'B' ,'M' ))
cond	65:15	65:56	5	avctx -> codec_tag ==MKTAG ('I' ,'L' ,'B' ,'M' )
water	65:15	0:0	6	avctx
op	65:20	0:0	6	->
water	65:22	0:0	6	codec_tag
op	65:32	0:0	6	==
call	65:35	65:56	6	MKTAG
arg	65:41	65:44	7	'I'
water	65:41	0:0	8	'I'
arg	65:45	65:48	7	'L'
water	65:45	0:0	8	'L'
arg	65:49	65:52	7	'B'
water	65:49	0:0	8	'B'
arg	65:53	65:56	7	'M'
water	65:53	0:0	8	'M'
stmts	65:59	95:4	5	
water	65:59	0:0	6	{
if	66:8	75:8	6	(avctx -> pix_fmt == PIX_FMT_PAL8 || avctx -> pix_fmt == PIX_FMT_GRAY8)
cond	66:12	66:64	7	avctx -> pix_fmt == PIX_FMT_PAL8 || avctx -> pix_fmt == PIX_FMT_GRAY8
water	66:12	0:0	8	avctx
op	66:17	0:0	8	->
water	66:19	0:0	8	pix_fmt
op	66:27	0:0	8	==
water	66:30	0:0	8	PIX_FMT_PAL8
op	66:43	0:0	8	||
water	66:46	0:0	8	avctx
op	66:51	0:0	8	->
water	66:53	0:0	8	pix_fmt
op	66:61	0:0	8	==
water	66:64	0:0	8	PIX_FMT_GRAY8
stmts	66:79	75:8	7	
water	66:79	0:0	8	{
for	67:12	74:12	8	(y = 0 ;y < avctx -> height;y ++)
forinit	67:16	67:21	9	y = 0 ;
water	67:16	0:0	10	y
op	67:18	0:0	10	=
water	67:20	0:0	10	0
water	67:21	0:0	10	;
cond	67:23	67:34	9	y < avctx -> height
water	67:23	0:0	10	y
op	67:25	0:0	10	<
water	67:27	0:0	10	avctx
op	67:32	0:0	10	->
water	67:34	0:0	10	height
forexpr	67:42	67:43	9	y ++
water	67:42	0:0	10	y
op	67:43	0:0	10	++
stmts	67:48	74:12	9	
water	67:48	0:0	10	{
decl	68:16	68:74	10	uint8_t	*row
op	68:29	0:0	10	=
op	68:31	0:0	10	&
water	68:32	0:0	10	s
op	68:33	0:0	10	->
water	68:35	0:0	10	frame
op	68:40	0:0	10	.
water	68:41	0:0	10	data
op	68:45	0:0	10	[
water	68:46	0:0	10	0
op	68:47	0:0	10	]
op	68:48	0:0	10	[
water	68:50	0:0	10	y
op	68:51	0:0	10	*
water	68:52	0:0	10	s
op	68:53	0:0	10	->
water	68:55	0:0	10	frame
op	68:60	0:0	10	.
water	68:61	0:0	10	linesize
op	68:69	0:0	10	[
water	68:70	0:0	10	0
op	68:71	0:0	10	]
op	68:73	0:0	10	]
call	69:16	69:43	10	memset
arg	69:23	69:26	11	row
water	69:23	0:0	12	row
arg	69:28	69:29	11	0
water	69:28	0:0	12	0
arg	69:31	69:43	11	avctx->width
water	69:31	0:0	12	avctx
op	69:36	0:0	12	->
water	69:38	0:0	12	width
water	69:44	0:0	10	;
for	70:16	73:16	10	(plane = 0 ;plane < s -> bpp && buf < buf_end;plane ++)
forinit	70:21	70:30	11	plane = 0 ;
water	70:21	0:0	12	plane
op	70:27	0:0	12	=
water	70:29	0:0	12	0
water	70:30	0:0	12	;
cond	70:32	70:56	11	plane < s -> bpp && buf < buf_end
water	70:32	0:0	12	plane
op	70:38	0:0	12	<
water	70:40	0:0	12	s
op	70:41	0:0	12	->
water	70:43	0:0	12	bpp
op	70:47	0:0	12	&&
water	70:50	0:0	12	buf
op	70:54	0:0	12	<
water	70:56	0:0	12	buf_end
forexpr	70:65	70:70	11	plane ++
water	70:65	0:0	12	plane
op	70:70	0:0	12	++
stmts	70:74	73:16	11	
water	70:74	0:0	12	{
call	71:20	71:84	12	decodeplane8
arg	71:33	71:36	13	row
water	71:33	0:0	14	row
arg	71:38	71:41	13	buf
water	71:38	0:0	14	buf
arg	71:43	71:77	13	FFMIN(s->planesize,buf_end-buf)
call	71:43	71:76	14	FFMIN
arg	71:49	71:61	15	s->planesize
water	71:49	0:0	16	s
op	71:50	0:0	16	->
water	71:52	0:0	16	planesize
arg	71:63	71:76	15	buf_end-buf
water	71:63	0:0	16	buf_end
op	71:71	0:0	16	-
water	71:73	0:0	16	buf
arg	71:79	71:84	13	plane
water	71:79	0:0	14	plane
water	71:85	0:0	12	;
water	72:20	0:0	12	buf
op	72:24	0:0	12	+=
water	72:27	0:0	12	s
op	72:28	0:0	12	->
water	72:30	0:0	12	planesize
water	72:39	0:0	12	;
water	73:16	0:0	12	}
water	74:12	0:0	10	}
water	75:8	0:0	8	}
else	75:10	85:8	6
stmts	75:15	85:8	7	
if	75:15	85:8	8	(s -> ham)
cond	75:19	75:22	9	s -> ham
water	75:19	0:0	10	s
op	75:20	0:0	10	->
water	75:22	0:0	10	ham
stmts	75:27	85:8	9	
water	75:27	0:0	10	{
for	76:12	84:12	10	(y = 0 ;y < avctx -> height;y ++)
forinit	76:17	76:22	11	y = 0 ;
water	76:17	0:0	12	y
op	76:19	0:0	12	=
water	76:21	0:0	12	0
water	76:22	0:0	12	;
cond	76:24	76:35	11	y < avctx -> height
water	76:24	0:0	12	y
op	76:26	0:0	12	<
water	76:28	0:0	12	avctx
op	76:33	0:0	12	->
water	76:35	0:0	12	height
forexpr	76:43	76:44	11	y ++
water	76:43	0:0	12	y
op	76:44	0:0	12	++
stmts	76:48	84:12	11	
water	76:48	0:0	12	{
decl	77:16	77:74	12	uint8_t	*row
op	77:29	0:0	12	=
op	77:31	0:0	12	&
water	77:32	0:0	12	s
op	77:33	0:0	12	->
water	77:35	0:0	12	frame
op	77:40	0:0	12	.
water	77:41	0:0	12	data
op	77:45	0:0	12	[
water	77:46	0:0	12	0
op	77:47	0:0	12	]
op	77:48	0:0	12	[
water	77:50	0:0	12	y
op	77:51	0:0	12	*
water	77:52	0:0	12	s
op	77:53	0:0	12	->
water	77:55	0:0	12	frame
op	77:60	0:0	12	.
water	77:61	0:0	12	linesize
op	77:69	0:0	12	[
water	77:70	0:0	12	0
op	77:71	0:0	12	]
op	77:73	0:0	12	]
call	78:16	78:54	12	memset
arg	78:23	78:33	13	s->ham_buf
water	78:23	0:0	14	s
op	78:24	0:0	14	->
water	78:26	0:0	14	ham_buf
arg	78:35	78:36	13	0
water	78:35	0:0	14	0
arg	78:38	78:54	13	s->planesize*8
water	78:38	0:0	14	s
op	78:39	0:0	14	->
water	78:41	0:0	14	planesize
op	78:51	0:0	14	*
water	78:53	0:0	14	8
water	78:55	0:0	12	;
for	79:16	82:16	12	(plane = 0 ;plane < s -> bpp && buf < buf_end;plane ++)
forinit	79:21	79:30	13	plane = 0 ;
water	79:21	0:0	14	plane
op	79:27	0:0	14	=
water	79:29	0:0	14	0
water	79:30	0:0	14	;
cond	79:32	79:56	13	plane < s -> bpp && buf < buf_end
water	79:32	0:0	14	plane
op	79:38	0:0	14	<
water	79:40	0:0	14	s
op	79:41	0:0	14	->
water	79:43	0:0	14	bpp
op	79:47	0:0	14	&&
water	79:50	0:0	14	buf
op	79:54	0:0	14	<
water	79:56	0:0	14	buf_end
forexpr	79:65	79:70	13	plane ++
water	79:65	0:0	14	plane
op	79:70	0:0	14	++
stmts	79:74	82:16	13	
water	79:74	0:0	14	{
call	80:20	80:91	14	decodeplane8
arg	80:33	80:43	15	s->ham_buf
water	80:33	0:0	16	s
op	80:34	0:0	16	->
water	80:36	0:0	16	ham_buf
arg	80:45	80:48	15	buf
water	80:45	0:0	16	buf
arg	80:50	80:84	15	FFMIN(s->planesize,buf_end-buf)
call	80:50	80:83	16	FFMIN
arg	80:56	80:68	17	s->planesize
water	80:56	0:0	18	s
op	80:57	0:0	18	->
water	80:59	0:0	18	planesize
arg	80:70	80:83	17	buf_end-buf
water	80:70	0:0	18	buf_end
op	80:78	0:0	18	-
water	80:80	0:0	18	buf
arg	80:86	80:91	15	plane
water	80:86	0:0	16	plane
water	80:92	0:0	14	;
water	81:20	0:0	14	buf
op	81:24	0:0	14	+=
water	81:27	0:0	14	s
op	81:28	0:0	14	->
water	81:30	0:0	14	planesize
water	81:39	0:0	14	;
water	82:16	0:0	14	}
call	83:16	83:92	12	decode_ham_plane32
arg	83:35	83:51	13	(uint32_t*)row
water	83:35	0:0	14	(
water	83:36	0:0	14	uint32_t
op	83:45	0:0	14	*
water	83:46	0:0	14	)
water	83:48	0:0	14	row
arg	83:53	83:63	13	s->ham_buf
water	83:53	0:0	14	s
op	83:54	0:0	14	->
water	83:56	0:0	14	ham_buf
arg	83:65	83:78	13	s->ham_palbuf
water	83:65	0:0	14	s
op	83:66	0:0	14	->
water	83:68	0:0	14	ham_palbuf
arg	83:80	83:92	13	s->planesize
water	83:80	0:0	14	s
op	83:81	0:0	14	->
water	83:83	0:0	14	planesize
water	83:93	0:0	12	;
water	84:12	0:0	12	}
water	85:8	0:0	10	}
else	85:10	94:8	6
stmts	85:15	94:8	7	
water	85:15	0:0	8	{
for	86:12	93:12	8	(y = 0 ;y < avctx -> height;y ++)
forinit	86:16	86:21	9	y = 0 ;
water	86:16	0:0	10	y
op	86:18	0:0	10	=
water	86:20	0:0	10	0
water	86:21	0:0	10	;
cond	86:23	86:34	9	y < avctx -> height
water	86:23	0:0	10	y
op	86:25	0:0	10	<
water	86:27	0:0	10	avctx
op	86:32	0:0	10	->
water	86:34	0:0	10	height
forexpr	86:42	86:43	9	y ++
water	86:42	0:0	10	y
op	86:43	0:0	10	++
stmts	86:48	93:12	9	
water	86:48	0:0	10	{
decl	87:16	87:72	10	uint8_t	*row
op	87:29	0:0	10	=
op	87:31	0:0	10	&
water	87:32	0:0	10	s
op	87:33	0:0	10	->
water	87:35	0:0	10	frame
op	87:40	0:0	10	.
water	87:41	0:0	10	data
op	87:45	0:0	10	[
water	87:46	0:0	10	0
op	87:47	0:0	10	]
op	87:48	0:0	10	[
water	87:49	0:0	10	y
op	87:50	0:0	10	*
water	87:51	0:0	10	s
op	87:52	0:0	10	->
water	87:54	0:0	10	frame
op	87:59	0:0	10	.
water	87:60	0:0	10	linesize
op	87:68	0:0	10	[
water	87:69	0:0	10	0
op	87:70	0:0	10	]
op	87:71	0:0	10	]
call	88:16	88:48	10	memset
arg	88:23	88:26	11	row
water	88:23	0:0	12	row
arg	88:28	88:29	11	0
water	88:28	0:0	12	0
arg	88:31	88:48	11	avctx->width<<2
water	88:31	0:0	12	avctx
op	88:36	0:0	12	->
water	88:38	0:0	12	width
op	88:44	0:0	12	<<
water	88:47	0:0	12	2
water	88:49	0:0	10	;
for	89:16	92:16	10	(plane = 0 ;plane < s -> bpp && buf < buf_end;plane ++)
forinit	89:21	89:30	11	plane = 0 ;
water	89:21	0:0	12	plane
op	89:27	0:0	12	=
water	89:29	0:0	12	0
water	89:30	0:0	12	;
cond	89:32	89:56	11	plane < s -> bpp && buf < buf_end
water	89:32	0:0	12	plane
op	89:38	0:0	12	<
water	89:40	0:0	12	s
op	89:41	0:0	12	->
water	89:43	0:0	12	bpp
op	89:47	0:0	12	&&
water	89:50	0:0	12	buf
op	89:54	0:0	12	<
water	89:56	0:0	12	buf_end
forexpr	89:65	89:70	11	plane ++
water	89:65	0:0	12	plane
op	89:70	0:0	12	++
stmts	89:74	92:16	11	
water	89:74	0:0	12	{
call	90:20	90:98	12	decodeplane32
arg	90:34	90:50	13	(uint32_t*)row
water	90:34	0:0	14	(
water	90:35	0:0	14	uint32_t
op	90:44	0:0	14	*
water	90:45	0:0	14	)
water	90:47	0:0	14	row
arg	90:52	90:55	13	buf
water	90:52	0:0	14	buf
arg	90:57	90:91	13	FFMIN(s->planesize,buf_end-buf)
call	90:57	90:90	14	FFMIN
arg	90:63	90:75	15	s->planesize
water	90:63	0:0	16	s
op	90:64	0:0	16	->
water	90:66	0:0	16	planesize
arg	90:77	90:90	15	buf_end-buf
water	90:77	0:0	16	buf_end
op	90:85	0:0	16	-
water	90:87	0:0	16	buf
arg	90:93	90:98	13	plane
water	90:93	0:0	14	plane
water	90:99	0:0	12	;
water	91:20	0:0	12	buf
op	91:24	0:0	12	+=
water	91:27	0:0	12	s
op	91:28	0:0	12	->
water	91:30	0:0	12	planesize
water	91:39	0:0	12	;
water	92:16	0:0	12	}
water	93:12	0:0	10	}
water	94:8	0:0	8	}
water	95:4	0:0	6	}
else	95:6	113:4	2
stmts	95:11	113:4	3	
if	95:11	113:4	4	(avctx -> codec_tag ==MKTAG ('P' ,'B' ,'M' ,' ' ))
cond	95:15	95:56	5	avctx -> codec_tag ==MKTAG ('P' ,'B' ,'M' ,' ' )
water	95:15	0:0	6	avctx
op	95:20	0:0	6	->
water	95:22	0:0	6	codec_tag
op	95:32	0:0	6	==
call	95:35	95:56	6	MKTAG
arg	95:41	95:44	7	'P'
water	95:41	0:0	8	'P'
arg	95:45	95:48	7	'B'
water	95:45	0:0	8	'B'
arg	95:49	95:52	7	'M'
water	95:49	0:0	8	'M'
arg	95:53	95:56	7	' '
water	95:53	0:0	8	' '
stmts	95:59	113:4	5	
water	95:59	0:0	6	{
if	96:8	102:8	6	(avctx -> pix_fmt == PIX_FMT_PAL8 || avctx -> pix_fmt == PIX_FMT_GRAY8)
cond	96:12	96:64	7	avctx -> pix_fmt == PIX_FMT_PAL8 || avctx -> pix_fmt == PIX_FMT_GRAY8
water	96:12	0:0	8	avctx
op	96:17	0:0	8	->
water	96:19	0:0	8	pix_fmt
op	96:27	0:0	8	==
water	96:30	0:0	8	PIX_FMT_PAL8
op	96:43	0:0	8	||
water	96:46	0:0	8	avctx
op	96:51	0:0	8	->
water	96:53	0:0	8	pix_fmt
op	96:61	0:0	8	==
water	96:64	0:0	8	PIX_FMT_GRAY8
stmts	96:79	102:8	7	
water	96:79	0:0	8	{
for	97:12	101:12	8	(y = 0 ;y < avctx -> height && buf_end > buf;y ++)
forinit	97:16	97:21	9	y = 0 ;
water	97:16	0:0	10	y
op	97:18	0:0	10	=
water	97:20	0:0	10	0
water	97:21	0:0	10	;
cond	97:23	97:54	9	y < avctx -> height && buf_end > buf
water	97:23	0:0	10	y
op	97:25	0:0	10	<
water	97:27	0:0	10	avctx
op	97:32	0:0	10	->
water	97:34	0:0	10	height
op	97:41	0:0	10	&&
water	97:44	0:0	10	buf_end
op	97:52	0:0	10	>
water	97:54	0:0	10	buf
forexpr	97:59	97:60	9	y ++
water	97:59	0:0	10	y
op	97:60	0:0	10	++
stmts	97:65	101:12	9	
water	97:65	0:0	10	{
decl	98:16	98:74	10	uint8_t	*row
op	98:29	0:0	10	=
op	98:31	0:0	10	&
water	98:32	0:0	10	s
op	98:33	0:0	10	->
water	98:35	0:0	10	frame
op	98:40	0:0	10	.
water	98:41	0:0	10	data
op	98:45	0:0	10	[
water	98:46	0:0	10	0
op	98:47	0:0	10	]
op	98:48	0:0	10	[
water	98:49	0:0	10	y
op	98:51	0:0	10	*
water	98:53	0:0	10	s
op	98:54	0:0	10	->
water	98:56	0:0	10	frame
op	98:61	0:0	10	.
water	98:62	0:0	10	linesize
op	98:70	0:0	10	[
water	98:71	0:0	10	0
op	98:72	0:0	10	]
op	98:73	0:0	10	]
call	99:16	99:67	10	memcpy
arg	99:23	99:26	11	row
water	99:23	0:0	12	row
arg	99:28	99:31	11	buf
water	99:28	0:0	12	buf
arg	99:33	99:67	11	FFMIN(avctx->width,buf_end-buf)
call	99:33	99:66	12	FFMIN
arg	99:39	99:51	13	avctx->width
water	99:39	0:0	14	avctx
op	99:44	0:0	14	->
water	99:46	0:0	14	width
arg	99:53	99:66	13	buf_end-buf
water	99:53	0:0	14	buf_end
op	99:61	0:0	14	-
water	99:63	0:0	14	buf
water	99:68	0:0	10	;
water	100:16	0:0	10	buf
op	100:20	0:0	10	+=
water	100:23	0:0	10	avctx
op	100:28	0:0	10	->
water	100:30	0:0	10	width
op	100:36	0:0	10	+
water	100:38	0:0	10	(
water	100:39	0:0	10	avctx
op	100:44	0:0	10	->
water	100:46	0:0	10	width
op	100:52	0:0	10	%
water	100:54	0:0	10	2
water	100:55	0:0	10	)
water	100:56	0:0	10	;
water	101:12	0:0	10	}
water	102:8	0:0	8	}
else	102:10	109:8	6
stmts	102:15	109:8	7	
if	102:15	109:8	8	(s -> ham)
cond	102:19	102:22	9	s -> ham
water	102:19	0:0	10	s
op	102:20	0:0	10	->
water	102:22	0:0	10	ham
stmts	102:27	109:8	9	
water	102:27	0:0	10	{
for	103:12	108:12	10	(y = 0 ;y < avctx -> height && buf_end > buf;y ++)
forinit	103:17	103:22	11	y = 0 ;
water	103:17	0:0	12	y
op	103:19	0:0	12	=
water	103:21	0:0	12	0
water	103:22	0:0	12	;
cond	103:24	103:55	11	y < avctx -> height && buf_end > buf
water	103:24	0:0	12	y
op	103:26	0:0	12	<
water	103:28	0:0	12	avctx
op	103:33	0:0	12	->
water	103:35	0:0	12	height
op	103:42	0:0	12	&&
water	103:45	0:0	12	buf_end
op	103:53	0:0	12	>
water	103:55	0:0	12	buf
forexpr	103:60	103:61	11	y ++
water	103:60	0:0	12	y
op	103:61	0:0	12	++
stmts	103:65	108:12	11	
water	103:65	0:0	12	{
decl	104:16	104:74	12	uint8_t	*row
op	104:29	0:0	12	=
op	104:31	0:0	12	&
water	104:32	0:0	12	s
op	104:33	0:0	12	->
water	104:35	0:0	12	frame
op	104:40	0:0	12	.
water	104:41	0:0	12	data
op	104:45	0:0	12	[
water	104:46	0:0	12	0
op	104:47	0:0	12	]
op	104:48	0:0	12	[
water	104:50	0:0	12	y
op	104:51	0:0	12	*
water	104:52	0:0	12	s
op	104:53	0:0	12	->
water	104:55	0:0	12	frame
op	104:60	0:0	12	.
water	104:61	0:0	12	linesize
op	104:69	0:0	12	[
water	104:70	0:0	12	0
op	104:71	0:0	12	]
op	104:73	0:0	12	]
call	105:16	105:74	12	memcpy
arg	105:23	105:33	13	s->ham_buf
water	105:23	0:0	14	s
op	105:24	0:0	14	->
water	105:26	0:0	14	ham_buf
arg	105:35	105:38	13	buf
water	105:35	0:0	14	buf
arg	105:40	105:74	13	FFMIN(avctx->width,buf_end-buf)
call	105:40	105:73	14	FFMIN
arg	105:46	105:58	15	avctx->width
water	105:46	0:0	16	avctx
op	105:51	0:0	16	->
water	105:53	0:0	16	width
arg	105:60	105:73	15	buf_end-buf
water	105:60	0:0	16	buf_end
op	105:68	0:0	16	-
water	105:70	0:0	16	buf
water	105:75	0:0	12	;
water	106:16	0:0	12	buf
op	106:20	0:0	12	+=
water	106:23	0:0	12	avctx
op	106:28	0:0	12	->
water	106:30	0:0	12	width
op	106:36	0:0	12	+
water	106:38	0:0	12	(
water	106:39	0:0	12	avctx
op	106:44	0:0	12	->
water	106:46	0:0	12	width
op	106:52	0:0	12	&
water	106:54	0:0	12	1
water	106:55	0:0	12	)
water	106:56	0:0	12	;
call	107:16	107:92	12	decode_ham_plane32
arg	107:35	107:51	13	(uint32_t*)row
water	107:35	0:0	14	(
water	107:36	0:0	14	uint32_t
op	107:45	0:0	14	*
water	107:46	0:0	14	)
water	107:48	0:0	14	row
arg	107:53	107:63	13	s->ham_buf
water	107:53	0:0	14	s
op	107:54	0:0	14	->
water	107:56	0:0	14	ham_buf
arg	107:65	107:78	13	s->ham_palbuf
water	107:65	0:0	14	s
op	107:66	0:0	14	->
water	107:68	0:0	14	ham_palbuf
arg	107:80	107:92	13	s->planesize
water	107:80	0:0	14	s
op	107:81	0:0	14	->
water	107:83	0:0	14	planesize
water	107:93	0:0	12	;
water	108:12	0:0	12	}
water	109:8	0:0	10	}
else	109:10	112:8	6
stmts	109:15	112:8	7	
water	109:15	0:0	8	{
call	110:12	110:60	8	av_log_ask_for_sample
arg	110:34	110:39	9	avctx
water	110:34	0:0	10	avctx
arg	110:41	110:60	9	"unsupported bpp\n"
water	110:41	0:0	10	"unsupported bpp\n"
water	110:61	0:0	8	;
return	111:12	111:38	8	AVERROR_INVALIDDATA
water	111:19	0:0	9	AVERROR_INVALIDDATA
water	112:8	0:0	8	}
water	113:4	0:0	6	}
op	115:4	0:0	2	*
water	115:5	0:0	2	data_size
op	115:15	0:0	2	=
op	115:17	0:0	2	sizeof
water	115:23	0:0	2	(
water	115:24	0:0	2	AVFrame
water	115:31	0:0	2	)
water	115:32	0:0	2	;
op	116:4	0:0	2	*
water	116:5	0:0	2	(
water	116:6	0:0	2	AVFrame
op	116:13	0:0	2	*
water	116:14	0:0	2	)
water	116:15	0:0	2	data
op	116:20	0:0	2	=
water	116:22	0:0	2	s
op	116:23	0:0	2	->
water	116:25	0:0	2	frame
water	116:30	0:0	2	;
return	117:4	117:19	2	buf_size
water	117:11	0:0	3	buf_size
