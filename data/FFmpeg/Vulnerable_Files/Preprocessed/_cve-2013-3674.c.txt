func	2:0	96:0	0	static int	cdg_decode_frame
params	2:27	0:0	1	
param	2:28	2:49	2	AVCodecContext *	avctx
param	3:28	3:38	2	void *	data
param	3:40	3:54	2	int *	got_frame
param	3:56	3:71	2	AVPacket *	avpkt
stmnts	0:0	95:19	1	
decl	5:4	5:36	2	const uint8_t	*buf
op	5:23	0:0	2	=
water	5:25	0:0	2	avpkt
op	5:30	0:0	2	->
water	5:32	0:0	2	data
decl	6:4	6:36	2	int	buf_size
op	6:23	0:0	2	=
water	6:25	0:0	2	avpkt
op	6:30	0:0	2	->
water	6:32	0:0	2	size
decl	7:4	7:11	2	int	ret
decl	8:4	8:25	2	uint8_t	command
water	8:19	0:0	2	,
decl	8:4	8:25	2	uint8_t	inst
decl	9:4	9:35	2	uint8_t	cdg_data[CDG_DATA_SIZE]
decl	10:4	10:21	2	AVFrame	new_frame
decl	11:4	11:44	2	CDGraphicsContext	*cc
op	11:26	0:0	2	=
water	11:28	0:0	2	avctx
op	11:33	0:0	2	->
water	11:35	0:0	2	priv_data
if	13:4	16:4	2	(buf_size < CDG_MINIMUM_PKT_SIZE)
cond	13:8	13:19	3	buf_size < CDG_MINIMUM_PKT_SIZE
water	13:8	0:0	4	buf_size
op	13:17	0:0	4	<
water	13:19	0:0	4	CDG_MINIMUM_PKT_SIZE
stmts	13:41	16:4	3	
water	13:41	0:0	4	{
call	14:8	14:68	4	av_log
arg	14:15	14:20	5	avctx
water	14:15	0:0	6	avctx
arg	14:22	14:34	5	AV_LOG_ERROR
water	14:22	0:0	6	AV_LOG_ERROR
arg	14:36	14:68	5	"buffer too small for decoder\n"
water	14:36	0:0	6	"buffer too small for decoder\n"
water	14:69	0:0	4	;
return	15:8	15:30	4	AVERROR(EINVAL)
call	15:15	15:29	5	AVERROR
arg	15:23	15:29	6	EINVAL
water	15:23	0:0	7	EINVAL
water	16:4	0:0	4	}
if	17:4	20:4	2	(buf_size > CDG_HEADER_SIZE + CDG_DATA_SIZE)
cond	17:8	17:37	3	buf_size > CDG_HEADER_SIZE + CDG_DATA_SIZE
water	17:8	0:0	4	buf_size
op	17:17	0:0	4	>
water	17:19	0:0	4	CDG_HEADER_SIZE
op	17:35	0:0	4	+
water	17:37	0:0	4	CDG_DATA_SIZE
stmts	17:52	20:4	3	
water	17:52	0:0	4	{
call	18:8	18:66	4	av_log
arg	18:15	18:20	5	avctx
water	18:15	0:0	6	avctx
arg	18:22	18:34	5	AV_LOG_ERROR
water	18:22	0:0	6	AV_LOG_ERROR
arg	18:36	18:66	5	"buffer too big for decoder\n"
water	18:36	0:0	6	"buffer too big for decoder\n"
water	18:67	0:0	4	;
return	19:8	19:30	4	AVERROR(EINVAL)
call	19:15	19:29	5	AVERROR
arg	19:23	19:29	6	EINVAL
water	19:23	0:0	7	EINVAL
water	20:4	0:0	4	}
water	22:4	0:0	2	ret
op	22:8	0:0	2	=
call	22:10	22:47	2	avctx->reget_buffer
arg	22:30	22:35	3	avctx
water	22:30	0:0	4	avctx
arg	22:37	22:47	3	&cc->frame
op	22:37	0:0	4	&
water	22:38	0:0	4	cc
op	22:40	0:0	4	->
water	22:42	0:0	4	frame
water	22:48	0:0	2	;
if	23:4	26:4	2	(ret)
cond	23:8	23:8	3	ret
water	23:8	0:0	4	ret
stmts	23:13	26:4	3	
water	23:13	0:0	4	{
call	24:8	24:61	4	av_log
arg	24:15	24:20	5	avctx
water	24:15	0:0	6	avctx
arg	24:22	24:34	5	AV_LOG_ERROR
water	24:22	0:0	6	AV_LOG_ERROR
arg	24:36	24:61	5	"reget_buffer() failed\n"
water	24:36	0:0	6	"reget_buffer() failed\n"
water	24:62	0:0	4	;
return	25:8	25:18	4	ret
water	25:15	0:0	5	ret
water	26:4	0:0	4	}
water	28:4	0:0	2	command
op	28:12	0:0	2	=
call	28:14	28:38	2	bytestream_get_byte
arg	28:34	28:38	3	&buf
op	28:34	0:0	4	&
water	28:35	0:0	4	buf
water	28:39	0:0	2	;
water	29:4	0:0	2	inst
op	29:12	0:0	2	=
call	29:14	29:38	2	bytestream_get_byte
arg	29:34	29:38	3	&buf
op	29:34	0:0	4	&
water	29:35	0:0	4	buf
water	29:39	0:0	2	;
water	30:4	0:0	2	inst
op	30:12	0:0	2	&=
water	30:15	0:0	2	CDG_MASK
water	30:23	0:0	2	;
water	31:4	0:0	2	buf
op	31:8	0:0	2	+=
water	31:11	0:0	2	2
water	31:12	0:0	2	;
call	32:4	32:68	2	bytestream_get_buffer
arg	32:26	32:30	3	&buf
op	32:26	0:0	4	&
water	32:27	0:0	4	buf
arg	32:32	32:40	3	cdg_data
water	32:32	0:0	4	cdg_data
arg	32:42	32:68	3	buf_size-CDG_HEADER_SIZE
water	32:42	0:0	4	buf_size
op	32:51	0:0	4	-
water	32:53	0:0	4	CDG_HEADER_SIZE
water	32:69	0:0	2	;
if	34:4	89:4	2	(( command & CDG_MASK ) == CDG_COMMAND)
cond	34:8	34:32	3	( command & CDG_MASK ) == CDG_COMMAND
water	34:8	0:0	4	(
water	34:9	0:0	4	command
op	34:17	0:0	4	&
water	34:19	0:0	4	CDG_MASK
water	34:27	0:0	4	)
op	34:29	0:0	4	==
water	34:32	0:0	4	CDG_COMMAND
stmts	34:45	89:4	3	
water	34:45	0:0	4	{
switch	35:8	86:8	4	(inst)
cond	35:16	35:16	5	inst
water	35:16	0:0	6	inst
stmts	35:22	86:8	5	
water	35:22	0:0	6	{
label	36:8	36:35	6	case CDG_INST_MEMORY_PRESET :
if	37:12	39:63	6	(! ( cdg_data [ 1 ] & 0 x0F ))
cond	37:16	37:36	7	! ( cdg_data [ 1 ] & 0 x0F )
op	37:16	0:0	8	!
water	37:17	0:0	8	(
water	37:18	0:0	8	cdg_data
op	37:26	0:0	8	[
water	37:27	0:0	8	1
op	37:28	0:0	8	]
op	37:30	0:0	8	&
water	37:32	0:0	8	0
water	37:33	0:0	8	x0F
water	37:36	0:0	8	)
stmts	38:16	39:63	7	
call	38:16	39:62	8	memset
arg	38:23	38:40	9	cc->frame.data[0]
water	38:23	0:0	10	cc
op	38:25	0:0	10	->
water	38:27	0:0	10	frame
op	38:32	0:0	10	.
water	38:33	0:0	10	data
op	38:37	0:0	10	[
water	38:38	0:0	10	0
op	38:39	0:0	10	]
arg	38:42	38:60	9	cdg_data[0]&0x0F
water	38:42	0:0	10	cdg_data
op	38:50	0:0	10	[
water	38:51	0:0	10	0
op	38:52	0:0	10	]
op	38:54	0:0	10	&
water	38:56	0:0	10	0
water	38:57	0:0	10	x0F
arg	39:23	39:62	9	cc->frame.linesize[0]*CDG_FULL_HEIGHT
water	39:23	0:0	10	cc
op	39:25	0:0	10	->
water	39:27	0:0	10	frame
op	39:32	0:0	10	.
water	39:33	0:0	10	linesize
op	39:41	0:0	10	[
water	39:42	0:0	10	0
op	39:43	0:0	10	]
op	39:45	0:0	10	*
water	39:47	0:0	10	CDG_FULL_HEIGHT
water	39:63	0:0	8	;
break	40:12	40:17	6	
label	41:8	41:33	6	case CDG_INST_LOAD_PAL_LO :
label	42:8	42:35	6	case CDG_INST_LOAD_PAL_HIGH :
if	43:12	46:12	6	(buf_size - CDG_HEADER_SIZE < CDG_DATA_SIZE)
cond	43:16	43:45	7	buf_size - CDG_HEADER_SIZE < CDG_DATA_SIZE
water	43:16	0:0	8	buf_size
op	43:25	0:0	8	-
water	43:27	0:0	8	CDG_HEADER_SIZE
op	43:43	0:0	8	<
water	43:45	0:0	8	CDG_DATA_SIZE
stmts	43:60	46:12	7	
water	43:60	0:0	8	{
call	44:16	44:84	8	av_log
arg	44:23	44:28	9	avctx
water	44:23	0:0	10	avctx
arg	44:30	44:42	9	AV_LOG_ERROR
water	44:30	0:0	10	AV_LOG_ERROR
arg	44:44	44:84	9	"buffer too small for loading palette\n"
water	44:44	0:0	10	"buffer too small for loading palette\n"
water	44:85	0:0	8	;
return	45:16	45:38	8	AVERROR(EINVAL)
call	45:23	45:37	9	AVERROR
arg	45:31	45:37	10	EINVAL
water	45:31	0:0	11	EINVAL
water	46:12	0:0	8	}
call	48:12	48:71	6	cdg_load_palette
arg	48:29	48:31	7	cc
water	48:29	0:0	8	cc
arg	48:33	48:41	7	cdg_data
water	48:33	0:0	8	cdg_data
arg	48:43	48:71	7	inst==CDG_INST_LOAD_PAL_LO
water	48:43	0:0	8	inst
op	48:48	0:0	8	==
water	48:51	0:0	8	CDG_INST_LOAD_PAL_LO
water	48:72	0:0	6	;
break	49:12	49:17	6	
label	50:8	50:35	6	case CDG_INST_BORDER_PRESET :
call	51:12	51:42	6	cdg_border_preset
arg	51:30	51:32	7	cc
water	51:30	0:0	8	cc
arg	51:34	51:42	7	cdg_data
water	51:34	0:0	8	cdg_data
water	51:43	0:0	6	;
break	52:12	52:17	6	
label	53:8	53:36	6	case CDG_INST_TILE_BLOCK_XOR :
label	54:8	54:32	6	case CDG_INST_TILE_BLOCK :
if	55:12	58:12	6	(buf_size - CDG_HEADER_SIZE < CDG_DATA_SIZE)
cond	55:16	55:45	7	buf_size - CDG_HEADER_SIZE < CDG_DATA_SIZE
water	55:16	0:0	8	buf_size
op	55:25	0:0	8	-
water	55:27	0:0	8	CDG_HEADER_SIZE
op	55:43	0:0	8	<
water	55:45	0:0	8	CDG_DATA_SIZE
stmts	55:60	58:12	7	
water	55:60	0:0	8	{
call	56:16	56:81	8	av_log
arg	56:23	56:28	9	avctx
water	56:23	0:0	10	avctx
arg	56:30	56:42	9	AV_LOG_ERROR
water	56:30	0:0	10	AV_LOG_ERROR
arg	56:44	56:81	9	"buffer too small for drawing tile\n"
water	56:44	0:0	10	"buffer too small for drawing tile\n"
water	56:82	0:0	8	;
return	57:16	57:38	8	AVERROR(EINVAL)
call	57:23	57:37	9	AVERROR
arg	57:31	57:37	10	EINVAL
water	57:31	0:0	11	EINVAL
water	58:12	0:0	8	}
water	60:12	0:0	6	ret
op	60:16	0:0	6	=
call	60:18	60:78	6	cdg_tile_block
arg	60:33	60:35	7	cc
water	60:33	0:0	8	cc
arg	60:37	60:45	7	cdg_data
water	60:37	0:0	8	cdg_data
arg	60:47	60:78	7	inst==CDG_INST_TILE_BLOCK_XOR
water	60:47	0:0	8	inst
op	60:52	0:0	8	==
water	60:55	0:0	8	CDG_INST_TILE_BLOCK_XOR
water	60:79	0:0	6	;
if	61:12	64:12	6	(ret)
cond	61:16	61:16	7	ret
water	61:16	0:0	8	ret
stmts	61:21	64:12	7	
water	61:21	0:0	8	{
call	62:16	62:68	8	av_log
arg	62:23	62:28	9	avctx
water	62:23	0:0	10	avctx
arg	62:30	62:42	9	AV_LOG_ERROR
water	62:30	0:0	10	AV_LOG_ERROR
arg	62:44	62:68	9	"tile is out of range\n"
water	62:44	0:0	10	"tile is out of range\n"
water	62:69	0:0	8	;
return	63:16	63:26	8	ret
water	63:23	0:0	9	ret
water	64:12	0:0	8	}
break	65:12	65:17	6	
label	66:8	66:35	6	case CDG_INST_SCROLL_PRESET :
label	67:8	67:33	6	case CDG_INST_SCROLL_COPY :
if	68:12	71:12	6	(buf_size - CDG_HEADER_SIZE < CDG_MINIMUM_SCROLL_SIZE)
cond	68:16	68:45	7	buf_size - CDG_HEADER_SIZE < CDG_MINIMUM_SCROLL_SIZE
water	68:16	0:0	8	buf_size
op	68:25	0:0	8	-
water	68:27	0:0	8	CDG_HEADER_SIZE
op	68:43	0:0	8	<
water	68:45	0:0	8	CDG_MINIMUM_SCROLL_SIZE
stmts	68:70	71:12	7	
water	68:70	0:0	8	{
call	69:16	69:78	8	av_log
arg	69:23	69:28	9	avctx
water	69:23	0:0	10	avctx
arg	69:30	69:42	9	AV_LOG_ERROR
water	69:30	0:0	10	AV_LOG_ERROR
arg	69:44	69:78	9	"buffer too small for scrolling\n"
water	69:44	0:0	10	"buffer too small for scrolling\n"
water	69:79	0:0	8	;
return	70:16	70:38	8	AVERROR(EINVAL)
call	70:23	70:37	9	AVERROR
arg	70:31	70:37	10	EINVAL
water	70:31	0:0	11	EINVAL
water	71:12	0:0	8	}
call	73:12	73:37	6	cdg_init_frame
arg	73:27	73:37	7	&new_frame
op	73:27	0:0	8	&
water	73:28	0:0	8	new_frame
water	73:38	0:0	6	;
water	74:12	0:0	6	ret
op	74:16	0:0	6	=
call	74:18	74:49	6	ff_get_buffer
arg	74:32	74:37	7	avctx
water	74:32	0:0	8	avctx
arg	74:39	74:49	7	&new_frame
op	74:39	0:0	8	&
water	74:40	0:0	8	new_frame
water	74:50	0:0	6	;
if	75:12	78:12	6	(ret)
cond	75:16	75:16	7	ret
water	75:16	0:0	8	ret
stmts	75:21	78:12	7	
water	75:21	0:0	8	{
call	76:16	76:67	8	av_log
arg	76:23	76:28	9	avctx
water	76:23	0:0	10	avctx
arg	76:30	76:42	9	AV_LOG_ERROR
water	76:30	0:0	10	AV_LOG_ERROR
arg	76:44	76:67	9	"get_buffer() failed\n"
water	76:44	0:0	10	"get_buffer() failed\n"
water	76:68	0:0	8	;
return	77:16	77:26	8	ret
water	77:23	0:0	9	ret
water	78:12	0:0	8	}
call	80:12	80:77	6	cdg_scroll
arg	80:23	80:25	7	cc
water	80:23	0:0	8	cc
arg	80:27	80:35	7	cdg_data
water	80:27	0:0	8	cdg_data
arg	80:37	80:47	7	&new_frame
op	80:37	0:0	8	&
water	80:38	0:0	8	new_frame
arg	80:49	80:77	7	inst==CDG_INST_SCROLL_COPY
water	80:49	0:0	8	inst
op	80:54	0:0	8	==
water	80:57	0:0	8	CDG_INST_SCROLL_COPY
water	80:78	0:0	6	;
call	81:12	81:51	6	avctx->release_buffer
arg	81:34	81:39	7	avctx
water	81:34	0:0	8	avctx
arg	81:41	81:51	7	&cc->frame
op	81:41	0:0	8	&
water	81:42	0:0	8	cc
op	81:44	0:0	8	->
water	81:46	0:0	8	frame
water	81:52	0:0	6	;
water	82:12	0:0	6	cc
op	82:14	0:0	6	->
water	82:16	0:0	6	frame
op	82:22	0:0	6	=
water	82:24	0:0	6	new_frame
water	82:33	0:0	6	;
break	83:12	83:17	6	
label	84:8	84:15	6	default :
break	85:12	85:17	6	
water	86:8	0:0	6	}
op	88:8	0:0	4	*
water	88:9	0:0	4	got_frame
op	88:19	0:0	4	=
water	88:21	0:0	4	1
water	88:22	0:0	4	;
water	89:4	0:0	4	}
else	89:6	92:4	2
stmts	89:11	92:4	3	
water	89:11	0:0	4	{
op	90:8	0:0	4	*
water	90:9	0:0	4	got_frame
op	90:19	0:0	4	=
water	90:21	0:0	4	0
water	90:22	0:0	4	;
water	91:8	0:0	4	buf_size
op	91:19	0:0	4	=
water	91:21	0:0	4	0
water	91:22	0:0	4	;
water	92:4	0:0	4	}
op	94:4	0:0	2	*
water	94:5	0:0	2	(
water	94:6	0:0	2	AVFrame
op	94:14	0:0	2	*
water	94:15	0:0	2	)
water	94:17	0:0	2	data
op	94:22	0:0	2	=
water	94:24	0:0	2	cc
op	94:26	0:0	2	->
water	94:28	0:0	2	frame
water	94:33	0:0	2	;
return	95:4	95:19	2	buf_size
water	95:11	0:0	3	buf_size
