func	2:0	112:0	0	static int	read_data
params	2:20	0:0	1	
param	2:21	2:33	2	void *	opaque
param	2:35	2:47	2	uint8_t *	buf
param	2:49	2:61	2	int	buf_size
stmnts	0:0	111:16	1	
decl	4:4	4:31	2	struct playlist	*v
op	4:23	0:0	2	=
water	4:25	0:0	2	opaque
decl	5:4	5:40	2	HLSContext	*c
op	5:18	0:0	2	=
water	5:20	0:0	2	v
op	5:21	0:0	2	->
water	5:23	0:0	2	parent
op	5:29	0:0	2	->
water	5:31	0:0	2	priv_data
decl	6:4	6:14	2	int	ret
water	6:11	0:0	2	,
decl	6:4	6:14	2	int	i
decl	7:4	7:23	2	int	just_opened
op	7:20	0:0	2	=
water	7:22	0:0	2	0
label	9:0	9:7	2	restart :
if	10:4	11:26	2	(! v -> needed)
cond	10:8	10:12	3	! v -> needed
op	10:8	0:0	4	!
water	10:9	0:0	4	v
op	10:10	0:0	4	->
water	10:12	0:0	4	needed
stmts	11:8	11:26	3	
return	11:8	11:26	4	AVERROR_EOF
water	11:15	0:0	5	AVERROR_EOF
if	13:4	86:4	2	(! v -> input)
cond	13:8	13:12	3	! v -> input
op	13:8	0:0	4	!
water	13:9	0:0	4	v
op	13:10	0:0	4	->
water	13:12	0:0	4	input
stmts	13:19	86:4	3	
water	13:19	0:0	4	{
decl	14:8	14:31	4	int64_t	reload_interval
decl	15:8	15:27	4	struct segment	*seg
if	19:8	27:8	4	(v -> ctx && v -> ctx -> nb_streams)
cond	19:12	19:30	5	v -> ctx && v -> ctx -> nb_streams
water	19:12	0:0	6	v
op	19:13	0:0	6	->
water	19:15	0:0	6	ctx
op	19:19	0:0	6	&&
water	19:22	0:0	6	v
op	19:23	0:0	6	->
water	19:25	0:0	6	ctx
op	19:28	0:0	6	->
water	19:30	0:0	6	nb_streams
stmts	19:42	27:8	5	
water	19:42	0:0	6	{
water	20:12	0:0	6	v
op	20:13	0:0	6	->
water	20:15	0:0	6	needed
op	20:22	0:0	6	=
water	20:24	0:0	6	0
water	20:25	0:0	6	;
for	21:12	26:12	6	(i = 0 ;i < v -> n_main_streams;i ++)
forinit	21:17	21:22	7	i = 0 ;
water	21:17	0:0	8	i
op	21:19	0:0	8	=
water	21:21	0:0	8	0
water	21:22	0:0	8	;
cond	21:24	21:31	7	i < v -> n_main_streams
water	21:24	0:0	8	i
op	21:26	0:0	8	<
water	21:28	0:0	8	v
op	21:29	0:0	8	->
water	21:31	0:0	8	n_main_streams
forexpr	21:47	21:48	7	i ++
water	21:47	0:0	8	i
op	21:48	0:0	8	++
stmts	21:52	26:12	7	
water	21:52	0:0	8	{
if	22:16	25:16	8	(v -> main_streams [ i ] -> discard < AVDISCARD_ALL)
cond	22:20	22:50	9	v -> main_streams [ i ] -> discard < AVDISCARD_ALL
water	22:20	0:0	10	v
op	22:21	0:0	10	->
water	22:23	0:0	10	main_streams
op	22:35	0:0	10	[
water	22:36	0:0	10	i
op	22:37	0:0	10	]
op	22:38	0:0	10	->
water	22:40	0:0	10	discard
op	22:48	0:0	10	<
water	22:50	0:0	10	AVDISCARD_ALL
stmts	22:65	25:16	9	
water	22:65	0:0	10	{
water	23:20	0:0	10	v
op	23:21	0:0	10	->
water	23:23	0:0	10	needed
op	23:30	0:0	10	=
water	23:32	0:0	10	1
water	23:33	0:0	10	;
break	24:20	24:25	10	
water	25:16	0:0	10	}
water	26:12	0:0	8	}
water	27:8	0:0	6	}
if	28:8	32:8	4	(! v -> needed)
cond	28:12	28:16	5	! v -> needed
op	28:12	0:0	6	!
water	28:13	0:0	6	v
op	28:14	0:0	6	->
water	28:16	0:0	6	needed
stmts	28:24	32:8	5	
water	28:24	0:0	6	{
call	29:12	30:24	6	av_log
arg	29:19	29:28	7	v->parent
water	29:19	0:0	8	v
op	29:20	0:0	8	->
water	29:22	0:0	8	parent
arg	29:30	29:41	7	AV_LOG_INFO
water	29:30	0:0	8	AV_LOG_INFO
arg	29:43	29:78	7	"No longer receiving playlist %d\n"
water	29:43	0:0	8	"No longer receiving playlist %d\n"
arg	30:16	30:24	7	v->index
water	30:16	0:0	8	v
op	30:17	0:0	8	->
water	30:19	0:0	8	index
water	30:25	0:0	6	;
return	31:12	31:30	6	AVERROR_EOF
water	31:19	0:0	7	AVERROR_EOF
water	32:8	0:0	6	}
water	36:8	0:0	4	reload_interval
op	36:24	0:0	4	=
call	36:26	36:51	4	default_reload_interval
arg	36:50	36:51	5	v
water	36:50	0:0	6	v
water	36:52	0:0	4	;
label	38:0	38:6	4	reload :
if	39:8	50:8	4	(! v -> finished &&av_gettime_relative ( ) - v -> last_load_time >= reload_interval)
cond	39:12	40:57	5	! v -> finished &&av_gettime_relative ( ) - v -> last_load_time >= reload_interval
op	39:12	0:0	6	!
water	39:13	0:0	6	v
op	39:14	0:0	6	->
water	39:16	0:0	6	finished
op	39:25	0:0	6	&&
call	40:12	40:32	6	av_gettime_relative
op	40:34	0:0	6	-
water	40:36	0:0	6	v
op	40:37	0:0	6	->
water	40:39	0:0	6	last_load_time
op	40:54	0:0	6	>=
water	40:57	0:0	6	reload_interval
stmts	40:74	50:8	5	
water	40:74	0:0	6	{
if	41:12	45:12	6	(( ret =parse_playlist (c ,v -> url ,v ,NULL ) ) < 0)
cond	41:16	41:61	7	( ret =parse_playlist (c ,v -> url ,v ,NULL ) ) < 0
water	41:16	0:0	8	(
water	41:17	0:0	8	ret
op	41:21	0:0	8	=
call	41:23	41:56	8	parse_playlist
arg	41:38	41:39	9	c
water	41:38	0:0	10	c
arg	41:41	41:47	9	v->url
water	41:41	0:0	10	v
op	41:42	0:0	10	->
water	41:44	0:0	10	url
arg	41:49	41:50	9	v
water	41:49	0:0	10	v
arg	41:52	41:56	9	NULL
water	41:52	0:0	10	NULL
water	41:57	0:0	8	)
op	41:59	0:0	8	<
water	41:61	0:0	8	0
stmts	41:64	45:12	7	
water	41:64	0:0	8	{
call	42:16	43:31	8	av_log
arg	42:23	42:32	9	v->parent
water	42:23	0:0	10	v
op	42:24	0:0	10	->
water	42:26	0:0	10	parent
arg	42:34	42:48	9	AV_LOG_WARNING
water	42:34	0:0	10	AV_LOG_WARNING
arg	42:50	42:82	9	"Failed to reload playlist %d\n"
water	42:50	0:0	10	"Failed to reload playlist %d\n"
arg	43:23	43:31	9	v->index
water	43:23	0:0	10	v
op	43:24	0:0	10	->
water	43:26	0:0	10	index
water	43:32	0:0	8	;
return	44:16	44:26	8	ret
water	44:23	0:0	9	ret
water	45:12	0:0	8	}
water	49:12	0:0	6	reload_interval
op	49:28	0:0	6	=
water	49:30	0:0	6	v
op	49:31	0:0	6	->
water	49:33	0:0	6	target_duration
op	49:49	0:0	6	/
water	49:51	0:0	6	2
water	49:52	0:0	6	;
water	50:8	0:0	6	}
if	51:8	56:8	4	(v -> cur_seq_no < v -> start_seq_no)
cond	51:12	51:31	5	v -> cur_seq_no < v -> start_seq_no
water	51:12	0:0	6	v
op	51:13	0:0	6	->
water	51:15	0:0	6	cur_seq_no
op	51:26	0:0	6	<
water	51:28	0:0	6	v
op	51:29	0:0	6	->
water	51:31	0:0	6	start_seq_no
stmts	51:45	56:8	5	
water	51:45	0:0	6	{
call	52:12	54:50	6	av_log
arg	52:19	52:23	7	NULL
water	52:19	0:0	8	NULL
arg	52:25	52:39	7	AV_LOG_WARNING
water	52:25	0:0	8	AV_LOG_WARNING
arg	53:19	53:73	7	"skipping %d segments ahead, expired from playlists\n"
water	53:19	0:0	8	"skipping %d segments ahead, expired from playlists\n"
arg	54:19	54:50	7	v->start_seq_no-v->cur_seq_no
water	54:19	0:0	8	v
op	54:20	0:0	8	->
water	54:22	0:0	8	start_seq_no
op	54:35	0:0	8	-
water	54:37	0:0	8	v
op	54:38	0:0	8	->
water	54:40	0:0	8	cur_seq_no
water	54:51	0:0	6	;
water	55:12	0:0	6	v
op	55:13	0:0	6	->
water	55:15	0:0	6	cur_seq_no
op	55:26	0:0	6	=
water	55:28	0:0	6	v
op	55:29	0:0	6	->
water	55:31	0:0	6	start_seq_no
water	55:43	0:0	6	;
water	56:8	0:0	6	}
if	57:8	67:8	4	(v -> cur_seq_no >= v -> start_seq_no + v -> n_segments)
cond	57:12	57:50	5	v -> cur_seq_no >= v -> start_seq_no + v -> n_segments
water	57:12	0:0	6	v
op	57:13	0:0	6	->
water	57:15	0:0	6	cur_seq_no
op	57:26	0:0	6	>=
water	57:29	0:0	6	v
op	57:30	0:0	6	->
water	57:32	0:0	6	start_seq_no
op	57:45	0:0	6	+
water	57:47	0:0	6	v
op	57:48	0:0	6	->
water	57:50	0:0	6	n_segments
stmts	57:62	67:8	5	
water	57:62	0:0	6	{
if	58:12	59:34	6	(v -> finished)
cond	58:16	58:19	7	v -> finished
water	58:16	0:0	8	v
op	58:17	0:0	8	->
water	58:19	0:0	8	finished
stmts	59:16	59:34	7	
return	59:16	59:34	8	AVERROR_EOF
water	59:23	0:0	9	AVERROR_EOF
while	60:12	64:12	6	(av_gettime_relative ( ) - v -> last_load_time < reload_interval)
cond	60:19	60:63	7	av_gettime_relative ( ) - v -> last_load_time < reload_interval
call	60:19	60:39	8	av_gettime_relative
op	60:41	0:0	8	-
water	60:43	0:0	8	v
op	60:44	0:0	8	->
water	60:46	0:0	8	last_load_time
op	60:61	0:0	8	<
water	60:63	0:0	8	reload_interval
stmts	60:80	64:12	7	
water	60:80	0:0	8	{
if	61:16	62:39	8	(ff_check_interrupt (c -> interrupt_callback ))
cond	61:20	61:60	9	ff_check_interrupt (c -> interrupt_callback )
call	61:20	61:60	10	ff_check_interrupt
arg	61:39	61:60	11	c->interrupt_callback
water	61:39	0:0	12	c
op	61:40	0:0	12	->
water	61:42	0:0	12	interrupt_callback
stmts	62:20	62:39	9	
return	62:20	62:39	10	AVERROR_EXIT
water	62:27	0:0	11	AVERROR_EXIT
call	63:16	63:34	8	av_usleep
arg	63:26	63:34	9	100*1000
water	63:26	0:0	10	100
op	63:29	0:0	10	*
water	63:30	0:0	10	1000
water	63:35	0:0	8	;
water	64:12	0:0	8	}
goto	66:12	66:23	6	reload
water	66:17	0:0	7	reload
water	67:8	0:0	6	}
water	69:8	0:0	4	seg
op	69:12	0:0	4	=
call	69:14	69:31	4	current_segment
arg	69:30	69:31	5	v
water	69:30	0:0	6	v
water	69:32	0:0	4	;
water	72:8	0:0	4	ret
op	72:12	0:0	4	=
call	72:14	72:40	4	update_init_section
arg	72:34	72:35	5	v
water	72:34	0:0	6	v
arg	72:37	72:40	5	seg
water	72:37	0:0	6	seg
water	72:41	0:0	4	;
if	73:8	74:22	4	(ret)
cond	73:12	73:12	5	ret
water	73:12	0:0	6	ret
stmts	74:12	74:22	5	
return	74:12	74:22	6	ret
water	74:19	0:0	7	ret
water	76:8	0:0	4	ret
op	76:12	0:0	4	=
call	76:14	76:34	4	open_input
arg	76:25	76:26	5	c
water	76:25	0:0	6	c
arg	76:28	76:29	5	v
water	76:28	0:0	6	v
arg	76:31	76:34	5	seg
water	76:31	0:0	6	seg
water	76:35	0:0	4	;
if	77:8	84:8	4	(ret < 0)
cond	77:12	77:18	5	ret < 0
water	77:12	0:0	6	ret
op	77:16	0:0	6	<
water	77:18	0:0	6	0
stmts	77:21	84:8	5	
water	77:21	0:0	6	{
if	78:12	79:35	6	(ff_check_interrupt (c -> interrupt_callback ))
cond	78:16	78:56	7	ff_check_interrupt (c -> interrupt_callback )
call	78:16	78:56	8	ff_check_interrupt
arg	78:35	78:56	9	c->interrupt_callback
water	78:35	0:0	10	c
op	78:36	0:0	10	->
water	78:38	0:0	10	interrupt_callback
stmts	79:16	79:35	7	
return	79:16	79:35	8	AVERROR_EXIT
water	79:23	0:0	9	AVERROR_EXIT
call	80:12	81:27	6	av_log
arg	80:19	80:28	7	v->parent
water	80:19	0:0	8	v
op	80:20	0:0	8	->
water	80:22	0:0	8	parent
arg	80:30	80:44	7	AV_LOG_WARNING
water	80:30	0:0	8	AV_LOG_WARNING
arg	80:46	80:87	7	"Failed to open segment of playlist %d\n"
water	80:46	0:0	8	"Failed to open segment of playlist %d\n"
arg	81:19	81:27	7	v->index
water	81:19	0:0	8	v
op	81:20	0:0	8	->
water	81:22	0:0	8	index
water	81:28	0:0	6	;
water	82:12	0:0	6	v
op	82:13	0:0	6	->
water	82:15	0:0	6	cur_seq_no
op	82:26	0:0	6	+=
water	82:29	0:0	6	1
water	82:30	0:0	6	;
goto	83:12	83:23	6	reload
water	83:17	0:0	7	reload
water	84:8	0:0	6	}
water	85:8	0:0	4	just_opened
op	85:20	0:0	4	=
water	85:22	0:0	4	1
water	85:23	0:0	4	;
water	86:4	0:0	4	}
if	88:4	94:4	2	(v -> init_sec_buf_read_offset < v -> init_sec_data_len)
cond	88:8	88:41	3	v -> init_sec_buf_read_offset < v -> init_sec_data_len
water	88:8	0:0	4	v
op	88:9	0:0	4	->
water	88:11	0:0	4	init_sec_buf_read_offset
op	88:36	0:0	4	<
water	88:38	0:0	4	v
op	88:39	0:0	4	->
water	88:41	0:0	4	init_sec_data_len
stmts	88:60	94:4	3	
water	88:60	0:0	4	{
decl	90:8	90:91	4	int	copy_size
op	90:22	0:0	4	=
call	90:24	90:90	5	FFMIN
arg	90:30	90:80	6	v->init_sec_data_len-v->init_sec_buf_read_offset
water	90:30	0:0	7	v
op	90:31	0:0	7	->
water	90:33	0:0	7	init_sec_data_len
op	90:51	0:0	7	-
water	90:53	0:0	7	v
op	90:54	0:0	7	->
water	90:56	0:0	7	init_sec_buf_read_offset
arg	90:82	90:90	6	buf_size
water	90:82	0:0	7	buf_size
call	91:8	91:46	4	memcpy
arg	91:15	91:18	5	buf
water	91:15	0:0	6	buf
arg	91:20	91:35	5	v->init_sec_buf
water	91:20	0:0	6	v
op	91:21	0:0	6	->
water	91:23	0:0	6	init_sec_buf
arg	91:37	91:46	5	copy_size
water	91:37	0:0	6	copy_size
water	91:47	0:0	4	;
water	92:8	0:0	4	v
op	92:9	0:0	4	->
water	92:11	0:0	4	init_sec_buf_read_offset
op	92:36	0:0	4	+=
water	92:39	0:0	4	copy_size
water	92:48	0:0	4	;
return	93:8	93:24	4	copy_size
water	93:15	0:0	5	copy_size
water	94:4	0:0	4	}
water	96:4	0:0	2	ret
op	96:8	0:0	2	=
call	96:10	96:73	2	read_from_url
arg	96:24	96:25	3	v
water	96:24	0:0	4	v
arg	96:27	96:45	3	current_segment(v)
call	96:27	96:44	4	current_segment
arg	96:43	96:44	5	v
water	96:43	0:0	6	v
arg	96:47	96:50	3	buf
water	96:47	0:0	4	buf
arg	96:52	96:60	3	buf_size
water	96:52	0:0	4	buf_size
arg	96:62	96:73	3	READ_NORMAL
water	96:62	0:0	4	READ_NORMAL
water	96:74	0:0	2	;
if	97:4	105:4	2	(ret > 0)
cond	97:8	97:14	3	ret > 0
water	97:8	0:0	4	ret
op	97:12	0:0	4	>
water	97:14	0:0	4	0
stmts	97:17	105:4	3	
water	97:17	0:0	4	{
if	98:8	102:8	4	(just_opened && v -> is_id3_timestamped != 0)
cond	98:12	98:52	5	just_opened && v -> is_id3_timestamped != 0
water	98:12	0:0	6	just_opened
op	98:24	0:0	6	&&
water	98:27	0:0	6	v
op	98:28	0:0	6	->
water	98:30	0:0	6	is_id3_timestamped
op	98:49	0:0	6	!=
water	98:52	0:0	6	0
stmts	98:55	102:8	5	
water	98:55	0:0	6	{
call	101:12	101:48	6	intercept_id3
arg	101:26	101:27	7	v
water	101:26	0:0	8	v
arg	101:29	101:32	7	buf
water	101:29	0:0	8	buf
arg	101:34	101:42	7	buf_size
water	101:34	0:0	8	buf_size
arg	101:44	101:48	7	&ret
op	101:44	0:0	8	&
water	101:45	0:0	8	ret
water	101:49	0:0	6	;
water	102:8	0:0	6	}
return	104:8	104:18	4	ret
water	104:15	0:0	5	ret
water	105:4	0:0	4	}
call	106:4	106:43	2	ff_format_io_close
arg	106:23	106:32	3	v->parent
water	106:23	0:0	4	v
op	106:24	0:0	4	->
water	106:26	0:0	4	parent
arg	106:34	106:43	3	&v->input
op	106:34	0:0	4	&
water	106:35	0:0	4	v
op	106:36	0:0	4	->
water	106:38	0:0	4	input
water	106:44	0:0	2	;
water	107:4	0:0	2	v
op	107:5	0:0	2	->
water	107:7	0:0	2	cur_seq_no
op	107:17	0:0	2	++
water	107:19	0:0	2	;
water	109:4	0:0	2	c
op	109:5	0:0	2	->
water	109:7	0:0	2	cur_seq_no
op	109:18	0:0	2	=
water	109:20	0:0	2	v
op	109:21	0:0	2	->
water	109:23	0:0	2	cur_seq_no
water	109:33	0:0	2	;
goto	111:4	111:16	2	restart
water	111:9	0:0	3	restart
