func	1:0	388:0	0	static int	tiff_decode_tag
params	1:26	0:0	1	
param	1:27	1:41	2	TiffContext *	s
param	1:43	1:57	2	AVFrame *	frame
stmnts	3:4	387:12	1	
water	3:4	0:0	2	unsigned
water	3:13	0:0	2	tag
water	3:16	0:0	2	,
water	3:18	0:0	2	type
water	3:22	0:0	2	,
water	3:24	0:0	2	count
water	3:29	0:0	2	,
water	3:31	0:0	2	off
water	3:34	0:0	2	,
water	3:36	0:0	2	value
op	3:42	0:0	2	=
water	3:44	0:0	2	0
water	3:45	0:0	2	,
water	3:47	0:0	2	value2
op	3:54	0:0	2	=
water	3:56	0:0	2	0
water	3:57	0:0	2	;
decl	4:4	4:16	2	int	i
water	4:9	0:0	2	,
decl	4:4	4:16	2	int	start
decl	5:4	5:11	2	int	pos
decl	6:4	6:11	2	int	ret
decl	7:4	7:14	2	double	*dp
water	9:4	0:0	2	ret
op	9:8	0:0	2	=
call	9:10	9:65	2	ff_tread_tag
arg	9:23	9:29	3	&s->gb
op	9:23	0:0	4	&
water	9:24	0:0	4	s
op	9:25	0:0	4	->
water	9:27	0:0	4	gb
arg	9:31	9:36	3	s->le
water	9:31	0:0	4	s
op	9:32	0:0	4	->
water	9:34	0:0	4	le
arg	9:38	9:42	3	&tag
op	9:38	0:0	4	&
water	9:39	0:0	4	tag
arg	9:44	9:49	3	&type
op	9:44	0:0	4	&
water	9:45	0:0	4	type
arg	9:51	9:57	3	&count
op	9:51	0:0	4	&
water	9:52	0:0	4	count
arg	9:59	9:65	3	&start
op	9:59	0:0	4	&
water	9:60	0:0	4	start
water	9:66	0:0	2	;
if	10:4	12:4	2	(ret < 0)
cond	10:8	10:14	3	ret < 0
water	10:8	0:0	4	ret
op	10:12	0:0	4	<
water	10:14	0:0	4	0
stmts	10:17	12:4	3	
water	10:17	0:0	4	{
goto	11:8	11:16	4	end
water	11:13	0:0	5	end
water	12:4	0:0	4	}
water	14:4	0:0	2	off
op	14:8	0:0	2	=
call	14:10	14:33	2	bytestream2_tell
arg	14:27	14:33	3	&s->gb
op	14:27	0:0	4	&
water	14:28	0:0	4	s
op	14:29	0:0	4	->
water	14:31	0:0	4	gb
water	14:34	0:0	2	;
if	15:4	33:4	2	(count == 1)
cond	15:8	15:17	3	count == 1
water	15:8	0:0	4	count
op	15:14	0:0	4	==
water	15:17	0:0	4	1
stmts	15:20	33:4	3	
water	15:20	0:0	4	{
switch	16:8	32:8	4	(type)
cond	16:16	16:16	5	type
water	16:16	0:0	6	type
stmts	16:22	32:8	5	
water	16:22	0:0	6	{
label	17:8	17:22	6	case TIFF_BYTE :
label	18:8	18:23	6	case TIFF_SHORT :
label	19:8	19:22	6	case TIFF_LONG :
water	20:12	0:0	6	value
op	20:18	0:0	6	=
call	20:20	20:47	6	ff_tget
arg	20:28	20:34	7	&s->gb
op	20:28	0:0	8	&
water	20:29	0:0	8	s
op	20:30	0:0	8	->
water	20:32	0:0	8	gb
arg	20:36	20:40	7	type
water	20:36	0:0	8	type
arg	20:42	20:47	7	s->le
water	20:42	0:0	8	s
op	20:43	0:0	8	->
water	20:45	0:0	8	le
water	20:48	0:0	6	;
break	21:12	21:17	6	
label	22:8	22:26	6	case TIFF_RATIONAL :
water	23:12	0:0	6	value
op	23:19	0:0	6	=
call	23:21	23:53	6	ff_tget
arg	23:29	23:35	7	&s->gb
op	23:29	0:0	8	&
water	23:30	0:0	8	s
op	23:31	0:0	8	->
water	23:33	0:0	8	gb
arg	23:37	23:46	7	TIFF_LONG
water	23:37	0:0	8	TIFF_LONG
arg	23:48	23:53	7	s->le
water	23:48	0:0	8	s
op	23:49	0:0	8	->
water	23:51	0:0	8	le
water	23:54	0:0	6	;
water	24:12	0:0	6	value2
op	24:19	0:0	6	=
call	24:21	24:53	6	ff_tget
arg	24:29	24:35	7	&s->gb
op	24:29	0:0	8	&
water	24:30	0:0	8	s
op	24:31	0:0	8	->
water	24:33	0:0	8	gb
arg	24:37	24:46	7	TIFF_LONG
water	24:37	0:0	8	TIFF_LONG
arg	24:48	24:53	7	s->le
water	24:48	0:0	8	s
op	24:49	0:0	8	->
water	24:51	0:0	8	le
water	24:54	0:0	6	;
break	25:12	25:17	6	
label	26:8	26:24	6	case TIFF_STRING :
if	27:12	29:12	6	(count <= 4)
cond	27:16	27:25	7	count <= 4
water	27:16	0:0	8	count
op	27:22	0:0	8	<=
water	27:25	0:0	8	4
stmts	27:28	29:12	7	
water	27:28	0:0	8	{
break	28:16	28:21	8	
water	29:12	0:0	8	}
label	30:8	30:15	6	default :
water	31:12	0:0	6	value
op	31:18	0:0	6	=
water	31:20	0:0	6	UINT_MAX
water	31:28	0:0	6	;
water	32:8	0:0	6	}
water	33:4	0:0	4	}
switch	35:4	377:4	2	(tag)
cond	35:12	35:12	3	tag
water	35:12	0:0	4	tag
stmts	35:17	377:4	3	
water	35:17	0:0	4	{
label	36:4	36:19	4	case TIFF_WIDTH :
water	37:8	0:0	4	s
op	37:9	0:0	4	->
water	37:11	0:0	4	width
op	37:17	0:0	4	=
water	37:19	0:0	4	value
water	37:24	0:0	4	;
break	38:8	38:13	4	
label	39:4	39:20	4	case TIFF_HEIGHT :
water	40:8	0:0	4	s
op	40:9	0:0	4	->
water	40:11	0:0	4	height
op	40:18	0:0	4	=
water	40:20	0:0	4	value
water	40:25	0:0	4	;
break	41:8	41:13	4	
label	42:4	42:17	4	case TIFF_BPP :
if	43:8	48:8	4	(count > 4 U)
cond	43:12	43:21	5	count > 4 U
water	43:12	0:0	6	count
op	43:18	0:0	6	>
water	43:20	0:0	6	4
water	43:21	0:0	6	U
stmts	43:24	48:8	5	
water	43:24	0:0	6	{
call	44:12	46:31	6	av_log
arg	44:19	44:27	7	s->avctx
water	44:19	0:0	8	s
op	44:20	0:0	8	->
water	44:22	0:0	8	avctx
arg	44:29	44:41	7	AV_LOG_ERROR
water	44:29	0:0	8	AV_LOG_ERROR
arg	45:19	45:75	7	"This format is not supported (bpp=%d, %d components)\n"
water	45:19	0:0	8	"This format is not supported (bpp=%d, %d components)\n"
arg	46:19	46:24	7	value
water	46:19	0:0	8	value
arg	46:26	46:31	7	count
water	46:26	0:0	8	count
water	46:32	0:0	6	;
return	47:12	47:38	6	AVERROR_INVALIDDATA
water	47:19	0:0	7	AVERROR_INVALIDDATA
water	48:8	0:0	6	}
water	49:8	0:0	4	s
op	49:9	0:0	4	->
water	49:11	0:0	4	bppcount
op	49:20	0:0	4	=
water	49:22	0:0	4	count
water	49:27	0:0	4	;
if	50:8	51:26	4	(count == 1)
cond	50:12	50:21	5	count == 1
water	50:12	0:0	6	count
op	50:18	0:0	6	==
water	50:21	0:0	6	1
stmts	51:12	51:26	5	
water	51:12	0:0	6	s
op	51:13	0:0	6	->
water	51:15	0:0	6	bpp
op	51:19	0:0	6	=
water	51:21	0:0	6	value
water	51:26	0:0	6	;
else	52:8	66:8	4
stmts	52:13	66:8	5	
water	52:13	0:0	6	{
switch	53:12	65:12	6	(type)
cond	53:20	53:20	7	type
water	53:20	0:0	8	type
stmts	53:26	65:12	7	
water	53:26	0:0	8	{
label	54:12	54:26	8	case TIFF_BYTE :
label	55:12	55:27	8	case TIFF_SHORT :
label	56:12	56:26	8	case TIFF_LONG :
water	57:16	0:0	8	s
op	57:17	0:0	8	->
water	57:19	0:0	8	bpp
op	57:23	0:0	8	=
water	57:25	0:0	8	0
water	57:26	0:0	8	;
if	58:16	59:46	8	(bytestream2_get_bytes_left (& s -> gb ) < type_sizes [ type ] * count)
cond	58:20	58:76	9	bytestream2_get_bytes_left (& s -> gb ) < type_sizes [ type ] * count
call	58:20	58:53	10	bytestream2_get_bytes_left
arg	58:47	58:53	11	&s->gb
op	58:47	0:0	12	&
water	58:48	0:0	12	s
op	58:49	0:0	12	->
water	58:51	0:0	12	gb
op	58:55	0:0	10	<
water	58:57	0:0	10	type_sizes
op	58:67	0:0	10	[
water	58:68	0:0	10	type
op	58:72	0:0	10	]
op	58:74	0:0	10	*
water	58:76	0:0	10	count
stmts	59:20	59:46	9	
return	59:20	59:46	10	AVERROR_INVALIDDATA
water	59:27	0:0	11	AVERROR_INVALIDDATA
for	60:16	61:58	8	(i = 0 ;i < count;i ++)
forinit	60:21	60:26	9	i = 0 ;
water	60:21	0:0	10	i
op	60:23	0:0	10	=
water	60:25	0:0	10	0
water	60:26	0:0	10	;
cond	60:28	60:32	9	i < count
water	60:28	0:0	10	i
op	60:30	0:0	10	<
water	60:32	0:0	10	count
forexpr	60:39	60:40	9	i ++
water	60:39	0:0	10	i
op	60:40	0:0	10	++
stmts	61:20	61:58	9	
water	61:20	0:0	10	s
op	61:21	0:0	10	->
water	61:23	0:0	10	bpp
op	61:27	0:0	10	+=
call	61:30	61:57	10	ff_tget
arg	61:38	61:44	11	&s->gb
op	61:38	0:0	12	&
water	61:39	0:0	12	s
op	61:40	0:0	12	->
water	61:42	0:0	12	gb
arg	61:46	61:50	11	type
water	61:46	0:0	12	type
arg	61:52	61:57	11	s->le
water	61:52	0:0	12	s
op	61:53	0:0	12	->
water	61:55	0:0	12	le
water	61:58	0:0	10	;
break	62:16	62:21	8	
label	63:12	63:19	8	default :
water	64:16	0:0	8	s
op	64:17	0:0	8	->
water	64:19	0:0	8	bpp
op	64:23	0:0	8	=
op	64:25	0:0	8	-
water	64:26	0:0	8	1
water	64:27	0:0	8	;
water	65:12	0:0	8	}
water	66:8	0:0	6	}
break	67:8	67:13	4	
label	68:4	68:31	4	case TIFF_SAMPLES_PER_PIXEL :
if	69:8	73:8	4	(count != 1)
cond	69:12	69:21	5	count != 1
water	69:12	0:0	6	count
op	69:18	0:0	6	!=
water	69:21	0:0	6	1
stmts	69:24	73:8	5	
water	69:24	0:0	6	{
call	70:12	71:79	6	av_log
arg	70:19	70:27	7	s->avctx
water	70:19	0:0	8	s
op	70:20	0:0	8	->
water	70:22	0:0	8	avctx
arg	70:29	70:41	7	AV_LOG_ERROR
water	70:29	0:0	8	AV_LOG_ERROR
arg	71:19	71:79	7	"Samples per pixel requires a single value, many provided\n"
water	71:19	0:0	8	"Samples per pixel requires a single value, many provided\n"
water	71:80	0:0	6	;
return	72:12	72:38	6	AVERROR_INVALIDDATA
water	72:19	0:0	7	AVERROR_INVALIDDATA
water	73:8	0:0	6	}
if	74:8	78:8	4	(value > 4 U)
cond	74:12	74:21	5	value > 4 U
water	74:12	0:0	6	value
op	74:18	0:0	6	>
water	74:20	0:0	6	4
water	74:21	0:0	6	U
stmts	74:24	78:8	5	
water	74:24	0:0	6	{
call	75:12	76:63	6	av_log
arg	75:19	75:27	7	s->avctx
water	75:19	0:0	8	s
op	75:20	0:0	8	->
water	75:22	0:0	8	avctx
arg	75:29	75:41	7	AV_LOG_ERROR
water	75:29	0:0	8	AV_LOG_ERROR
arg	76:19	76:56	7	"Samples per pixel %d is too large\n"
water	76:19	0:0	8	"Samples per pixel %d is too large\n"
arg	76:58	76:63	7	value
water	76:58	0:0	8	value
water	76:64	0:0	6	;
return	77:12	77:38	6	AVERROR_INVALIDDATA
water	77:19	0:0	7	AVERROR_INVALIDDATA
water	78:8	0:0	6	}
if	79:8	80:27	4	(s -> bppcount == 1)
cond	79:12	79:27	5	s -> bppcount == 1
water	79:12	0:0	6	s
op	79:13	0:0	6	->
water	79:15	0:0	6	bppcount
op	79:24	0:0	6	==
water	79:27	0:0	6	1
stmts	80:12	80:27	5	
water	80:12	0:0	6	s
op	80:13	0:0	6	->
water	80:15	0:0	6	bpp
op	80:19	0:0	6	*=
water	80:22	0:0	6	value
water	80:27	0:0	6	;
water	81:8	0:0	4	s
op	81:9	0:0	4	->
water	81:11	0:0	4	bppcount
op	81:20	0:0	4	=
water	81:22	0:0	4	value
water	81:27	0:0	4	;
break	82:8	82:13	4	
label	83:4	83:19	4	case TIFF_COMPR :
water	84:8	0:0	4	s
op	84:9	0:0	4	->
water	84:11	0:0	4	compr
op	84:21	0:0	4	=
water	84:23	0:0	4	value
water	84:28	0:0	4	;
water	85:8	0:0	4	s
op	85:9	0:0	4	->
water	85:11	0:0	4	predictor
op	85:21	0:0	4	=
water	85:23	0:0	4	0
water	85:24	0:0	4	;
switch	86:8	119:8	4	(s -> compr)
cond	86:16	86:19	5	s -> compr
water	86:16	0:0	6	s
op	86:17	0:0	6	->
water	86:19	0:0	6	compr
stmts	86:26	119:8	5	
water	86:26	0:0	6	{
label	87:8	87:21	6	case TIFF_RAW :
label	88:8	88:26	6	case TIFF_PACKBITS :
label	89:8	89:21	6	case TIFF_LZW :
label	90:8	90:27	6	case TIFF_CCITT_RLE :
break	91:12	91:17	6	
label	92:8	92:20	6	case TIFF_G3 :
label	93:8	93:20	6	case TIFF_G4 :
water	94:12	0:0	6	s
op	94:13	0:0	6	->
water	94:15	0:0	6	fax_opts
op	94:24	0:0	6	=
water	94:26	0:0	6	0
water	94:27	0:0	6	;
break	95:12	95:17	6	
label	96:8	96:25	6	case TIFF_DEFLATE :
label	97:8	97:31	6	case TIFF_ADOBE_DEFLATE :
break	99:12	99:17	6	
call	101:12	101:76	6	av_log
arg	101:19	101:27	7	s->avctx
water	101:19	0:0	8	s
op	101:20	0:0	8	->
water	101:22	0:0	8	avctx
arg	101:29	101:41	7	AV_LOG_ERROR
water	101:29	0:0	8	AV_LOG_ERROR
arg	101:43	101:76	7	"Deflate: ZLib not compiled in\n"
water	101:43	0:0	8	"Deflate: ZLib not compiled in\n"
water	101:77	0:0	6	;
return	102:12	102:34	6	AVERROR(ENOSYS)
call	102:19	102:33	7	AVERROR
arg	102:27	102:33	8	ENOSYS
water	102:27	0:0	9	ENOSYS
label	104:8	104:22	6	case TIFF_JPEG :
label	105:8	105:25	6	case TIFF_NEWJPEG :
call	106:12	106:70	6	avpriv_report_missing_feature
arg	106:42	106:50	7	s->avctx
water	106:42	0:0	8	s
op	106:43	0:0	8	->
water	106:45	0:0	8	avctx
arg	106:52	106:70	7	"JPEG compression"
water	106:52	0:0	8	"JPEG compression"
water	106:71	0:0	6	;
return	107:12	107:39	6	AVERROR_PATCHWELCOME
water	107:19	0:0	7	AVERROR_PATCHWELCOME
label	108:8	108:22	6	case TIFF_LZMA :
break	110:12	110:17	6	
call	112:12	112:67	6	av_log
arg	112:19	112:27	7	s->avctx
water	112:19	0:0	8	s
op	112:20	0:0	8	->
water	112:22	0:0	8	avctx
arg	112:29	112:41	7	AV_LOG_ERROR
water	112:29	0:0	8	AV_LOG_ERROR
arg	112:43	112:67	7	"LZMA not compiled in\n"
water	112:43	0:0	8	"LZMA not compiled in\n"
water	112:68	0:0	6	;
return	113:12	113:34	6	AVERROR(ENOSYS)
call	113:19	113:33	7	AVERROR
arg	113:27	113:33	8	ENOSYS
water	113:27	0:0	9	ENOSYS
label	115:8	115:15	6	default :
call	116:12	117:27	6	av_log
arg	116:19	116:27	7	s->avctx
water	116:19	0:0	8	s
op	116:20	0:0	8	->
water	116:22	0:0	8	avctx
arg	116:29	116:41	7	AV_LOG_ERROR
water	116:29	0:0	8	AV_LOG_ERROR
arg	116:43	116:76	7	"Unknown compression method %i\n"
water	116:43	0:0	8	"Unknown compression method %i\n"
arg	117:19	117:27	7	s->compr
water	117:19	0:0	8	s
op	117:20	0:0	8	->
water	117:22	0:0	8	compr
water	117:28	0:0	6	;
return	118:12	118:38	6	AVERROR_INVALIDDATA
water	118:19	0:0	7	AVERROR_INVALIDDATA
water	119:8	0:0	6	}
break	120:8	120:13	4	
label	121:4	121:26	4	case TIFF_ROWSPERSTRIP :
if	122:8	123:29	4	(! value || ( type == TIFF_LONG && value == UINT_MAX ))
cond	122:12	122:61	5	! value || ( type == TIFF_LONG && value == UINT_MAX )
op	122:12	0:0	6	!
water	122:13	0:0	6	value
op	122:19	0:0	6	||
water	122:22	0:0	6	(
water	122:23	0:0	6	type
op	122:28	0:0	6	==
water	122:31	0:0	6	TIFF_LONG
op	122:41	0:0	6	&&
water	122:44	0:0	6	value
op	122:50	0:0	6	==
water	122:53	0:0	6	UINT_MAX
water	122:61	0:0	6	)
stmts	123:12	123:29	5	
water	123:12	0:0	6	value
op	123:18	0:0	6	=
water	123:20	0:0	6	s
op	123:21	0:0	6	->
water	123:23	0:0	6	height
water	123:29	0:0	6	;
water	124:8	0:0	4	s
op	124:9	0:0	4	->
water	124:11	0:0	4	rps
op	124:15	0:0	4	=
call	124:17	124:39	4	FFMIN
arg	124:23	124:28	5	value
water	124:23	0:0	6	value
arg	124:30	124:39	5	s->height
water	124:30	0:0	6	s
op	124:31	0:0	6	->
water	124:33	0:0	6	height
water	124:40	0:0	4	;
break	125:8	125:13	4	
label	126:4	126:24	4	case TIFF_STRIP_OFFS :
if	127:8	130:8	4	(count == 1)
cond	127:12	127:21	5	count == 1
water	127:12	0:0	6	count
op	127:18	0:0	6	==
water	127:21	0:0	6	1
stmts	127:24	130:8	5	
water	127:24	0:0	6	{
water	128:12	0:0	6	s
op	128:13	0:0	6	->
water	128:15	0:0	6	strippos
op	128:24	0:0	6	=
water	128:26	0:0	6	0
water	128:27	0:0	6	;
water	129:12	0:0	6	s
op	129:13	0:0	6	->
water	129:15	0:0	6	stripoff
op	129:24	0:0	6	=
water	129:26	0:0	6	value
water	129:31	0:0	6	;
water	130:8	0:0	6	}
else	130:10	131:29	4
stmts	131:12	131:29	5	
water	131:12	0:0	6	s
op	131:13	0:0	6	->
water	131:15	0:0	6	strippos
op	131:24	0:0	6	=
water	131:26	0:0	6	off
water	131:29	0:0	6	;
water	132:8	0:0	4	s
op	132:9	0:0	4	->
water	132:11	0:0	4	strips
op	132:18	0:0	4	=
water	132:20	0:0	4	count
water	132:25	0:0	4	;
if	133:8	134:30	4	(s -> strips == 1)
cond	133:12	133:25	5	s -> strips == 1
water	133:12	0:0	6	s
op	133:13	0:0	6	->
water	133:15	0:0	6	strips
op	133:22	0:0	6	==
water	133:25	0:0	6	1
stmts	134:12	134:30	5	
water	134:12	0:0	6	s
op	134:13	0:0	6	->
water	134:15	0:0	6	rps
op	134:19	0:0	6	=
water	134:21	0:0	6	s
op	134:22	0:0	6	->
water	134:24	0:0	6	height
water	134:30	0:0	6	;
water	135:8	0:0	4	s
op	135:9	0:0	4	->
water	135:11	0:0	4	sot
op	135:15	0:0	4	=
water	135:17	0:0	4	type
water	135:21	0:0	4	;
break	136:8	136:13	4	
label	137:4	137:24	4	case TIFF_STRIP_SIZE :
if	138:8	142:8	4	(count == 1)
cond	138:12	138:21	5	count == 1
water	138:12	0:0	6	count
op	138:18	0:0	6	==
water	138:21	0:0	6	1
stmts	138:24	142:8	5	
water	138:24	0:0	6	{
water	139:12	0:0	6	s
op	139:13	0:0	6	->
water	139:15	0:0	6	stripsizesoff
op	139:29	0:0	6	=
water	139:31	0:0	6	0
water	139:32	0:0	6	;
water	140:12	0:0	6	s
op	140:13	0:0	6	->
water	140:15	0:0	6	stripsize
op	140:29	0:0	6	=
water	140:31	0:0	6	value
water	140:36	0:0	6	;
water	141:12	0:0	6	s
op	141:13	0:0	6	->
water	141:15	0:0	6	strips
op	141:29	0:0	6	=
water	141:31	0:0	6	1
water	141:32	0:0	6	;
water	142:8	0:0	6	}
else	142:10	144:8	4
stmts	142:15	144:8	5	
water	142:15	0:0	6	{
water	143:12	0:0	6	s
op	143:13	0:0	6	->
water	143:15	0:0	6	stripsizesoff
op	143:29	0:0	6	=
water	143:31	0:0	6	off
water	143:34	0:0	6	;
water	144:8	0:0	6	}
water	145:8	0:0	4	s
op	145:9	0:0	4	->
water	145:11	0:0	4	strips
op	145:18	0:0	4	=
water	145:20	0:0	4	count
water	145:25	0:0	4	;
water	146:8	0:0	4	s
op	146:9	0:0	4	->
water	146:11	0:0	4	sstype
op	146:18	0:0	4	=
water	146:20	0:0	4	type
water	146:24	0:0	4	;
break	147:8	147:13	4	
label	148:4	148:18	4	case TIFF_XRES :
label	149:4	149:18	4	case TIFF_YRES :
call	150:8	150:37	4	set_sar
arg	150:16	150:17	5	s
water	150:16	0:0	6	s
arg	150:19	150:22	5	tag
water	150:19	0:0	6	tag
arg	150:24	150:29	5	value
water	150:24	0:0	6	value
arg	150:31	150:37	5	value2
water	150:31	0:0	6	value2
water	150:38	0:0	4	;
break	151:8	151:13	4	
label	152:4	152:30	4	case TIFF_TILE_BYTE_COUNTS :
label	153:4	153:25	4	case TIFF_TILE_LENGTH :
label	154:4	154:26	4	case TIFF_TILE_OFFSETS :
label	155:4	155:24	4	case TIFF_TILE_WIDTH :
call	156:8	156:73	4	av_log
arg	156:15	156:23	5	s->avctx
water	156:15	0:0	6	s
op	156:16	0:0	6	->
water	156:18	0:0	6	avctx
arg	156:25	156:37	5	AV_LOG_ERROR
water	156:25	0:0	6	AV_LOG_ERROR
arg	156:39	156:73	5	"Tiled images are not supported\n"
water	156:39	0:0	6	"Tiled images are not supported\n"
water	156:74	0:0	4	;
return	157:8	157:35	4	AVERROR_PATCHWELCOME
water	157:15	0:0	5	AVERROR_PATCHWELCOME
break	158:8	158:13	4	
label	159:4	159:23	4	case TIFF_PREDICTOR :
water	160:8	0:0	4	s
op	160:9	0:0	4	->
water	160:11	0:0	4	predictor
op	160:21	0:0	4	=
water	160:23	0:0	4	value
water	160:28	0:0	4	;
break	161:8	161:13	4	
label	162:4	162:25	4	case TIFF_PHOTOMETRIC :
switch	163:8	188:8	4	(value)
cond	163:16	163:16	5	value
water	163:16	0:0	6	value
stmts	163:23	188:8	5	
water	163:23	0:0	6	{
label	164:8	164:43	6	case TIFF_PHOTOMETRIC_WHITE_IS_ZERO :
label	165:8	165:43	6	case TIFF_PHOTOMETRIC_BLACK_IS_ZERO :
label	166:8	166:33	6	case TIFF_PHOTOMETRIC_RGB :
label	167:8	167:37	6	case TIFF_PHOTOMETRIC_PALETTE :
label	168:8	168:35	6	case TIFF_PHOTOMETRIC_YCBCR :
water	169:12	0:0	6	s
op	169:13	0:0	6	->
water	169:15	0:0	6	photometric
op	169:27	0:0	6	=
water	169:29	0:0	6	value
water	169:34	0:0	6	;
break	170:12	170:17	6	
label	171:8	171:40	6	case TIFF_PHOTOMETRIC_ALPHA_MASK :
label	172:8	172:39	6	case TIFF_PHOTOMETRIC_SEPARATED :
label	173:8	173:37	6	case TIFF_PHOTOMETRIC_CIE_LAB :
label	174:8	174:37	6	case TIFF_PHOTOMETRIC_ICC_LAB :
label	175:8	175:37	6	case TIFF_PHOTOMETRIC_ITU_LAB :
label	176:8	176:33	6	case TIFF_PHOTOMETRIC_CFA :
label	177:8	177:35	6	case TIFF_PHOTOMETRIC_LOG_L :
label	178:8	178:37	6	case TIFF_PHOTOMETRIC_LOG_LUV :
label	179:8	179:40	6	case TIFF_PHOTOMETRIC_LINEAR_RAW :
call	180:12	182:47	6	avpriv_report_missing_feature
arg	180:42	180:50	7	s->avctx
water	180:42	0:0	8	s
op	180:43	0:0	8	->
water	180:45	0:0	8	avctx
arg	181:42	181:76	7	"PhotometricInterpretation 0x%04X"
water	181:42	0:0	8	"PhotometricInterpretation 0x%04X"
arg	182:42	182:47	7	value
water	182:42	0:0	8	value
water	182:48	0:0	6	;
return	183:12	183:39	6	AVERROR_PATCHWELCOME
water	183:19	0:0	7	AVERROR_PATCHWELCOME
label	184:8	184:15	6	default :
call	185:12	186:37	6	av_log
arg	185:19	185:27	7	s->avctx
water	185:19	0:0	8	s
op	185:20	0:0	8	->
water	185:22	0:0	8	avctx
arg	185:29	185:41	7	AV_LOG_ERROR
water	185:29	0:0	8	AV_LOG_ERROR
arg	185:43	186:30	7	"PhotometricInterpretation %u is ""unknown\n"
water	185:43	0:0	8	"PhotometricInterpretation %u is "
water	186:19	0:0	8	"unknown\n"
arg	186:32	186:37	7	value
water	186:32	0:0	8	value
water	186:38	0:0	6	;
return	187:12	187:38	6	AVERROR_INVALIDDATA
water	187:19	0:0	7	AVERROR_INVALIDDATA
water	188:8	0:0	6	}
break	189:8	189:13	4	
label	190:4	190:24	4	case TIFF_FILL_ORDER :
if	191:8	195:8	4	(value < 1 || value > 2)
cond	191:12	191:33	5	value < 1 || value > 2
water	191:12	0:0	6	value
op	191:18	0:0	6	<
water	191:20	0:0	6	1
op	191:22	0:0	6	||
water	191:25	0:0	6	value
op	191:31	0:0	6	>
water	191:33	0:0	6	2
stmts	191:36	195:8	5	
water	191:36	0:0	6	{
call	192:12	193:76	6	av_log
arg	192:19	192:27	7	s->avctx
water	192:19	0:0	8	s
op	192:20	0:0	8	->
water	192:22	0:0	8	avctx
arg	192:29	192:41	7	AV_LOG_ERROR
water	192:29	0:0	8	AV_LOG_ERROR
arg	193:19	193:69	7	"Unknown FillOrder value %d, trying default one\n"
water	193:19	0:0	8	"Unknown FillOrder value %d, trying default one\n"
arg	193:71	193:76	7	value
water	193:71	0:0	8	value
water	193:77	0:0	6	;
water	194:12	0:0	6	value
op	194:18	0:0	6	=
water	194:20	0:0	6	1
water	194:21	0:0	6	;
water	195:8	0:0	6	}
water	196:8	0:0	4	s
op	196:9	0:0	4	->
water	196:11	0:0	4	fill_order
op	196:22	0:0	4	=
water	196:24	0:0	4	value
op	196:30	0:0	4	-
water	196:32	0:0	4	1
water	196:33	0:0	4	;
break	197:8	197:13	4	
label	198:4	198:17	4	case TIFF_PAL :
water	198:19	0:0	4	{
decl	199:8	199:32	4	GetByteContext	pal_gb[3]
water	200:8	0:0	4	off
op	200:12	0:0	4	=
water	200:14	0:0	4	type_sizes
op	200:24	0:0	4	[
water	200:25	0:0	4	type
op	200:29	0:0	4	]
water	200:30	0:0	4	;
if	201:8	203:38	4	(count / 3 > 256 ||bytestream2_get_bytes_left (& s -> gb ) < count / 3 * off * 3)
cond	201:12	202:67	5	count / 3 > 256 ||bytestream2_get_bytes_left (& s -> gb ) < count / 3 * off * 3
water	201:12	0:0	6	count
op	201:18	0:0	6	/
water	201:20	0:0	6	3
op	201:22	0:0	6	>
water	201:24	0:0	6	256
op	201:28	0:0	6	||
call	202:12	202:45	6	bytestream2_get_bytes_left
arg	202:39	202:45	7	&s->gb
op	202:39	0:0	8	&
water	202:40	0:0	8	s
op	202:41	0:0	8	->
water	202:43	0:0	8	gb
op	202:47	0:0	6	<
water	202:49	0:0	6	count
op	202:55	0:0	6	/
water	202:57	0:0	6	3
op	202:59	0:0	6	*
water	202:61	0:0	6	off
op	202:65	0:0	6	*
water	202:67	0:0	6	3
stmts	203:12	203:38	5	
return	203:12	203:38	6	AVERROR_INVALIDDATA
water	203:19	0:0	7	AVERROR_INVALIDDATA
water	205:8	0:0	4	pal_gb
op	205:14	0:0	4	[
water	205:15	0:0	4	0
op	205:16	0:0	4	]
op	205:18	0:0	4	=
water	205:20	0:0	4	pal_gb
op	205:26	0:0	4	[
water	205:27	0:0	4	1
op	205:28	0:0	4	]
op	205:30	0:0	4	=
water	205:32	0:0	4	pal_gb
op	205:38	0:0	4	[
water	205:39	0:0	4	2
op	205:40	0:0	4	]
op	205:42	0:0	4	=
water	205:44	0:0	4	s
op	205:45	0:0	4	->
water	205:47	0:0	4	gb
water	205:49	0:0	4	;
call	206:8	206:52	4	bytestream2_skip
arg	206:25	206:35	5	&pal_gb[1]
op	206:25	0:0	6	&
water	206:26	0:0	6	pal_gb
op	206:32	0:0	6	[
water	206:33	0:0	6	1
op	206:34	0:0	6	]
arg	206:37	206:52	5	count/3*off
water	206:37	0:0	6	count
op	206:43	0:0	6	/
water	206:45	0:0	6	3
op	206:47	0:0	6	*
water	206:49	0:0	6	off
water	206:53	0:0	4	;
call	207:8	207:56	4	bytestream2_skip
arg	207:25	207:35	5	&pal_gb[2]
op	207:25	0:0	6	&
water	207:26	0:0	6	pal_gb
op	207:32	0:0	6	[
water	207:33	0:0	6	2
op	207:34	0:0	6	]
arg	207:37	207:56	5	count/3*off*2
water	207:37	0:0	6	count
op	207:43	0:0	6	/
water	207:45	0:0	6	3
op	207:47	0:0	6	*
water	207:49	0:0	6	off
op	207:53	0:0	6	*
water	207:55	0:0	6	2
water	207:57	0:0	4	;
water	209:8	0:0	4	off
op	209:12	0:0	4	=
water	209:14	0:0	4	(
water	209:15	0:0	4	type_sizes
op	209:25	0:0	4	[
water	209:26	0:0	4	type
op	209:30	0:0	4	]
op	209:32	0:0	4	-
water	209:34	0:0	4	1
water	209:35	0:0	4	)
op	209:37	0:0	4	<<
water	209:40	0:0	4	3
water	209:41	0:0	4	;
for	210:8	216:8	4	(i = 0 ;i < count / 3;i ++)
forinit	210:13	210:18	5	i = 0 ;
water	210:13	0:0	6	i
op	210:15	0:0	6	=
water	210:17	0:0	6	0
water	210:18	0:0	6	;
cond	210:20	210:32	5	i < count / 3
water	210:20	0:0	6	i
op	210:22	0:0	6	<
water	210:24	0:0	6	count
op	210:30	0:0	6	/
water	210:32	0:0	6	3
forexpr	210:35	210:36	5	i ++
water	210:35	0:0	6	i
op	210:36	0:0	6	++
stmts	210:40	216:8	5	
water	210:40	0:0	6	{
decl	211:12	211:35	6	uint32_t	p
op	211:23	0:0	6	=
water	211:25	0:0	6	0
water	211:26	0:0	6	xFF000000
water	212:12	0:0	6	p
op	212:14	0:0	6	|=
water	212:17	0:0	6	(
call	212:18	212:49	6	ff_tget
arg	212:26	212:36	7	&pal_gb[0]
op	212:26	0:0	8	&
water	212:27	0:0	8	pal_gb
op	212:33	0:0	8	[
water	212:34	0:0	8	0
op	212:35	0:0	8	]
arg	212:38	212:42	7	type
water	212:38	0:0	8	type
arg	212:44	212:49	7	s->le
water	212:44	0:0	8	s
op	212:45	0:0	8	->
water	212:47	0:0	8	le
op	212:51	0:0	6	>>
water	212:54	0:0	6	off
water	212:57	0:0	6	)
op	212:59	0:0	6	<<
water	212:62	0:0	6	16
water	212:64	0:0	6	;
water	213:12	0:0	6	p
op	213:14	0:0	6	|=
water	213:17	0:0	6	(
call	213:18	213:49	6	ff_tget
arg	213:26	213:36	7	&pal_gb[1]
op	213:26	0:0	8	&
water	213:27	0:0	8	pal_gb
op	213:33	0:0	8	[
water	213:34	0:0	8	1
op	213:35	0:0	8	]
arg	213:38	213:42	7	type
water	213:38	0:0	8	type
arg	213:44	213:49	7	s->le
water	213:44	0:0	8	s
op	213:45	0:0	8	->
water	213:47	0:0	8	le
op	213:51	0:0	6	>>
water	213:54	0:0	6	off
water	213:57	0:0	6	)
op	213:59	0:0	6	<<
water	213:62	0:0	6	8
water	213:63	0:0	6	;
water	214:12	0:0	6	p
op	214:14	0:0	6	|=
call	214:18	214:49	6	ff_tget
arg	214:26	214:36	7	&pal_gb[2]
op	214:26	0:0	8	&
water	214:27	0:0	8	pal_gb
op	214:33	0:0	8	[
water	214:34	0:0	8	2
op	214:35	0:0	8	]
arg	214:38	214:42	7	type
water	214:38	0:0	8	type
arg	214:44	214:49	7	s->le
water	214:44	0:0	8	s
op	214:45	0:0	8	->
water	214:47	0:0	8	le
op	214:51	0:0	6	>>
water	214:54	0:0	6	off
water	214:57	0:0	6	;
water	215:12	0:0	6	s
op	215:13	0:0	6	->
water	215:15	0:0	6	palette
op	215:22	0:0	6	[
water	215:23	0:0	6	i
op	215:24	0:0	6	]
op	215:26	0:0	6	=
water	215:28	0:0	6	p
water	215:29	0:0	6	;
water	216:8	0:0	6	}
water	217:8	0:0	4	s
op	217:9	0:0	4	->
water	217:11	0:0	4	palette_is_set
op	217:26	0:0	4	=
water	217:28	0:0	4	1
water	217:29	0:0	4	;
break	218:8	218:13	4	
water	219:4	0:0	4	}
label	220:4	220:20	4	case TIFF_PLANAR :
water	221:8	0:0	4	s
op	221:9	0:0	4	->
water	221:11	0:0	4	planar
op	221:18	0:0	4	=
water	221:20	0:0	4	value
op	221:26	0:0	4	==
water	221:29	0:0	4	2
water	221:30	0:0	4	;
break	222:8	222:13	4	
label	223:4	223:31	4	case TIFF_YCBCR_SUBSAMPLING :
if	224:8	227:8	4	(count != 2)
cond	224:12	224:21	5	count != 2
water	224:12	0:0	6	count
op	224:18	0:0	6	!=
water	224:21	0:0	6	2
stmts	224:24	227:8	5	
water	224:24	0:0	6	{
call	225:12	225:70	6	av_log
arg	225:19	225:27	7	s->avctx
water	225:19	0:0	8	s
op	225:20	0:0	8	->
water	225:22	0:0	8	avctx
arg	225:29	225:41	7	AV_LOG_ERROR
water	225:29	0:0	8	AV_LOG_ERROR
arg	225:43	225:70	7	"subsample count invalid\n"
water	225:43	0:0	8	"subsample count invalid\n"
water	225:71	0:0	6	;
return	226:12	226:38	6	AVERROR_INVALIDDATA
water	226:19	0:0	7	AVERROR_INVALIDDATA
water	227:8	0:0	6	}
for	228:8	229:60	4	(i = 0 ;i < count;i ++)
forinit	228:13	228:18	5	i = 0 ;
water	228:13	0:0	6	i
op	228:15	0:0	6	=
water	228:17	0:0	6	0
water	228:18	0:0	6	;
cond	228:20	228:24	5	i < count
water	228:20	0:0	6	i
op	228:22	0:0	6	<
water	228:24	0:0	6	count
forexpr	228:31	228:32	5	i ++
water	228:31	0:0	6	i
op	228:32	0:0	6	++
stmts	229:12	229:60	5	
water	229:12	0:0	6	s
op	229:13	0:0	6	->
water	229:15	0:0	6	subsampling
op	229:26	0:0	6	[
water	229:27	0:0	6	i
op	229:28	0:0	6	]
op	229:30	0:0	6	=
call	229:32	229:59	6	ff_tget
arg	229:40	229:46	7	&s->gb
op	229:40	0:0	8	&
water	229:41	0:0	8	s
op	229:42	0:0	8	->
water	229:44	0:0	8	gb
arg	229:48	229:52	7	type
water	229:48	0:0	8	type
arg	229:54	229:59	7	s->le
water	229:54	0:0	8	s
op	229:55	0:0	8	->
water	229:57	0:0	8	le
water	229:60	0:0	6	;
break	230:8	230:13	4	
label	231:4	231:23	4	case TIFF_T4OPTIONS :
if	232:8	233:31	4	(s -> compr == TIFF_G3)
cond	232:12	232:24	5	s -> compr == TIFF_G3
water	232:12	0:0	6	s
op	232:13	0:0	6	->
water	232:15	0:0	6	compr
op	232:21	0:0	6	==
water	232:24	0:0	6	TIFF_G3
stmts	233:12	233:31	5	
water	233:12	0:0	6	s
op	233:13	0:0	6	->
water	233:15	0:0	6	fax_opts
op	233:24	0:0	6	=
water	233:26	0:0	6	value
water	233:31	0:0	6	;
break	234:8	234:13	4	
label	235:4	235:23	4	case TIFF_T6OPTIONS :
if	236:8	237:31	4	(s -> compr == TIFF_G4)
cond	236:12	236:24	5	s -> compr == TIFF_G4
water	236:12	0:0	6	s
op	236:13	0:0	6	->
water	236:15	0:0	6	compr
op	236:21	0:0	6	==
water	236:24	0:0	6	TIFF_G4
stmts	237:12	237:31	5	
water	237:12	0:0	6	s
op	237:13	0:0	6	->
water	237:15	0:0	6	fax_opts
op	237:24	0:0	6	=
water	237:26	0:0	6	value
water	237:31	0:0	6	;
break	238:8	238:13	4	
if	240:4	243:4	4	(( ret =add_metadata (count ,type ,name ,sep ,s ,frame ) ) < 0)
cond	240:8	240:65	5	( ret =add_metadata (count ,type ,name ,sep ,s ,frame ) ) < 0
water	240:8	0:0	6	(
water	240:9	0:0	6	ret
op	240:13	0:0	6	=
call	240:15	240:60	6	add_metadata
arg	240:28	240:33	7	count
water	240:28	0:0	8	count
arg	240:35	240:39	7	type
water	240:35	0:0	8	type
arg	240:41	240:45	7	name
water	240:41	0:0	8	name
arg	240:47	240:50	7	sep
water	240:47	0:0	8	sep
arg	240:52	240:53	7	s
water	240:52	0:0	8	s
arg	240:55	240:60	7	frame
water	240:55	0:0	8	frame
water	240:61	0:0	6	)
op	240:63	0:0	6	<
water	240:65	0:0	6	0
stmts	240:68	243:4	5	
water	240:68	0:0	6	{
call	241:8	241:76	6	av_log
arg	241:15	241:23	7	s->avctx
water	241:15	0:0	8	s
op	241:16	0:0	8	->
water	241:18	0:0	8	avctx
arg	241:25	241:37	7	AV_LOG_ERROR
water	241:25	0:0	8	AV_LOG_ERROR
arg	241:39	241:76	7	"Error allocating temporary buffer\n"
water	241:39	0:0	8	"Error allocating temporary buffer\n"
water	241:77	0:0	6	;
goto	242:8	242:16	6	end
water	242:13	0:0	7	end
water	243:4	0:0	6	}
label	244:4	244:31	4	case TIFF_MODEL_PIXEL_SCALE :
call	245:8	245:54	4	ADD_METADATA
arg	245:21	245:26	5	count
water	245:21	0:0	6	count
arg	245:28	245:48	5	"ModelPixelScaleTag"
water	245:28	0:0	6	"ModelPixelScaleTag"
arg	245:50	245:54	5	NULL
water	245:50	0:0	6	NULL
water	245:55	0:0	4	;
break	246:8	246:13	4	
label	247:4	247:34	4	case TIFF_MODEL_TRANSFORMATION :
call	248:8	248:58	4	ADD_METADATA
arg	248:21	248:26	5	count
water	248:21	0:0	6	count
arg	248:28	248:52	5	"ModelTransformationTag"
water	248:28	0:0	6	"ModelTransformationTag"
arg	248:54	248:58	5	NULL
water	248:54	0:0	6	NULL
water	248:59	0:0	4	;
break	249:8	249:13	4	
label	250:4	250:28	4	case TIFF_MODEL_TIEPOINT :
call	251:8	251:52	4	ADD_METADATA
arg	251:21	251:26	5	count
water	251:21	0:0	6	count
arg	251:28	251:46	5	"ModelTiepointTag"
water	251:28	0:0	6	"ModelTiepointTag"
arg	251:48	251:52	5	NULL
water	251:48	0:0	6	NULL
water	251:53	0:0	4	;
break	252:8	252:13	4	
label	253:4	253:31	4	case TIFF_GEO_KEY_DIRECTORY :
call	254:8	254:47	4	ADD_METADATA
arg	254:21	254:22	5	1
water	254:21	0:0	6	1
arg	254:24	254:41	5	"GeoTIFF_Version"
water	254:24	0:0	6	"GeoTIFF_Version"
arg	254:43	254:47	5	NULL
water	254:43	0:0	6	NULL
water	254:48	0:0	4	;
call	255:8	255:51	4	ADD_METADATA
arg	255:21	255:22	5	2
water	255:21	0:0	6	2
arg	255:24	255:46	5	"GeoTIFF_Key_Revision"
water	255:24	0:0	6	"GeoTIFF_Key_Revision"
arg	255:48	255:51	5	"."
water	255:48	0:0	6	"."
water	255:52	0:0	4	;
water	256:8	0:0	4	s
op	256:9	0:0	4	->
water	256:11	0:0	4	geotag_count
op	256:26	0:0	4	=
call	256:28	256:55	4	ff_tget_short
arg	256:42	256:48	5	&s->gb
op	256:42	0:0	6	&
water	256:43	0:0	6	s
op	256:44	0:0	6	->
water	256:46	0:0	6	gb
arg	256:50	256:55	5	s->le
water	256:50	0:0	6	s
op	256:51	0:0	6	->
water	256:53	0:0	6	le
water	256:56	0:0	4	;
if	257:8	260:8	4	(s -> geotag_count > count / 4 - 1)
cond	257:12	257:42	5	s -> geotag_count > count / 4 - 1
water	257:12	0:0	6	s
op	257:13	0:0	6	->
water	257:15	0:0	6	geotag_count
op	257:28	0:0	6	>
water	257:30	0:0	6	count
op	257:36	0:0	6	/
water	257:38	0:0	6	4
op	257:40	0:0	6	-
water	257:42	0:0	6	1
stmts	257:45	260:8	5	
water	257:45	0:0	6	{
water	258:12	0:0	6	s
op	258:13	0:0	6	->
water	258:15	0:0	6	geotag_count
op	258:28	0:0	6	=
water	258:30	0:0	6	count
op	258:36	0:0	6	/
water	258:38	0:0	6	4
op	258:40	0:0	6	-
water	258:42	0:0	6	1
water	258:43	0:0	6	;
call	259:12	259:100	6	av_log
arg	259:19	259:27	7	s->avctx
water	259:19	0:0	8	s
op	259:20	0:0	8	->
water	259:22	0:0	8	avctx
arg	259:29	259:43	7	AV_LOG_WARNING
water	259:29	0:0	8	AV_LOG_WARNING
arg	259:45	259:100	7	"GeoTIFF key directory buffer shorter than specified\n"
water	259:45	0:0	8	"GeoTIFF key directory buffer shorter than specified\n"
water	259:101	0:0	6	;
water	260:8	0:0	6	}
if	261:8	264:8	4	(bytestream2_get_bytes_left (& s -> gb ) < s -> geotag_count * sizeof ( int16_t ) * 4)
cond	261:12	261:85	5	bytestream2_get_bytes_left (& s -> gb ) < s -> geotag_count * sizeof ( int16_t ) * 4
call	261:12	261:45	6	bytestream2_get_bytes_left
arg	261:39	261:45	7	&s->gb
op	261:39	0:0	8	&
water	261:40	0:0	8	s
op	261:41	0:0	8	->
water	261:43	0:0	8	gb
op	261:47	0:0	6	<
water	261:49	0:0	6	s
op	261:50	0:0	6	->
water	261:52	0:0	6	geotag_count
op	261:65	0:0	6	*
op	261:67	0:0	6	sizeof
water	261:73	0:0	6	(
water	261:74	0:0	6	int16_t
water	261:81	0:0	6	)
op	261:83	0:0	6	*
water	261:85	0:0	6	4
stmts	261:88	264:8	5	
water	261:88	0:0	6	{
water	262:12	0:0	6	s
op	262:13	0:0	6	->
water	262:15	0:0	6	geotag_count
op	262:28	0:0	6	=
water	262:30	0:0	6	0
water	262:31	0:0	6	;
return	263:12	263:21	6	-1
op	263:19	0:0	7	-
water	263:20	0:0	7	1
water	264:8	0:0	6	}
water	265:8	0:0	4	s
op	265:9	0:0	4	->
water	265:11	0:0	4	geotags
op	265:19	0:0	4	=
call	265:21	265:73	4	av_mallocz_array
arg	265:38	265:53	5	s->geotag_count
water	265:38	0:0	6	s
op	265:39	0:0	6	->
water	265:41	0:0	6	geotag_count
arg	265:55	265:73	5	sizeof(TiffGeoTag)
op	265:55	0:0	6	sizeof
water	265:61	0:0	6	(
water	265:62	0:0	6	TiffGeoTag
water	265:72	0:0	6	)
water	265:74	0:0	4	;
if	266:8	270:8	4	(! s -> geotags)
cond	266:12	266:16	5	! s -> geotags
op	266:12	0:0	6	!
water	266:13	0:0	6	s
op	266:14	0:0	6	->
water	266:16	0:0	6	geotags
stmts	266:25	270:8	5	
water	266:25	0:0	6	{
call	267:12	267:80	6	av_log
arg	267:19	267:27	7	s->avctx
water	267:19	0:0	8	s
op	267:20	0:0	8	->
water	267:22	0:0	8	avctx
arg	267:29	267:41	7	AV_LOG_ERROR
water	267:29	0:0	8	AV_LOG_ERROR
arg	267:43	267:80	7	"Error allocating temporary buffer\n"
water	267:43	0:0	8	"Error allocating temporary buffer\n"
water	267:81	0:0	6	;
water	268:12	0:0	6	s
op	268:13	0:0	6	->
water	268:15	0:0	6	geotag_count
op	268:28	0:0	6	=
water	268:30	0:0	6	0
water	268:31	0:0	6	;
goto	269:12	269:20	6	end
water	269:17	0:0	7	end
water	270:8	0:0	6	}
for	271:8	280:8	4	(i = 0 ;i < s -> geotag_count;i ++)
forinit	271:13	271:18	5	i = 0 ;
water	271:13	0:0	6	i
op	271:15	0:0	6	=
water	271:17	0:0	6	0
water	271:18	0:0	6	;
cond	271:20	271:27	5	i < s -> geotag_count
water	271:20	0:0	6	i
op	271:22	0:0	6	<
water	271:24	0:0	6	s
op	271:25	0:0	6	->
water	271:27	0:0	6	geotag_count
forexpr	271:41	271:42	5	i ++
water	271:41	0:0	6	i
op	271:42	0:0	6	++
stmts	271:46	280:8	5	
water	271:46	0:0	6	{
water	272:12	0:0	6	s
op	272:13	0:0	6	->
water	272:15	0:0	6	geotags
op	272:22	0:0	6	[
water	272:23	0:0	6	i
op	272:24	0:0	6	]
op	272:25	0:0	6	.
water	272:26	0:0	6	key
op	272:33	0:0	6	=
call	272:35	272:62	6	ff_tget_short
arg	272:49	272:55	7	&s->gb
op	272:49	0:0	8	&
water	272:50	0:0	8	s
op	272:51	0:0	8	->
water	272:53	0:0	8	gb
arg	272:57	272:62	7	s->le
water	272:57	0:0	8	s
op	272:58	0:0	8	->
water	272:60	0:0	8	le
water	272:63	0:0	6	;
water	273:12	0:0	6	s
op	273:13	0:0	6	->
water	273:15	0:0	6	geotags
op	273:22	0:0	6	[
water	273:23	0:0	6	i
op	273:24	0:0	6	]
op	273:25	0:0	6	.
water	273:26	0:0	6	type
op	273:33	0:0	6	=
call	273:35	273:62	6	ff_tget_short
arg	273:49	273:55	7	&s->gb
op	273:49	0:0	8	&
water	273:50	0:0	8	s
op	273:51	0:0	8	->
water	273:53	0:0	8	gb
arg	273:57	273:62	7	s->le
water	273:57	0:0	8	s
op	273:58	0:0	8	->
water	273:60	0:0	8	le
water	273:63	0:0	6	;
water	274:12	0:0	6	s
op	274:13	0:0	6	->
water	274:15	0:0	6	geotags
op	274:22	0:0	6	[
water	274:23	0:0	6	i
op	274:24	0:0	6	]
op	274:25	0:0	6	.
water	274:26	0:0	6	count
op	274:33	0:0	6	=
call	274:35	274:62	6	ff_tget_short
arg	274:49	274:55	7	&s->gb
op	274:49	0:0	8	&
water	274:50	0:0	8	s
op	274:51	0:0	8	->
water	274:53	0:0	8	gb
arg	274:57	274:62	7	s->le
water	274:57	0:0	8	s
op	274:58	0:0	8	->
water	274:60	0:0	8	le
water	274:63	0:0	6	;
if	276:12	277:100	6	(! s -> geotags [ i ] . type)
cond	276:16	276:31	7	! s -> geotags [ i ] . type
op	276:16	0:0	8	!
water	276:17	0:0	8	s
op	276:18	0:0	8	->
water	276:20	0:0	8	geotags
op	276:27	0:0	8	[
water	276:28	0:0	8	i
op	276:29	0:0	8	]
op	276:30	0:0	8	.
water	276:31	0:0	8	type
stmts	277:16	277:100	7	
water	277:16	0:0	8	s
op	277:17	0:0	8	->
water	277:19	0:0	8	geotags
op	277:26	0:0	8	[
water	277:27	0:0	8	i
op	277:28	0:0	8	]
op	277:29	0:0	8	.
water	277:30	0:0	8	val
op	277:35	0:0	8	=
call	277:37	277:99	8	get_geokey_val
arg	277:52	277:69	9	s->geotags[i].key
water	277:52	0:0	10	s
op	277:53	0:0	10	->
water	277:55	0:0	10	geotags
op	277:62	0:0	10	[
water	277:63	0:0	10	i
op	277:64	0:0	10	]
op	277:65	0:0	10	.
water	277:66	0:0	10	key
arg	277:71	277:99	9	ff_tget_short(&s->gb,s->le)
call	277:71	277:98	10	ff_tget_short
arg	277:85	277:91	11	&s->gb
op	277:85	0:0	12	&
water	277:86	0:0	12	s
op	277:87	0:0	12	->
water	277:89	0:0	12	gb
arg	277:93	277:98	11	s->le
water	277:93	0:0	12	s
op	277:94	0:0	12	->
water	277:96	0:0	12	le
water	277:100	0:0	8	;
else	278:12	279:67	6
stmts	279:16	279:67	7	
water	279:16	0:0	8	s
op	279:17	0:0	8	->
water	279:19	0:0	8	geotags
op	279:26	0:0	8	[
water	279:27	0:0	8	i
op	279:28	0:0	8	]
op	279:29	0:0	8	.
water	279:30	0:0	8	offset
op	279:37	0:0	8	=
call	279:39	279:66	8	ff_tget_short
arg	279:53	279:59	9	&s->gb
op	279:53	0:0	10	&
water	279:54	0:0	10	s
op	279:55	0:0	10	->
water	279:57	0:0	10	gb
arg	279:61	279:66	9	s->le
water	279:61	0:0	10	s
op	279:62	0:0	10	->
water	279:64	0:0	10	le
water	279:67	0:0	8	;
water	280:8	0:0	6	}
break	281:8	281:13	4	
label	282:4	282:31	4	case TIFF_GEO_DOUBLE_PARAMS :
if	283:8	284:38	4	(count >= INT_MAX / sizeof ( int64_t ))
cond	283:12	283:45	5	count >= INT_MAX / sizeof ( int64_t )
water	283:12	0:0	6	count
op	283:18	0:0	6	>=
water	283:21	0:0	6	INT_MAX
op	283:29	0:0	6	/
op	283:31	0:0	6	sizeof
water	283:37	0:0	6	(
water	283:38	0:0	6	int64_t
water	283:45	0:0	6	)
stmts	284:12	284:38	5	
return	284:12	284:38	6	AVERROR_INVALIDDATA
water	284:19	0:0	7	AVERROR_INVALIDDATA
if	285:8	286:38	4	(bytestream2_get_bytes_left (& s -> gb ) < count * sizeof ( int64_t ))
cond	285:12	285:71	5	bytestream2_get_bytes_left (& s -> gb ) < count * sizeof ( int64_t )
call	285:12	285:45	6	bytestream2_get_bytes_left
arg	285:39	285:45	7	&s->gb
op	285:39	0:0	8	&
water	285:40	0:0	8	s
op	285:41	0:0	8	->
water	285:43	0:0	8	gb
op	285:47	0:0	6	<
water	285:49	0:0	6	count
op	285:55	0:0	6	*
op	285:57	0:0	6	sizeof
water	285:63	0:0	6	(
water	285:64	0:0	6	int64_t
water	285:71	0:0	6	)
stmts	286:12	286:38	5	
return	286:12	286:38	6	AVERROR_INVALIDDATA
water	286:19	0:0	7	AVERROR_INVALIDDATA
water	287:8	0:0	4	dp
op	287:11	0:0	4	=
call	287:13	287:50	4	av_malloc_array
arg	287:29	287:34	5	count
water	287:29	0:0	6	count
arg	287:36	287:50	5	sizeof(double)
op	287:36	0:0	6	sizeof
water	287:42	0:0	6	(
water	287:43	0:0	6	double
water	287:49	0:0	6	)
water	287:51	0:0	4	;
if	288:8	291:8	4	(! dp)
cond	288:12	288:13	5	! dp
op	288:12	0:0	6	!
water	288:13	0:0	6	dp
stmts	288:17	291:8	5	
water	288:17	0:0	6	{
call	289:12	289:80	6	av_log
arg	289:19	289:27	7	s->avctx
water	289:19	0:0	8	s
op	289:20	0:0	8	->
water	289:22	0:0	8	avctx
arg	289:29	289:41	7	AV_LOG_ERROR
water	289:29	0:0	8	AV_LOG_ERROR
arg	289:43	289:80	7	"Error allocating temporary buffer\n"
water	289:43	0:0	8	"Error allocating temporary buffer\n"
water	289:81	0:0	6	;
goto	290:12	290:20	6	end
water	290:17	0:0	7	end
water	291:8	0:0	6	}
for	292:8	293:49	4	(i = 0 ;i < count;i ++)
forinit	292:13	292:18	5	i = 0 ;
water	292:13	0:0	6	i
op	292:15	0:0	6	=
water	292:17	0:0	6	0
water	292:18	0:0	6	;
cond	292:20	292:24	5	i < count
water	292:20	0:0	6	i
op	292:22	0:0	6	<
water	292:24	0:0	6	count
forexpr	292:31	292:32	5	i ++
water	292:31	0:0	6	i
op	292:32	0:0	6	++
stmts	293:12	293:49	5	
water	293:12	0:0	6	dp
op	293:14	0:0	6	[
water	293:15	0:0	6	i
op	293:16	0:0	6	]
op	293:18	0:0	6	=
call	293:20	293:48	6	ff_tget_double
arg	293:35	293:41	7	&s->gb
op	293:35	0:0	8	&
water	293:36	0:0	8	s
op	293:37	0:0	8	->
water	293:39	0:0	8	gb
arg	293:43	293:48	7	s->le
water	293:43	0:0	8	s
op	293:44	0:0	8	->
water	293:46	0:0	8	le
water	293:49	0:0	6	;
for	294:8	309:8	4	(i = 0 ;i < s -> geotag_count;i ++)
forinit	294:13	294:18	5	i = 0 ;
water	294:13	0:0	6	i
op	294:15	0:0	6	=
water	294:17	0:0	6	0
water	294:18	0:0	6	;
cond	294:20	294:27	5	i < s -> geotag_count
water	294:20	0:0	6	i
op	294:22	0:0	6	<
water	294:24	0:0	6	s
op	294:25	0:0	6	->
water	294:27	0:0	6	geotag_count
forexpr	294:41	294:42	5	i ++
water	294:41	0:0	6	i
op	294:42	0:0	6	++
stmts	294:46	309:8	5	
water	294:46	0:0	6	{
if	295:12	308:12	6	(s -> geotags [ i ] . type == TIFF_GEO_DOUBLE_PARAMS)
cond	295:16	295:38	7	s -> geotags [ i ] . type == TIFF_GEO_DOUBLE_PARAMS
water	295:16	0:0	8	s
op	295:17	0:0	8	->
water	295:19	0:0	8	geotags
op	295:26	0:0	8	[
water	295:27	0:0	8	i
op	295:28	0:0	8	]
op	295:29	0:0	8	.
water	295:30	0:0	8	type
op	295:35	0:0	8	==
water	295:38	0:0	8	TIFF_GEO_DOUBLE_PARAMS
stmts	295:62	308:12	7	
water	295:62	0:0	8	{
if	296:16	299:16	8	(s -> geotags [ i ] . count == 0 || s -> geotags [ i ] . offset + s -> geotags [ i ] . count > count)
cond	296:20	297:68	9	s -> geotags [ i ] . count == 0 || s -> geotags [ i ] . offset + s -> geotags [ i ] . count > count
water	296:20	0:0	10	s
op	296:21	0:0	10	->
water	296:23	0:0	10	geotags
op	296:30	0:0	10	[
water	296:31	0:0	10	i
op	296:32	0:0	10	]
op	296:33	0:0	10	.
water	296:34	0:0	10	count
op	296:40	0:0	10	==
water	296:43	0:0	10	0
op	297:20	0:0	10	||
water	297:23	0:0	10	s
op	297:24	0:0	10	->
water	297:26	0:0	10	geotags
op	297:33	0:0	10	[
water	297:34	0:0	10	i
op	297:35	0:0	10	]
op	297:36	0:0	10	.
water	297:37	0:0	10	offset
op	297:44	0:0	10	+
water	297:46	0:0	10	s
op	297:47	0:0	10	->
water	297:49	0:0	10	geotags
op	297:56	0:0	10	[
water	297:57	0:0	10	i
op	297:58	0:0	10	]
op	297:59	0:0	10	.
water	297:60	0:0	10	count
op	297:66	0:0	10	>
water	297:68	0:0	10	count
stmts	297:75	299:16	9	
water	297:75	0:0	10	{
call	298:20	298:98	10	av_log
arg	298:27	298:35	11	s->avctx
water	298:27	0:0	12	s
op	298:28	0:0	12	->
water	298:30	0:0	12	avctx
arg	298:37	298:51	11	AV_LOG_WARNING
water	298:37	0:0	12	AV_LOG_WARNING
arg	298:53	298:79	11	"Invalid GeoTIFF key %d\n"
water	298:53	0:0	12	"Invalid GeoTIFF key %d\n"
arg	298:81	298:98	11	s->geotags[i].key
water	298:81	0:0	12	s
op	298:82	0:0	12	->
water	298:84	0:0	12	geotags
op	298:91	0:0	12	[
water	298:92	0:0	12	i
op	298:93	0:0	12	]
op	298:94	0:0	12	.
water	298:95	0:0	12	key
water	298:99	0:0	10	;
water	299:16	0:0	10	}
else	299:18	307:16	8
stmts	299:23	307:16	9	
water	299:23	0:0	10	{
decl	300:20	300:96	10	char	*ap
op	300:29	0:0	10	=
call	300:31	300:95	11	doubles2str
arg	300:43	300:68	12	&dp[s->geotags[i].offset]
op	300:43	0:0	13	&
water	300:44	0:0	13	dp
op	300:46	0:0	13	[
water	300:47	0:0	13	s
op	300:48	0:0	13	->
water	300:50	0:0	13	geotags
op	300:57	0:0	13	[
water	300:58	0:0	13	i
op	300:59	0:0	13	]
op	300:60	0:0	13	.
water	300:61	0:0	13	offset
op	300:67	0:0	13	]
arg	300:70	300:89	12	s->geotags[i].count
water	300:70	0:0	13	s
op	300:71	0:0	13	->
water	300:73	0:0	13	geotags
op	300:80	0:0	13	[
water	300:81	0:0	13	i
op	300:82	0:0	13	]
op	300:83	0:0	13	.
water	300:84	0:0	13	count
arg	300:91	300:95	12	", "
water	300:91	0:0	13	", "
if	301:20	305:20	10	(! ap)
cond	301:24	301:25	11	! ap
op	301:24	0:0	12	!
water	301:25	0:0	12	ap
stmts	301:29	305:20	11	
water	301:29	0:0	12	{
call	302:24	302:92	12	av_log
arg	302:31	302:39	13	s->avctx
water	302:31	0:0	14	s
op	302:32	0:0	14	->
water	302:34	0:0	14	avctx
arg	302:41	302:53	13	AV_LOG_ERROR
water	302:41	0:0	14	AV_LOG_ERROR
arg	302:55	302:92	13	"Error allocating temporary buffer\n"
water	302:55	0:0	14	"Error allocating temporary buffer\n"
water	302:93	0:0	12	;
call	303:24	303:36	12	av_freep
arg	303:33	303:36	13	&dp
op	303:33	0:0	14	&
water	303:34	0:0	14	dp
water	303:37	0:0	12	;
return	304:24	304:46	12	AVERROR(ENOMEM)
call	304:31	304:45	13	AVERROR
arg	304:39	304:45	14	ENOMEM
water	304:39	0:0	15	ENOMEM
water	305:20	0:0	12	}
water	306:20	0:0	10	s
op	306:21	0:0	10	->
water	306:23	0:0	10	geotags
op	306:30	0:0	10	[
water	306:31	0:0	10	i
op	306:32	0:0	10	]
op	306:33	0:0	10	.
water	306:34	0:0	10	val
op	306:38	0:0	10	=
water	306:40	0:0	10	ap
water	306:42	0:0	10	;
water	307:16	0:0	10	}
water	308:12	0:0	8	}
water	309:8	0:0	6	}
call	310:8	310:20	4	av_freep
arg	310:17	310:20	5	&dp
op	310:17	0:0	6	&
water	310:18	0:0	6	dp
water	310:21	0:0	4	;
break	311:8	311:13	4	
label	312:4	312:30	4	case TIFF_GEO_ASCII_PARAMS :
water	313:8	0:0	4	pos
op	313:12	0:0	4	=
call	313:14	313:37	4	bytestream2_tell
arg	313:31	313:37	5	&s->gb
op	313:31	0:0	6	&
water	313:32	0:0	6	s
op	313:33	0:0	6	->
water	313:35	0:0	6	gb
water	313:38	0:0	4	;
for	314:8	335:8	4	(i = 0 ;i < s -> geotag_count;i ++)
forinit	314:13	314:18	5	i = 0 ;
water	314:13	0:0	6	i
op	314:15	0:0	6	=
water	314:17	0:0	6	0
water	314:18	0:0	6	;
cond	314:20	314:27	5	i < s -> geotag_count
water	314:20	0:0	6	i
op	314:22	0:0	6	<
water	314:24	0:0	6	s
op	314:25	0:0	6	->
water	314:27	0:0	6	geotag_count
forexpr	314:41	314:42	5	i ++
water	314:41	0:0	6	i
op	314:42	0:0	6	++
stmts	314:46	335:8	5	
water	314:46	0:0	6	{
if	315:12	334:12	6	(s -> geotags [ i ] . type == TIFF_GEO_ASCII_PARAMS)
cond	315:16	315:38	7	s -> geotags [ i ] . type == TIFF_GEO_ASCII_PARAMS
water	315:16	0:0	8	s
op	315:17	0:0	8	->
water	315:19	0:0	8	geotags
op	315:26	0:0	8	[
water	315:27	0:0	8	i
op	315:28	0:0	8	]
op	315:29	0:0	8	.
water	315:30	0:0	8	type
op	315:35	0:0	8	==
water	315:38	0:0	8	TIFF_GEO_ASCII_PARAMS
stmts	315:61	334:12	7	
water	315:61	0:0	8	{
if	316:16	319:16	8	(s -> geotags [ i ] . count == 0 || s -> geotags [ i ] . offset + s -> geotags [ i ] . count > count)
cond	316:20	317:69	9	s -> geotags [ i ] . count == 0 || s -> geotags [ i ] . offset + s -> geotags [ i ] . count > count
water	316:20	0:0	10	s
op	316:21	0:0	10	->
water	316:23	0:0	10	geotags
op	316:30	0:0	10	[
water	316:31	0:0	10	i
op	316:32	0:0	10	]
op	316:33	0:0	10	.
water	316:34	0:0	10	count
op	316:40	0:0	10	==
water	316:43	0:0	10	0
op	317:20	0:0	10	||
water	317:23	0:0	10	s
op	317:24	0:0	10	->
water	317:26	0:0	10	geotags
op	317:33	0:0	10	[
water	317:34	0:0	10	i
op	317:35	0:0	10	]
op	317:36	0:0	10	.
water	317:37	0:0	10	offset
op	317:44	0:0	10	+
water	317:47	0:0	10	s
op	317:48	0:0	10	->
water	317:50	0:0	10	geotags
op	317:57	0:0	10	[
water	317:58	0:0	10	i
op	317:59	0:0	10	]
op	317:60	0:0	10	.
water	317:61	0:0	10	count
op	317:67	0:0	10	>
water	317:69	0:0	10	count
stmts	317:76	319:16	9	
water	317:76	0:0	10	{
call	318:20	318:98	10	av_log
arg	318:27	318:35	11	s->avctx
water	318:27	0:0	12	s
op	318:28	0:0	12	->
water	318:30	0:0	12	avctx
arg	318:37	318:51	11	AV_LOG_WARNING
water	318:37	0:0	12	AV_LOG_WARNING
arg	318:53	318:79	11	"Invalid GeoTIFF key %d\n"
water	318:53	0:0	12	"Invalid GeoTIFF key %d\n"
arg	318:81	318:98	11	s->geotags[i].key
water	318:81	0:0	12	s
op	318:82	0:0	12	->
water	318:84	0:0	12	geotags
op	318:91	0:0	12	[
water	318:92	0:0	12	i
op	318:93	0:0	12	]
op	318:94	0:0	12	.
water	318:95	0:0	12	key
water	318:99	0:0	10	;
water	319:16	0:0	10	}
else	319:18	333:16	8
stmts	319:23	333:16	9	
water	319:23	0:0	10	{
decl	320:20	320:28	10	char	*ap
call	322:20	322:81	10	bytestream2_seek
arg	322:37	322:43	11	&s->gb
op	322:37	0:0	12	&
water	322:38	0:0	12	s
op	322:39	0:0	12	->
water	322:41	0:0	12	gb
arg	322:45	322:71	11	pos+s->geotags[i].offset
water	322:45	0:0	12	pos
op	322:49	0:0	12	+
water	322:51	0:0	12	s
op	322:52	0:0	12	->
water	322:54	0:0	12	geotags
op	322:61	0:0	12	[
water	322:62	0:0	12	i
op	322:63	0:0	12	]
op	322:64	0:0	12	.
water	322:65	0:0	12	offset
arg	322:73	322:81	11	SEEK_SET
water	322:73	0:0	12	SEEK_SET
water	322:82	0:0	10	;
if	323:20	324:50	10	(bytestream2_get_bytes_left (& s -> gb ) < s -> geotags [ i ] . count)
cond	323:24	323:75	11	bytestream2_get_bytes_left (& s -> gb ) < s -> geotags [ i ] . count
call	323:24	323:57	12	bytestream2_get_bytes_left
arg	323:51	323:57	13	&s->gb
op	323:51	0:0	14	&
water	323:52	0:0	14	s
op	323:53	0:0	14	->
water	323:55	0:0	14	gb
op	323:59	0:0	12	<
water	323:61	0:0	12	s
op	323:62	0:0	12	->
water	323:64	0:0	12	geotags
op	323:71	0:0	12	[
water	323:72	0:0	12	i
op	323:73	0:0	12	]
op	323:74	0:0	12	.
water	323:75	0:0	12	count
stmts	324:24	324:50	11	
return	324:24	324:50	12	AVERROR_INVALIDDATA
water	324:31	0:0	13	AVERROR_INVALIDDATA
water	325:20	0:0	10	ap
op	325:23	0:0	10	=
call	325:25	325:54	10	av_malloc
arg	325:35	325:54	11	s->geotags[i].count
water	325:35	0:0	12	s
op	325:36	0:0	12	->
water	325:38	0:0	12	geotags
op	325:45	0:0	12	[
water	325:46	0:0	12	i
op	325:47	0:0	12	]
op	325:48	0:0	12	.
water	325:49	0:0	12	count
water	325:55	0:0	10	;
if	326:20	329:20	10	(! ap)
cond	326:24	326:25	11	! ap
op	326:24	0:0	12	!
water	326:25	0:0	12	ap
stmts	326:29	329:20	11	
water	326:29	0:0	12	{
call	327:24	327:92	12	av_log
arg	327:31	327:39	13	s->avctx
water	327:31	0:0	14	s
op	327:32	0:0	14	->
water	327:34	0:0	14	avctx
arg	327:41	327:53	13	AV_LOG_ERROR
water	327:41	0:0	14	AV_LOG_ERROR
arg	327:55	327:92	13	"Error allocating temporary buffer\n"
water	327:55	0:0	14	"Error allocating temporary buffer\n"
water	327:93	0:0	12	;
return	328:24	328:46	12	AVERROR(ENOMEM)
call	328:31	328:45	13	AVERROR
arg	328:39	328:45	14	ENOMEM
water	328:39	0:0	15	ENOMEM
water	329:20	0:0	12	}
call	330:20	330:75	10	bytestream2_get_bufferu
arg	330:44	330:50	11	&s->gb
op	330:44	0:0	12	&
water	330:45	0:0	12	s
op	330:46	0:0	12	->
water	330:48	0:0	12	gb
arg	330:52	330:54	11	ap
water	330:52	0:0	12	ap
arg	330:56	330:75	11	s->geotags[i].count
water	330:56	0:0	12	s
op	330:57	0:0	12	->
water	330:59	0:0	12	geotags
op	330:66	0:0	12	[
water	330:67	0:0	12	i
op	330:68	0:0	12	]
op	330:69	0:0	12	.
water	330:70	0:0	12	count
water	330:76	0:0	10	;
water	331:20	0:0	10	ap
op	331:22	0:0	10	[
water	331:23	0:0	10	s
op	331:24	0:0	10	->
water	331:26	0:0	10	geotags
op	331:33	0:0	10	[
water	331:34	0:0	10	i
op	331:35	0:0	10	]
op	331:36	0:0	10	.
water	331:37	0:0	10	count
op	331:43	0:0	10	-
water	331:45	0:0	10	1
op	331:46	0:0	10	]
op	331:48	0:0	10	=
water	331:50	0:0	10	'\0'
water	331:54	0:0	10	;
water	332:20	0:0	10	s
op	332:21	0:0	10	->
water	332:23	0:0	10	geotags
op	332:30	0:0	10	[
water	332:31	0:0	10	i
op	332:32	0:0	10	]
op	332:33	0:0	10	.
water	332:34	0:0	10	val
op	332:38	0:0	10	=
water	332:40	0:0	10	ap
water	332:42	0:0	10	;
water	333:16	0:0	10	}
water	334:12	0:0	8	}
water	335:8	0:0	6	}
break	336:8	336:13	4	
label	337:4	337:20	4	case TIFF_ARTIST :
call	338:8	338:42	4	ADD_METADATA
arg	338:21	338:26	5	count
water	338:21	0:0	6	count
arg	338:28	338:36	5	"artist"
water	338:28	0:0	6	"artist"
arg	338:38	338:42	5	NULL
water	338:38	0:0	6	NULL
water	338:43	0:0	4	;
break	339:8	339:13	4	
label	340:4	340:23	4	case TIFF_COPYRIGHT :
call	341:8	341:45	4	ADD_METADATA
arg	341:21	341:26	5	count
water	341:21	0:0	6	count
arg	341:28	341:39	5	"copyright"
water	341:28	0:0	6	"copyright"
arg	341:41	341:45	5	NULL
water	341:41	0:0	6	NULL
water	341:46	0:0	4	;
break	342:8	342:13	4	
label	343:4	343:18	4	case TIFF_DATE :
call	344:8	344:40	4	ADD_METADATA
arg	344:21	344:26	5	count
water	344:21	0:0	6	count
arg	344:28	344:34	5	"date"
water	344:28	0:0	6	"date"
arg	344:36	344:40	5	NULL
water	344:36	0:0	6	NULL
water	344:41	0:0	4	;
break	345:8	345:13	4	
label	346:4	346:27	4	case TIFF_DOCUMENT_NAME :
call	347:8	347:49	4	ADD_METADATA
arg	347:21	347:26	5	count
water	347:21	0:0	6	count
arg	347:28	347:43	5	"document_name"
water	347:28	0:0	6	"document_name"
arg	347:45	347:49	5	NULL
water	347:45	0:0	6	NULL
water	347:50	0:0	4	;
break	348:8	348:13	4	
label	349:4	349:27	4	case TIFF_HOST_COMPUTER :
call	350:8	350:44	4	ADD_METADATA
arg	350:21	350:26	5	count
water	350:21	0:0	6	count
arg	350:28	350:38	5	"computer"
water	350:28	0:0	6	"computer"
arg	350:40	350:44	5	NULL
water	350:40	0:0	6	NULL
water	350:45	0:0	4	;
break	351:8	351:13	4	
label	352:4	352:31	4	case TIFF_IMAGE_DESCRIPTION :
call	353:8	353:47	4	ADD_METADATA
arg	353:21	353:26	5	count
water	353:21	0:0	6	count
arg	353:28	353:41	5	"description"
water	353:28	0:0	6	"description"
arg	353:43	353:47	5	NULL
water	353:43	0:0	6	NULL
water	353:48	0:0	4	;
break	354:8	354:13	4	
label	355:4	355:18	4	case TIFF_MAKE :
call	356:8	356:40	4	ADD_METADATA
arg	356:21	356:26	5	count
water	356:21	0:0	6	count
arg	356:28	356:34	5	"make"
water	356:28	0:0	6	"make"
arg	356:36	356:40	5	NULL
water	356:36	0:0	6	NULL
water	356:41	0:0	4	;
break	357:8	357:13	4	
label	358:4	358:19	4	case TIFF_MODEL :
call	359:8	359:41	4	ADD_METADATA
arg	359:21	359:26	5	count
water	359:21	0:0	6	count
arg	359:28	359:35	5	"model"
water	359:28	0:0	6	"model"
arg	359:37	359:41	5	NULL
water	359:37	0:0	6	NULL
water	359:42	0:0	4	;
break	360:8	360:13	4	
label	361:4	361:23	4	case TIFF_PAGE_NAME :
call	362:8	362:45	4	ADD_METADATA
arg	362:21	362:26	5	count
water	362:21	0:0	6	count
arg	362:28	362:39	5	"page_name"
water	362:28	0:0	6	"page_name"
arg	362:41	362:45	5	NULL
water	362:41	0:0	6	NULL
water	362:46	0:0	4	;
break	363:8	363:13	4	
label	364:4	364:25	4	case TIFF_PAGE_NUMBER :
call	365:8	365:48	4	ADD_METADATA
arg	365:21	365:26	5	count
water	365:21	0:0	6	count
arg	365:28	365:41	5	"page_number"
water	365:28	0:0	6	"page_number"
arg	365:43	365:48	5	" / "
water	365:43	0:0	6	" / "
water	365:49	0:0	4	;
break	366:8	366:13	4	
label	367:4	367:27	4	case TIFF_SOFTWARE_NAME :
call	368:8	368:44	4	ADD_METADATA
arg	368:21	368:26	5	count
water	368:21	0:0	6	count
arg	368:28	368:38	5	"software"
water	368:28	0:0	6	"software"
arg	368:40	368:44	5	NULL
water	368:40	0:0	6	NULL
water	368:45	0:0	4	;
break	369:8	369:13	4	
label	370:4	370:11	4	default :
if	371:8	376:8	4	(s -> avctx -> err_recognition & AV_EF_EXPLODE)
cond	371:12	371:40	5	s -> avctx -> err_recognition & AV_EF_EXPLODE
water	371:12	0:0	6	s
op	371:13	0:0	6	->
water	371:15	0:0	6	avctx
op	371:20	0:0	6	->
water	371:22	0:0	6	err_recognition
op	371:38	0:0	6	&
water	371:40	0:0	6	AV_EF_EXPLODE
stmts	371:55	376:8	5	
water	371:55	0:0	6	{
call	372:12	374:27	6	av_log
arg	372:19	372:27	7	s->avctx
water	372:19	0:0	8	s
op	372:20	0:0	8	->
water	372:22	0:0	8	avctx
arg	372:29	372:41	7	AV_LOG_ERROR
water	372:29	0:0	8	AV_LOG_ERROR
arg	373:19	373:58	7	"Unknown or unsupported tag %d/0X%0X\n"
water	373:19	0:0	8	"Unknown or unsupported tag %d/0X%0X\n"
arg	374:19	374:22	7	tag
water	374:19	0:0	8	tag
arg	374:24	374:27	7	tag
water	374:24	0:0	8	tag
water	374:28	0:0	6	;
return	375:12	375:38	6	AVERROR_INVALIDDATA
water	375:19	0:0	7	AVERROR_INVALIDDATA
water	376:8	0:0	6	}
water	377:4	0:0	4	}
label	378:0	378:3	2	end :
if	379:4	385:4	2	(s -> bpp > 64 U)
cond	379:8	379:19	3	s -> bpp > 64 U
water	379:8	0:0	4	s
op	379:9	0:0	4	->
water	379:11	0:0	4	bpp
op	379:15	0:0	4	>
water	379:17	0:0	4	64
water	379:19	0:0	4	U
stmts	379:22	385:4	3	
water	379:22	0:0	4	{
call	380:8	382:29	4	av_log
arg	380:15	380:23	5	s->avctx
water	380:15	0:0	6	s
op	380:16	0:0	6	->
water	380:18	0:0	6	avctx
arg	380:25	380:37	5	AV_LOG_ERROR
water	380:25	0:0	6	AV_LOG_ERROR
arg	381:16	381:72	5	"This format is not supported (bpp=%d, %d components)\n"
water	381:16	0:0	6	"This format is not supported (bpp=%d, %d components)\n"
arg	382:16	382:22	5	s->bpp
water	382:16	0:0	6	s
op	382:17	0:0	6	->
water	382:19	0:0	6	bpp
arg	382:24	382:29	5	count
water	382:24	0:0	6	count
water	382:30	0:0	4	;
water	383:8	0:0	4	s
op	383:9	0:0	4	->
water	383:11	0:0	4	bpp
op	383:15	0:0	4	=
water	383:17	0:0	4	0
water	383:18	0:0	4	;
return	384:8	384:34	4	AVERROR_INVALIDDATA
water	384:15	0:0	5	AVERROR_INVALIDDATA
water	385:4	0:0	4	}
call	386:4	386:44	2	bytestream2_seek
arg	386:21	386:27	3	&s->gb
op	386:21	0:0	4	&
water	386:22	0:0	4	s
op	386:23	0:0	4	->
water	386:25	0:0	4	gb
arg	386:29	386:34	3	start
water	386:29	0:0	4	start
arg	386:36	386:44	3	SEEK_SET
water	386:36	0:0	4	SEEK_SET
water	386:45	0:0	2	;
return	387:4	387:12	2	0
water	387:11	0:0	3	0
