func	1:0	137:0	0	static int	get_siz
params	1:18	0:0	1	
param	1:19	1:44	2	Jpeg2000DecoderContext *	s
stmnts	0:0	136:12	1	
decl	3:4	3:9	2	int	i
decl	4:4	4:19	2	int	ncomponents
decl	5:4	5:31	2	uint32_t	log2_chroma_wh
op	5:28	0:0	2	=
water	5:30	0:0	2	0
decl	6:4	6:50	2	const enum AVPixelFormat	*possible_fmts
op	6:44	0:0	2	=
water	6:46	0:0	2	NULL
decl	7:4	7:28	2	int	possible_fmts_nb
op	7:25	0:0	2	=
water	7:27	0:0	2	0
if	9:4	10:34	2	(bytestream2_get_bytes_left (& s -> g ) < 36)
cond	9:8	9:44	3	bytestream2_get_bytes_left (& s -> g ) < 36
call	9:8	9:40	4	bytestream2_get_bytes_left
arg	9:35	9:40	5	&s->g
op	9:35	0:0	6	&
water	9:36	0:0	6	s
op	9:37	0:0	6	->
water	9:39	0:0	6	g
op	9:42	0:0	4	<
water	9:44	0:0	4	36
stmts	10:8	10:34	3	
return	10:8	10:34	4	AVERROR_INVALIDDATA
water	10:15	0:0	5	AVERROR_INVALIDDATA
water	12:4	0:0	2	s
op	12:5	0:0	2	->
water	12:7	0:0	2	avctx
op	12:12	0:0	2	->
water	12:14	0:0	2	profile
op	12:22	0:0	2	=
call	12:24	12:51	2	bytestream2_get_be16u
arg	12:46	12:51	3	&s->g
op	12:46	0:0	4	&
water	12:47	0:0	4	s
op	12:48	0:0	4	->
water	12:50	0:0	4	g
water	12:52	0:0	2	;
water	13:4	0:0	2	s
op	13:5	0:0	2	->
water	13:7	0:0	2	width
op	13:22	0:0	2	=
call	13:24	13:51	2	bytestream2_get_be32u
arg	13:46	13:51	3	&s->g
op	13:46	0:0	4	&
water	13:47	0:0	4	s
op	13:48	0:0	4	->
water	13:50	0:0	4	g
water	13:52	0:0	2	;
water	14:4	0:0	2	s
op	14:5	0:0	2	->
water	14:7	0:0	2	height
op	14:22	0:0	2	=
call	14:24	14:51	2	bytestream2_get_be32u
arg	14:46	14:51	3	&s->g
op	14:46	0:0	4	&
water	14:47	0:0	4	s
op	14:48	0:0	4	->
water	14:50	0:0	4	g
water	14:52	0:0	2	;
water	15:4	0:0	2	s
op	15:5	0:0	2	->
water	15:7	0:0	2	image_offset_x
op	15:22	0:0	2	=
call	15:24	15:51	2	bytestream2_get_be32u
arg	15:46	15:51	3	&s->g
op	15:46	0:0	4	&
water	15:47	0:0	4	s
op	15:48	0:0	4	->
water	15:50	0:0	4	g
water	15:52	0:0	2	;
water	16:4	0:0	2	s
op	16:5	0:0	2	->
water	16:7	0:0	2	image_offset_y
op	16:22	0:0	2	=
call	16:24	16:51	2	bytestream2_get_be32u
arg	16:46	16:51	3	&s->g
op	16:46	0:0	4	&
water	16:47	0:0	4	s
op	16:48	0:0	4	->
water	16:50	0:0	4	g
water	16:52	0:0	2	;
water	17:4	0:0	2	s
op	17:5	0:0	2	->
water	17:7	0:0	2	tile_width
op	17:22	0:0	2	=
call	17:24	17:51	2	bytestream2_get_be32u
arg	17:46	17:51	3	&s->g
op	17:46	0:0	4	&
water	17:47	0:0	4	s
op	17:48	0:0	4	->
water	17:50	0:0	4	g
water	17:52	0:0	2	;
water	18:4	0:0	2	s
op	18:5	0:0	2	->
water	18:7	0:0	2	tile_height
op	18:22	0:0	2	=
call	18:24	18:51	2	bytestream2_get_be32u
arg	18:46	18:51	3	&s->g
op	18:46	0:0	4	&
water	18:47	0:0	4	s
op	18:48	0:0	4	->
water	18:50	0:0	4	g
water	18:52	0:0	2	;
water	19:4	0:0	2	s
op	19:5	0:0	2	->
water	19:7	0:0	2	tile_offset_x
op	19:22	0:0	2	=
call	19:24	19:51	2	bytestream2_get_be32u
arg	19:46	19:51	3	&s->g
op	19:46	0:0	4	&
water	19:47	0:0	4	s
op	19:48	0:0	4	->
water	19:50	0:0	4	g
water	19:52	0:0	2	;
water	20:4	0:0	2	s
op	20:5	0:0	2	->
water	20:7	0:0	2	tile_offset_y
op	20:22	0:0	2	=
call	20:24	20:51	2	bytestream2_get_be32u
arg	20:46	20:51	3	&s->g
op	20:46	0:0	4	&
water	20:47	0:0	4	s
op	20:48	0:0	4	->
water	20:50	0:0	4	g
water	20:52	0:0	2	;
water	21:4	0:0	2	ncomponents
op	21:22	0:0	2	=
call	21:24	21:51	2	bytestream2_get_be16u
arg	21:46	21:51	3	&s->g
op	21:46	0:0	4	&
water	21:47	0:0	4	s
op	21:48	0:0	4	->
water	21:50	0:0	4	g
water	21:52	0:0	2	;
if	23:4	26:4	2	(s -> image_offset_x || s -> image_offset_y)
cond	23:8	23:32	3	s -> image_offset_x || s -> image_offset_y
water	23:8	0:0	4	s
op	23:9	0:0	4	->
water	23:11	0:0	4	image_offset_x
op	23:26	0:0	4	||
water	23:29	0:0	4	s
op	23:30	0:0	4	->
water	23:32	0:0	4	image_offset_y
stmts	23:48	26:4	3	
water	23:48	0:0	4	{
call	24:8	24:67	4	avpriv_request_sample
arg	24:30	24:38	5	s->avctx
water	24:30	0:0	6	s
op	24:31	0:0	6	->
water	24:33	0:0	6	avctx
arg	24:40	24:67	5	"Support for image offsets"
water	24:40	0:0	6	"Support for image offsets"
water	24:68	0:0	4	;
return	25:8	25:35	4	AVERROR_PATCHWELCOME
water	25:15	0:0	5	AVERROR_PATCHWELCOME
water	26:4	0:0	4	}
if	28:4	32:4	2	(ncomponents <= 0)
cond	28:8	28:23	3	ncomponents <= 0
water	28:8	0:0	4	ncomponents
op	28:20	0:0	4	<=
water	28:23	0:0	4	0
stmts	28:26	32:4	3	
water	28:26	0:0	4	{
call	29:8	30:29	4	av_log
arg	29:15	29:23	5	s->avctx
water	29:15	0:0	6	s
op	29:16	0:0	6	->
water	29:18	0:0	6	avctx
arg	29:25	29:37	5	AV_LOG_ERROR
water	29:25	0:0	6	AV_LOG_ERROR
arg	29:39	29:75	5	"Invalid number of components: %d\n"
water	29:39	0:0	6	"Invalid number of components: %d\n"
arg	30:15	30:29	5	s->ncomponents
water	30:15	0:0	6	s
op	30:16	0:0	6	->
water	30:18	0:0	6	ncomponents
water	30:30	0:0	4	;
return	31:8	31:34	4	AVERROR_INVALIDDATA
water	31:15	0:0	5	AVERROR_INVALIDDATA
water	32:4	0:0	4	}
if	34:4	38:4	2	(ncomponents > 4)
cond	34:8	34:22	3	ncomponents > 4
water	34:8	0:0	4	ncomponents
op	34:20	0:0	4	>
water	34:22	0:0	4	4
stmts	34:25	38:4	3	
water	34:25	0:0	4	{
call	35:8	36:44	4	avpriv_request_sample
arg	35:30	35:38	5	s->avctx
water	35:30	0:0	6	s
op	35:31	0:0	6	->
water	35:33	0:0	6	avctx
arg	35:40	35:67	5	"Support for %d components"
water	35:40	0:0	6	"Support for %d components"
arg	36:30	36:44	5	s->ncomponents
water	36:30	0:0	6	s
op	36:31	0:0	6	->
water	36:33	0:0	6	ncomponents
water	36:45	0:0	4	;
return	37:8	37:35	4	AVERROR_PATCHWELCOME
water	37:15	0:0	5	AVERROR_PATCHWELCOME
water	38:4	0:0	4	}
water	40:4	0:0	2	s
op	40:5	0:0	2	->
water	40:7	0:0	2	ncomponents
op	40:19	0:0	2	=
water	40:21	0:0	2	ncomponents
water	40:32	0:0	2	;
if	42:4	46:4	2	(s -> tile_width <= 0 || s -> tile_height <= 0)
cond	42:8	42:48	3	s -> tile_width <= 0 || s -> tile_height <= 0
water	42:8	0:0	4	s
op	42:9	0:0	4	->
water	42:11	0:0	4	tile_width
op	42:22	0:0	4	<=
water	42:25	0:0	4	0
op	42:27	0:0	4	||
water	42:30	0:0	4	s
op	42:31	0:0	4	->
water	42:33	0:0	4	tile_height
op	42:45	0:0	4	<=
water	42:48	0:0	4	0
stmts	42:51	46:4	3	
water	42:51	0:0	4	{
call	43:8	44:44	4	av_log
arg	43:15	43:23	5	s->avctx
water	43:15	0:0	6	s
op	43:16	0:0	6	->
water	43:18	0:0	6	avctx
arg	43:25	43:37	5	AV_LOG_ERROR
water	43:25	0:0	6	AV_LOG_ERROR
arg	43:39	43:72	5	"Invalid tile dimension %dx%d.\n"
water	43:39	0:0	6	"Invalid tile dimension %dx%d.\n"
arg	44:15	44:28	5	s->tile_width
water	44:15	0:0	6	s
op	44:16	0:0	6	->
water	44:18	0:0	6	tile_width
arg	44:30	44:44	5	s->tile_height
water	44:30	0:0	6	s
op	44:31	0:0	6	->
water	44:33	0:0	6	tile_height
water	44:45	0:0	4	;
return	45:8	45:34	4	AVERROR_INVALIDDATA
water	45:15	0:0	5	AVERROR_INVALIDDATA
water	46:4	0:0	4	}
if	48:4	49:34	2	(bytestream2_get_bytes_left (& s -> g ) < 3 * s -> ncomponents)
cond	48:8	48:51	3	bytestream2_get_bytes_left (& s -> g ) < 3 * s -> ncomponents
call	48:8	48:40	4	bytestream2_get_bytes_left
arg	48:35	48:40	5	&s->g
op	48:35	0:0	6	&
water	48:36	0:0	6	s
op	48:37	0:0	6	->
water	48:39	0:0	6	g
op	48:42	0:0	4	<
water	48:44	0:0	4	3
op	48:46	0:0	4	*
water	48:48	0:0	4	s
op	48:49	0:0	4	->
water	48:51	0:0	4	ncomponents
stmts	49:8	49:34	3	
return	49:8	49:34	4	AVERROR_INVALIDDATA
water	49:15	0:0	5	AVERROR_INVALIDDATA
for	51:4	64:4	2	(i = 0 ;i < s -> ncomponents;i ++)
forinit	51:9	51:14	3	i = 0 ;
water	51:9	0:0	4	i
op	51:11	0:0	4	=
water	51:13	0:0	4	0
water	51:14	0:0	4	;
cond	51:16	51:23	3	i < s -> ncomponents
water	51:16	0:0	4	i
op	51:18	0:0	4	<
water	51:20	0:0	4	s
op	51:21	0:0	4	->
water	51:23	0:0	4	ncomponents
forexpr	51:36	51:37	3	i ++
water	51:36	0:0	4	i
op	51:37	0:0	4	++
stmts	51:41	64:4	3	
water	51:41	0:0	4	{
decl	52:8	52:51	4	uint8_t	x
op	52:21	0:0	4	=
call	52:23	52:50	5	bytestream2_get_byteu
arg	52:45	52:50	6	&s->g
op	52:45	0:0	7	&
water	52:46	0:0	7	s
op	52:47	0:0	7	->
water	52:49	0:0	7	g
water	53:8	0:0	4	s
op	53:9	0:0	4	->
water	53:11	0:0	4	cbps
op	53:15	0:0	4	[
water	53:16	0:0	4	i
op	53:17	0:0	4	]
op	53:21	0:0	4	=
water	53:23	0:0	4	(
water	53:24	0:0	4	x
op	53:26	0:0	4	&
water	53:28	0:0	4	0
water	53:29	0:0	4	x7f
water	53:32	0:0	4	)
op	53:34	0:0	4	+
water	53:36	0:0	4	1
water	53:37	0:0	4	;
water	54:8	0:0	4	s
op	54:9	0:0	4	->
water	54:11	0:0	4	precision
op	54:21	0:0	4	=
call	54:23	54:53	4	FFMAX
arg	54:29	54:39	5	s->cbps[i]
water	54:29	0:0	6	s
op	54:30	0:0	6	->
water	54:32	0:0	6	cbps
op	54:36	0:0	6	[
water	54:37	0:0	6	i
op	54:38	0:0	6	]
arg	54:41	54:53	5	s->precision
water	54:41	0:0	6	s
op	54:42	0:0	6	->
water	54:44	0:0	6	precision
water	54:54	0:0	4	;
water	55:8	0:0	4	s
op	55:9	0:0	4	->
water	55:11	0:0	4	sgnd
op	55:15	0:0	4	[
water	55:16	0:0	4	i
op	55:17	0:0	4	]
op	55:21	0:0	4	=
op	55:23	0:0	4	!
op	55:24	0:0	4	!
water	55:25	0:0	4	(
water	55:26	0:0	4	x
op	55:28	0:0	4	&
water	55:30	0:0	4	0
water	55:31	0:0	4	x80
water	55:34	0:0	4	)
water	55:35	0:0	4	;
water	56:8	0:0	4	s
op	56:9	0:0	4	->
water	56:11	0:0	4	cdx
op	56:14	0:0	4	[
water	56:15	0:0	4	i
op	56:16	0:0	4	]
op	56:21	0:0	4	=
call	56:23	56:50	4	bytestream2_get_byteu
arg	56:45	56:50	5	&s->g
op	56:45	0:0	6	&
water	56:46	0:0	6	s
op	56:47	0:0	6	->
water	56:49	0:0	6	g
water	56:51	0:0	4	;
water	57:8	0:0	4	s
op	57:9	0:0	4	->
water	57:11	0:0	4	cdy
op	57:14	0:0	4	[
water	57:15	0:0	4	i
op	57:16	0:0	4	]
op	57:21	0:0	4	=
call	57:23	57:50	4	bytestream2_get_byteu
arg	57:45	57:50	5	&s->g
op	57:45	0:0	6	&
water	57:46	0:0	6	s
op	57:47	0:0	6	->
water	57:49	0:0	6	g
water	57:51	0:0	4	;
if	58:8	62:8	4	(! s -> cdx [ i ] || s -> cdx [ i ] == 3 || s -> cdx [ i ] > 4 || ! s -> cdy [ i ] || s -> cdy [ i ] == 3 || s -> cdy [ i ] > 4)
cond	58:15	59:59	5	! s -> cdx [ i ] || s -> cdx [ i ] == 3 || s -> cdx [ i ] > 4 || ! s -> cdy [ i ] || s -> cdy [ i ] == 3 || s -> cdy [ i ] > 4
op	58:15	0:0	6	!
water	58:16	0:0	6	s
op	58:17	0:0	6	->
water	58:19	0:0	6	cdx
op	58:22	0:0	6	[
water	58:23	0:0	6	i
op	58:24	0:0	6	]
op	58:26	0:0	6	||
water	58:29	0:0	6	s
op	58:30	0:0	6	->
water	58:32	0:0	6	cdx
op	58:35	0:0	6	[
water	58:36	0:0	6	i
op	58:37	0:0	6	]
op	58:39	0:0	6	==
water	58:42	0:0	6	3
op	58:44	0:0	6	||
water	58:47	0:0	6	s
op	58:48	0:0	6	->
water	58:50	0:0	6	cdx
op	58:53	0:0	6	[
water	58:54	0:0	6	i
op	58:55	0:0	6	]
op	58:57	0:0	6	>
water	58:59	0:0	6	4
op	59:12	0:0	6	||
op	59:15	0:0	6	!
water	59:16	0:0	6	s
op	59:17	0:0	6	->
water	59:19	0:0	6	cdy
op	59:22	0:0	6	[
water	59:23	0:0	6	i
op	59:24	0:0	6	]
op	59:26	0:0	6	||
water	59:29	0:0	6	s
op	59:30	0:0	6	->
water	59:32	0:0	6	cdy
op	59:35	0:0	6	[
water	59:36	0:0	6	i
op	59:37	0:0	6	]
op	59:39	0:0	6	==
water	59:42	0:0	6	3
op	59:44	0:0	6	||
water	59:47	0:0	6	s
op	59:48	0:0	6	->
water	59:50	0:0	6	cdy
op	59:53	0:0	6	[
water	59:54	0:0	6	i
op	59:55	0:0	6	]
op	59:57	0:0	6	>
water	59:59	0:0	6	4
stmts	59:62	62:8	5	
water	59:62	0:0	6	{
call	60:12	60:72	6	av_log
arg	60:19	60:27	7	s->avctx
water	60:19	0:0	8	s
op	60:20	0:0	8	->
water	60:22	0:0	8	avctx
arg	60:29	60:41	7	AV_LOG_ERROR
water	60:29	0:0	8	AV_LOG_ERROR
arg	60:43	60:72	7	"Invalid sample seperation\n"
water	60:43	0:0	8	"Invalid sample seperation\n"
water	60:73	0:0	6	;
return	61:12	61:38	6	AVERROR_INVALIDDATA
water	61:19	0:0	7	AVERROR_INVALIDDATA
water	62:8	0:0	6	}
water	63:8	0:0	4	log2_chroma_wh
op	63:23	0:0	4	|=
water	63:26	0:0	4	s
op	63:27	0:0	4	->
water	63:29	0:0	4	cdy
op	63:32	0:0	4	[
water	63:33	0:0	4	i
op	63:34	0:0	4	]
op	63:36	0:0	4	>>
water	63:39	0:0	4	1
op	63:41	0:0	4	<<
water	63:44	0:0	4	i
op	63:46	0:0	4	*
water	63:48	0:0	4	4
op	63:50	0:0	4	|
water	63:52	0:0	4	s
op	63:53	0:0	4	->
water	63:55	0:0	4	cdx
op	63:58	0:0	4	[
water	63:59	0:0	4	i
op	63:60	0:0	4	]
op	63:62	0:0	4	>>
water	63:65	0:0	4	1
op	63:67	0:0	4	<<
water	63:70	0:0	4	i
op	63:72	0:0	4	*
water	63:74	0:0	4	4
op	63:76	0:0	4	+
water	63:78	0:0	4	2
water	63:79	0:0	4	;
water	64:4	0:0	4	}
water	66:4	0:0	2	s
op	66:5	0:0	2	->
water	66:7	0:0	2	numXtiles
op	66:17	0:0	2	=
call	66:19	66:82	2	ff_jpeg2000_ceildiv
arg	66:39	66:67	3	s->width-s->tile_offset_x
water	66:39	0:0	4	s
op	66:40	0:0	4	->
water	66:42	0:0	4	width
op	66:49	0:0	4	-
water	66:51	0:0	4	s
op	66:52	0:0	4	->
water	66:54	0:0	4	tile_offset_x
arg	66:69	66:82	3	s->tile_width
water	66:69	0:0	4	s
op	66:70	0:0	4	->
water	66:72	0:0	4	tile_width
water	66:83	0:0	2	;
water	67:4	0:0	2	s
op	67:5	0:0	2	->
water	67:7	0:0	2	numYtiles
op	67:17	0:0	2	=
call	67:19	67:83	2	ff_jpeg2000_ceildiv
arg	67:39	67:67	3	s->height-s->tile_offset_y
water	67:39	0:0	4	s
op	67:40	0:0	4	->
water	67:42	0:0	4	height
op	67:49	0:0	4	-
water	67:51	0:0	4	s
op	67:52	0:0	4	->
water	67:54	0:0	4	tile_offset_y
arg	67:69	67:83	3	s->tile_height
water	67:69	0:0	4	s
op	67:70	0:0	4	->
water	67:72	0:0	4	tile_height
water	67:84	0:0	2	;
if	69:4	72:4	2	(s -> numXtiles * ( uint64_t ) s -> numYtiles > INT_MAX / sizeof ( * s -> tile ))
cond	69:8	69:71	3	s -> numXtiles * ( uint64_t ) s -> numYtiles > INT_MAX / sizeof ( * s -> tile )
water	69:8	0:0	4	s
op	69:9	0:0	4	->
water	69:11	0:0	4	numXtiles
op	69:21	0:0	4	*
water	69:23	0:0	4	(
water	69:24	0:0	4	uint64_t
water	69:32	0:0	4	)
water	69:33	0:0	4	s
op	69:34	0:0	4	->
water	69:36	0:0	4	numYtiles
op	69:46	0:0	4	>
water	69:48	0:0	4	INT_MAX
op	69:55	0:0	4	/
op	69:56	0:0	4	sizeof
water	69:62	0:0	4	(
op	69:63	0:0	4	*
water	69:64	0:0	4	s
op	69:65	0:0	4	->
water	69:67	0:0	4	tile
water	69:71	0:0	4	)
stmts	69:74	72:4	3	
water	69:74	0:0	4	{
water	70:8	0:0	4	s
op	70:9	0:0	4	->
water	70:11	0:0	4	numXtiles
op	70:21	0:0	4	=
water	70:23	0:0	4	s
op	70:24	0:0	4	->
water	70:26	0:0	4	numYtiles
op	70:36	0:0	4	=
water	70:38	0:0	4	0
water	70:39	0:0	4	;
return	71:8	71:30	4	AVERROR(EINVAL)
call	71:15	71:29	5	AVERROR
arg	71:23	71:29	6	EINVAL
water	71:23	0:0	7	EINVAL
water	72:4	0:0	4	}
water	74:4	0:0	2	s
op	74:5	0:0	2	->
water	74:7	0:0	2	tile
op	74:12	0:0	2	=
call	74:14	74:76	2	av_mallocz_array
arg	74:31	74:58	3	s->numXtiles*s->numYtiles
water	74:31	0:0	4	s
op	74:32	0:0	4	->
water	74:34	0:0	4	numXtiles
op	74:44	0:0	4	*
water	74:46	0:0	4	s
op	74:47	0:0	4	->
water	74:49	0:0	4	numYtiles
arg	74:60	74:76	3	sizeof(*s->tile)
op	74:60	0:0	4	sizeof
water	74:66	0:0	4	(
op	74:67	0:0	4	*
water	74:68	0:0	4	s
op	74:69	0:0	4	->
water	74:71	0:0	4	tile
water	74:75	0:0	4	)
water	74:77	0:0	2	;
if	75:4	78:4	2	(! s -> tile)
cond	75:8	75:12	3	! s -> tile
op	75:8	0:0	4	!
water	75:9	0:0	4	s
op	75:10	0:0	4	->
water	75:12	0:0	4	tile
stmts	75:18	78:4	3	
water	75:18	0:0	4	{
water	76:8	0:0	4	s
op	76:9	0:0	4	->
water	76:11	0:0	4	numXtiles
op	76:21	0:0	4	=
water	76:23	0:0	4	s
op	76:24	0:0	4	->
water	76:26	0:0	4	numYtiles
op	76:36	0:0	4	=
water	76:38	0:0	4	0
water	76:39	0:0	4	;
return	77:8	77:30	4	AVERROR(ENOMEM)
call	77:15	77:29	5	AVERROR
arg	77:23	77:29	6	ENOMEM
water	77:23	0:0	7	ENOMEM
water	78:4	0:0	4	}
for	80:4	86:4	2	(i = 0 ;i < s -> numXtiles * s -> numYtiles;i ++)
forinit	80:9	80:14	3	i = 0 ;
water	80:9	0:0	4	i
op	80:11	0:0	4	=
water	80:13	0:0	4	0
water	80:14	0:0	4	;
cond	80:16	80:38	3	i < s -> numXtiles * s -> numYtiles
water	80:16	0:0	4	i
op	80:18	0:0	4	<
water	80:20	0:0	4	s
op	80:21	0:0	4	->
water	80:23	0:0	4	numXtiles
op	80:33	0:0	4	*
water	80:35	0:0	4	s
op	80:36	0:0	4	->
water	80:38	0:0	4	numYtiles
forexpr	80:49	80:50	3	i ++
water	80:49	0:0	4	i
op	80:50	0:0	4	++
stmts	80:54	86:4	3	
water	80:54	0:0	4	{
decl	81:8	81:40	4	Jpeg2000Tile	*tile
op	81:27	0:0	4	=
water	81:29	0:0	4	s
op	81:30	0:0	4	->
water	81:32	0:0	4	tile
op	81:37	0:0	4	+
water	81:39	0:0	4	i
water	83:8	0:0	4	tile
op	83:12	0:0	4	->
water	83:14	0:0	4	comp
op	83:19	0:0	4	=
call	83:21	83:68	4	av_mallocz
arg	83:32	83:68	5	s->ncomponents*sizeof(*tile->comp)
water	83:32	0:0	6	s
op	83:33	0:0	6	->
water	83:35	0:0	6	ncomponents
op	83:47	0:0	6	*
op	83:49	0:0	6	sizeof
water	83:55	0:0	6	(
op	83:56	0:0	6	*
water	83:57	0:0	6	tile
op	83:61	0:0	6	->
water	83:63	0:0	6	comp
water	83:67	0:0	6	)
water	83:69	0:0	4	;
if	84:8	85:34	4	(! tile -> comp)
cond	84:12	84:19	5	! tile -> comp
op	84:12	0:0	6	!
water	84:13	0:0	6	tile
op	84:17	0:0	6	->
water	84:19	0:0	6	comp
stmts	85:12	85:34	5	
return	85:12	85:34	6	AVERROR(ENOMEM)
call	85:19	85:33	7	AVERROR
arg	85:27	85:33	8	ENOMEM
water	85:27	0:0	9	ENOMEM
water	86:4	0:0	4	}
water	89:4	0:0	2	s
op	89:5	0:0	2	->
water	89:7	0:0	2	avctx
op	89:12	0:0	2	->
water	89:14	0:0	2	width
op	89:21	0:0	2	=
call	89:23	90:66	2	ff_jpeg2000_ceildivpow2
arg	89:47	89:76	3	s->width-s->image_offset_x
water	89:47	0:0	4	s
op	89:48	0:0	4	->
water	89:50	0:0	4	width
op	89:57	0:0	4	-
water	89:59	0:0	4	s
op	89:60	0:0	4	->
water	89:62	0:0	4	image_offset_x
arg	90:47	90:66	3	s->reduction_factor
water	90:47	0:0	4	s
op	90:48	0:0	4	->
water	90:50	0:0	4	reduction_factor
water	90:67	0:0	2	;
water	91:4	0:0	2	s
op	91:5	0:0	2	->
water	91:7	0:0	2	avctx
op	91:12	0:0	2	->
water	91:14	0:0	2	height
op	91:21	0:0	2	=
call	91:23	92:66	2	ff_jpeg2000_ceildivpow2
arg	91:47	91:76	3	s->height-s->image_offset_y
water	91:47	0:0	4	s
op	91:48	0:0	4	->
water	91:50	0:0	4	height
op	91:57	0:0	4	-
water	91:59	0:0	4	s
op	91:60	0:0	4	->
water	91:62	0:0	4	image_offset_y
arg	92:47	92:66	3	s->reduction_factor
water	92:47	0:0	4	s
op	92:48	0:0	4	->
water	92:50	0:0	4	reduction_factor
water	92:67	0:0	2	;
if	94:4	98:4	2	(s -> avctx -> profile == FF_PROFILE_JPEG2000_DCINEMA_2K || s -> avctx -> profile == FF_PROFILE_JPEG2000_DCINEMA_4K)
cond	94:8	95:29	3	s -> avctx -> profile == FF_PROFILE_JPEG2000_DCINEMA_2K || s -> avctx -> profile == FF_PROFILE_JPEG2000_DCINEMA_4K
water	94:8	0:0	4	s
op	94:9	0:0	4	->
water	94:11	0:0	4	avctx
op	94:16	0:0	4	->
water	94:18	0:0	4	profile
op	94:26	0:0	4	==
water	94:29	0:0	4	FF_PROFILE_JPEG2000_DCINEMA_2K
op	94:60	0:0	4	||
water	95:8	0:0	4	s
op	95:9	0:0	4	->
water	95:11	0:0	4	avctx
op	95:16	0:0	4	->
water	95:18	0:0	4	profile
op	95:26	0:0	4	==
water	95:29	0:0	4	FF_PROFILE_JPEG2000_DCINEMA_4K
stmts	95:61	98:4	3	
water	95:61	0:0	4	{
water	96:8	0:0	4	possible_fmts
op	96:22	0:0	4	=
water	96:24	0:0	4	xyz_pix_fmts
water	96:36	0:0	4	;
water	97:8	0:0	4	possible_fmts_nb
op	97:25	0:0	4	=
call	97:27	97:54	4	FF_ARRAY_ELEMS
arg	97:42	97:54	5	xyz_pix_fmts
water	97:42	0:0	6	xyz_pix_fmts
water	97:55	0:0	4	;
water	98:4	0:0	4	}
else	98:6	117:4	2
stmts	98:11	117:4	3	
water	98:11	0:0	4	{
switch	99:8	116:8	4	(s -> colour_space)
cond	99:16	99:19	5	s -> colour_space
water	99:16	0:0	6	s
op	99:17	0:0	6	->
water	99:19	0:0	6	colour_space
stmts	99:33	116:8	5	
water	99:33	0:0	6	{
label	100:8	100:15	6	case 16 :
water	101:12	0:0	6	possible_fmts
op	101:26	0:0	6	=
water	101:28	0:0	6	rgb_pix_fmts
water	101:40	0:0	6	;
water	102:12	0:0	6	possible_fmts_nb
op	102:29	0:0	6	=
call	102:31	102:58	6	FF_ARRAY_ELEMS
arg	102:46	102:58	7	rgb_pix_fmts
water	102:46	0:0	8	rgb_pix_fmts
water	102:59	0:0	6	;
break	103:12	103:17	6	
label	104:8	104:15	6	case 17 :
water	105:12	0:0	6	possible_fmts
op	105:26	0:0	6	=
water	105:28	0:0	6	gray_pix_fmts
water	105:41	0:0	6	;
water	106:12	0:0	6	possible_fmts_nb
op	106:29	0:0	6	=
call	106:31	106:59	6	FF_ARRAY_ELEMS
arg	106:46	106:59	7	gray_pix_fmts
water	106:46	0:0	8	gray_pix_fmts
water	106:60	0:0	6	;
break	107:12	107:17	6	
label	108:8	108:15	6	case 18 :
water	109:12	0:0	6	possible_fmts
op	109:26	0:0	6	=
water	109:28	0:0	6	yuv_pix_fmts
water	109:40	0:0	6	;
water	110:12	0:0	6	possible_fmts_nb
op	110:29	0:0	6	=
call	110:31	110:58	6	FF_ARRAY_ELEMS
arg	110:46	110:58	7	yuv_pix_fmts
water	110:46	0:0	8	yuv_pix_fmts
water	110:59	0:0	6	;
break	111:12	111:17	6	
label	112:8	112:15	6	default :
water	113:12	0:0	6	possible_fmts
op	113:26	0:0	6	=
water	113:28	0:0	6	all_pix_fmts
water	113:40	0:0	6	;
water	114:12	0:0	6	possible_fmts_nb
op	114:29	0:0	6	=
call	114:31	114:58	6	FF_ARRAY_ELEMS
arg	114:46	114:58	7	all_pix_fmts
water	114:46	0:0	8	all_pix_fmts
water	114:59	0:0	6	;
break	115:12	115:17	6	
water	116:8	0:0	6	}
water	117:4	0:0	4	}
for	118:4	123:4	2	(i = 0 ;i < possible_fmts_nb;++ i)
forinit	118:9	118:14	3	i = 0 ;
water	118:9	0:0	4	i
op	118:11	0:0	4	=
water	118:13	0:0	4	0
water	118:14	0:0	4	;
cond	118:16	118:20	3	i < possible_fmts_nb
water	118:16	0:0	4	i
op	118:18	0:0	4	<
water	118:20	0:0	4	possible_fmts_nb
forexpr	118:38	118:40	3	++ i
op	118:38	0:0	4	++
water	118:40	0:0	4	i
stmts	118:43	123:4	3	
water	118:43	0:0	4	{
if	119:8	122:8	4	(pix_fmt_match (possible_fmts [ i ] ,ncomponents ,s -> precision ,log2_chroma_wh ,s -> pal8 ))
cond	119:12	119:94	5	pix_fmt_match (possible_fmts [ i ] ,ncomponents ,s -> precision ,log2_chroma_wh ,s -> pal8 )
call	119:12	119:94	6	pix_fmt_match
arg	119:26	119:42	7	possible_fmts[i]
water	119:26	0:0	8	possible_fmts
op	119:39	0:0	8	[
water	119:40	0:0	8	i
op	119:41	0:0	8	]
arg	119:44	119:55	7	ncomponents
water	119:44	0:0	8	ncomponents
arg	119:57	119:69	7	s->precision
water	119:57	0:0	8	s
op	119:58	0:0	8	->
water	119:60	0:0	8	precision
arg	119:71	119:85	7	log2_chroma_wh
water	119:71	0:0	8	log2_chroma_wh
arg	119:87	119:94	7	s->pal8
water	119:87	0:0	8	s
op	119:88	0:0	8	->
water	119:90	0:0	8	pal8
stmts	119:97	122:8	5	
water	119:97	0:0	6	{
water	120:12	0:0	6	s
op	120:13	0:0	6	->
water	120:15	0:0	6	avctx
op	120:20	0:0	6	->
water	120:22	0:0	6	pix_fmt
op	120:30	0:0	6	=
water	120:32	0:0	6	possible_fmts
op	120:45	0:0	6	[
water	120:46	0:0	6	i
op	120:47	0:0	6	]
water	120:48	0:0	6	;
break	121:12	121:17	6	
water	122:8	0:0	6	}
water	123:4	0:0	4	}
if	124:4	135:4	2	(i == possible_fmts_nb)
cond	124:8	124:13	3	i == possible_fmts_nb
water	124:8	0:0	4	i
op	124:10	0:0	4	==
water	124:13	0:0	4	possible_fmts_nb
stmts	124:31	135:4	3	
water	124:31	0:0	4	{
call	125:8	133:46	4	av_log
arg	125:15	125:23	5	s->avctx
water	125:15	0:0	6	s
op	125:16	0:0	6	->
water	125:18	0:0	6	avctx
arg	125:25	125:37	5	AV_LOG_ERROR
water	125:25	0:0	6	AV_LOG_ERROR
arg	126:15	128:65	5	"Unknown pix_fmt, profile: %d, colour_space: %d, ""components: %d, precision: %d, ""cdx[1]: %d, cdy[1]: %d, cdx[2]: %d, cdy[2]: %d\n"
water	126:15	0:0	6	"Unknown pix_fmt, profile: %d, colour_space: %d, "
water	127:15	0:0	6	"components: %d, precision: %d, "
water	128:15	0:0	6	"cdx[1]: %d, cdy[1]: %d, cdx[2]: %d, cdy[2]: %d\n"
arg	129:15	129:32	5	s->avctx->profile
water	129:15	0:0	6	s
op	129:16	0:0	6	->
water	129:18	0:0	6	avctx
op	129:23	0:0	6	->
water	129:25	0:0	6	profile
arg	129:34	129:49	5	s->colour_space
water	129:34	0:0	6	s
op	129:35	0:0	6	->
water	129:37	0:0	6	colour_space
arg	129:51	129:62	5	ncomponents
water	129:51	0:0	6	ncomponents
arg	129:64	129:76	5	s->precision
water	129:64	0:0	6	s
op	129:65	0:0	6	->
water	129:67	0:0	6	precision
arg	130:15	130:46	5	ncomponents>2?s->cdx[1]:0
water	130:15	0:0	6	ncomponents
op	130:27	0:0	6	>
water	130:29	0:0	6	2
water	130:31	0:0	6	?
water	130:33	0:0	6	s
op	130:34	0:0	6	->
water	130:36	0:0	6	cdx
op	130:39	0:0	6	[
water	130:40	0:0	6	1
op	130:41	0:0	6	]
water	130:43	0:0	6	:
water	130:45	0:0	6	0
arg	131:15	131:46	5	ncomponents>2?s->cdy[1]:0
water	131:15	0:0	6	ncomponents
op	131:27	0:0	6	>
water	131:29	0:0	6	2
water	131:31	0:0	6	?
water	131:33	0:0	6	s
op	131:34	0:0	6	->
water	131:36	0:0	6	cdy
op	131:39	0:0	6	[
water	131:40	0:0	6	1
op	131:41	0:0	6	]
water	131:43	0:0	6	:
water	131:45	0:0	6	0
arg	132:15	132:46	5	ncomponents>2?s->cdx[2]:0
water	132:15	0:0	6	ncomponents
op	132:27	0:0	6	>
water	132:29	0:0	6	2
water	132:31	0:0	6	?
water	132:33	0:0	6	s
op	132:34	0:0	6	->
water	132:36	0:0	6	cdx
op	132:39	0:0	6	[
water	132:40	0:0	6	2
op	132:41	0:0	6	]
water	132:43	0:0	6	:
water	132:45	0:0	6	0
arg	133:15	133:46	5	ncomponents>2?s->cdy[2]:0
water	133:15	0:0	6	ncomponents
op	133:27	0:0	6	>
water	133:29	0:0	6	2
water	133:31	0:0	6	?
water	133:33	0:0	6	s
op	133:34	0:0	6	->
water	133:36	0:0	6	cdy
op	133:39	0:0	6	[
water	133:40	0:0	6	2
op	133:41	0:0	6	]
water	133:43	0:0	6	:
water	133:45	0:0	6	0
water	133:47	0:0	4	;
return	134:8	134:35	4	AVERROR_PATCHWELCOME
water	134:15	0:0	5	AVERROR_PATCHWELCOME
water	135:4	0:0	4	}
return	136:4	136:12	2	0
water	136:11	0:0	3	0
