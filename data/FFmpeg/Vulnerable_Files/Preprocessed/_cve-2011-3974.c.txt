func	2:0	23:0	0	static inline int	decode_residual_inter
params	2:39	0:0	1	
param	2:40	2:53	2	AVSContext *	h
stmnts	0:0	22:12	1	
decl	3:4	3:13	2	int	block
decl	6:4	6:36	2	int	cbp
op	6:11	0:0	2	=
call	6:13	6:35	3	get_ue_golomb
arg	6:27	6:35	4	&h->s.gb
op	6:27	0:0	5	&
water	6:28	0:0	5	h
op	6:29	0:0	5	->
water	6:31	0:0	5	s
op	6:32	0:0	5	.
water	6:33	0:0	5	gb
if	7:4	10:4	2	(cbp > 63)
cond	7:7	7:13	3	cbp > 63
water	7:7	0:0	4	cbp
op	7:11	0:0	4	>
water	7:13	0:0	4	63
stmts	7:16	10:4	3	
water	7:16	0:0	4	{
call	8:8	8:62	4	av_log
arg	8:15	8:25	5	h->s.avctx
water	8:15	0:0	6	h
op	8:16	0:0	6	->
water	8:18	0:0	6	s
op	8:19	0:0	6	.
water	8:20	0:0	6	avctx
arg	8:27	8:39	5	AV_LOG_ERROR
water	8:27	0:0	6	AV_LOG_ERROR
arg	8:41	8:62	5	"illegal inter cbp\n"
water	8:41	0:0	6	"illegal inter cbp\n"
water	8:63	0:0	4	;
return	9:8	9:17	4	-1
op	9:15	0:0	5	-
water	9:16	0:0	5	1
water	10:4	0:0	4	}
water	11:4	0:0	2	h
op	11:5	0:0	2	->
water	11:7	0:0	2	cbp
op	11:11	0:0	2	=
water	11:13	0:0	2	cbp_tab
op	11:20	0:0	2	[
water	11:21	0:0	2	cbp
op	11:24	0:0	2	]
op	11:25	0:0	2	[
water	11:26	0:0	2	1
op	11:27	0:0	2	]
water	11:28	0:0	2	;
if	14:4	15:54	2	(h -> cbp && ! h -> qp_fixed)
cond	14:7	14:21	3	h -> cbp && ! h -> qp_fixed
water	14:7	0:0	4	h
op	14:8	0:0	4	->
water	14:10	0:0	4	cbp
op	14:14	0:0	4	&&
op	14:17	0:0	4	!
water	14:18	0:0	4	h
op	14:19	0:0	4	->
water	14:21	0:0	4	qp_fixed
stmts	15:8	15:54	3	
water	15:8	0:0	4	h
op	15:9	0:0	4	->
water	15:11	0:0	4	qp
op	15:14	0:0	4	=
water	15:16	0:0	4	(
water	15:17	0:0	4	h
op	15:18	0:0	4	->
water	15:20	0:0	4	qp
op	15:23	0:0	4	+
call	15:25	15:47	4	get_se_golomb
arg	15:39	15:47	5	&h->s.gb
op	15:39	0:0	6	&
water	15:40	0:0	6	h
op	15:41	0:0	6	->
water	15:43	0:0	6	s
op	15:44	0:0	6	.
water	15:45	0:0	6	gb
water	15:48	0:0	4	)
op	15:50	0:0	4	&
water	15:52	0:0	4	63
water	15:54	0:0	4	;
for	16:4	19:75	2	(block = 0 ;block < 4;block ++)
forinit	16:8	16:15	3	block = 0 ;
water	16:8	0:0	4	block
op	16:13	0:0	4	=
water	16:14	0:0	4	0
water	16:15	0:0	4	;
cond	16:16	16:22	3	block < 4
water	16:16	0:0	4	block
op	16:21	0:0	4	<
water	16:22	0:0	4	4
forexpr	16:24	16:29	3	block ++
water	16:24	0:0	4	block
op	16:29	0:0	4	++
stmts	17:8	19:75	3	
if	17:8	19:75	4	(h -> cbp & ( 1 << block ))
cond	17:11	17:29	5	h -> cbp & ( 1 << block )
water	17:11	0:0	6	h
op	17:12	0:0	6	->
water	17:14	0:0	6	cbp
op	17:18	0:0	6	&
water	17:20	0:0	6	(
water	17:21	0:0	6	1
op	17:22	0:0	6	<<
water	17:24	0:0	6	block
water	17:29	0:0	6	)
stmts	18:12	19:75	5	
call	18:12	19:74	6	decode_residual_block
arg	18:34	18:35	7	h
water	18:34	0:0	8	h
arg	18:36	18:44	7	&h->s.gb
op	18:36	0:0	8	&
water	18:37	0:0	8	h
op	18:38	0:0	8	->
water	18:40	0:0	8	s
op	18:41	0:0	8	.
water	18:42	0:0	8	gb
arg	18:45	18:62	7	ff_cavs_inter_dec
water	18:45	0:0	8	ff_cavs_inter_dec
arg	18:63	18:64	7	0
water	18:63	0:0	8	0
arg	18:65	18:70	7	h->qp
water	18:65	0:0	8	h
op	18:66	0:0	8	->
water	18:68	0:0	8	qp
arg	19:34	19:61	7	h->cy+h->luma_scan[block]
water	19:34	0:0	8	h
op	19:35	0:0	8	->
water	19:37	0:0	8	cy
op	19:40	0:0	8	+
water	19:42	0:0	8	h
op	19:43	0:0	8	->
water	19:45	0:0	8	luma_scan
op	19:54	0:0	8	[
water	19:55	0:0	8	block
op	19:60	0:0	8	]
arg	19:63	19:74	7	h->l_stride
water	19:63	0:0	8	h
op	19:64	0:0	8	->
water	19:66	0:0	8	l_stride
water	19:75	0:0	6	;
call	20:4	20:28	2	decode_residual_chroma
arg	20:27	20:28	3	h
water	20:27	0:0	4	h
water	20:29	0:0	2	;
return	22:4	22:12	2	0
water	22:11	0:0	3	0
