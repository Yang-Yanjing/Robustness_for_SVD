func	1:0	185:0	0	static int	smka_decode_frame
params	1:28	0:0	1	
param	1:29	1:50	2	AVCodecContext *	avctx
param	1:52	1:62	2	void *	data
param	2:29	2:47	2	int *	got_frame_ptr
param	2:49	2:64	2	AVPacket *	avpkt
stmnts	0:0	184:14	1	
decl	4:4	4:29	2	AVFrame	*frame
op	4:23	0:0	2	=
water	4:25	0:0	2	data
decl	5:4	5:36	2	const uint8_t	*buf
op	5:23	0:0	2	=
water	5:25	0:0	2	avpkt
op	5:30	0:0	2	->
water	5:32	0:0	2	data
decl	6:4	6:30	2	int	buf_size
op	6:17	0:0	2	=
water	6:19	0:0	2	avpkt
op	6:24	0:0	2	->
water	6:26	0:0	2	size
decl	7:4	7:20	2	GetBitContext	gb
decl	8:4	8:32	2	HuffContext	h[4]
op	8:21	0:0	2	=
water	8:23	0:0	2	{
water	8:25	0:0	2	{
water	8:27	0:0	2	0
water	8:29	0:0	2	}
water	8:31	0:0	2	}
decl	9:4	9:32	2	VLC	vlc[4]
op	9:21	0:0	2	=
water	9:23	0:0	2	{
water	9:25	0:0	2	{
water	9:27	0:0	2	0
water	9:29	0:0	2	}
water	9:31	0:0	2	}
decl	10:4	10:20	2	int16_t	*samples
decl	11:4	11:21	2	uint8_t	*samples8
decl	12:4	12:11	2	int	val
decl	13:4	13:19	2	int	i
water	13:9	0:0	2	,
decl	13:4	13:19	2	int	res
water	13:14	0:0	2	,
decl	13:4	13:19	2	int	ret
decl	14:4	14:16	2	int	unp_size
decl	15:4	15:20	2	int	bits
water	15:12	0:0	2	,
decl	15:4	15:20	2	int	stereo
decl	16:4	16:24	2	int	pred[2]
op	16:16	0:0	2	=
water	16:18	0:0	2	{
water	16:19	0:0	2	0
water	16:20	0:0	2	,
water	16:22	0:0	2	0
water	16:23	0:0	2	}
if	18:4	21:4	2	(buf_size <= 4)
cond	18:8	18:20	3	buf_size <= 4
water	18:8	0:0	4	buf_size
op	18:17	0:0	4	<=
water	18:20	0:0	4	4
stmts	18:23	21:4	3	
water	18:23	0:0	4	{
call	19:8	19:59	4	av_log
arg	19:15	19:20	5	avctx
water	19:15	0:0	6	avctx
arg	19:22	19:34	5	AV_LOG_ERROR
water	19:22	0:0	6	AV_LOG_ERROR
arg	19:36	19:59	5	"packet is too small\n"
water	19:36	0:0	6	"packet is too small\n"
water	19:60	0:0	4	;
return	20:8	20:30	4	AVERROR(EINVAL)
call	20:15	20:29	5	AVERROR
arg	20:23	20:29	6	EINVAL
water	20:23	0:0	7	EINVAL
water	21:4	0:0	4	}
water	23:4	0:0	2	unp_size
op	23:13	0:0	2	=
call	23:15	23:26	2	AV_RL32
arg	23:23	23:26	3	buf
water	23:23	0:0	4	buf
water	23:27	0:0	2	;
if	25:4	28:4	2	(unp_size > ( 1 U << 24 ))
cond	25:8	25:26	3	unp_size > ( 1 U << 24 )
water	25:8	0:0	4	unp_size
op	25:17	0:0	4	>
water	25:19	0:0	4	(
water	25:20	0:0	4	1
water	25:21	0:0	4	U
op	25:22	0:0	4	<<
water	25:24	0:0	4	24
water	25:26	0:0	4	)
stmts	25:29	28:4	3	
water	25:29	0:0	4	{
call	26:8	26:57	4	av_log
arg	26:15	26:20	5	avctx
water	26:15	0:0	6	avctx
arg	26:22	26:34	5	AV_LOG_ERROR
water	26:22	0:0	6	AV_LOG_ERROR
arg	26:36	26:57	5	"packet is too big\n"
water	26:36	0:0	6	"packet is too big\n"
water	26:58	0:0	4	;
return	27:8	27:34	4	AVERROR_INVALIDDATA
water	27:15	0:0	5	AVERROR_INVALIDDATA
water	28:4	0:0	4	}
if	30:4	31:18	2	(( ret =init_get_bits8 (& gb ,buf + 4 ,buf_size - 4 ) ) < 0)
cond	30:8	30:61	3	( ret =init_get_bits8 (& gb ,buf + 4 ,buf_size - 4 ) ) < 0
water	30:8	0:0	4	(
water	30:9	0:0	4	ret
op	30:13	0:0	4	=
call	30:15	30:56	4	init_get_bits8
arg	30:30	30:33	5	&gb
op	30:30	0:0	6	&
water	30:31	0:0	6	gb
arg	30:35	30:42	5	buf+4
water	30:35	0:0	6	buf
op	30:39	0:0	6	+
water	30:41	0:0	6	4
arg	30:44	30:56	5	buf_size-4
water	30:44	0:0	6	buf_size
op	30:53	0:0	6	-
water	30:55	0:0	6	4
water	30:57	0:0	4	)
op	30:59	0:0	4	<
water	30:61	0:0	4	0
stmts	31:8	31:18	3	
return	31:8	31:18	4	ret
water	31:15	0:0	5	ret
if	33:4	37:4	2	(!get_bits1 (& gb ))
cond	33:7	33:21	3	!get_bits1 (& gb )
op	33:7	0:0	4	!
call	33:8	33:21	4	get_bits1
arg	33:18	33:21	5	&gb
op	33:18	0:0	6	&
water	33:19	0:0	6	gb
stmts	33:23	37:4	3	
water	33:23	0:0	4	{
call	34:8	34:53	4	av_log
arg	34:15	34:20	5	avctx
water	34:15	0:0	6	avctx
arg	34:22	34:33	5	AV_LOG_INFO
water	34:22	0:0	6	AV_LOG_INFO
arg	34:35	34:53	5	"Sound: no data\n"
water	34:35	0:0	6	"Sound: no data\n"
water	34:54	0:0	4	;
op	35:8	0:0	4	*
water	35:9	0:0	4	got_frame_ptr
op	35:23	0:0	4	=
water	35:25	0:0	4	0
water	35:26	0:0	4	;
return	36:8	36:16	4	1
water	36:15	0:0	5	1
water	37:4	0:0	4	}
water	38:4	0:0	2	stereo
op	38:11	0:0	2	=
call	38:13	38:26	2	get_bits1
arg	38:23	38:26	3	&gb
op	38:23	0:0	4	&
water	38:24	0:0	4	gb
water	38:27	0:0	2	;
water	39:4	0:0	2	bits
op	39:9	0:0	2	=
call	39:11	39:24	2	get_bits1
arg	39:21	39:24	3	&gb
op	39:21	0:0	4	&
water	39:22	0:0	4	gb
water	39:25	0:0	2	;
if	40:4	43:4	2	(stereo ^ ( avctx -> channels != 1 ))
cond	40:8	40:38	3	stereo ^ ( avctx -> channels != 1 )
water	40:8	0:0	4	stereo
op	40:15	0:0	4	^
water	40:17	0:0	4	(
water	40:18	0:0	4	avctx
op	40:23	0:0	4	->
water	40:25	0:0	4	channels
op	40:34	0:0	4	!=
water	40:37	0:0	4	1
water	40:38	0:0	4	)
stmts	40:41	43:4	3	
water	40:41	0:0	4	{
call	41:8	41:57	4	av_log
arg	41:15	41:20	5	avctx
water	41:15	0:0	6	avctx
arg	41:22	41:34	5	AV_LOG_ERROR
water	41:22	0:0	6	AV_LOG_ERROR
arg	41:36	41:57	5	"channels mismatch\n"
water	41:36	0:0	6	"channels mismatch\n"
water	41:58	0:0	4	;
return	42:8	42:30	4	AVERROR(EINVAL)
call	42:15	42:29	5	AVERROR
arg	42:23	42:29	6	EINVAL
water	42:23	0:0	7	EINVAL
water	43:4	0:0	4	}
if	44:4	47:4	2	(bits == ( avctx -> sample_fmt == AV_SAMPLE_FMT_U8 ))
cond	44:8	44:54	3	bits == ( avctx -> sample_fmt == AV_SAMPLE_FMT_U8 )
water	44:8	0:0	4	bits
op	44:13	0:0	4	==
water	44:16	0:0	4	(
water	44:17	0:0	4	avctx
op	44:22	0:0	4	->
water	44:24	0:0	4	sample_fmt
op	44:35	0:0	4	==
water	44:38	0:0	4	AV_SAMPLE_FMT_U8
water	44:54	0:0	4	)
stmts	44:57	47:4	3	
water	44:57	0:0	4	{
call	45:8	45:62	4	av_log
arg	45:15	45:20	5	avctx
water	45:15	0:0	6	avctx
arg	45:22	45:34	5	AV_LOG_ERROR
water	45:22	0:0	6	AV_LOG_ERROR
arg	45:36	45:62	5	"sample format mismatch\n"
water	45:36	0:0	6	"sample format mismatch\n"
water	45:63	0:0	4	;
return	46:8	46:30	4	AVERROR(EINVAL)
call	46:15	46:29	5	AVERROR
arg	46:23	46:29	6	EINVAL
water	46:23	0:0	7	EINVAL
water	47:4	0:0	4	}
water	50:4	0:0	2	frame
op	50:9	0:0	2	->
water	50:11	0:0	2	nb_samples
op	50:22	0:0	2	=
water	50:24	0:0	2	unp_size
op	50:33	0:0	2	/
water	50:35	0:0	2	(
water	50:36	0:0	2	avctx
op	50:41	0:0	2	->
water	50:43	0:0	2	channels
op	50:52	0:0	2	*
water	50:54	0:0	2	(
water	50:55	0:0	2	bits
op	50:60	0:0	2	+
water	50:62	0:0	2	1
water	50:63	0:0	2	)
water	50:64	0:0	2	)
water	50:65	0:0	2	;
if	51:4	52:18	2	(( ret =ff_get_buffer (avctx ,frame ,0 ) ) < 0)
cond	51:8	51:49	3	( ret =ff_get_buffer (avctx ,frame ,0 ) ) < 0
water	51:8	0:0	4	(
water	51:9	0:0	4	ret
op	51:13	0:0	4	=
call	51:15	51:44	4	ff_get_buffer
arg	51:29	51:34	5	avctx
water	51:29	0:0	6	avctx
arg	51:36	51:41	5	frame
water	51:36	0:0	6	frame
arg	51:43	51:44	5	0
water	51:43	0:0	6	0
water	51:45	0:0	4	)
op	51:47	0:0	4	<
water	51:49	0:0	4	0
stmts	52:8	52:18	3	
return	52:8	52:18	4	ret
water	52:15	0:0	5	ret
water	53:4	0:0	2	samples
op	53:13	0:0	2	=
water	53:15	0:0	2	(
water	53:16	0:0	2	int16_t
op	53:24	0:0	2	*
water	53:25	0:0	2	)
water	53:26	0:0	2	frame
op	53:31	0:0	2	->
water	53:33	0:0	2	data
op	53:37	0:0	2	[
water	53:38	0:0	2	0
op	53:39	0:0	2	]
water	53:40	0:0	2	;
water	54:4	0:0	2	samples8
op	54:13	0:0	2	=
water	54:26	0:0	2	frame
op	54:31	0:0	2	->
water	54:33	0:0	2	data
op	54:37	0:0	2	[
water	54:38	0:0	2	0
op	54:39	0:0	2	]
water	54:40	0:0	2	;
for	57:4	84:4	2	(i = 0 ;i < ( 1 << ( bits + stereo ) );i ++)
forinit	57:8	57:13	3	i = 0 ;
water	57:8	0:0	4	i
op	57:10	0:0	4	=
water	57:12	0:0	4	0
water	57:13	0:0	4	;
cond	57:15	57:40	3	i < ( 1 << ( bits + stereo ) )
water	57:15	0:0	4	i
op	57:17	0:0	4	<
water	57:19	0:0	4	(
water	57:20	0:0	4	1
op	57:22	0:0	4	<<
water	57:25	0:0	4	(
water	57:26	0:0	4	bits
op	57:31	0:0	4	+
water	57:33	0:0	4	stereo
water	57:39	0:0	4	)
water	57:40	0:0	4	)
forexpr	57:43	57:44	3	i ++
water	57:43	0:0	4	i
op	57:44	0:0	4	++
stmts	57:48	84:4	3	
water	57:48	0:0	4	{
water	58:8	0:0	4	h
op	58:9	0:0	4	[
water	58:10	0:0	4	i
op	58:11	0:0	4	]
op	58:12	0:0	4	.
water	58:13	0:0	4	length
op	58:20	0:0	4	=
water	58:22	0:0	4	256
water	58:25	0:0	4	;
water	59:8	0:0	4	h
op	59:9	0:0	4	[
water	59:10	0:0	4	i
op	59:11	0:0	4	]
op	59:12	0:0	4	.
water	59:13	0:0	4	maxlength
op	59:23	0:0	4	=
water	59:25	0:0	4	0
water	59:26	0:0	4	;
water	60:8	0:0	4	h
op	60:9	0:0	4	[
water	60:10	0:0	4	i
op	60:11	0:0	4	]
op	60:12	0:0	4	.
water	60:13	0:0	4	current
op	60:21	0:0	4	=
water	60:23	0:0	4	0
water	60:24	0:0	4	;
water	61:8	0:0	4	h
op	61:9	0:0	4	[
water	61:10	0:0	4	i
op	61:11	0:0	4	]
op	61:12	0:0	4	.
water	61:13	0:0	4	bits
op	61:18	0:0	4	=
call	61:20	61:38	4	av_mallocz
arg	61:31	61:38	5	256*4
water	61:31	0:0	6	256
op	61:35	0:0	6	*
water	61:37	0:0	6	4
water	61:39	0:0	4	;
water	62:8	0:0	4	h
op	62:9	0:0	4	[
water	62:10	0:0	4	i
op	62:11	0:0	4	]
op	62:12	0:0	4	.
water	62:13	0:0	4	lengths
op	62:21	0:0	4	=
call	62:23	62:51	4	av_mallocz
arg	62:34	62:51	5	256*sizeof(int)
water	62:34	0:0	6	256
op	62:38	0:0	6	*
op	62:40	0:0	6	sizeof
water	62:46	0:0	6	(
water	62:47	0:0	6	int
water	62:50	0:0	6	)
water	62:52	0:0	4	;
water	63:8	0:0	4	h
op	63:9	0:0	4	[
water	63:10	0:0	4	i
op	63:11	0:0	4	]
op	63:12	0:0	4	.
water	63:13	0:0	4	values
op	63:20	0:0	4	=
call	63:22	63:50	4	av_mallocz
arg	63:33	63:50	5	256*sizeof(int)
water	63:33	0:0	6	256
op	63:37	0:0	6	*
op	63:39	0:0	6	sizeof
water	63:45	0:0	6	(
water	63:46	0:0	6	int
water	63:49	0:0	6	)
water	63:51	0:0	4	;
if	64:8	67:8	4	(! h [ i ] . bits || ! h [ i ] . lengths || ! h [ i ] . values)
cond	64:12	64:49	5	! h [ i ] . bits || ! h [ i ] . lengths || ! h [ i ] . values
op	64:12	0:0	6	!
water	64:13	0:0	6	h
op	64:14	0:0	6	[
water	64:15	0:0	6	i
op	64:16	0:0	6	]
op	64:17	0:0	6	.
water	64:18	0:0	6	bits
op	64:23	0:0	6	||
op	64:26	0:0	6	!
water	64:27	0:0	6	h
op	64:28	0:0	6	[
water	64:29	0:0	6	i
op	64:30	0:0	6	]
op	64:31	0:0	6	.
water	64:32	0:0	6	lengths
op	64:40	0:0	6	||
op	64:43	0:0	6	!
water	64:44	0:0	6	h
op	64:45	0:0	6	[
water	64:46	0:0	6	i
op	64:47	0:0	6	]
op	64:48	0:0	6	.
water	64:49	0:0	6	values
stmts	64:57	67:8	5	
water	64:57	0:0	6	{
water	65:12	0:0	6	ret
op	65:16	0:0	6	=
call	65:18	65:32	6	AVERROR
arg	65:26	65:32	7	ENOMEM
water	65:26	0:0	8	ENOMEM
water	65:33	0:0	6	;
goto	66:12	66:22	6	error
water	66:17	0:0	7	error
water	67:8	0:0	6	}
call	68:8	68:22	4	skip_bits1
arg	68:19	68:22	5	&gb
op	68:19	0:0	6	&
water	68:20	0:0	6	gb
water	68:23	0:0	4	;
if	69:8	72:8	4	(smacker_decode_tree (& gb ,& h [ i ] ,0 ,0 ) < 0)
cond	69:12	69:52	5	smacker_decode_tree (& gb ,& h [ i ] ,0 ,0 ) < 0
call	69:12	69:48	6	smacker_decode_tree
arg	69:32	69:35	7	&gb
op	69:32	0:0	8	&
water	69:33	0:0	8	gb
arg	69:37	69:42	7	&h[i]
op	69:37	0:0	8	&
water	69:38	0:0	8	h
op	69:39	0:0	8	[
water	69:40	0:0	8	i
op	69:41	0:0	8	]
arg	69:44	69:45	7	0
water	69:44	0:0	8	0
arg	69:47	69:48	7	0
water	69:47	0:0	8	0
op	69:50	0:0	6	<
water	69:52	0:0	6	0
stmts	69:55	72:8	5	
water	69:55	0:0	6	{
water	70:12	0:0	6	ret
op	70:16	0:0	6	=
water	70:18	0:0	6	AVERROR_INVALIDDATA
water	70:37	0:0	6	;
goto	71:12	71:22	6	error
water	71:17	0:0	7	error
water	72:8	0:0	6	}
call	73:8	73:22	4	skip_bits1
arg	73:19	73:22	5	&gb
op	73:19	0:0	6	&
water	73:20	0:0	6	gb
water	73:23	0:0	4	;
if	74:8	83:8	4	(h [ i ] . current > 1)
cond	74:11	74:26	5	h [ i ] . current > 1
water	74:11	0:0	6	h
op	74:12	0:0	6	[
water	74:13	0:0	6	i
op	74:14	0:0	6	]
op	74:15	0:0	6	.
water	74:16	0:0	6	current
op	74:24	0:0	6	>
water	74:26	0:0	6	1
stmts	74:29	83:8	5	
water	74:29	0:0	6	{
water	75:12	0:0	6	res
op	75:16	0:0	6	=
call	75:18	77:78	6	init_vlc
arg	75:27	75:34	7	&vlc[i]
op	75:27	0:0	8	&
water	75:28	0:0	8	vlc
op	75:31	0:0	8	[
water	75:32	0:0	8	i
op	75:33	0:0	8	]
arg	75:36	75:48	7	SMKTREE_BITS
water	75:36	0:0	8	SMKTREE_BITS
arg	75:50	75:61	7	h[i].length
water	75:50	0:0	8	h
op	75:51	0:0	8	[
water	75:52	0:0	8	i
op	75:53	0:0	8	]
op	75:54	0:0	8	.
water	75:55	0:0	8	length
arg	76:20	76:32	7	h[i].lengths
water	76:20	0:0	8	h
op	76:21	0:0	8	[
water	76:22	0:0	8	i
op	76:23	0:0	8	]
op	76:24	0:0	8	.
water	76:25	0:0	8	lengths
arg	76:34	76:45	7	sizeof(int)
op	76:34	0:0	8	sizeof
water	76:40	0:0	8	(
water	76:41	0:0	8	int
water	76:44	0:0	8	)
arg	76:47	76:58	7	sizeof(int)
op	76:47	0:0	8	sizeof
water	76:53	0:0	8	(
water	76:54	0:0	8	int
water	76:57	0:0	8	)
arg	77:20	77:29	7	h[i].bits
water	77:20	0:0	8	h
op	77:21	0:0	8	[
water	77:22	0:0	8	i
op	77:23	0:0	8	]
op	77:24	0:0	8	.
water	77:25	0:0	8	bits
arg	77:31	77:47	7	sizeof(uint32_t)
op	77:31	0:0	8	sizeof
water	77:37	0:0	8	(
water	77:38	0:0	8	uint32_t
water	77:46	0:0	8	)
arg	77:49	77:65	7	sizeof(uint32_t)
op	77:49	0:0	8	sizeof
water	77:55	0:0	8	(
water	77:56	0:0	8	uint32_t
water	77:64	0:0	8	)
arg	77:67	77:78	7	INIT_VLC_LE
water	77:67	0:0	8	INIT_VLC_LE
water	77:79	0:0	6	;
if	78:12	82:12	6	(res < 0)
cond	78:15	78:21	7	res < 0
water	78:15	0:0	8	res
op	78:19	0:0	8	<
water	78:21	0:0	8	0
stmts	78:24	82:12	7	
water	78:24	0:0	8	{
call	79:16	79:70	8	av_log
arg	79:23	79:28	9	avctx
water	79:23	0:0	10	avctx
arg	79:30	79:42	9	AV_LOG_ERROR
water	79:30	0:0	10	AV_LOG_ERROR
arg	79:44	79:70	9	"Cannot build VLC table\n"
water	79:44	0:0	10	"Cannot build VLC table\n"
water	79:71	0:0	8	;
water	80:16	0:0	8	ret
op	80:20	0:0	8	=
water	80:22	0:0	8	AVERROR_INVALIDDATA
water	80:41	0:0	8	;
goto	81:16	81:26	8	error
water	81:21	0:0	9	error
water	82:12	0:0	8	}
water	83:8	0:0	6	}
water	84:4	0:0	4	}
if	86:4	138:4	2	(bits)
cond	86:7	86:7	3	bits
water	86:7	0:0	4	bits
stmts	86:13	138:4	3	
water	86:13	0:0	4	{
for	87:8	88:68	4	(i = stereo ;i >= 0;i --)
forinit	87:12	87:22	5	i = stereo ;
water	87:12	0:0	6	i
op	87:14	0:0	6	=
water	87:16	0:0	6	stereo
water	87:22	0:0	6	;
cond	87:24	87:29	5	i >= 0
water	87:24	0:0	6	i
op	87:26	0:0	6	>=
water	87:29	0:0	6	0
forexpr	87:32	87:33	5	i --
water	87:32	0:0	6	i
op	87:33	0:0	6	--
stmts	88:12	88:68	5	
water	88:12	0:0	6	pred
op	88:16	0:0	6	[
water	88:17	0:0	6	i
op	88:18	0:0	6	]
op	88:20	0:0	6	=
call	88:22	88:67	6	sign_extend
arg	88:34	88:63	7	av_bswap16(get_bits(&gb,16))
call	88:34	88:62	8	av_bswap16
arg	88:45	88:62	9	get_bits(&gb,16)
call	88:45	88:61	10	get_bits
arg	88:54	88:57	11	&gb
op	88:54	0:0	12	&
water	88:55	0:0	12	gb
arg	88:59	88:61	11	16
water	88:59	0:0	12	16
arg	88:65	88:67	7	16
water	88:65	0:0	8	16
water	88:68	0:0	6	;
for	89:8	90:32	4	(i = 0 ;i <= stereo;i ++)
forinit	89:12	89:17	5	i = 0 ;
water	89:12	0:0	6	i
op	89:14	0:0	6	=
water	89:16	0:0	6	0
water	89:17	0:0	6	;
cond	89:19	89:24	5	i <= stereo
water	89:19	0:0	6	i
op	89:21	0:0	6	<=
water	89:24	0:0	6	stereo
forexpr	89:32	89:33	5	i ++
water	89:32	0:0	6	i
op	89:33	0:0	6	++
stmts	90:12	90:32	5	
op	90:12	0:0	6	*
water	90:13	0:0	6	samples
op	90:20	0:0	6	++
op	90:23	0:0	6	=
water	90:25	0:0	6	pred
op	90:29	0:0	6	[
water	90:30	0:0	6	i
op	90:31	0:0	6	]
water	90:32	0:0	6	;
for	91:8	137:8	4	(;i < unp_size / 2;i ++)
forinit	91:12	91:12	5	;
water	91:12	0:0	6	;
cond	91:14	91:29	5	i < unp_size / 2
water	91:14	0:0	6	i
op	91:16	0:0	6	<
water	91:18	0:0	6	unp_size
op	91:27	0:0	6	/
water	91:29	0:0	6	2
forexpr	91:32	91:33	5	i ++
water	91:32	0:0	6	i
op	91:33	0:0	6	++
stmts	91:37	137:8	5	
water	91:37	0:0	6	{
if	92:12	93:42	6	(get_bits_left (& gb ) < 0)
cond	92:15	92:34	7	get_bits_left (& gb ) < 0
call	92:15	92:32	8	get_bits_left
arg	92:29	92:32	9	&gb
op	92:29	0:0	10	&
water	92:30	0:0	10	gb
op	92:33	0:0	8	<
water	92:34	0:0	8	0
stmts	93:16	93:42	7	
return	93:16	93:42	8	AVERROR_INVALIDDATA
water	93:23	0:0	9	AVERROR_INVALIDDATA
if	94:12	115:12	6	(i & stereo)
cond	94:15	94:19	7	i & stereo
water	94:15	0:0	8	i
op	94:17	0:0	8	&
water	94:19	0:0	8	stereo
stmts	94:27	115:12	7	
water	94:27	0:0	8	{
if	95:16	96:70	8	(vlc [ 2 ] . table)
cond	95:19	95:26	9	vlc [ 2 ] . table
water	95:19	0:0	10	vlc
op	95:22	0:0	10	[
water	95:23	0:0	10	2
op	95:24	0:0	10	]
op	95:25	0:0	10	.
water	95:26	0:0	10	table
stmts	96:20	96:70	9	
water	96:20	0:0	10	res
op	96:24	0:0	10	=
call	96:26	96:69	10	get_vlc2
arg	96:35	96:38	11	&gb
op	96:35	0:0	12	&
water	96:36	0:0	12	gb
arg	96:40	96:52	11	vlc[2].table
water	96:40	0:0	12	vlc
op	96:43	0:0	12	[
water	96:44	0:0	12	2
op	96:45	0:0	12	]
op	96:46	0:0	12	.
water	96:47	0:0	12	table
arg	96:54	96:66	11	SMKTREE_BITS
water	96:54	0:0	12	SMKTREE_BITS
arg	96:68	96:69	11	3
water	96:68	0:0	12	3
water	96:70	0:0	10	;
else	97:16	98:27	8
stmts	98:20	98:27	9	
water	98:20	0:0	10	res
op	98:24	0:0	10	=
water	98:26	0:0	10	0
water	98:27	0:0	10	;
if	99:16	102:16	8	(res < 0)
cond	99:20	99:26	9	res < 0
water	99:20	0:0	10	res
op	99:24	0:0	10	<
water	99:26	0:0	10	0
stmts	99:29	102:16	9	
water	99:29	0:0	10	{
call	100:20	100:63	10	av_log
arg	100:27	100:32	11	avctx
water	100:27	0:0	12	avctx
arg	100:34	100:46	11	AV_LOG_ERROR
water	100:34	0:0	12	AV_LOG_ERROR
arg	100:48	100:63	11	"invalid vlc\n"
water	100:48	0:0	12	"invalid vlc\n"
water	100:64	0:0	10	;
return	101:20	101:46	10	AVERROR_INVALIDDATA
water	101:27	0:0	11	AVERROR_INVALIDDATA
water	102:16	0:0	10	}
water	103:16	0:0	8	val
op	103:21	0:0	8	=
water	103:23	0:0	8	h
op	103:24	0:0	8	[
water	103:25	0:0	8	2
op	103:26	0:0	8	]
op	103:27	0:0	8	.
water	103:28	0:0	8	values
op	103:34	0:0	8	[
water	103:35	0:0	8	res
op	103:38	0:0	8	]
water	103:39	0:0	8	;
if	104:16	105:70	8	(vlc [ 3 ] . table)
cond	104:19	104:26	9	vlc [ 3 ] . table
water	104:19	0:0	10	vlc
op	104:22	0:0	10	[
water	104:23	0:0	10	3
op	104:24	0:0	10	]
op	104:25	0:0	10	.
water	104:26	0:0	10	table
stmts	105:20	105:70	9	
water	105:20	0:0	10	res
op	105:24	0:0	10	=
call	105:26	105:69	10	get_vlc2
arg	105:35	105:38	11	&gb
op	105:35	0:0	12	&
water	105:36	0:0	12	gb
arg	105:40	105:52	11	vlc[3].table
water	105:40	0:0	12	vlc
op	105:43	0:0	12	[
water	105:44	0:0	12	3
op	105:45	0:0	12	]
op	105:46	0:0	12	.
water	105:47	0:0	12	table
arg	105:54	105:66	11	SMKTREE_BITS
water	105:54	0:0	12	SMKTREE_BITS
arg	105:68	105:69	11	3
water	105:68	0:0	12	3
water	105:70	0:0	10	;
else	106:16	107:27	8
stmts	107:20	107:27	9	
water	107:20	0:0	10	res
op	107:24	0:0	10	=
water	107:26	0:0	10	0
water	107:27	0:0	10	;
if	108:16	111:16	8	(res < 0)
cond	108:20	108:26	9	res < 0
water	108:20	0:0	10	res
op	108:24	0:0	10	<
water	108:26	0:0	10	0
stmts	108:29	111:16	9	
water	108:29	0:0	10	{
call	109:20	109:63	10	av_log
arg	109:27	109:32	11	avctx
water	109:27	0:0	12	avctx
arg	109:34	109:46	11	AV_LOG_ERROR
water	109:34	0:0	12	AV_LOG_ERROR
arg	109:48	109:63	11	"invalid vlc\n"
water	109:48	0:0	12	"invalid vlc\n"
water	109:64	0:0	10	;
return	110:20	110:46	10	AVERROR_INVALIDDATA
water	110:27	0:0	11	AVERROR_INVALIDDATA
water	111:16	0:0	10	}
water	112:16	0:0	8	val
op	112:20	0:0	8	|=
water	112:23	0:0	8	h
op	112:24	0:0	8	[
water	112:25	0:0	8	3
op	112:26	0:0	8	]
op	112:27	0:0	8	.
water	112:28	0:0	8	values
op	112:34	0:0	8	[
water	112:35	0:0	8	res
op	112:38	0:0	8	]
op	112:40	0:0	8	<<
water	112:43	0:0	8	8
water	112:44	0:0	8	;
water	113:16	0:0	8	pred
op	113:20	0:0	8	[
water	113:21	0:0	8	1
op	113:22	0:0	8	]
op	113:24	0:0	8	+=
call	113:27	113:46	8	sign_extend
arg	113:39	113:42	9	val
water	113:39	0:0	10	val
arg	113:44	113:46	9	16
water	113:44	0:0	10	16
water	113:47	0:0	8	;
op	114:16	0:0	8	*
water	114:17	0:0	8	samples
op	114:24	0:0	8	++
op	114:27	0:0	8	=
water	114:29	0:0	8	pred
op	114:33	0:0	8	[
water	114:34	0:0	8	1
op	114:35	0:0	8	]
water	114:36	0:0	8	;
water	115:12	0:0	8	}
else	115:14	136:12	6
stmts	115:19	136:12	7	
water	115:19	0:0	8	{
if	116:16	117:70	8	(vlc [ 0 ] . table)
cond	116:19	116:26	9	vlc [ 0 ] . table
water	116:19	0:0	10	vlc
op	116:22	0:0	10	[
water	116:23	0:0	10	0
op	116:24	0:0	10	]
op	116:25	0:0	10	.
water	116:26	0:0	10	table
stmts	117:20	117:70	9	
water	117:20	0:0	10	res
op	117:24	0:0	10	=
call	117:26	117:69	10	get_vlc2
arg	117:35	117:38	11	&gb
op	117:35	0:0	12	&
water	117:36	0:0	12	gb
arg	117:40	117:52	11	vlc[0].table
water	117:40	0:0	12	vlc
op	117:43	0:0	12	[
water	117:44	0:0	12	0
op	117:45	0:0	12	]
op	117:46	0:0	12	.
water	117:47	0:0	12	table
arg	117:54	117:66	11	SMKTREE_BITS
water	117:54	0:0	12	SMKTREE_BITS
arg	117:68	117:69	11	3
water	117:68	0:0	12	3
water	117:70	0:0	10	;
else	118:16	119:27	8
stmts	119:20	119:27	9	
water	119:20	0:0	10	res
op	119:24	0:0	10	=
water	119:26	0:0	10	0
water	119:27	0:0	10	;
if	120:16	123:16	8	(res < 0)
cond	120:20	120:26	9	res < 0
water	120:20	0:0	10	res
op	120:24	0:0	10	<
water	120:26	0:0	10	0
stmts	120:29	123:16	9	
water	120:29	0:0	10	{
call	121:20	121:63	10	av_log
arg	121:27	121:32	11	avctx
water	121:27	0:0	12	avctx
arg	121:34	121:46	11	AV_LOG_ERROR
water	121:34	0:0	12	AV_LOG_ERROR
arg	121:48	121:63	11	"invalid vlc\n"
water	121:48	0:0	12	"invalid vlc\n"
water	121:64	0:0	10	;
return	122:20	122:46	10	AVERROR_INVALIDDATA
water	122:27	0:0	11	AVERROR_INVALIDDATA
water	123:16	0:0	10	}
water	124:16	0:0	8	val
op	124:21	0:0	8	=
water	124:23	0:0	8	h
op	124:24	0:0	8	[
water	124:25	0:0	8	0
op	124:26	0:0	8	]
op	124:27	0:0	8	.
water	124:28	0:0	8	values
op	124:34	0:0	8	[
water	124:35	0:0	8	res
op	124:38	0:0	8	]
water	124:39	0:0	8	;
if	125:16	126:70	8	(vlc [ 1 ] . table)
cond	125:19	125:26	9	vlc [ 1 ] . table
water	125:19	0:0	10	vlc
op	125:22	0:0	10	[
water	125:23	0:0	10	1
op	125:24	0:0	10	]
op	125:25	0:0	10	.
water	125:26	0:0	10	table
stmts	126:20	126:70	9	
water	126:20	0:0	10	res
op	126:24	0:0	10	=
call	126:26	126:69	10	get_vlc2
arg	126:35	126:38	11	&gb
op	126:35	0:0	12	&
water	126:36	0:0	12	gb
arg	126:40	126:52	11	vlc[1].table
water	126:40	0:0	12	vlc
op	126:43	0:0	12	[
water	126:44	0:0	12	1
op	126:45	0:0	12	]
op	126:46	0:0	12	.
water	126:47	0:0	12	table
arg	126:54	126:66	11	SMKTREE_BITS
water	126:54	0:0	12	SMKTREE_BITS
arg	126:68	126:69	11	3
water	126:68	0:0	12	3
water	126:70	0:0	10	;
else	127:16	128:27	8
stmts	128:20	128:27	9	
water	128:20	0:0	10	res
op	128:24	0:0	10	=
water	128:26	0:0	10	0
water	128:27	0:0	10	;
if	129:16	132:16	8	(res < 0)
cond	129:20	129:26	9	res < 0
water	129:20	0:0	10	res
op	129:24	0:0	10	<
water	129:26	0:0	10	0
stmts	129:29	132:16	9	
water	129:29	0:0	10	{
call	130:20	130:63	10	av_log
arg	130:27	130:32	11	avctx
water	130:27	0:0	12	avctx
arg	130:34	130:46	11	AV_LOG_ERROR
water	130:34	0:0	12	AV_LOG_ERROR
arg	130:48	130:63	11	"invalid vlc\n"
water	130:48	0:0	12	"invalid vlc\n"
water	130:64	0:0	10	;
return	131:20	131:46	10	AVERROR_INVALIDDATA
water	131:27	0:0	11	AVERROR_INVALIDDATA
water	132:16	0:0	10	}
water	133:16	0:0	8	val
op	133:20	0:0	8	|=
water	133:23	0:0	8	h
op	133:24	0:0	8	[
water	133:25	0:0	8	1
op	133:26	0:0	8	]
op	133:27	0:0	8	.
water	133:28	0:0	8	values
op	133:34	0:0	8	[
water	133:35	0:0	8	res
op	133:38	0:0	8	]
op	133:40	0:0	8	<<
water	133:43	0:0	8	8
water	133:44	0:0	8	;
water	134:16	0:0	8	pred
op	134:20	0:0	8	[
water	134:21	0:0	8	0
op	134:22	0:0	8	]
op	134:24	0:0	8	+=
call	134:27	134:46	8	sign_extend
arg	134:39	134:42	9	val
water	134:39	0:0	10	val
arg	134:44	134:46	9	16
water	134:44	0:0	10	16
water	134:47	0:0	8	;
op	135:16	0:0	8	*
water	135:17	0:0	8	samples
op	135:24	0:0	8	++
op	135:27	0:0	8	=
water	135:29	0:0	8	pred
op	135:33	0:0	8	[
water	135:34	0:0	8	0
op	135:35	0:0	8	]
water	135:36	0:0	8	;
water	136:12	0:0	8	}
water	137:8	0:0	6	}
water	138:4	0:0	4	}
else	138:6	170:4	2
stmts	138:11	170:4	3	
water	138:11	0:0	4	{
for	139:8	140:38	4	(i = stereo ;i >= 0;i --)
forinit	139:12	139:22	5	i = stereo ;
water	139:12	0:0	6	i
op	139:14	0:0	6	=
water	139:16	0:0	6	stereo
water	139:22	0:0	6	;
cond	139:24	139:29	5	i >= 0
water	139:24	0:0	6	i
op	139:26	0:0	6	>=
water	139:29	0:0	6	0
forexpr	139:32	139:33	5	i --
water	139:32	0:0	6	i
op	139:33	0:0	6	--
stmts	140:12	140:38	5	
water	140:12	0:0	6	pred
op	140:16	0:0	6	[
water	140:17	0:0	6	i
op	140:18	0:0	6	]
op	140:20	0:0	6	=
call	140:22	140:37	6	get_bits
arg	140:31	140:34	7	&gb
op	140:31	0:0	8	&
water	140:32	0:0	8	gb
arg	140:36	140:37	7	8
water	140:36	0:0	8	8
water	140:38	0:0	6	;
for	141:8	142:33	4	(i = 0 ;i <= stereo;i ++)
forinit	141:12	141:17	5	i = 0 ;
water	141:12	0:0	6	i
op	141:14	0:0	6	=
water	141:16	0:0	6	0
water	141:17	0:0	6	;
cond	141:19	141:24	5	i <= stereo
water	141:19	0:0	6	i
op	141:21	0:0	6	<=
water	141:24	0:0	6	stereo
forexpr	141:32	141:33	5	i ++
water	141:32	0:0	6	i
op	141:33	0:0	6	++
stmts	142:12	142:33	5	
op	142:12	0:0	6	*
water	142:13	0:0	6	samples8
op	142:21	0:0	6	++
op	142:24	0:0	6	=
water	142:26	0:0	6	pred
op	142:30	0:0	6	[
water	142:31	0:0	6	i
op	142:32	0:0	6	]
water	142:33	0:0	6	;
for	143:8	169:8	4	(;i < unp_size;i ++)
forinit	143:12	143:12	5	;
water	143:12	0:0	6	;
cond	143:14	143:18	5	i < unp_size
water	143:14	0:0	6	i
op	143:16	0:0	6	<
water	143:18	0:0	6	unp_size
forexpr	143:28	143:29	5	i ++
water	143:28	0:0	6	i
op	143:29	0:0	6	++
stmts	143:33	169:8	5	
water	143:33	0:0	6	{
if	144:12	145:42	6	(get_bits_left (& gb ) < 0)
cond	144:15	144:34	7	get_bits_left (& gb ) < 0
call	144:15	144:32	8	get_bits_left
arg	144:29	144:32	9	&gb
op	144:29	0:0	10	&
water	144:30	0:0	10	gb
op	144:33	0:0	8	<
water	144:34	0:0	8	0
stmts	145:16	145:42	7	
return	145:16	145:42	8	AVERROR_INVALIDDATA
water	145:23	0:0	9	AVERROR_INVALIDDATA
if	146:12	157:12	6	(i & stereo)
cond	146:15	146:19	7	i & stereo
water	146:15	0:0	8	i
op	146:17	0:0	8	&
water	146:19	0:0	8	stereo
stmts	146:26	157:12	7	
water	146:26	0:0	8	{
if	147:16	148:70	8	(vlc [ 1 ] . table)
cond	147:19	147:26	9	vlc [ 1 ] . table
water	147:19	0:0	10	vlc
op	147:22	0:0	10	[
water	147:23	0:0	10	1
op	147:24	0:0	10	]
op	147:25	0:0	10	.
water	147:26	0:0	10	table
stmts	148:20	148:70	9	
water	148:20	0:0	10	res
op	148:24	0:0	10	=
call	148:26	148:69	10	get_vlc2
arg	148:35	148:38	11	&gb
op	148:35	0:0	12	&
water	148:36	0:0	12	gb
arg	148:40	148:52	11	vlc[1].table
water	148:40	0:0	12	vlc
op	148:43	0:0	12	[
water	148:44	0:0	12	1
op	148:45	0:0	12	]
op	148:46	0:0	12	.
water	148:47	0:0	12	table
arg	148:54	148:66	11	SMKTREE_BITS
water	148:54	0:0	12	SMKTREE_BITS
arg	148:68	148:69	11	3
water	148:68	0:0	12	3
water	148:70	0:0	10	;
else	149:16	150:27	8
stmts	150:20	150:27	9	
water	150:20	0:0	10	res
op	150:24	0:0	10	=
water	150:26	0:0	10	0
water	150:27	0:0	10	;
if	151:16	154:16	8	(res < 0)
cond	151:20	151:26	9	res < 0
water	151:20	0:0	10	res
op	151:24	0:0	10	<
water	151:26	0:0	10	0
stmts	151:29	154:16	9	
water	151:29	0:0	10	{
call	152:20	152:63	10	av_log
arg	152:27	152:32	11	avctx
water	152:27	0:0	12	avctx
arg	152:34	152:46	11	AV_LOG_ERROR
water	152:34	0:0	12	AV_LOG_ERROR
arg	152:48	152:63	11	"invalid vlc\n"
water	152:48	0:0	12	"invalid vlc\n"
water	152:64	0:0	10	;
return	153:20	153:46	10	AVERROR_INVALIDDATA
water	153:27	0:0	11	AVERROR_INVALIDDATA
water	154:16	0:0	10	}
water	155:16	0:0	8	pred
op	155:20	0:0	8	[
water	155:21	0:0	8	1
op	155:22	0:0	8	]
op	155:24	0:0	8	+=
call	155:27	155:58	8	sign_extend
arg	155:39	155:55	9	h[1].values[res]
water	155:39	0:0	10	h
op	155:40	0:0	10	[
water	155:41	0:0	10	1
op	155:42	0:0	10	]
op	155:43	0:0	10	.
water	155:44	0:0	10	values
op	155:50	0:0	10	[
water	155:51	0:0	10	res
op	155:54	0:0	10	]
arg	155:57	155:58	9	8
water	155:57	0:0	10	8
water	155:59	0:0	8	;
op	156:16	0:0	8	*
water	156:17	0:0	8	samples8
op	156:25	0:0	8	++
op	156:28	0:0	8	=
water	156:30	0:0	8	pred
op	156:34	0:0	8	[
water	156:35	0:0	8	1
op	156:36	0:0	8	]
water	156:37	0:0	8	;
water	157:12	0:0	8	}
else	157:14	168:12	6
stmts	157:19	168:12	7	
water	157:19	0:0	8	{
if	158:16	159:70	8	(vlc [ 0 ] . table)
cond	158:19	158:26	9	vlc [ 0 ] . table
water	158:19	0:0	10	vlc
op	158:22	0:0	10	[
water	158:23	0:0	10	0
op	158:24	0:0	10	]
op	158:25	0:0	10	.
water	158:26	0:0	10	table
stmts	159:20	159:70	9	
water	159:20	0:0	10	res
op	159:24	0:0	10	=
call	159:26	159:69	10	get_vlc2
arg	159:35	159:38	11	&gb
op	159:35	0:0	12	&
water	159:36	0:0	12	gb
arg	159:40	159:52	11	vlc[0].table
water	159:40	0:0	12	vlc
op	159:43	0:0	12	[
water	159:44	0:0	12	0
op	159:45	0:0	12	]
op	159:46	0:0	12	.
water	159:47	0:0	12	table
arg	159:54	159:66	11	SMKTREE_BITS
water	159:54	0:0	12	SMKTREE_BITS
arg	159:68	159:69	11	3
water	159:68	0:0	12	3
water	159:70	0:0	10	;
else	160:16	161:27	8
stmts	161:20	161:27	9	
water	161:20	0:0	10	res
op	161:24	0:0	10	=
water	161:26	0:0	10	0
water	161:27	0:0	10	;
if	162:16	165:16	8	(res < 0)
cond	162:20	162:26	9	res < 0
water	162:20	0:0	10	res
op	162:24	0:0	10	<
water	162:26	0:0	10	0
stmts	162:29	165:16	9	
water	162:29	0:0	10	{
call	163:20	163:63	10	av_log
arg	163:27	163:32	11	avctx
water	163:27	0:0	12	avctx
arg	163:34	163:46	11	AV_LOG_ERROR
water	163:34	0:0	12	AV_LOG_ERROR
arg	163:48	163:63	11	"invalid vlc\n"
water	163:48	0:0	12	"invalid vlc\n"
water	163:64	0:0	10	;
return	164:20	164:46	10	AVERROR_INVALIDDATA
water	164:27	0:0	11	AVERROR_INVALIDDATA
water	165:16	0:0	10	}
water	166:16	0:0	8	pred
op	166:20	0:0	8	[
water	166:21	0:0	8	0
op	166:22	0:0	8	]
op	166:24	0:0	8	+=
call	166:27	166:58	8	sign_extend
arg	166:39	166:55	9	h[0].values[res]
water	166:39	0:0	10	h
op	166:40	0:0	10	[
water	166:41	0:0	10	0
op	166:42	0:0	10	]
op	166:43	0:0	10	.
water	166:44	0:0	10	values
op	166:50	0:0	10	[
water	166:51	0:0	10	res
op	166:54	0:0	10	]
arg	166:57	166:58	9	8
water	166:57	0:0	10	8
water	166:59	0:0	8	;
op	167:16	0:0	8	*
water	167:17	0:0	8	samples8
op	167:25	0:0	8	++
op	167:28	0:0	8	=
water	167:30	0:0	8	pred
op	167:34	0:0	8	[
water	167:35	0:0	8	0
op	167:36	0:0	8	]
water	167:37	0:0	8	;
water	168:12	0:0	8	}
water	169:8	0:0	6	}
water	170:4	0:0	4	}
op	172:4	0:0	2	*
water	172:5	0:0	2	got_frame_ptr
op	172:19	0:0	2	=
water	172:21	0:0	2	1
water	172:22	0:0	2	;
water	173:4	0:0	2	ret
op	173:8	0:0	2	=
water	173:10	0:0	2	buf_size
water	173:18	0:0	2	;
label	175:0	175:5	2	error :
for	176:4	182:4	2	(i = 0 ;i < 4;i ++)
forinit	176:8	176:13	3	i = 0 ;
water	176:8	0:0	4	i
op	176:10	0:0	4	=
water	176:12	0:0	4	0
water	176:13	0:0	4	;
cond	176:15	176:19	3	i < 4
water	176:15	0:0	4	i
op	176:17	0:0	4	<
water	176:19	0:0	4	4
forexpr	176:22	176:23	3	i ++
water	176:22	0:0	4	i
op	176:23	0:0	4	++
stmts	176:27	182:4	3	
water	176:27	0:0	4	{
if	177:8	178:32	4	(vlc [ i ] . table)
cond	177:11	177:18	5	vlc [ i ] . table
water	177:11	0:0	6	vlc
op	177:14	0:0	6	[
water	177:15	0:0	6	i
op	177:16	0:0	6	]
op	177:17	0:0	6	.
water	177:18	0:0	6	table
stmts	178:12	178:32	5	
call	178:12	178:31	6	ff_free_vlc
arg	178:24	178:31	7	&vlc[i]
op	178:24	0:0	8	&
water	178:25	0:0	8	vlc
op	178:28	0:0	8	[
water	178:29	0:0	8	i
op	178:30	0:0	8	]
water	178:32	0:0	6	;
call	179:8	179:25	4	av_free
arg	179:16	179:25	5	h[i].bits
water	179:16	0:0	6	h
op	179:17	0:0	6	[
water	179:18	0:0	6	i
op	179:19	0:0	6	]
op	179:20	0:0	6	.
water	179:21	0:0	6	bits
water	179:26	0:0	4	;
call	180:8	180:28	4	av_free
arg	180:16	180:28	5	h[i].lengths
water	180:16	0:0	6	h
op	180:17	0:0	6	[
water	180:18	0:0	6	i
op	180:19	0:0	6	]
op	180:20	0:0	6	.
water	180:21	0:0	6	lengths
water	180:29	0:0	4	;
call	181:8	181:27	4	av_free
arg	181:16	181:27	5	h[i].values
water	181:16	0:0	6	h
op	181:17	0:0	6	[
water	181:18	0:0	6	i
op	181:19	0:0	6	]
op	181:20	0:0	6	.
water	181:21	0:0	6	values
water	181:28	0:0	4	;
water	182:4	0:0	4	}
return	184:4	184:14	2	ret
water	184:11	0:0	3	ret
