func	2:0	66:0	0	static int	ipvideo_decode_block_opcode_0xA
params	2:42	0:0	1	
param	2:43	2:60	2	IpvideoContext *	s
param	2:62	2:76	2	AVFrame *	frame
stmnts	0:0	65:12	1	
decl	4:4	4:12	2	int	x
water	4:9	0:0	2	,
decl	4:4	4:12	2	int	y
decl	5:4	5:22	2	unsigned char	P[8]
decl	6:4	6:17	2	int	flags
op	6:14	0:0	2	=
water	6:16	0:0	2	0
if	8:4	11:4	2	(bytestream2_get_bytes_left (& s -> stream_ptr ) < 16)
cond	8:8	8:53	3	bytestream2_get_bytes_left (& s -> stream_ptr ) < 16
call	8:8	8:49	4	bytestream2_get_bytes_left
arg	8:35	8:49	5	&s->stream_ptr
op	8:35	0:0	6	&
water	8:36	0:0	6	s
op	8:37	0:0	6	->
water	8:39	0:0	6	stream_ptr
op	8:51	0:0	4	<
water	8:53	0:0	4	16
stmts	8:57	11:4	3	
water	8:57	0:0	4	{
call	9:8	9:73	4	av_log
arg	9:15	9:23	5	s->avctx
water	9:15	0:0	6	s
op	9:16	0:0	6	->
water	9:18	0:0	6	avctx
arg	9:25	9:37	5	AV_LOG_ERROR
water	9:25	0:0	6	AV_LOG_ERROR
arg	9:39	9:73	5	"too little data for opcode 0xA\n"
water	9:39	0:0	6	"too little data for opcode 0xA\n"
water	9:74	0:0	4	;
return	10:8	10:34	4	AVERROR_INVALIDDATA
water	10:15	0:0	5	AVERROR_INVALIDDATA
water	11:4	0:0	4	}
call	13:4	13:47	2	bytestream2_get_buffer
arg	13:27	13:41	3	&s->stream_ptr
op	13:27	0:0	4	&
water	13:28	0:0	4	s
op	13:29	0:0	4	->
water	13:31	0:0	4	stream_ptr
arg	13:43	13:44	3	P
water	13:43	0:0	4	P
arg	13:46	13:47	3	4
water	13:46	0:0	4	4
water	13:48	0:0	2	;
if	17:4	35:4	2	(P [ 0 ] <= P [ 1 ])
cond	17:8	17:19	3	P [ 0 ] <= P [ 1 ]
water	17:8	0:0	4	P
op	17:9	0:0	4	[
water	17:10	0:0	4	0
op	17:11	0:0	4	]
op	17:13	0:0	4	<=
water	17:16	0:0	4	P
op	17:17	0:0	4	[
water	17:18	0:0	4	1
op	17:19	0:0	4	]
stmts	17:22	35:4	3	
water	17:22	0:0	4	{
for	20:8	33:8	4	(y = 0 ;y < 16;y ++)
forinit	20:13	20:18	5	y = 0 ;
water	20:13	0:0	6	y
op	20:15	0:0	6	=
water	20:17	0:0	6	0
water	20:18	0:0	6	;
cond	20:20	20:24	5	y < 16
water	20:20	0:0	6	y
op	20:22	0:0	6	<
water	20:24	0:0	6	16
forexpr	20:28	20:29	5	y ++
water	20:28	0:0	6	y
op	20:29	0:0	6	++
stmts	20:33	33:8	5	
water	20:33	0:0	6	{
if	22:12	25:12	6	(! ( y & 3 ))
cond	22:16	22:23	7	! ( y & 3 )
op	22:16	0:0	8	!
water	22:17	0:0	8	(
water	22:18	0:0	8	y
op	22:20	0:0	8	&
water	22:22	0:0	8	3
water	22:23	0:0	8	)
stmts	22:26	25:12	7	
water	22:26	0:0	8	{
if	23:16	23:67	8	(y)
cond	23:20	23:20	9	y
water	23:20	0:0	10	y
stmts	23:23	23:67	9	
call	23:23	23:66	10	bytestream2_get_buffer
arg	23:46	23:60	11	&s->stream_ptr
op	23:46	0:0	12	&
water	23:47	0:0	12	s
op	23:48	0:0	12	->
water	23:50	0:0	12	stream_ptr
arg	23:62	23:63	11	P
water	23:62	0:0	12	P
arg	23:65	23:66	11	4
water	23:65	0:0	12	4
water	23:67	0:0	10	;
water	24:16	0:0	8	flags
op	24:22	0:0	8	=
call	24:24	24:59	8	bytestream2_get_le32
arg	24:45	24:59	9	&s->stream_ptr
op	24:45	0:0	10	&
water	24:46	0:0	10	s
op	24:47	0:0	10	->
water	24:49	0:0	10	stream_ptr
water	24:60	0:0	8	;
water	25:12	0:0	8	}
for	27:12	28:49	6	(x = 0 ;x < 4;x ++ , flags >>= 2)
forinit	27:17	27:22	7	x = 0 ;
water	27:17	0:0	8	x
op	27:19	0:0	8	=
water	27:21	0:0	8	0
water	27:22	0:0	8	;
cond	27:24	27:28	7	x < 4
water	27:24	0:0	8	x
op	27:26	0:0	8	<
water	27:28	0:0	8	4
forexpr	27:31	27:46	7	x ++ , flags >>= 2
water	27:31	0:0	8	x
op	27:32	0:0	8	++
water	27:34	0:0	8	,
water	27:36	0:0	8	flags
op	27:42	0:0	8	>>=
water	27:46	0:0	8	2
stmts	28:16	28:49	7	
op	28:16	0:0	8	*
water	28:17	0:0	8	s
op	28:18	0:0	8	->
water	28:20	0:0	8	pixel_ptr
op	28:29	0:0	8	++
op	28:32	0:0	8	=
water	28:34	0:0	8	P
op	28:35	0:0	8	[
water	28:36	0:0	8	flags
op	28:42	0:0	8	&
water	28:44	0:0	8	0
water	28:45	0:0	8	x03
op	28:48	0:0	8	]
water	28:49	0:0	8	;
water	30:12	0:0	6	s
op	30:13	0:0	6	->
water	30:15	0:0	6	pixel_ptr
op	30:25	0:0	6	+=
water	30:28	0:0	6	s
op	30:29	0:0	6	->
water	30:31	0:0	6	stride
op	30:38	0:0	6	-
water	30:40	0:0	6	4
water	30:41	0:0	6	;
if	32:12	32:57	6	(y == 7)
cond	32:16	32:21	7	y == 7
water	32:16	0:0	8	y
op	32:18	0:0	8	==
water	32:21	0:0	8	7
stmts	32:24	32:57	7	
water	32:24	0:0	8	s
op	32:25	0:0	8	->
water	32:27	0:0	8	pixel_ptr
op	32:37	0:0	8	-=
water	32:40	0:0	8	8
op	32:42	0:0	8	*
water	32:44	0:0	8	s
op	32:45	0:0	8	->
water	32:47	0:0	8	stride
op	32:54	0:0	8	-
water	32:56	0:0	8	4
water	32:57	0:0	8	;
water	33:8	0:0	6	}
water	35:4	0:0	4	}
else	35:6	62:4	2
stmts	35:11	62:4	3	
water	35:11	0:0	4	{
decl	37:8	37:16	4	int	vert
decl	38:8	38:61	4	uint64_t	flags
op	38:23	0:0	4	=
call	38:25	38:60	5	bytestream2_get_le64
arg	38:46	38:60	6	&s->stream_ptr
op	38:46	0:0	7	&
water	38:47	0:0	7	s
op	38:48	0:0	7	->
water	38:50	0:0	7	stream_ptr
call	40:8	40:55	4	bytestream2_get_buffer
arg	40:31	40:45	5	&s->stream_ptr
op	40:31	0:0	6	&
water	40:32	0:0	6	s
op	40:33	0:0	6	->
water	40:35	0:0	6	stream_ptr
arg	40:47	40:52	5	P+4
water	40:47	0:0	6	P
op	40:49	0:0	6	+
water	40:51	0:0	6	4
arg	40:54	40:55	5	4
water	40:54	0:0	6	4
water	40:56	0:0	4	;
water	41:8	0:0	4	vert
op	41:13	0:0	4	=
water	41:15	0:0	4	P
op	41:16	0:0	4	[
water	41:17	0:0	4	4
op	41:18	0:0	4	]
op	41:20	0:0	4	<=
water	41:23	0:0	4	P
op	41:24	0:0	4	[
water	41:25	0:0	4	5
op	41:26	0:0	4	]
water	41:27	0:0	4	;
for	46:8	61:8	4	(y = 0 ;y < 16;y ++)
forinit	46:13	46:18	5	y = 0 ;
water	46:13	0:0	6	y
op	46:15	0:0	6	=
water	46:17	0:0	6	0
water	46:18	0:0	6	;
cond	46:20	46:24	5	y < 16
water	46:20	0:0	6	y
op	46:22	0:0	6	<
water	46:24	0:0	6	16
forexpr	46:28	46:29	5	y ++
water	46:28	0:0	6	y
op	46:29	0:0	6	++
stmts	46:33	61:8	5	
water	46:33	0:0	6	{
for	47:12	48:49	6	(x = 0 ;x < 4;x ++ , flags >>= 2)
forinit	47:17	47:22	7	x = 0 ;
water	47:17	0:0	8	x
op	47:19	0:0	8	=
water	47:21	0:0	8	0
water	47:22	0:0	8	;
cond	47:24	47:28	7	x < 4
water	47:24	0:0	8	x
op	47:26	0:0	8	<
water	47:28	0:0	8	4
forexpr	47:31	47:46	7	x ++ , flags >>= 2
water	47:31	0:0	8	x
op	47:32	0:0	8	++
water	47:34	0:0	8	,
water	47:36	0:0	8	flags
op	47:42	0:0	8	>>=
water	47:46	0:0	8	2
stmts	48:16	48:49	7	
op	48:16	0:0	8	*
water	48:17	0:0	8	s
op	48:18	0:0	8	->
water	48:20	0:0	8	pixel_ptr
op	48:29	0:0	8	++
op	48:32	0:0	8	=
water	48:34	0:0	8	P
op	48:35	0:0	8	[
water	48:36	0:0	8	flags
op	48:42	0:0	8	&
water	48:44	0:0	8	0
water	48:45	0:0	8	x03
op	48:48	0:0	8	]
water	48:49	0:0	8	;
if	50:12	54:12	6	(vert)
cond	50:16	50:16	7	vert
water	50:16	0:0	8	vert
stmts	50:22	54:12	7	
water	50:22	0:0	8	{
water	51:16	0:0	8	s
op	51:17	0:0	8	->
water	51:19	0:0	8	pixel_ptr
op	51:29	0:0	8	+=
water	51:32	0:0	8	s
op	51:33	0:0	8	->
water	51:35	0:0	8	stride
op	51:42	0:0	8	-
water	51:44	0:0	8	4
water	51:45	0:0	8	;
if	53:16	53:61	8	(y == 7)
cond	53:20	53:25	9	y == 7
water	53:20	0:0	10	y
op	53:22	0:0	10	==
water	53:25	0:0	10	7
stmts	53:28	53:61	9	
water	53:28	0:0	10	s
op	53:29	0:0	10	->
water	53:31	0:0	10	pixel_ptr
op	53:41	0:0	10	-=
water	53:44	0:0	10	8
op	53:46	0:0	10	*
water	53:48	0:0	10	s
op	53:49	0:0	10	->
water	53:51	0:0	10	stride
op	53:58	0:0	10	-
water	53:60	0:0	10	4
water	53:61	0:0	10	;
water	54:12	0:0	8	}
else	54:14	54:57	6
stmts	54:19	54:57	7	
if	54:19	54:57	8	(y & 1)
cond	54:23	54:27	9	y & 1
water	54:23	0:0	10	y
op	54:25	0:0	10	&
water	54:27	0:0	10	1
stmts	54:30	54:57	9	
water	54:30	0:0	10	s
op	54:31	0:0	10	->
water	54:33	0:0	10	pixel_ptr
op	54:43	0:0	10	+=
water	54:46	0:0	10	s
op	54:47	0:0	10	->
water	54:49	0:0	10	line_inc
water	54:57	0:0	10	;
if	57:12	60:12	6	(y == 7)
cond	57:16	57:21	7	y == 7
water	57:16	0:0	8	y
op	57:18	0:0	8	==
water	57:21	0:0	8	7
stmts	57:24	60:12	7	
water	57:24	0:0	8	{
call	58:16	58:34	8	memcpy
arg	58:23	58:24	9	P
water	58:23	0:0	10	P
arg	58:26	58:31	9	P+4
water	58:26	0:0	10	P
op	58:28	0:0	10	+
water	58:30	0:0	10	4
arg	58:33	58:34	9	4
water	58:33	0:0	10	4
water	58:35	0:0	8	;
water	59:16	0:0	8	flags
op	59:22	0:0	8	=
call	59:24	59:59	8	bytestream2_get_le64
arg	59:45	59:59	9	&s->stream_ptr
op	59:45	0:0	10	&
water	59:46	0:0	10	s
op	59:47	0:0	10	->
water	59:49	0:0	10	stream_ptr
water	59:60	0:0	8	;
water	60:12	0:0	8	}
water	61:8	0:0	6	}
water	62:4	0:0	4	}
return	65:4	65:12	2	0
water	65:11	0:0	3	0
