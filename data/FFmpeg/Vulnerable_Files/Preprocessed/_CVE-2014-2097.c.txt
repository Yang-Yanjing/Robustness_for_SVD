func	1:0	230:0	0	static int	tak_decode_frame
params	1:27	0:0	1	
param	1:28	1:49	2	AVCodecContext *	avctx
param	1:51	1:61	2	void *	data
param	2:28	2:46	2	int *	got_frame_ptr
param	2:48	2:61	2	AVPacket *	pkt
stmnts	0:0	229:20	1	
decl	4:4	4:40	2	TAKDecContext	*s
op	4:22	0:0	2	=
water	4:24	0:0	2	avctx
op	4:29	0:0	2	->
water	4:31	0:0	2	priv_data
decl	5:4	5:28	2	AVFrame	*frame
op	5:22	0:0	2	=
water	5:24	0:0	2	data
decl	6:4	6:38	2	ThreadFrame	tframe
op	6:23	0:0	2	=
water	6:25	0:0	2	{
op	6:27	0:0	2	.
water	6:28	0:0	2	f
op	6:30	0:0	2	=
water	6:32	0:0	2	data
water	6:37	0:0	2	}
decl	7:4	7:30	2	GetBitContext	*gb
op	7:22	0:0	2	=
op	7:24	0:0	2	&
water	7:25	0:0	2	s
op	7:26	0:0	2	->
water	7:28	0:0	2	gb
decl	8:4	8:27	2	int	chan
water	8:12	0:0	2	,
decl	8:4	8:27	2	int	i
water	8:15	0:0	2	,
decl	8:4	8:27	2	int	ret
water	8:20	0:0	2	,
decl	8:4	8:27	2	int	hsize
if	10:4	11:34	2	(pkt -> size < TAK_MIN_FRAME_HEADER_BYTES)
cond	10:8	10:20	3	pkt -> size < TAK_MIN_FRAME_HEADER_BYTES
water	10:8	0:0	4	pkt
op	10:11	0:0	4	->
water	10:13	0:0	4	size
op	10:18	0:0	4	<
water	10:20	0:0	4	TAK_MIN_FRAME_HEADER_BYTES
stmts	11:8	11:34	3	
return	11:8	11:34	4	AVERROR_INVALIDDATA
water	11:15	0:0	5	AVERROR_INVALIDDATA
if	13:4	14:18	2	(( ret =init_get_bits8 (gb ,pkt -> data ,pkt -> size ) ) < 0)
cond	13:8	13:59	3	( ret =init_get_bits8 (gb ,pkt -> data ,pkt -> size ) ) < 0
water	13:8	0:0	4	(
water	13:9	0:0	4	ret
op	13:13	0:0	4	=
call	13:15	13:54	4	init_get_bits8
arg	13:30	13:32	5	gb
water	13:30	0:0	6	gb
arg	13:34	13:43	5	pkt->data
water	13:34	0:0	6	pkt
op	13:37	0:0	6	->
water	13:39	0:0	6	data
arg	13:45	13:54	5	pkt->size
water	13:45	0:0	6	pkt
op	13:48	0:0	6	->
water	13:50	0:0	6	size
water	13:55	0:0	4	)
op	13:57	0:0	4	<
water	13:59	0:0	4	0
stmts	14:8	14:18	3	
return	14:8	14:18	4	ret
water	14:15	0:0	5	ret
if	16:4	17:18	2	(( ret =ff_tak_decode_frame_header (avctx ,gb ,& s -> ti ,0 ) ) < 0)
cond	16:8	16:67	3	( ret =ff_tak_decode_frame_header (avctx ,gb ,& s -> ti ,0 ) ) < 0
water	16:8	0:0	4	(
water	16:9	0:0	4	ret
op	16:13	0:0	4	=
call	16:15	16:62	4	ff_tak_decode_frame_header
arg	16:42	16:47	5	avctx
water	16:42	0:0	6	avctx
arg	16:49	16:51	5	gb
water	16:49	0:0	6	gb
arg	16:53	16:59	5	&s->ti
op	16:53	0:0	6	&
water	16:54	0:0	6	s
op	16:55	0:0	6	->
water	16:57	0:0	6	ti
arg	16:61	16:62	5	0
water	16:61	0:0	6	0
water	16:63	0:0	4	)
op	16:65	0:0	4	<
water	16:67	0:0	4	0
stmts	17:8	17:18	3	
return	17:8	17:18	4	ret
water	17:15	0:0	5	ret
if	19:4	25:4	2	(avctx -> err_recognition & AV_EF_CRCCHECK)
cond	19:8	19:33	3	avctx -> err_recognition & AV_EF_CRCCHECK
water	19:8	0:0	4	avctx
op	19:13	0:0	4	->
water	19:15	0:0	4	err_recognition
op	19:31	0:0	4	&
water	19:33	0:0	4	AV_EF_CRCCHECK
stmts	19:49	25:4	3	
water	19:49	0:0	4	{
water	20:8	0:0	4	hsize
op	20:14	0:0	4	=
call	20:16	20:33	4	get_bits_count
arg	20:31	20:33	5	gb
water	20:31	0:0	6	gb
op	20:35	0:0	4	/
water	20:37	0:0	4	8
water	20:38	0:0	4	;
if	21:8	24:8	4	(ff_tak_check_crc (pkt -> data ,hsize ))
cond	21:12	21:45	5	ff_tak_check_crc (pkt -> data ,hsize )
call	21:12	21:45	6	ff_tak_check_crc
arg	21:29	21:38	7	pkt->data
water	21:29	0:0	8	pkt
op	21:32	0:0	8	->
water	21:34	0:0	8	data
arg	21:40	21:45	7	hsize
water	21:40	0:0	8	hsize
stmts	21:48	24:8	5	
water	21:48	0:0	6	{
call	22:12	22:53	6	av_log
arg	22:19	22:24	7	avctx
water	22:19	0:0	8	avctx
arg	22:26	22:38	7	AV_LOG_ERROR
water	22:26	0:0	8	AV_LOG_ERROR
arg	22:40	22:53	7	"CRC error\n"
water	22:40	0:0	8	"CRC error\n"
water	22:54	0:0	6	;
return	23:12	23:38	6	AVERROR_INVALIDDATA
water	23:19	0:0	7	AVERROR_INVALIDDATA
water	24:8	0:0	6	}
water	25:4	0:0	4	}
if	27:4	31:4	2	(s -> ti . codec != TAK_CODEC_MONO_STEREO && s -> ti . codec != TAK_CODEC_MULTICHANNEL)
cond	27:8	28:23	3	s -> ti . codec != TAK_CODEC_MONO_STEREO && s -> ti . codec != TAK_CODEC_MULTICHANNEL
water	27:8	0:0	4	s
op	27:9	0:0	4	->
water	27:11	0:0	4	ti
op	27:13	0:0	4	.
water	27:14	0:0	4	codec
op	27:20	0:0	4	!=
water	27:23	0:0	4	TAK_CODEC_MONO_STEREO
op	27:45	0:0	4	&&
water	28:8	0:0	4	s
op	28:9	0:0	4	->
water	28:11	0:0	4	ti
op	28:13	0:0	4	.
water	28:14	0:0	4	codec
op	28:20	0:0	4	!=
water	28:23	0:0	4	TAK_CODEC_MULTICHANNEL
stmts	28:47	31:4	3	
water	28:47	0:0	4	{
call	29:8	29:74	4	av_log
arg	29:15	29:20	5	avctx
water	29:15	0:0	6	avctx
arg	29:22	29:34	5	AV_LOG_ERROR
water	29:22	0:0	6	AV_LOG_ERROR
arg	29:36	29:61	5	"unsupported codec: %d\n"
water	29:36	0:0	6	"unsupported codec: %d\n"
arg	29:63	29:74	5	s->ti.codec
water	29:63	0:0	6	s
op	29:64	0:0	6	->
water	29:66	0:0	6	ti
op	29:68	0:0	6	.
water	29:69	0:0	6	codec
water	29:75	0:0	4	;
return	30:8	30:35	4	AVERROR_PATCHWELCOME
water	30:15	0:0	5	AVERROR_PATCHWELCOME
water	31:4	0:0	4	}
if	32:4	36:4	2	(s -> ti . data_type)
cond	32:8	32:14	3	s -> ti . data_type
water	32:8	0:0	4	s
op	32:9	0:0	4	->
water	32:11	0:0	4	ti
op	32:13	0:0	4	.
water	32:14	0:0	4	data_type
stmts	32:25	36:4	3	
water	32:25	0:0	4	{
call	33:8	34:61	4	av_log
arg	33:15	33:20	5	avctx
water	33:15	0:0	6	avctx
arg	33:22	33:34	5	AV_LOG_ERROR
water	33:22	0:0	6	AV_LOG_ERROR
arg	34:15	34:44	5	"unsupported data type: %d\n"
water	34:15	0:0	6	"unsupported data type: %d\n"
arg	34:46	34:61	5	s->ti.data_type
water	34:46	0:0	6	s
op	34:47	0:0	6	->
water	34:49	0:0	6	ti
op	34:51	0:0	6	.
water	34:52	0:0	6	data_type
water	34:62	0:0	4	;
return	35:8	35:34	4	AVERROR_INVALIDDATA
water	35:15	0:0	5	AVERROR_INVALIDDATA
water	36:4	0:0	4	}
if	37:4	41:4	2	(s -> ti . codec == TAK_CODEC_MONO_STEREO && s -> ti . channels > 2)
cond	37:8	37:65	3	s -> ti . codec == TAK_CODEC_MONO_STEREO && s -> ti . channels > 2
water	37:8	0:0	4	s
op	37:9	0:0	4	->
water	37:11	0:0	4	ti
op	37:13	0:0	4	.
water	37:14	0:0	4	codec
op	37:20	0:0	4	==
water	37:23	0:0	4	TAK_CODEC_MONO_STEREO
op	37:45	0:0	4	&&
water	37:48	0:0	4	s
op	37:49	0:0	4	->
water	37:51	0:0	4	ti
op	37:53	0:0	4	.
water	37:54	0:0	4	channels
op	37:63	0:0	4	>
water	37:65	0:0	4	2
stmts	37:68	41:4	3	
water	37:68	0:0	4	{
call	38:8	39:65	4	av_log
arg	38:15	38:20	5	avctx
water	38:15	0:0	6	avctx
arg	38:22	38:34	5	AV_LOG_ERROR
water	38:22	0:0	6	AV_LOG_ERROR
arg	39:15	39:49	5	"invalid number of channels: %d\n"
water	39:15	0:0	6	"invalid number of channels: %d\n"
arg	39:51	39:65	5	s->ti.channels
water	39:51	0:0	6	s
op	39:52	0:0	6	->
water	39:54	0:0	6	ti
op	39:56	0:0	6	.
water	39:57	0:0	6	channels
water	39:66	0:0	4	;
return	40:8	40:34	4	AVERROR_INVALIDDATA
water	40:15	0:0	5	AVERROR_INVALIDDATA
water	41:4	0:0	4	}
if	42:4	46:4	2	(s -> ti . channels > 6)
cond	42:8	42:25	3	s -> ti . channels > 6
water	42:8	0:0	4	s
op	42:9	0:0	4	->
water	42:11	0:0	4	ti
op	42:13	0:0	4	.
water	42:14	0:0	4	channels
op	42:23	0:0	4	>
water	42:25	0:0	4	6
stmts	42:28	46:4	3	
water	42:28	0:0	4	{
call	43:8	44:69	4	av_log
arg	43:15	43:20	5	avctx
water	43:15	0:0	6	avctx
arg	43:22	43:34	5	AV_LOG_ERROR
water	43:22	0:0	6	AV_LOG_ERROR
arg	44:15	44:53	5	"unsupported number of channels: %d\n"
water	44:15	0:0	6	"unsupported number of channels: %d\n"
arg	44:55	44:69	5	s->ti.channels
water	44:55	0:0	6	s
op	44:56	0:0	6	->
water	44:58	0:0	6	ti
op	44:60	0:0	6	.
water	44:61	0:0	6	channels
water	44:70	0:0	4	;
return	45:8	45:34	4	AVERROR_INVALIDDATA
water	45:15	0:0	5	AVERROR_INVALIDDATA
water	46:4	0:0	4	}
if	48:4	51:4	2	(s -> ti . frame_samples <= 0)
cond	48:8	48:31	3	s -> ti . frame_samples <= 0
water	48:8	0:0	4	s
op	48:9	0:0	4	->
water	48:11	0:0	4	ti
op	48:13	0:0	4	.
water	48:14	0:0	4	frame_samples
op	48:28	0:0	4	<=
water	48:31	0:0	4	0
stmts	48:34	51:4	3	
water	48:34	0:0	4	{
call	49:8	49:77	4	av_log
arg	49:15	49:20	5	avctx
water	49:15	0:0	6	avctx
arg	49:22	49:34	5	AV_LOG_ERROR
water	49:22	0:0	6	AV_LOG_ERROR
arg	49:36	49:77	5	"unsupported/invalid number of samples\n"
water	49:36	0:0	6	"unsupported/invalid number of samples\n"
water	49:78	0:0	4	;
return	50:8	50:34	4	AVERROR_INVALIDDATA
water	50:15	0:0	5	AVERROR_INVALIDDATA
water	51:4	0:0	4	}
water	53:4	0:0	2	avctx
op	53:9	0:0	2	->
water	53:11	0:0	2	bits_per_raw_sample
op	53:31	0:0	2	=
water	53:33	0:0	2	s
op	53:34	0:0	2	->
water	53:36	0:0	2	ti
op	53:38	0:0	2	.
water	53:39	0:0	2	bps
water	53:42	0:0	2	;
if	54:4	55:18	2	(( ret =set_bps_params (avctx ) ) < 0)
cond	54:8	54:40	3	( ret =set_bps_params (avctx ) ) < 0
water	54:8	0:0	4	(
water	54:9	0:0	4	ret
op	54:13	0:0	4	=
call	54:15	54:35	4	set_bps_params
arg	54:30	54:35	5	avctx
water	54:30	0:0	6	avctx
water	54:36	0:0	4	)
op	54:38	0:0	4	<
water	54:40	0:0	4	0
stmts	55:8	55:18	3	
return	55:8	55:18	4	ret
water	55:15	0:0	5	ret
if	56:4	59:4	2	(s -> ti . sample_rate != avctx -> sample_rate)
cond	56:8	56:36	3	s -> ti . sample_rate != avctx -> sample_rate
water	56:8	0:0	4	s
op	56:9	0:0	4	->
water	56:11	0:0	4	ti
op	56:13	0:0	4	.
water	56:14	0:0	4	sample_rate
op	56:26	0:0	4	!=
water	56:29	0:0	4	avctx
op	56:34	0:0	4	->
water	56:36	0:0	4	sample_rate
stmts	56:49	59:4	3	
water	56:49	0:0	4	{
water	57:8	0:0	4	avctx
op	57:13	0:0	4	->
water	57:15	0:0	4	sample_rate
op	57:27	0:0	4	=
water	57:29	0:0	4	s
op	57:30	0:0	4	->
water	57:32	0:0	4	ti
op	57:34	0:0	4	.
water	57:35	0:0	4	sample_rate
water	57:46	0:0	4	;
call	58:8	58:36	4	set_sample_rate_params
arg	58:31	58:36	5	avctx
water	58:31	0:0	6	avctx
water	58:37	0:0	4	;
water	59:4	0:0	4	}
if	60:4	61:47	2	(s -> ti . ch_layout)
cond	60:8	60:14	3	s -> ti . ch_layout
water	60:8	0:0	4	s
op	60:9	0:0	4	->
water	60:11	0:0	4	ti
op	60:13	0:0	4	.
water	60:14	0:0	4	ch_layout
stmts	61:8	61:47	3	
water	61:8	0:0	4	avctx
op	61:13	0:0	4	->
water	61:15	0:0	4	channel_layout
op	61:30	0:0	4	=
water	61:32	0:0	4	s
op	61:33	0:0	4	->
water	61:35	0:0	4	ti
op	61:37	0:0	4	.
water	61:38	0:0	4	ch_layout
water	61:47	0:0	4	;
water	62:4	0:0	2	avctx
op	62:9	0:0	2	->
water	62:11	0:0	2	channels
op	62:20	0:0	2	=
water	62:22	0:0	2	s
op	62:23	0:0	2	->
water	62:25	0:0	2	ti
op	62:27	0:0	2	.
water	62:28	0:0	2	channels
water	62:36	0:0	2	;
water	64:4	0:0	2	s
op	64:5	0:0	2	->
water	64:7	0:0	2	nb_samples
op	64:18	0:0	2	=
water	64:20	0:0	2	s
op	64:21	0:0	2	->
water	64:23	0:0	2	ti
op	64:25	0:0	2	.
water	64:26	0:0	2	last_frame_samples
water	64:45	0:0	2	?
water	64:47	0:0	2	s
op	64:48	0:0	2	->
water	64:50	0:0	2	ti
op	64:52	0:0	2	.
water	64:53	0:0	2	last_frame_samples
water	65:45	0:0	2	:
water	65:47	0:0	2	s
op	65:48	0:0	2	->
water	65:50	0:0	2	ti
op	65:52	0:0	2	.
water	65:53	0:0	2	frame_samples
water	65:66	0:0	2	;
water	67:4	0:0	2	frame
op	67:9	0:0	2	->
water	67:11	0:0	2	nb_samples
op	67:22	0:0	2	=
water	67:24	0:0	2	s
op	67:25	0:0	2	->
water	67:27	0:0	2	nb_samples
water	67:37	0:0	2	;
if	68:4	69:18	2	(( ret =ff_thread_get_buffer (avctx ,& tframe ,0 ) ) < 0)
cond	68:8	68:58	3	( ret =ff_thread_get_buffer (avctx ,& tframe ,0 ) ) < 0
water	68:8	0:0	4	(
water	68:9	0:0	4	ret
op	68:13	0:0	4	=
call	68:15	68:53	4	ff_thread_get_buffer
arg	68:36	68:41	5	avctx
water	68:36	0:0	6	avctx
arg	68:43	68:50	5	&tframe
op	68:43	0:0	6	&
water	68:44	0:0	6	tframe
arg	68:52	68:53	5	0
water	68:52	0:0	6	0
water	68:54	0:0	4	)
op	68:56	0:0	4	<
water	68:58	0:0	4	0
stmts	69:8	69:18	3	
return	69:8	69:18	4	ret
water	69:15	0:0	5	ret
call	70:4	70:32	2	ff_thread_finish_setup
arg	70:27	70:32	3	avctx
water	70:27	0:0	4	avctx
water	70:33	0:0	2	;
if	72:4	84:4	2	(avctx -> bits_per_raw_sample <= 16)
cond	72:8	72:38	3	avctx -> bits_per_raw_sample <= 16
water	72:8	0:0	4	avctx
op	72:13	0:0	4	->
water	72:15	0:0	4	bits_per_raw_sample
op	72:35	0:0	4	<=
water	72:38	0:0	4	16
stmts	72:42	84:4	3	
water	72:42	0:0	4	{
decl	73:8	75:72	4	int	buf_size
op	73:21	0:0	4	=
call	73:23	75:71	5	av_samples_get_buffer_size
arg	73:50	73:54	6	NULL
water	73:50	0:0	7	NULL
arg	73:56	73:71	6	avctx->channels
water	73:56	0:0	7	avctx
op	73:61	0:0	7	->
water	73:63	0:0	7	channels
arg	74:50	74:63	6	s->nb_samples
water	74:50	0:0	7	s
op	74:51	0:0	7	->
water	74:53	0:0	7	nb_samples
arg	75:50	75:68	6	AV_SAMPLE_FMT_S32P
water	75:50	0:0	7	AV_SAMPLE_FMT_S32P
arg	75:70	75:71	6	0
water	75:70	0:0	7	0
call	76:8	76:74	4	av_fast_malloc
arg	76:23	76:40	5	&s->decode_buffer
op	76:23	0:0	6	&
water	76:24	0:0	6	s
op	76:25	0:0	6	->
water	76:27	0:0	6	decode_buffer
arg	76:42	76:64	5	&s->decode_buffer_size
op	76:42	0:0	6	&
water	76:43	0:0	6	s
op	76:44	0:0	6	->
water	76:46	0:0	6	decode_buffer_size
arg	76:66	76:74	5	buf_size
water	76:66	0:0	6	buf_size
water	76:75	0:0	4	;
if	77:8	78:34	4	(! s -> decode_buffer)
cond	77:12	77:16	5	! s -> decode_buffer
op	77:12	0:0	6	!
water	77:13	0:0	6	s
op	77:14	0:0	6	->
water	77:16	0:0	6	decode_buffer
stmts	78:12	78:34	5	
return	78:12	78:34	6	AVERROR(ENOMEM)
call	78:19	78:33	7	AVERROR
arg	78:27	78:33	8	ENOMEM
water	78:27	0:0	9	ENOMEM
water	79:8	0:0	4	ret
op	79:12	0:0	4	=
call	79:14	81:73	4	av_samples_fill_arrays
arg	79:37	79:59	5	(uint8_t**)s->decoded
water	79:37	0:0	6	(
water	79:38	0:0	6	uint8_t
op	79:46	0:0	6	*
op	79:47	0:0	6	*
water	79:48	0:0	6	)
water	79:49	0:0	6	s
op	79:50	0:0	6	->
water	79:52	0:0	6	decoded
arg	79:61	79:65	5	NULL
water	79:61	0:0	6	NULL
arg	80:37	80:53	5	s->decode_buffer
water	80:37	0:0	6	s
op	80:38	0:0	6	->
water	80:40	0:0	6	decode_buffer
arg	80:55	80:70	5	avctx->channels
water	80:55	0:0	6	avctx
op	80:60	0:0	6	->
water	80:62	0:0	6	channels
arg	81:37	81:50	5	s->nb_samples
water	81:37	0:0	6	s
op	81:38	0:0	6	->
water	81:40	0:0	6	nb_samples
arg	81:52	81:70	5	AV_SAMPLE_FMT_S32P
water	81:52	0:0	6	AV_SAMPLE_FMT_S32P
arg	81:72	81:73	5	0
water	81:72	0:0	6	0
water	81:74	0:0	4	;
if	82:8	83:22	4	(ret < 0)
cond	82:12	82:18	5	ret < 0
water	82:12	0:0	6	ret
op	82:16	0:0	6	<
water	82:18	0:0	6	0
stmts	83:12	83:22	5	
return	83:12	83:22	6	ret
water	83:19	0:0	7	ret
water	84:4	0:0	4	}
else	84:6	87:4	2
stmts	84:11	87:4	3	
water	84:11	0:0	4	{
for	85:8	86:68	4	(chan = 0 ;chan < avctx -> channels;chan ++)
forinit	85:13	85:21	5	chan = 0 ;
water	85:13	0:0	6	chan
op	85:18	0:0	6	=
water	85:20	0:0	6	0
water	85:21	0:0	6	;
cond	85:23	85:37	5	chan < avctx -> channels
water	85:23	0:0	6	chan
op	85:28	0:0	6	<
water	85:30	0:0	6	avctx
op	85:35	0:0	6	->
water	85:37	0:0	6	channels
forexpr	85:47	85:51	5	chan ++
water	85:47	0:0	6	chan
op	85:51	0:0	6	++
stmts	86:12	86:68	5	
water	86:12	0:0	6	s
op	86:13	0:0	6	->
water	86:15	0:0	6	decoded
op	86:22	0:0	6	[
water	86:23	0:0	6	chan
op	86:27	0:0	6	]
op	86:29	0:0	6	=
water	86:31	0:0	6	(
water	86:32	0:0	6	int32_t
op	86:40	0:0	6	*
water	86:41	0:0	6	)
water	86:42	0:0	6	frame
op	86:47	0:0	6	->
water	86:49	0:0	6	extended_data
op	86:62	0:0	6	[
water	86:63	0:0	6	chan
op	86:67	0:0	6	]
water	86:68	0:0	6	;
water	87:4	0:0	4	}
if	89:4	95:4	2	(s -> nb_samples < 16)
cond	89:8	89:24	3	s -> nb_samples < 16
water	89:8	0:0	4	s
op	89:9	0:0	4	->
water	89:11	0:0	4	nb_samples
op	89:22	0:0	4	<
water	89:24	0:0	4	16
stmts	89:28	95:4	3	
water	89:28	0:0	4	{
for	90:8	94:8	4	(chan = 0 ;chan < avctx -> channels;chan ++)
forinit	90:13	90:21	5	chan = 0 ;
water	90:13	0:0	6	chan
op	90:18	0:0	6	=
water	90:20	0:0	6	0
water	90:21	0:0	6	;
cond	90:23	90:37	5	chan < avctx -> channels
water	90:23	0:0	6	chan
op	90:28	0:0	6	<
water	90:30	0:0	6	avctx
op	90:35	0:0	6	->
water	90:37	0:0	6	channels
forexpr	90:47	90:51	5	chan ++
water	90:47	0:0	6	chan
op	90:51	0:0	6	++
stmts	90:55	94:8	5	
water	90:55	0:0	6	{
decl	91:12	91:47	6	int32_t	*decoded
op	91:29	0:0	6	=
water	91:31	0:0	6	s
op	91:32	0:0	6	->
water	91:34	0:0	6	decoded
op	91:41	0:0	6	[
water	91:42	0:0	6	chan
op	91:46	0:0	6	]
for	92:12	93:70	6	(i = 0 ;i < s -> nb_samples;i ++)
forinit	92:17	92:22	7	i = 0 ;
water	92:17	0:0	8	i
op	92:19	0:0	8	=
water	92:21	0:0	8	0
water	92:22	0:0	8	;
cond	92:24	92:31	7	i < s -> nb_samples
water	92:24	0:0	8	i
op	92:26	0:0	8	<
water	92:28	0:0	8	s
op	92:29	0:0	8	->
water	92:31	0:0	8	nb_samples
forexpr	92:43	92:44	7	i ++
water	92:43	0:0	8	i
op	92:44	0:0	8	++
stmts	93:16	93:70	7	
water	93:16	0:0	8	decoded
op	93:23	0:0	8	[
water	93:24	0:0	8	i
op	93:25	0:0	8	]
op	93:27	0:0	8	=
call	93:29	93:69	8	get_sbits
arg	93:39	93:41	9	gb
water	93:39	0:0	10	gb
arg	93:43	93:69	9	avctx->bits_per_raw_sample
water	93:43	0:0	10	avctx
op	93:48	0:0	10	->
water	93:50	0:0	10	bits_per_raw_sample
water	93:70	0:0	8	;
water	94:8	0:0	6	}
water	95:4	0:0	4	}
else	95:6	183:4	2
stmts	95:11	183:4	3	
water	95:11	0:0	4	{
if	96:8	111:8	4	(s -> ti . codec == TAK_CODEC_MONO_STEREO)
cond	96:12	96:27	5	s -> ti . codec == TAK_CODEC_MONO_STEREO
water	96:12	0:0	6	s
op	96:13	0:0	6	->
water	96:15	0:0	6	ti
op	96:17	0:0	6	.
water	96:18	0:0	6	codec
op	96:24	0:0	6	==
water	96:27	0:0	6	TAK_CODEC_MONO_STEREO
stmts	96:50	111:8	5	
water	96:50	0:0	6	{
for	97:12	99:30	6	(chan = 0 ;chan < avctx -> channels;chan ++)
forinit	97:17	97:25	7	chan = 0 ;
water	97:17	0:0	8	chan
op	97:22	0:0	8	=
water	97:24	0:0	8	0
water	97:25	0:0	8	;
cond	97:27	97:41	7	chan < avctx -> channels
water	97:27	0:0	8	chan
op	97:32	0:0	8	<
water	97:34	0:0	8	avctx
op	97:39	0:0	8	->
water	97:41	0:0	8	channels
forexpr	97:51	97:55	7	chan ++
water	97:51	0:0	8	chan
op	97:55	0:0	8	++
stmts	98:16	99:30	7	
if	98:16	99:30	8	(ret =decode_channel (s ,chan ))
cond	98:20	98:48	9	ret =decode_channel (s ,chan )
water	98:20	0:0	10	ret
op	98:24	0:0	10	=
call	98:26	98:48	10	decode_channel
arg	98:41	98:42	11	s
water	98:41	0:0	12	s
arg	98:44	98:48	11	chan
water	98:44	0:0	12	chan
stmts	99:20	99:30	9	
return	99:20	99:30	10	ret
water	99:27	0:0	11	ret
if	101:12	110:12	6	(avctx -> channels == 2)
cond	101:16	101:35	7	avctx -> channels == 2
water	101:16	0:0	8	avctx
op	101:21	0:0	8	->
water	101:23	0:0	8	channels
op	101:32	0:0	8	==
water	101:35	0:0	8	2
stmts	101:38	110:12	7	
water	101:38	0:0	8	{
water	102:16	0:0	8	s
op	102:17	0:0	8	->
water	102:19	0:0	8	nb_subframes
op	102:32	0:0	8	=
call	102:34	102:48	8	get_bits
arg	102:43	102:45	9	gb
water	102:43	0:0	10	gb
arg	102:47	102:48	9	1
water	102:47	0:0	10	1
op	102:50	0:0	8	+
water	102:52	0:0	8	1
water	102:53	0:0	8	;
if	103:16	105:16	8	(s -> nb_subframes > 1)
cond	103:20	103:38	9	s -> nb_subframes > 1
water	103:20	0:0	10	s
op	103:21	0:0	10	->
water	103:23	0:0	10	nb_subframes
op	103:36	0:0	10	>
water	103:38	0:0	10	1
stmts	103:41	105:16	9	
water	103:41	0:0	10	{
water	104:20	0:0	10	s
op	104:21	0:0	10	->
water	104:23	0:0	10	subframe_len
op	104:35	0:0	10	[
water	104:36	0:0	10	1
op	104:37	0:0	10	]
op	104:39	0:0	10	=
call	104:41	104:55	10	get_bits
arg	104:50	104:52	11	gb
water	104:50	0:0	12	gb
arg	104:54	104:55	11	6
water	104:54	0:0	12	6
water	104:56	0:0	10	;
water	105:16	0:0	10	}
water	107:16	0:0	8	s
op	107:17	0:0	8	->
water	107:19	0:0	8	dmode
op	107:25	0:0	8	=
call	107:27	107:41	8	get_bits
arg	107:36	107:38	9	gb
water	107:36	0:0	10	gb
arg	107:40	107:41	9	3
water	107:40	0:0	10	3
water	107:42	0:0	8	;
if	108:16	109:30	8	(ret =decorrelate (s ,0 ,1 ,s -> nb_samples - 1 ))
cond	108:20	108:64	9	ret =decorrelate (s ,0 ,1 ,s -> nb_samples - 1 )
water	108:20	0:0	10	ret
op	108:24	0:0	10	=
call	108:26	108:64	10	decorrelate
arg	108:38	108:39	11	s
water	108:38	0:0	12	s
arg	108:41	108:42	11	0
water	108:41	0:0	12	0
arg	108:44	108:45	11	1
water	108:44	0:0	12	1
arg	108:47	108:64	11	s->nb_samples-1
water	108:47	0:0	12	s
op	108:48	0:0	12	->
water	108:50	0:0	12	nb_samples
op	108:61	0:0	12	-
water	108:63	0:0	12	1
stmts	109:20	109:30	9	
return	109:20	109:30	10	ret
water	109:27	0:0	11	ret
water	110:12	0:0	8	}
water	111:8	0:0	6	}
else	111:10	171:8	4
stmts	111:15	171:8	5	
if	111:15	171:8	6	(s -> ti . codec == TAK_CODEC_MULTICHANNEL)
cond	111:19	111:34	7	s -> ti . codec == TAK_CODEC_MULTICHANNEL
water	111:19	0:0	8	s
op	111:20	0:0	8	->
water	111:22	0:0	8	ti
op	111:24	0:0	8	.
water	111:25	0:0	8	codec
op	111:31	0:0	8	==
water	111:34	0:0	8	TAK_CODEC_MULTICHANNEL
stmts	111:58	171:8	7	
water	111:58	0:0	8	{
if	112:12	146:12	8	(get_bits1 (gb ))
cond	112:16	112:28	9	get_bits1 (gb )
call	112:16	112:28	10	get_bits1
arg	112:26	112:28	11	gb
water	112:26	0:0	12	gb
stmts	112:31	146:12	9	
water	112:31	0:0	10	{
decl	113:16	113:31	10	int	ch_mask
op	113:28	0:0	10	=
water	113:30	0:0	10	0
water	115:16	0:0	10	chan
op	115:21	0:0	10	=
call	115:23	115:37	10	get_bits
arg	115:32	115:34	11	gb
water	115:32	0:0	12	gb
arg	115:36	115:37	11	4
water	115:36	0:0	12	4
op	115:39	0:0	10	+
water	115:41	0:0	10	1
water	115:42	0:0	10	;
if	116:16	117:46	10	(chan > avctx -> channels)
cond	116:20	116:34	11	chan > avctx -> channels
water	116:20	0:0	12	chan
op	116:25	0:0	12	>
water	116:27	0:0	12	avctx
op	116:32	0:0	12	->
water	116:34	0:0	12	channels
stmts	117:20	117:46	11	
return	117:20	117:46	12	AVERROR_INVALIDDATA
water	117:27	0:0	13	AVERROR_INVALIDDATA
for	119:16	145:16	10	(i = 0 ;i < chan;i ++)
forinit	119:21	119:26	11	i = 0 ;
water	119:21	0:0	12	i
op	119:23	0:0	12	=
water	119:25	0:0	12	0
water	119:26	0:0	12	;
cond	119:28	119:32	11	i < chan
water	119:28	0:0	12	i
op	119:30	0:0	12	<
water	119:32	0:0	12	chan
forexpr	119:38	119:39	11	i ++
water	119:38	0:0	12	i
op	119:39	0:0	12	++
stmts	119:43	145:16	11	
water	119:43	0:0	12	{
decl	120:20	120:46	12	int	nbit
op	120:29	0:0	12	=
call	120:31	120:45	13	get_bits
arg	120:40	120:42	14	gb
water	120:40	0:0	15	gb
arg	120:44	120:45	14	4
water	120:44	0:0	15	4
if	122:20	123:50	12	(nbit >= avctx -> channels)
cond	122:24	122:39	13	nbit >= avctx -> channels
water	122:24	0:0	14	nbit
op	122:29	0:0	14	>=
water	122:32	0:0	14	avctx
op	122:37	0:0	14	->
water	122:39	0:0	14	channels
stmts	123:24	123:50	13	
return	123:24	123:50	14	AVERROR_INVALIDDATA
water	123:31	0:0	15	AVERROR_INVALIDDATA
if	125:20	126:50	12	(ch_mask & 1 << nbit)
cond	125:24	125:39	13	ch_mask & 1 << nbit
water	125:24	0:0	14	ch_mask
op	125:32	0:0	14	&
water	125:34	0:0	14	1
op	125:36	0:0	14	<<
water	125:39	0:0	14	nbit
stmts	126:24	126:50	13	
return	126:24	126:50	14	AVERROR_INVALIDDATA
water	126:31	0:0	15	AVERROR_INVALIDDATA
water	128:20	0:0	12	s
op	128:21	0:0	12	->
water	128:23	0:0	12	mcdparams
op	128:32	0:0	12	[
water	128:33	0:0	12	i
op	128:34	0:0	12	]
op	128:35	0:0	12	.
water	128:36	0:0	12	present
op	128:44	0:0	12	=
call	128:46	128:58	12	get_bits1
arg	128:56	128:58	13	gb
water	128:56	0:0	14	gb
water	128:59	0:0	12	;
if	129:20	141:20	12	(s -> mcdparams [ i ] . present)
cond	129:24	129:40	13	s -> mcdparams [ i ] . present
water	129:24	0:0	14	s
op	129:25	0:0	14	->
water	129:27	0:0	14	mcdparams
op	129:36	0:0	14	[
water	129:37	0:0	14	i
op	129:38	0:0	14	]
op	129:39	0:0	14	.
water	129:40	0:0	14	present
stmts	129:49	141:20	13	
water	129:49	0:0	14	{
water	130:24	0:0	14	s
op	130:25	0:0	14	->
water	130:27	0:0	14	mcdparams
op	130:36	0:0	14	[
water	130:37	0:0	14	i
op	130:38	0:0	14	]
op	130:39	0:0	14	.
water	130:40	0:0	14	index
op	130:46	0:0	14	=
call	130:48	130:62	14	get_bits
arg	130:57	130:59	15	gb
water	130:57	0:0	16	gb
arg	130:61	130:62	15	2
water	130:61	0:0	16	2
water	130:63	0:0	14	;
water	131:24	0:0	14	s
op	131:25	0:0	14	->
water	131:27	0:0	14	mcdparams
op	131:36	0:0	14	[
water	131:37	0:0	14	i
op	131:38	0:0	14	]
op	131:39	0:0	14	.
water	131:40	0:0	14	chan2
op	131:46	0:0	14	=
call	131:48	131:62	14	get_bits
arg	131:57	131:59	15	gb
water	131:57	0:0	16	gb
arg	131:61	131:62	15	4
water	131:61	0:0	16	4
water	131:63	0:0	14	;
if	132:24	138:24	14	(s -> mcdparams [ i ] . index == 1)
cond	132:28	132:53	15	s -> mcdparams [ i ] . index == 1
water	132:28	0:0	16	s
op	132:29	0:0	16	->
water	132:31	0:0	16	mcdparams
op	132:40	0:0	16	[
water	132:41	0:0	16	i
op	132:42	0:0	16	]
op	132:43	0:0	16	.
water	132:44	0:0	16	index
op	132:50	0:0	16	==
water	132:53	0:0	16	1
stmts	132:56	138:24	15	
water	132:56	0:0	16	{
if	133:28	135:58	16	(( nbit == s -> mcdparams [ i ] . chan2 ) || ( ch_mask & 1 << s -> mcdparams [ i ] . chan2 ))
cond	133:32	134:69	17	( nbit == s -> mcdparams [ i ] . chan2 ) || ( ch_mask & 1 << s -> mcdparams [ i ] . chan2 )
water	133:32	0:0	18	(
water	133:33	0:0	18	nbit
op	133:38	0:0	18	==
water	133:41	0:0	18	s
op	133:42	0:0	18	->
water	133:44	0:0	18	mcdparams
op	133:53	0:0	18	[
water	133:54	0:0	18	i
op	133:55	0:0	18	]
op	133:56	0:0	18	.
water	133:57	0:0	18	chan2
water	133:62	0:0	18	)
op	133:64	0:0	18	||
water	134:32	0:0	18	(
water	134:33	0:0	18	ch_mask
op	134:41	0:0	18	&
water	134:43	0:0	18	1
op	134:45	0:0	18	<<
water	134:48	0:0	18	s
op	134:49	0:0	18	->
water	134:51	0:0	18	mcdparams
op	134:60	0:0	18	[
water	134:61	0:0	18	i
op	134:62	0:0	18	]
op	134:63	0:0	18	.
water	134:64	0:0	18	chan2
water	134:69	0:0	18	)
stmts	135:32	135:58	17	
return	135:32	135:58	18	AVERROR_INVALIDDATA
water	135:39	0:0	19	AVERROR_INVALIDDATA
water	137:28	0:0	16	ch_mask
op	137:36	0:0	16	|=
water	137:39	0:0	16	1
op	137:41	0:0	16	<<
water	137:44	0:0	16	s
op	137:45	0:0	16	->
water	137:47	0:0	16	mcdparams
op	137:56	0:0	16	[
water	137:57	0:0	16	i
op	137:58	0:0	16	]
op	137:59	0:0	16	.
water	137:60	0:0	16	chan2
water	137:65	0:0	16	;
water	138:24	0:0	16	}
else	138:26	140:24	14
stmts	138:31	140:24	15	
if	138:31	140:24	16	(! ( ch_mask & 1 << s -> mcdparams [ i ] . chan2 ))
cond	138:35	138:73	17	! ( ch_mask & 1 << s -> mcdparams [ i ] . chan2 )
op	138:35	0:0	18	!
water	138:36	0:0	18	(
water	138:37	0:0	18	ch_mask
op	138:45	0:0	18	&
water	138:47	0:0	18	1
op	138:49	0:0	18	<<
water	138:52	0:0	18	s
op	138:53	0:0	18	->
water	138:55	0:0	18	mcdparams
op	138:64	0:0	18	[
water	138:65	0:0	18	i
op	138:66	0:0	18	]
op	138:67	0:0	18	.
water	138:68	0:0	18	chan2
water	138:73	0:0	18	)
stmts	138:76	140:24	17	
water	138:76	0:0	18	{
return	139:28	139:54	18	AVERROR_INVALIDDATA
water	139:35	0:0	19	AVERROR_INVALIDDATA
water	140:24	0:0	18	}
water	141:20	0:0	14	}
water	142:20	0:0	12	s
op	142:21	0:0	12	->
water	142:23	0:0	12	mcdparams
op	142:32	0:0	12	[
water	142:33	0:0	12	i
op	142:34	0:0	12	]
op	142:35	0:0	12	.
water	142:36	0:0	12	chan1
op	142:42	0:0	12	=
water	142:44	0:0	12	nbit
water	142:48	0:0	12	;
water	144:20	0:0	12	ch_mask
op	144:28	0:0	12	|=
water	144:31	0:0	12	1
op	144:33	0:0	12	<<
water	144:36	0:0	12	nbit
water	144:40	0:0	12	;
water	145:16	0:0	12	}
water	146:12	0:0	10	}
else	146:14	152:12	8
stmts	146:19	152:12	9	
water	146:19	0:0	10	{
water	147:16	0:0	10	chan
op	147:21	0:0	10	=
water	147:23	0:0	10	avctx
op	147:28	0:0	10	->
water	147:30	0:0	10	channels
water	147:38	0:0	10	;
for	148:16	151:16	10	(i = 0 ;i < chan;i ++)
forinit	148:21	148:26	11	i = 0 ;
water	148:21	0:0	12	i
op	148:23	0:0	12	=
water	148:25	0:0	12	0
water	148:26	0:0	12	;
cond	148:28	148:32	11	i < chan
water	148:28	0:0	12	i
op	148:30	0:0	12	<
water	148:32	0:0	12	chan
forexpr	148:38	148:39	11	i ++
water	148:38	0:0	12	i
op	148:39	0:0	12	++
stmts	148:43	151:16	11	
water	148:43	0:0	12	{
water	149:20	0:0	12	s
op	149:21	0:0	12	->
water	149:23	0:0	12	mcdparams
op	149:32	0:0	12	[
water	149:33	0:0	12	i
op	149:34	0:0	12	]
op	149:35	0:0	12	.
water	149:36	0:0	12	present
op	149:44	0:0	12	=
water	149:46	0:0	12	0
water	149:47	0:0	12	;
water	150:20	0:0	12	s
op	150:21	0:0	12	->
water	150:23	0:0	12	mcdparams
op	150:32	0:0	12	[
water	150:33	0:0	12	i
op	150:34	0:0	12	]
op	150:35	0:0	12	.
water	150:36	0:0	12	chan1
op	150:44	0:0	12	=
water	150:46	0:0	12	i
water	150:47	0:0	12	;
water	151:16	0:0	12	}
water	152:12	0:0	10	}
for	154:12	170:12	8	(i = 0 ;i < chan;i ++)
forinit	154:17	154:22	9	i = 0 ;
water	154:17	0:0	10	i
op	154:19	0:0	10	=
water	154:21	0:0	10	0
water	154:22	0:0	10	;
cond	154:24	154:28	9	i < chan
water	154:24	0:0	10	i
op	154:26	0:0	10	<
water	154:28	0:0	10	chan
forexpr	154:34	154:35	9	i ++
water	154:34	0:0	10	i
op	154:35	0:0	10	++
stmts	154:39	170:12	9	
water	154:39	0:0	10	{
if	155:16	157:34	10	(s -> mcdparams [ i ] . present && s -> mcdparams [ i ] . index == 1)
cond	155:20	155:72	11	s -> mcdparams [ i ] . present && s -> mcdparams [ i ] . index == 1
water	155:20	0:0	12	s
op	155:21	0:0	12	->
water	155:23	0:0	12	mcdparams
op	155:32	0:0	12	[
water	155:33	0:0	12	i
op	155:34	0:0	12	]
op	155:35	0:0	12	.
water	155:36	0:0	12	present
op	155:44	0:0	12	&&
water	155:47	0:0	12	s
op	155:48	0:0	12	->
water	155:50	0:0	12	mcdparams
op	155:59	0:0	12	[
water	155:60	0:0	12	i
op	155:61	0:0	12	]
op	155:62	0:0	12	.
water	155:63	0:0	12	index
op	155:69	0:0	12	==
water	155:72	0:0	12	1
stmts	156:20	157:34	11	
if	156:20	157:34	12	(ret =decode_channel (s ,s -> mcdparams [ i ] . chan2 ))
cond	156:24	156:69	13	ret =decode_channel (s ,s -> mcdparams [ i ] . chan2 )
water	156:24	0:0	14	ret
op	156:28	0:0	14	=
call	156:30	156:69	14	decode_channel
arg	156:45	156:46	15	s
water	156:45	0:0	16	s
arg	156:48	156:69	15	s->mcdparams[i].chan2
water	156:48	0:0	16	s
op	156:49	0:0	16	->
water	156:51	0:0	16	mcdparams
op	156:60	0:0	16	[
water	156:61	0:0	16	i
op	156:62	0:0	16	]
op	156:63	0:0	16	.
water	156:64	0:0	16	chan2
stmts	157:24	157:34	13	
return	157:24	157:34	14	ret
water	157:31	0:0	15	ret
if	159:16	160:30	10	(ret =decode_channel (s ,s -> mcdparams [ i ] . chan1 ))
cond	159:20	159:65	11	ret =decode_channel (s ,s -> mcdparams [ i ] . chan1 )
water	159:20	0:0	12	ret
op	159:24	0:0	12	=
call	159:26	159:65	12	decode_channel
arg	159:41	159:42	13	s
water	159:41	0:0	14	s
arg	159:44	159:65	13	s->mcdparams[i].chan1
water	159:44	0:0	14	s
op	159:45	0:0	14	->
water	159:47	0:0	14	mcdparams
op	159:56	0:0	14	[
water	159:57	0:0	14	i
op	159:58	0:0	14	]
op	159:59	0:0	14	.
water	159:60	0:0	14	chan1
stmts	160:20	160:30	11	
return	160:20	160:30	12	ret
water	160:27	0:0	13	ret
if	162:16	169:16	10	(s -> mcdparams [ i ] . present)
cond	162:20	162:36	11	s -> mcdparams [ i ] . present
water	162:20	0:0	12	s
op	162:21	0:0	12	->
water	162:23	0:0	12	mcdparams
op	162:32	0:0	12	[
water	162:33	0:0	12	i
op	162:34	0:0	12	]
op	162:35	0:0	12	.
water	162:36	0:0	12	present
stmts	162:45	169:16	11	
water	162:45	0:0	12	{
water	163:20	0:0	12	s
op	163:21	0:0	12	->
water	163:23	0:0	12	dmode
op	163:29	0:0	12	=
water	163:31	0:0	12	mc_dmodes
op	163:40	0:0	12	[
water	163:41	0:0	12	s
op	163:42	0:0	12	->
water	163:44	0:0	12	mcdparams
op	163:53	0:0	12	[
water	163:54	0:0	12	i
op	163:55	0:0	12	]
op	163:56	0:0	12	.
water	163:57	0:0	12	index
op	163:62	0:0	12	]
water	163:63	0:0	12	;
if	164:20	168:34	12	(ret =decorrelate (s ,s -> mcdparams [ i ] . chan2 ,s -> mcdparams [ i ] . chan1 ,s -> nb_samples - 1 ))
cond	164:24	167:59	13	ret =decorrelate (s ,s -> mcdparams [ i ] . chan2 ,s -> mcdparams [ i ] . chan1 ,s -> nb_samples - 1 )
water	164:24	0:0	14	ret
op	164:28	0:0	14	=
call	164:30	167:59	14	decorrelate
arg	164:42	164:43	15	s
water	164:42	0:0	16	s
arg	165:42	165:63	15	s->mcdparams[i].chan2
water	165:42	0:0	16	s
op	165:43	0:0	16	->
water	165:45	0:0	16	mcdparams
op	165:54	0:0	16	[
water	165:55	0:0	16	i
op	165:56	0:0	16	]
op	165:57	0:0	16	.
water	165:58	0:0	16	chan2
arg	166:42	166:63	15	s->mcdparams[i].chan1
water	166:42	0:0	16	s
op	166:43	0:0	16	->
water	166:45	0:0	16	mcdparams
op	166:54	0:0	16	[
water	166:55	0:0	16	i
op	166:56	0:0	16	]
op	166:57	0:0	16	.
water	166:58	0:0	16	chan1
arg	167:42	167:59	15	s->nb_samples-1
water	167:42	0:0	16	s
op	167:43	0:0	16	->
water	167:45	0:0	16	nb_samples
op	167:56	0:0	16	-
water	167:58	0:0	16	1
stmts	168:24	168:34	13	
return	168:24	168:34	14	ret
water	168:31	0:0	15	ret
water	169:16	0:0	12	}
water	170:12	0:0	10	}
water	171:8	0:0	8	}
for	173:8	182:8	4	(chan = 0 ;chan < avctx -> channels;chan ++)
forinit	173:13	173:21	5	chan = 0 ;
water	173:13	0:0	6	chan
op	173:18	0:0	6	=
water	173:20	0:0	6	0
water	173:21	0:0	6	;
cond	173:23	173:37	5	chan < avctx -> channels
water	173:23	0:0	6	chan
op	173:28	0:0	6	<
water	173:30	0:0	6	avctx
op	173:35	0:0	6	->
water	173:37	0:0	6	channels
forexpr	173:47	173:51	5	chan ++
water	173:47	0:0	6	chan
op	173:51	0:0	6	++
stmts	173:55	182:8	5	
water	173:55	0:0	6	{
decl	174:12	174:47	6	int32_t	*decoded
op	174:29	0:0	6	=
water	174:31	0:0	6	s
op	174:32	0:0	6	->
water	174:34	0:0	6	decoded
op	174:41	0:0	6	[
water	174:42	0:0	6	chan
op	174:46	0:0	6	]
if	176:12	177:69	6	(s -> lpc_mode [ chan ])
cond	176:16	176:32	7	s -> lpc_mode [ chan ]
water	176:16	0:0	8	s
op	176:17	0:0	8	->
water	176:19	0:0	8	lpc_mode
op	176:27	0:0	8	[
water	176:28	0:0	8	chan
op	176:32	0:0	8	]
stmts	177:16	177:69	7	
call	177:16	177:68	8	decode_lpc
arg	177:27	177:34	9	decoded
water	177:27	0:0	10	decoded
arg	177:36	177:53	9	s->lpc_mode[chan]
water	177:36	0:0	10	s
op	177:37	0:0	10	->
water	177:39	0:0	10	lpc_mode
op	177:47	0:0	10	[
water	177:48	0:0	10	chan
op	177:52	0:0	10	]
arg	177:55	177:68	9	s->nb_samples
water	177:55	0:0	10	s
op	177:56	0:0	10	->
water	177:58	0:0	10	nb_samples
water	177:69	0:0	8	;
if	179:12	181:56	6	(s -> sample_shift [ chan ] > 0)
cond	179:16	179:40	7	s -> sample_shift [ chan ] > 0
water	179:16	0:0	8	s
op	179:17	0:0	8	->
water	179:19	0:0	8	sample_shift
op	179:31	0:0	8	[
water	179:32	0:0	8	chan
op	179:36	0:0	8	]
op	179:38	0:0	8	>
water	179:40	0:0	8	0
stmts	180:16	181:56	7	
for	180:16	181:56	8	(i = 0 ;i < s -> nb_samples;i ++)
forinit	180:21	180:26	9	i = 0 ;
water	180:21	0:0	10	i
op	180:23	0:0	10	=
water	180:25	0:0	10	0
water	180:26	0:0	10	;
cond	180:28	180:35	9	i < s -> nb_samples
water	180:28	0:0	10	i
op	180:30	0:0	10	<
water	180:32	0:0	10	s
op	180:33	0:0	10	->
water	180:35	0:0	10	nb_samples
forexpr	180:47	180:48	9	i ++
water	180:47	0:0	10	i
op	180:48	0:0	10	++
stmts	181:20	181:56	9	
water	181:20	0:0	10	decoded
op	181:27	0:0	10	[
water	181:28	0:0	10	i
op	181:29	0:0	10	]
op	181:31	0:0	10	<<=
water	181:35	0:0	10	s
op	181:36	0:0	10	->
water	181:38	0:0	10	sample_shift
op	181:50	0:0	10	[
water	181:51	0:0	10	chan
op	181:55	0:0	10	]
water	181:56	0:0	10	;
water	182:8	0:0	6	}
water	183:4	0:0	4	}
call	185:4	185:21	2	align_get_bits
arg	185:19	185:21	3	gb
water	185:19	0:0	4	gb
water	185:22	0:0	2	;
call	186:4	186:20	2	skip_bits
arg	186:14	186:16	3	gb
water	186:14	0:0	4	gb
arg	186:18	186:20	3	24
water	186:18	0:0	4	24
water	186:21	0:0	2	;
if	187:4	188:49	2	(get_bits_left (gb ) < 0)
cond	187:8	187:28	3	get_bits_left (gb ) < 0
call	187:8	187:24	4	get_bits_left
arg	187:22	187:24	5	gb
water	187:22	0:0	6	gb
op	187:26	0:0	4	<
water	187:28	0:0	4	0
stmts	188:8	188:49	3	
call	188:8	188:48	4	av_log
arg	188:15	188:20	5	avctx
water	188:15	0:0	6	avctx
arg	188:22	188:34	5	AV_LOG_DEBUG
water	188:22	0:0	6	AV_LOG_DEBUG
arg	188:36	188:48	5	"overread\n"
water	188:36	0:0	6	"overread\n"
water	188:49	0:0	4	;
else	189:4	190:50	2
stmts	189:9	190:50	3	
if	189:9	190:50	4	(get_bits_left (gb ) > 0)
cond	189:13	189:33	5	get_bits_left (gb ) > 0
call	189:13	189:29	6	get_bits_left
arg	189:27	189:29	7	gb
water	189:27	0:0	8	gb
op	189:31	0:0	6	>
water	189:33	0:0	6	0
stmts	190:8	190:50	5	
call	190:8	190:49	6	av_log
arg	190:15	190:20	7	avctx
water	190:15	0:0	8	avctx
arg	190:22	190:34	7	AV_LOG_DEBUG
water	190:22	0:0	8	AV_LOG_DEBUG
arg	190:36	190:49	7	"underread\n"
water	190:36	0:0	8	"underread\n"
water	190:50	0:0	6	;
if	192:4	198:4	2	(avctx -> err_recognition & AV_EF_CRCCHECK)
cond	192:8	192:33	3	avctx -> err_recognition & AV_EF_CRCCHECK
water	192:8	0:0	4	avctx
op	192:13	0:0	4	->
water	192:15	0:0	4	err_recognition
op	192:31	0:0	4	&
water	192:33	0:0	4	AV_EF_CRCCHECK
stmts	192:49	198:4	3	
water	192:49	0:0	4	{
if	193:8	197:8	4	(ff_tak_check_crc (pkt -> data + hsize ,get_bits_count (gb ) / 8 - hsize ))
cond	193:12	194:59	5	ff_tak_check_crc (pkt -> data + hsize ,get_bits_count (gb ) / 8 - hsize )
call	193:12	194:59	6	ff_tak_check_crc
arg	193:29	193:46	7	pkt->data+hsize
water	193:29	0:0	8	pkt
op	193:32	0:0	8	->
water	193:34	0:0	8	data
op	193:39	0:0	8	+
water	193:41	0:0	8	hsize
arg	194:29	194:59	7	get_bits_count(gb)/8-hsize
call	194:29	194:46	8	get_bits_count
arg	194:44	194:46	9	gb
water	194:44	0:0	10	gb
op	194:48	0:0	8	/
water	194:50	0:0	8	8
op	194:52	0:0	8	-
water	194:54	0:0	8	hsize
stmts	194:62	197:8	5	
water	194:62	0:0	6	{
call	195:12	195:53	6	av_log
arg	195:19	195:24	7	avctx
water	195:19	0:0	8	avctx
arg	195:26	195:38	7	AV_LOG_ERROR
water	195:26	0:0	8	AV_LOG_ERROR
arg	195:40	195:53	7	"CRC error\n"
water	195:40	0:0	8	"CRC error\n"
water	195:54	0:0	6	;
return	196:12	196:38	6	AVERROR_INVALIDDATA
water	196:19	0:0	7	AVERROR_INVALIDDATA
water	197:8	0:0	6	}
water	198:4	0:0	4	}
switch	201:4	225:4	2	(avctx -> sample_fmt)
cond	201:12	201:19	3	avctx -> sample_fmt
water	201:12	0:0	4	avctx
op	201:17	0:0	4	->
water	201:19	0:0	4	sample_fmt
stmts	201:31	225:4	3	
water	201:31	0:0	4	{
label	202:4	202:26	4	case AV_SAMPLE_FMT_U8P :
for	203:8	208:8	4	(chan = 0 ;chan < avctx -> channels;chan ++)
forinit	203:13	203:21	5	chan = 0 ;
water	203:13	0:0	6	chan
op	203:18	0:0	6	=
water	203:20	0:0	6	0
water	203:21	0:0	6	;
cond	203:23	203:37	5	chan < avctx -> channels
water	203:23	0:0	6	chan
op	203:28	0:0	6	<
water	203:30	0:0	6	avctx
op	203:35	0:0	6	->
water	203:37	0:0	6	channels
forexpr	203:47	203:51	5	chan ++
water	203:47	0:0	6	chan
op	203:51	0:0	6	++
stmts	203:55	208:8	5	
water	203:55	0:0	6	{
decl	204:12	204:68	6	uint8_t	*samples
op	204:29	0:0	6	=
water	204:31	0:0	6	(
water	204:32	0:0	6	uint8_t
op	204:40	0:0	6	*
water	204:41	0:0	6	)
water	204:42	0:0	6	frame
op	204:47	0:0	6	->
water	204:49	0:0	6	extended_data
op	204:62	0:0	6	[
water	204:63	0:0	6	chan
op	204:67	0:0	6	]
decl	205:12	205:47	6	int32_t	*decoded
op	205:29	0:0	6	=
water	205:31	0:0	6	s
op	205:32	0:0	6	->
water	205:34	0:0	6	decoded
op	205:41	0:0	6	[
water	205:42	0:0	6	chan
op	205:46	0:0	6	]
for	206:12	207:46	6	(i = 0 ;i < s -> nb_samples;i ++)
forinit	206:17	206:22	7	i = 0 ;
water	206:17	0:0	8	i
op	206:19	0:0	8	=
water	206:21	0:0	8	0
water	206:22	0:0	8	;
cond	206:24	206:31	7	i < s -> nb_samples
water	206:24	0:0	8	i
op	206:26	0:0	8	<
water	206:28	0:0	8	s
op	206:29	0:0	8	->
water	206:31	0:0	8	nb_samples
forexpr	206:43	206:44	7	i ++
water	206:43	0:0	8	i
op	206:44	0:0	8	++
stmts	207:16	207:46	7	
water	207:16	0:0	8	samples
op	207:23	0:0	8	[
water	207:24	0:0	8	i
op	207:25	0:0	8	]
op	207:27	0:0	8	=
water	207:29	0:0	8	decoded
op	207:36	0:0	8	[
water	207:37	0:0	8	i
op	207:38	0:0	8	]
op	207:40	0:0	8	+
water	207:42	0:0	8	0
water	207:43	0:0	8	x80
water	207:46	0:0	8	;
water	208:8	0:0	6	}
break	209:8	209:13	4	
label	210:4	210:27	4	case AV_SAMPLE_FMT_S16P :
for	211:8	216:8	4	(chan = 0 ;chan < avctx -> channels;chan ++)
forinit	211:13	211:21	5	chan = 0 ;
water	211:13	0:0	6	chan
op	211:18	0:0	6	=
water	211:20	0:0	6	0
water	211:21	0:0	6	;
cond	211:23	211:37	5	chan < avctx -> channels
water	211:23	0:0	6	chan
op	211:28	0:0	6	<
water	211:30	0:0	6	avctx
op	211:35	0:0	6	->
water	211:37	0:0	6	channels
forexpr	211:47	211:51	5	chan ++
water	211:47	0:0	6	chan
op	211:51	0:0	6	++
stmts	211:55	216:8	5	
water	211:55	0:0	6	{
decl	212:12	212:68	6	int16_t	*samples
op	212:29	0:0	6	=
water	212:31	0:0	6	(
water	212:32	0:0	6	int16_t
op	212:40	0:0	6	*
water	212:41	0:0	6	)
water	212:42	0:0	6	frame
op	212:47	0:0	6	->
water	212:49	0:0	6	extended_data
op	212:62	0:0	6	[
water	212:63	0:0	6	chan
op	212:67	0:0	6	]
decl	213:12	213:47	6	int32_t	*decoded
op	213:29	0:0	6	=
water	213:31	0:0	6	s
op	213:32	0:0	6	->
water	213:34	0:0	6	decoded
op	213:41	0:0	6	[
water	213:42	0:0	6	chan
op	213:46	0:0	6	]
for	214:12	215:39	6	(i = 0 ;i < s -> nb_samples;i ++)
forinit	214:17	214:22	7	i = 0 ;
water	214:17	0:0	8	i
op	214:19	0:0	8	=
water	214:21	0:0	8	0
water	214:22	0:0	8	;
cond	214:24	214:31	7	i < s -> nb_samples
water	214:24	0:0	8	i
op	214:26	0:0	8	<
water	214:28	0:0	8	s
op	214:29	0:0	8	->
water	214:31	0:0	8	nb_samples
forexpr	214:43	214:44	7	i ++
water	214:43	0:0	8	i
op	214:44	0:0	8	++
stmts	215:16	215:39	7	
water	215:16	0:0	8	samples
op	215:23	0:0	8	[
water	215:24	0:0	8	i
op	215:25	0:0	8	]
op	215:27	0:0	8	=
water	215:29	0:0	8	decoded
op	215:36	0:0	8	[
water	215:37	0:0	8	i
op	215:38	0:0	8	]
water	215:39	0:0	8	;
water	216:8	0:0	6	}
break	217:8	217:13	4	
label	218:4	218:27	4	case AV_SAMPLE_FMT_S32P :
for	219:8	223:8	4	(chan = 0 ;chan < avctx -> channels;chan ++)
forinit	219:13	219:21	5	chan = 0 ;
water	219:13	0:0	6	chan
op	219:18	0:0	6	=
water	219:20	0:0	6	0
water	219:21	0:0	6	;
cond	219:23	219:37	5	chan < avctx -> channels
water	219:23	0:0	6	chan
op	219:28	0:0	6	<
water	219:30	0:0	6	avctx
op	219:35	0:0	6	->
water	219:37	0:0	6	channels
forexpr	219:47	219:51	5	chan ++
water	219:47	0:0	6	chan
op	219:51	0:0	6	++
stmts	219:55	223:8	5	
water	219:55	0:0	6	{
decl	220:12	220:68	6	int32_t	*samples
op	220:29	0:0	6	=
water	220:31	0:0	6	(
water	220:32	0:0	6	int32_t
op	220:40	0:0	6	*
water	220:41	0:0	6	)
water	220:42	0:0	6	frame
op	220:47	0:0	6	->
water	220:49	0:0	6	extended_data
op	220:62	0:0	6	[
water	220:63	0:0	6	chan
op	220:67	0:0	6	]
for	221:12	222:32	6	(i = 0 ;i < s -> nb_samples;i ++)
forinit	221:17	221:22	7	i = 0 ;
water	221:17	0:0	8	i
op	221:19	0:0	8	=
water	221:21	0:0	8	0
water	221:22	0:0	8	;
cond	221:24	221:31	7	i < s -> nb_samples
water	221:24	0:0	8	i
op	221:26	0:0	8	<
water	221:28	0:0	8	s
op	221:29	0:0	8	->
water	221:31	0:0	8	nb_samples
forexpr	221:43	221:44	7	i ++
water	221:43	0:0	8	i
op	221:44	0:0	8	++
stmts	222:16	222:32	7	
water	222:16	0:0	8	samples
op	222:23	0:0	8	[
water	222:24	0:0	8	i
op	222:25	0:0	8	]
op	222:27	0:0	8	<<=
water	222:31	0:0	8	8
water	222:32	0:0	8	;
water	223:8	0:0	6	}
break	224:8	224:13	4	
water	225:4	0:0	4	}
op	227:4	0:0	2	*
water	227:5	0:0	2	got_frame_ptr
op	227:19	0:0	2	=
water	227:21	0:0	2	1
water	227:22	0:0	2	;
return	229:4	229:20	2	pkt->size
water	229:11	0:0	3	pkt
op	229:14	0:0	3	->
water	229:16	0:0	3	size
