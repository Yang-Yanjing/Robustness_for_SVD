func	2:0	71:0	0	static int	decode_frame
params	2:23	0:0	1	
param	2:24	2:45	2	AVCodecContext *	avctx
param	3:24	3:34	2	void *	data
param	3:36	3:50	2	int *	data_size
param	4:24	4:39	2	AVPacket *	avpkt
stmnts	0:0	70:19	1	
decl	6:4	6:36	2	const uint8_t	*buf
op	6:23	0:0	2	=
water	6:25	0:0	2	avpkt
op	6:30	0:0	2	->
water	6:32	0:0	2	data
decl	7:4	7:36	2	int	buf_size
op	7:23	0:0	2	=
water	7:25	0:0	2	avpkt
op	7:30	0:0	2	->
water	7:32	0:0	2	size
decl	8:4	8:41	2	const uint8_t	*buf_end
op	8:27	0:0	2	=
water	8:29	0:0	2	buf
op	8:32	0:0	2	+
water	8:33	0:0	2	buf_size
decl	9:4	9:40	2	MadContext	*t
op	9:22	0:0	2	=
water	9:24	0:0	2	avctx
op	9:29	0:0	2	->
water	9:31	0:0	2	priv_data
decl	10:4	10:29	2	MpegEncContext	*s
op	10:22	0:0	2	=
op	10:24	0:0	2	&
water	10:25	0:0	2	t
op	10:26	0:0	2	->
water	10:28	0:0	2	s
decl	11:4	11:18	2	int	chunk_type
decl	12:4	12:13	2	int	inter
if	14:4	18:4	2	(buf_size < 17)
cond	14:8	14:19	3	buf_size < 17
water	14:8	0:0	4	buf_size
op	14:17	0:0	4	<
water	14:19	0:0	4	17
stmts	14:23	18:4	3	
water	14:23	0:0	4	{
call	15:8	15:62	4	av_log
arg	15:15	15:20	5	avctx
water	15:15	0:0	6	avctx
arg	15:22	15:34	5	AV_LOG_ERROR
water	15:22	0:0	6	AV_LOG_ERROR
arg	15:36	15:62	5	"Input buffer too small\n"
water	15:36	0:0	6	"Input buffer too small\n"
water	15:63	0:0	4	;
op	16:8	0:0	4	*
water	16:9	0:0	4	data_size
op	16:19	0:0	4	=
water	16:21	0:0	4	0
water	16:22	0:0	4	;
return	17:8	17:17	4	-1
op	17:15	0:0	5	-
water	17:16	0:0	5	1
water	18:4	0:0	4	}
water	20:4	0:0	2	chunk_type
op	20:15	0:0	2	=
call	20:17	20:32	2	AV_RL32
arg	20:25	20:32	3	&buf[0]
op	20:25	0:0	4	&
water	20:26	0:0	4	buf
op	20:29	0:0	4	[
water	20:30	0:0	4	0
op	20:31	0:0	4	]
water	20:33	0:0	2	;
water	21:4	0:0	2	inter
op	21:10	0:0	2	=
water	21:12	0:0	2	(
water	21:13	0:0	2	chunk_type
op	21:24	0:0	2	==
water	21:27	0:0	2	MADm_TAG
op	21:36	0:0	2	||
water	21:39	0:0	2	chunk_type
op	21:50	0:0	2	==
water	21:53	0:0	2	MADe_TAG
water	21:61	0:0	2	)
water	21:62	0:0	2	;
water	22:4	0:0	2	buf
op	22:8	0:0	2	+=
water	22:11	0:0	2	8
water	22:12	0:0	2	;
call	24:4	25:43	2	av_reduce
arg	24:14	24:35	3	&avctx->time_base.num
op	24:14	0:0	4	&
water	24:15	0:0	4	avctx
op	24:20	0:0	4	->
water	24:22	0:0	4	time_base
op	24:31	0:0	4	.
water	24:32	0:0	4	num
arg	24:37	24:58	3	&avctx->time_base.den
op	24:37	0:0	4	&
water	24:38	0:0	4	avctx
op	24:43	0:0	4	->
water	24:45	0:0	4	time_base
op	24:54	0:0	4	.
water	24:55	0:0	4	den
arg	25:14	25:30	3	AV_RL16(&buf[6])
call	25:14	25:29	4	AV_RL16
arg	25:22	25:29	5	&buf[6]
op	25:22	0:0	6	&
water	25:23	0:0	6	buf
op	25:26	0:0	6	[
water	25:27	0:0	6	6
op	25:28	0:0	6	]
arg	25:32	25:36	3	1000
water	25:32	0:0	4	1000
arg	25:38	25:43	3	1<<30
water	25:38	0:0	4	1
op	25:39	0:0	4	<<
water	25:41	0:0	4	30
water	25:44	0:0	2	;
water	27:4	0:0	2	s
op	27:5	0:0	2	->
water	27:7	0:0	2	width
op	27:14	0:0	2	=
call	27:16	27:31	2	AV_RL16
arg	27:24	27:31	3	&buf[8]
op	27:24	0:0	4	&
water	27:25	0:0	4	buf
op	27:28	0:0	4	[
water	27:29	0:0	4	8
op	27:30	0:0	4	]
water	27:32	0:0	2	;
water	28:4	0:0	2	s
op	28:5	0:0	2	->
water	28:7	0:0	2	height
op	28:14	0:0	2	=
call	28:16	28:32	2	AV_RL16
arg	28:24	28:32	3	&buf[10]
op	28:24	0:0	4	&
water	28:25	0:0	4	buf
op	28:28	0:0	4	[
water	28:29	0:0	4	10
op	28:31	0:0	4	]
water	28:33	0:0	2	;
call	29:4	29:32	2	calc_intra_matrix
arg	29:22	29:23	3	t
water	29:22	0:0	4	t
arg	29:25	29:32	3	buf[13]
water	29:25	0:0	4	buf
op	29:28	0:0	4	[
water	29:29	0:0	4	13
op	29:31	0:0	4	]
water	29:33	0:0	2	;
water	30:4	0:0	2	buf
op	30:8	0:0	2	+=
water	30:11	0:0	2	16
water	30:13	0:0	2	;
if	32:4	42:4	2	(avctx -> width != s -> width || avctx -> height != s -> height)
cond	32:8	32:56	3	avctx -> width != s -> width || avctx -> height != s -> height
water	32:8	0:0	4	avctx
op	32:13	0:0	4	->
water	32:15	0:0	4	width
op	32:21	0:0	4	!=
water	32:24	0:0	4	s
op	32:25	0:0	4	->
water	32:27	0:0	4	width
op	32:33	0:0	4	||
water	32:36	0:0	4	avctx
op	32:41	0:0	4	->
water	32:43	0:0	4	height
op	32:50	0:0	4	!=
water	32:53	0:0	4	s
op	32:54	0:0	4	->
water	32:56	0:0	4	height
stmts	32:64	42:4	3	
water	32:64	0:0	4	{
if	33:8	34:21	4	(( s -> width * s -> height ) / 2048 * 7 > buf_end - buf)
cond	33:11	33:51	5	( s -> width * s -> height ) / 2048 * 7 > buf_end - buf
water	33:11	0:0	6	(
water	33:12	0:0	6	s
op	33:13	0:0	6	->
water	33:15	0:0	6	width
op	33:21	0:0	6	*
water	33:23	0:0	6	s
op	33:24	0:0	6	->
water	33:26	0:0	6	height
water	33:32	0:0	6	)
op	33:33	0:0	6	/
water	33:34	0:0	6	2048
op	33:38	0:0	6	*
water	33:39	0:0	6	7
op	33:41	0:0	6	>
water	33:43	0:0	6	buf_end
op	33:50	0:0	6	-
water	33:51	0:0	6	buf
stmts	34:12	34:21	5	
return	34:12	34:21	6	-1
op	34:19	0:0	7	-
water	34:20	0:0	7	1
if	35:8	36:21	4	(av_image_check_size (s -> width ,s -> height ,0 ,avctx ) < 0)
cond	35:12	35:65	5	av_image_check_size (s -> width ,s -> height ,0 ,avctx ) < 0
call	35:12	35:61	6	av_image_check_size
arg	35:32	35:40	7	s->width
water	35:32	0:0	8	s
op	35:33	0:0	8	->
water	35:35	0:0	8	width
arg	35:42	35:51	7	s->height
water	35:42	0:0	8	s
op	35:43	0:0	8	->
water	35:45	0:0	8	height
arg	35:53	35:54	7	0
water	35:53	0:0	8	0
arg	35:56	35:61	7	avctx
water	35:56	0:0	8	avctx
op	35:63	0:0	6	<
water	35:65	0:0	6	0
stmts	36:12	36:21	5	
return	36:12	36:21	6	-1
op	36:19	0:0	7	-
water	36:20	0:0	7	1
call	37:8	37:57	4	avcodec_set_dimensions
arg	37:31	37:36	5	avctx
water	37:31	0:0	6	avctx
arg	37:38	37:46	5	s->width
water	37:38	0:0	6	s
op	37:39	0:0	6	->
water	37:41	0:0	6	width
arg	37:48	37:57	5	s->height
water	37:48	0:0	6	s
op	37:49	0:0	6	->
water	37:51	0:0	6	height
water	37:58	0:0	4	;
if	38:8	39:51	4	(t -> frame . data [ 0 ])
cond	38:12	38:27	5	t -> frame . data [ 0 ]
water	38:12	0:0	6	t
op	38:13	0:0	6	->
water	38:15	0:0	6	frame
op	38:20	0:0	6	.
water	38:21	0:0	6	data
op	38:25	0:0	6	[
water	38:26	0:0	6	0
op	38:27	0:0	6	]
stmts	39:12	39:51	5	
call	39:12	39:50	6	avctx->release_buffer
arg	39:34	39:39	7	avctx
water	39:34	0:0	8	avctx
arg	39:41	39:50	7	&t->frame
op	39:41	0:0	8	&
water	39:42	0:0	8	t
op	39:43	0:0	8	->
water	39:45	0:0	8	frame
water	39:51	0:0	6	;
if	40:8	41:56	4	(t -> last_frame . data [ 0 ])
cond	40:12	40:32	5	t -> last_frame . data [ 0 ]
water	40:12	0:0	6	t
op	40:13	0:0	6	->
water	40:15	0:0	6	last_frame
op	40:25	0:0	6	.
water	40:26	0:0	6	data
op	40:30	0:0	6	[
water	40:31	0:0	6	0
op	40:32	0:0	6	]
stmts	41:12	41:56	5	
call	41:12	41:55	6	avctx->release_buffer
arg	41:34	41:39	7	avctx
water	41:34	0:0	8	avctx
arg	41:41	41:55	7	&t->last_frame
op	41:41	0:0	8	&
water	41:42	0:0	8	t
op	41:43	0:0	8	->
water	41:45	0:0	8	last_frame
water	41:56	0:0	6	;
water	42:4	0:0	4	}
water	44:4	0:0	2	t
op	44:5	0:0	2	->
water	44:7	0:0	2	frame
op	44:12	0:0	2	.
water	44:13	0:0	2	reference
op	44:23	0:0	2	=
water	44:25	0:0	2	3
water	44:26	0:0	2	;
if	45:4	50:4	2	(! t -> frame . data [ 0 ])
cond	45:8	45:24	3	! t -> frame . data [ 0 ]
op	45:8	0:0	4	!
water	45:9	0:0	4	t
op	45:10	0:0	4	->
water	45:12	0:0	4	frame
op	45:17	0:0	4	.
water	45:18	0:0	4	data
op	45:22	0:0	4	[
water	45:23	0:0	4	0
op	45:24	0:0	4	]
stmts	45:27	50:4	3	
water	45:27	0:0	4	{
if	46:8	49:8	4	(avctx -> get_buffer (avctx ,& t -> frame ) < 0)
cond	46:12	46:50	5	avctx -> get_buffer (avctx ,& t -> frame ) < 0
call	46:12	46:46	6	avctx->get_buffer
arg	46:30	46:35	7	avctx
water	46:30	0:0	8	avctx
arg	46:37	46:46	7	&t->frame
op	46:37	0:0	8	&
water	46:38	0:0	8	t
op	46:39	0:0	8	->
water	46:41	0:0	8	frame
op	46:48	0:0	6	<
water	46:50	0:0	6	0
stmts	46:53	49:8	5	
water	46:53	0:0	6	{
call	47:12	47:63	6	av_log
arg	47:19	47:24	7	avctx
water	47:19	0:0	8	avctx
arg	47:26	47:38	7	AV_LOG_ERROR
water	47:26	0:0	8	AV_LOG_ERROR
arg	47:40	47:63	7	"get_buffer() failed\n"
water	47:40	0:0	8	"get_buffer() failed\n"
water	47:64	0:0	6	;
return	48:12	48:21	6	-1
op	48:19	0:0	7	-
water	48:20	0:0	7	1
water	49:8	0:0	6	}
water	50:4	0:0	4	}
call	52:4	52:106	2	av_fast_malloc
arg	52:19	52:36	3	&t->bitstream_buf
op	52:19	0:0	4	&
water	52:20	0:0	4	t
op	52:21	0:0	4	->
water	52:23	0:0	4	bitstream_buf
arg	52:38	52:60	3	&t->bitstream_buf_size
op	52:38	0:0	4	&
water	52:39	0:0	4	t
op	52:40	0:0	4	->
water	52:42	0:0	4	bitstream_buf_size
arg	52:62	52:106	3	(buf_end-buf)+FF_INPUT_BUFFER_PADDING_SIZE
water	52:62	0:0	4	(
water	52:63	0:0	4	buf_end
op	52:70	0:0	4	-
water	52:71	0:0	4	buf
water	52:74	0:0	4	)
op	52:76	0:0	4	+
water	52:78	0:0	4	FF_INPUT_BUFFER_PADDING_SIZE
water	52:107	0:0	2	;
if	53:4	54:30	2	(! t -> bitstream_buf)
cond	53:8	53:12	3	! t -> bitstream_buf
op	53:8	0:0	4	!
water	53:9	0:0	4	t
op	53:10	0:0	4	->
water	53:12	0:0	4	bitstream_buf
stmts	54:8	54:30	3	
return	54:8	54:30	4	AVERROR(ENOMEM)
call	54:15	54:29	5	AVERROR
arg	54:23	54:29	6	ENOMEM
water	54:23	0:0	7	ENOMEM
call	55:4	55:71	2	bswap16_buf
arg	55:16	55:32	3	t->bitstream_buf
water	55:16	0:0	4	t
op	55:17	0:0	4	->
water	55:19	0:0	4	bitstream_buf
arg	55:34	55:54	3	(constuint16_t*)buf
water	55:34	0:0	4	(
water	55:35	0:0	4	const
water	55:41	0:0	4	uint16_t
op	55:49	0:0	4	*
water	55:50	0:0	4	)
water	55:51	0:0	4	buf
arg	55:56	55:71	3	(buf_end-buf)/2
water	55:56	0:0	4	(
water	55:57	0:0	4	buf_end
op	55:64	0:0	4	-
water	55:65	0:0	4	buf
water	55:68	0:0	4	)
op	55:69	0:0	4	/
water	55:70	0:0	4	2
water	55:72	0:0	2	;
call	56:4	56:86	2	memset
arg	56:11	56:53	3	(uint8_t*)t->bitstream_buf+(buf_end-buf)
water	56:11	0:0	4	(
water	56:12	0:0	4	uint8_t
op	56:19	0:0	4	*
water	56:20	0:0	4	)
water	56:21	0:0	4	t
op	56:22	0:0	4	->
water	56:24	0:0	4	bitstream_buf
op	56:38	0:0	4	+
water	56:40	0:0	4	(
water	56:41	0:0	4	buf_end
op	56:48	0:0	4	-
water	56:49	0:0	4	buf
water	56:52	0:0	4	)
arg	56:55	56:56	3	0
water	56:55	0:0	4	0
arg	56:58	56:86	3	FF_INPUT_BUFFER_PADDING_SIZE
water	56:58	0:0	4	FF_INPUT_BUFFER_PADDING_SIZE
water	56:87	0:0	2	;
call	57:4	57:59	2	init_get_bits
arg	57:18	57:24	3	&s->gb
op	57:18	0:0	4	&
water	57:19	0:0	4	s
op	57:20	0:0	4	->
water	57:22	0:0	4	gb
arg	57:26	57:42	3	t->bitstream_buf
water	57:26	0:0	4	t
op	57:27	0:0	4	->
water	57:29	0:0	4	bitstream_buf
arg	57:44	57:59	3	8*(buf_end-buf)
water	57:44	0:0	4	8
op	57:45	0:0	4	*
water	57:46	0:0	4	(
water	57:47	0:0	4	buf_end
op	57:54	0:0	4	-
water	57:55	0:0	4	buf
water	57:58	0:0	4	)
water	57:60	0:0	2	;
for	59:4	62:25	2	(s -> mb_y = 0 ;s -> mb_y < ( avctx -> height + 15 ) / 16;s -> mb_y ++)
forinit	59:9	59:18	3	s -> mb_y = 0 ;
water	59:9	0:0	4	s
op	59:10	0:0	4	->
water	59:12	0:0	4	mb_y
op	59:16	0:0	4	=
water	59:17	0:0	4	0
water	59:18	0:0	4	;
cond	59:20	59:49	3	s -> mb_y < ( avctx -> height + 15 ) / 16
water	59:20	0:0	4	s
op	59:21	0:0	4	->
water	59:23	0:0	4	mb_y
op	59:28	0:0	4	<
water	59:30	0:0	4	(
water	59:31	0:0	4	avctx
op	59:36	0:0	4	->
water	59:38	0:0	4	height
op	59:44	0:0	4	+
water	59:45	0:0	4	15
water	59:47	0:0	4	)
op	59:48	0:0	4	/
water	59:49	0:0	4	16
forexpr	59:53	59:60	3	s -> mb_y ++
water	59:53	0:0	4	s
op	59:54	0:0	4	->
water	59:56	0:0	4	mb_y
op	59:60	0:0	4	++
stmts	60:8	62:25	3	
for	60:8	62:25	4	(s -> mb_x = 0 ;s -> mb_x < ( avctx -> width + 15 ) / 16;s -> mb_x ++)
forinit	60:13	60:22	5	s -> mb_x = 0 ;
water	60:13	0:0	6	s
op	60:14	0:0	6	->
water	60:16	0:0	6	mb_x
op	60:20	0:0	6	=
water	60:21	0:0	6	0
water	60:22	0:0	6	;
cond	60:24	60:53	5	s -> mb_x < ( avctx -> width + 15 ) / 16
water	60:24	0:0	6	s
op	60:25	0:0	6	->
water	60:27	0:0	6	mb_x
op	60:32	0:0	6	<
water	60:34	0:0	6	(
water	60:35	0:0	6	avctx
op	60:40	0:0	6	->
water	60:42	0:0	6	width
op	60:48	0:0	6	+
water	60:49	0:0	6	15
water	60:51	0:0	6	)
op	60:52	0:0	6	/
water	60:53	0:0	6	16
forexpr	60:57	60:64	5	s -> mb_x ++
water	60:57	0:0	6	s
op	60:58	0:0	6	->
water	60:60	0:0	6	mb_x
op	60:64	0:0	6	++
stmts	61:12	62:25	5	
if	61:12	62:25	6	(decode_mb (t ,inter ) < 0)
cond	61:15	61:37	7	decode_mb (t ,inter ) < 0
call	61:15	61:33	8	decode_mb
arg	61:25	61:26	9	t
water	61:25	0:0	10	t
arg	61:28	61:33	9	inter
water	61:28	0:0	10	inter
op	61:35	0:0	8	<
water	61:37	0:0	8	0
stmts	62:16	62:25	7	
return	62:16	62:25	8	-1
op	62:23	0:0	9	-
water	62:24	0:0	9	1
op	64:4	0:0	2	*
water	64:5	0:0	2	data_size
op	64:15	0:0	2	=
op	64:17	0:0	2	sizeof
water	64:23	0:0	2	(
water	64:24	0:0	2	AVFrame
water	64:31	0:0	2	)
water	64:32	0:0	2	;
op	65:4	0:0	2	*
water	65:5	0:0	2	(
water	65:6	0:0	2	AVFrame
op	65:13	0:0	2	*
water	65:14	0:0	2	)
water	65:15	0:0	2	data
op	65:20	0:0	2	=
water	65:22	0:0	2	t
op	65:23	0:0	2	->
water	65:25	0:0	2	frame
water	65:30	0:0	2	;
if	67:4	68:48	2	(chunk_type != MADe_TAG)
cond	67:8	67:22	3	chunk_type != MADe_TAG
water	67:8	0:0	4	chunk_type
op	67:19	0:0	4	!=
water	67:22	0:0	4	MADe_TAG
stmts	68:8	68:48	3	
call	68:8	68:47	4	FFSWAP
arg	68:15	68:22	5	AVFrame
water	68:15	0:0	6	AVFrame
arg	68:24	68:32	5	t->frame
water	68:24	0:0	6	t
op	68:25	0:0	6	->
water	68:27	0:0	6	frame
arg	68:34	68:47	5	t->last_frame
water	68:34	0:0	6	t
op	68:35	0:0	6	->
water	68:37	0:0	6	last_frame
water	68:48	0:0	4	;
return	70:4	70:19	2	buf_size
water	70:11	0:0	3	buf_size
