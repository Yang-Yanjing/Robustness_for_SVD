func	1:0	545:0	0	static int	decode_audio_block
params	1:29	0:0	1	
param	1:30	1:49	2	AC3DecodeContext *	s
param	1:51	1:58	2	int	blk
stmnts	0:0	544:12	1	
decl	3:4	3:38	2	int	fbw_channels
op	3:21	0:0	2	=
water	3:23	0:0	2	s
op	3:24	0:0	2	->
water	3:26	0:0	2	fbw_channels
decl	4:4	4:38	2	int	channel_mode
op	4:21	0:0	2	=
water	4:23	0:0	2	s
op	4:24	0:0	2	->
water	4:26	0:0	2	channel_mode
decl	5:4	5:23	2	int	i
water	5:9	0:0	2	,
decl	5:4	5:23	2	int	bnd
water	5:14	0:0	2	,
decl	5:4	5:23	2	int	seg
water	5:19	0:0	2	,
decl	5:4	5:23	2	int	ch
decl	6:4	6:28	2	int	different_transforms
decl	7:4	7:22	2	int	downmix_output
decl	8:4	8:18	2	int	cpl_in_use
decl	9:4	9:32	2	GetBitContext	*gbc
op	9:23	0:0	2	=
op	9:25	0:0	2	&
water	9:26	0:0	2	s
op	9:27	0:0	2	->
water	9:29	0:0	2	gbc
decl	10:4	10:54	2	uint8_t	bit_alloc_stages[AC3_MAX_CHANNELS]
op	10:47	0:0	2	=
water	10:49	0:0	2	{
water	10:51	0:0	2	0
water	10:53	0:0	2	}
water	12:4	0:0	2	different_transforms
op	12:25	0:0	2	=
water	12:27	0:0	2	0
water	12:28	0:0	2	;
if	13:4	19:4	2	(s -> block_switch_syntax)
cond	13:8	13:11	3	s -> block_switch_syntax
water	13:8	0:0	4	s
op	13:9	0:0	4	->
water	13:11	0:0	4	block_switch_syntax
stmts	13:32	19:4	3	
water	13:32	0:0	4	{
for	14:8	18:8	4	(ch = 1 ;ch <= fbw_channels;ch ++)
forinit	14:13	14:19	5	ch = 1 ;
water	14:13	0:0	6	ch
op	14:16	0:0	6	=
water	14:18	0:0	6	1
water	14:19	0:0	6	;
cond	14:21	14:27	5	ch <= fbw_channels
water	14:21	0:0	6	ch
op	14:24	0:0	6	<=
water	14:27	0:0	6	fbw_channels
forexpr	14:41	14:43	5	ch ++
water	14:41	0:0	6	ch
op	14:43	0:0	6	++
stmts	14:47	18:8	5	
water	14:47	0:0	6	{
water	15:12	0:0	6	s
op	15:13	0:0	6	->
water	15:15	0:0	6	block_switch
op	15:27	0:0	6	[
water	15:28	0:0	6	ch
op	15:30	0:0	6	]
op	15:32	0:0	6	=
call	15:34	15:47	6	get_bits1
arg	15:44	15:47	7	gbc
water	15:44	0:0	8	gbc
water	15:48	0:0	6	;
if	16:12	17:40	6	(ch > 1 && s -> block_switch [ ch ] != s -> block_switch [ 1 ])
cond	16:16	16:66	7	ch > 1 && s -> block_switch [ ch ] != s -> block_switch [ 1 ]
water	16:16	0:0	8	ch
op	16:19	0:0	8	>
water	16:21	0:0	8	1
op	16:23	0:0	8	&&
water	16:26	0:0	8	s
op	16:27	0:0	8	->
water	16:29	0:0	8	block_switch
op	16:41	0:0	8	[
water	16:42	0:0	8	ch
op	16:44	0:0	8	]
op	16:46	0:0	8	!=
water	16:49	0:0	8	s
op	16:50	0:0	8	->
water	16:52	0:0	8	block_switch
op	16:64	0:0	8	[
water	16:65	0:0	8	1
op	16:66	0:0	8	]
stmts	17:16	17:40	7	
water	17:16	0:0	8	different_transforms
op	17:37	0:0	8	=
water	17:39	0:0	8	1
water	17:40	0:0	8	;
water	18:8	0:0	6	}
water	19:4	0:0	4	}
if	21:4	25:4	2	(s -> dither_flag_syntax)
cond	21:8	21:11	3	s -> dither_flag_syntax
water	21:8	0:0	4	s
op	21:9	0:0	4	->
water	21:11	0:0	4	dither_flag_syntax
stmts	21:31	25:4	3	
water	21:31	0:0	4	{
for	22:8	24:8	4	(ch = 1 ;ch <= fbw_channels;ch ++)
forinit	22:13	22:19	5	ch = 1 ;
water	22:13	0:0	6	ch
op	22:16	0:0	6	=
water	22:18	0:0	6	1
water	22:19	0:0	6	;
cond	22:21	22:27	5	ch <= fbw_channels
water	22:21	0:0	6	ch
op	22:24	0:0	6	<=
water	22:27	0:0	6	fbw_channels
forexpr	22:41	22:43	5	ch ++
water	22:41	0:0	6	ch
op	22:43	0:0	6	++
stmts	22:47	24:8	5	
water	22:47	0:0	6	{
water	23:12	0:0	6	s
op	23:13	0:0	6	->
water	23:15	0:0	6	dither_flag
op	23:26	0:0	6	[
water	23:27	0:0	6	ch
op	23:29	0:0	6	]
op	23:31	0:0	6	=
call	23:33	23:46	6	get_bits1
arg	23:43	23:46	7	gbc
water	23:43	0:0	8	gbc
water	23:47	0:0	6	;
water	24:8	0:0	6	}
water	25:4	0:0	4	}
water	27:4	0:0	2	i
op	27:6	0:0	2	=
op	27:8	0:0	2	!
water	27:9	0:0	2	s
op	27:10	0:0	2	->
water	27:12	0:0	2	channel_mode
water	27:24	0:0	2	;
do	28:4	41:4	2	(i --)
cond	41:13	41:14	3	i --
water	41:13	0:0	4	i
op	41:14	0:0	4	--
stmts	28:7	41:4	3	
water	28:7	0:0	4	{
if	29:8	38:8	4	(get_bits1 (gbc ))
cond	29:12	29:25	5	get_bits1 (gbc )
call	29:12	29:25	6	get_bits1
arg	29:22	29:25	7	gbc
water	29:22	0:0	8	gbc
stmts	29:28	38:8	5	
water	29:28	0:0	6	{
decl	32:12	32:45	6	int	range_bits
op	32:27	0:0	6	=
call	32:29	32:44	7	get_bits
arg	32:38	32:41	8	gbc
water	32:38	0:0	9	gbc
arg	32:43	32:44	8	8
water	32:43	0:0	9	8
decl	33:12	33:50	6	INTFLOAT	range
op	33:27	0:0	6	=
call	33:29	33:49	7	AC3_RANGE
arg	33:39	33:49	8	range_bits
water	33:39	0:0	9	range_bits
if	34:12	35:62	6	(range_bits <= 127 || s -> drc_scale <= 1 . 0)
cond	34:16	34:55	7	range_bits <= 127 || s -> drc_scale <= 1 . 0
water	34:16	0:0	8	range_bits
op	34:27	0:0	8	<=
water	34:30	0:0	8	127
op	34:34	0:0	8	||
water	34:37	0:0	8	s
op	34:38	0:0	8	->
water	34:40	0:0	8	drc_scale
op	34:50	0:0	8	<=
water	34:53	0:0	8	1
op	34:54	0:0	8	.
water	34:55	0:0	8	0
stmts	35:16	35:62	7	
water	35:16	0:0	8	s
op	35:17	0:0	8	->
water	35:19	0:0	8	dynamic_range
op	35:32	0:0	8	[
water	35:33	0:0	8	i
op	35:34	0:0	8	]
op	35:36	0:0	8	=
call	35:38	35:61	8	AC3_DYNAMIC_RANGE
arg	35:56	35:61	9	range
water	35:56	0:0	10	range
water	35:62	0:0	8	;
else	36:12	37:43	6
stmts	37:16	37:43	7	
water	37:16	0:0	8	s
op	37:17	0:0	8	->
water	37:19	0:0	8	dynamic_range
op	37:32	0:0	8	[
water	37:33	0:0	8	i
op	37:34	0:0	8	]
op	37:36	0:0	8	=
water	37:38	0:0	8	range
water	37:43	0:0	8	;
water	38:8	0:0	6	}
else	38:10	40:8	4
stmts	38:15	40:8	5	
if	38:15	40:8	6	(blk == 0)
cond	38:19	38:26	7	blk == 0
water	38:19	0:0	8	blk
op	38:23	0:0	8	==
water	38:26	0:0	8	0
stmts	38:29	40:8	7	
water	38:29	0:0	8	{
water	39:12	0:0	8	s
op	39:13	0:0	8	->
water	39:15	0:0	8	dynamic_range
op	39:28	0:0	8	[
water	39:29	0:0	8	i
op	39:30	0:0	8	]
op	39:32	0:0	8	=
water	39:34	0:0	8	AC3_DYNAMIC_RANGE1
water	39:52	0:0	8	;
water	40:8	0:0	8	}
water	41:4	0:0	4	}
water	41:17	0:0	2	;
if	43:4	96:4	2	(s -> eac3 && ( ! blk ||get_bits1 (gbc ) ))
cond	43:8	43:42	3	s -> eac3 && ( ! blk ||get_bits1 (gbc ) )
water	43:8	0:0	4	s
op	43:9	0:0	4	->
water	43:11	0:0	4	eac3
op	43:16	0:0	4	&&
water	43:19	0:0	4	(
op	43:20	0:0	4	!
water	43:21	0:0	4	blk
op	43:25	0:0	4	||
call	43:28	43:41	4	get_bits1
arg	43:38	43:41	5	gbc
water	43:38	0:0	6	gbc
water	43:42	0:0	4	)
stmts	43:45	96:4	3	
water	43:45	0:0	4	{
water	44:8	0:0	4	s
op	44:9	0:0	4	->
water	44:11	0:0	4	spx_in_use
op	44:22	0:0	4	=
call	44:24	44:37	4	get_bits1
arg	44:34	44:37	5	gbc
water	44:34	0:0	6	gbc
water	44:38	0:0	4	;
if	45:8	90:8	4	(s -> spx_in_use)
cond	45:12	45:15	5	s -> spx_in_use
water	45:12	0:0	6	s
op	45:13	0:0	6	->
water	45:15	0:0	6	spx_in_use
stmts	45:27	90:8	5	
water	45:27	0:0	6	{
decl	46:12	47:42	6	int	dst_start_freq
water	46:30	0:0	6	,
decl	46:12	47:42	6	int	dst_end_freq
water	46:44	0:0	6	,
decl	46:12	47:42	6	int	src_start_freq
water	46:60	0:0	6	,
decl	46:12	47:42	6	int	start_subband
water	47:29	0:0	6	,
decl	46:12	47:42	6	int	end_subband
if	49:12	51:12	6	(s -> channel_mode == AC3_CHMODE_MONO)
cond	49:16	49:35	7	s -> channel_mode == AC3_CHMODE_MONO
water	49:16	0:0	8	s
op	49:17	0:0	8	->
water	49:19	0:0	8	channel_mode
op	49:32	0:0	8	==
water	49:35	0:0	8	AC3_CHMODE_MONO
stmts	49:52	51:12	7	
water	49:52	0:0	8	{
water	50:16	0:0	8	s
op	50:17	0:0	8	->
water	50:19	0:0	8	channel_uses_spx
op	50:35	0:0	8	[
water	50:36	0:0	8	1
op	50:37	0:0	8	]
op	50:39	0:0	8	=
water	50:41	0:0	8	1
water	50:42	0:0	8	;
water	51:12	0:0	8	}
else	51:14	54:12	6
stmts	51:19	54:12	7	
water	51:19	0:0	8	{
for	52:16	53:60	8	(ch = 1 ;ch <= fbw_channels;ch ++)
forinit	52:21	52:27	9	ch = 1 ;
water	52:21	0:0	10	ch
op	52:24	0:0	10	=
water	52:26	0:0	10	1
water	52:27	0:0	10	;
cond	52:29	52:35	9	ch <= fbw_channels
water	52:29	0:0	10	ch
op	52:32	0:0	10	<=
water	52:35	0:0	10	fbw_channels
forexpr	52:49	52:51	9	ch ++
water	52:49	0:0	10	ch
op	52:51	0:0	10	++
stmts	53:20	53:60	9	
water	53:20	0:0	10	s
op	53:21	0:0	10	->
water	53:23	0:0	10	channel_uses_spx
op	53:39	0:0	10	[
water	53:40	0:0	10	ch
op	53:42	0:0	10	]
op	53:44	0:0	10	=
call	53:46	53:59	10	get_bits1
arg	53:56	53:59	11	gbc
water	53:56	0:0	12	gbc
water	53:60	0:0	10	;
water	54:12	0:0	8	}
water	57:12	0:0	6	dst_start_freq
op	57:27	0:0	6	=
call	57:29	57:44	6	get_bits
arg	57:38	57:41	7	gbc
water	57:38	0:0	8	gbc
arg	57:43	57:44	7	2
water	57:43	0:0	8	2
water	57:45	0:0	6	;
water	58:12	0:0	6	start_subband
op	58:27	0:0	6	=
call	58:29	58:44	6	get_bits
arg	58:38	58:41	7	gbc
water	58:38	0:0	8	gbc
arg	58:43	58:44	7	3
water	58:43	0:0	8	3
op	58:46	0:0	6	+
water	58:48	0:0	6	2
water	58:49	0:0	6	;
if	59:12	60:50	6	(start_subband > 7)
cond	59:16	59:32	7	start_subband > 7
water	59:16	0:0	8	start_subband
op	59:30	0:0	8	>
water	59:32	0:0	8	7
stmts	60:16	60:50	7	
water	60:16	0:0	8	start_subband
op	60:30	0:0	8	+=
water	60:33	0:0	8	start_subband
op	60:47	0:0	8	-
water	60:49	0:0	8	7
water	60:50	0:0	8	;
water	61:12	0:0	6	end_subband
op	61:27	0:0	6	=
call	61:29	61:44	6	get_bits
arg	61:38	61:41	7	gbc
water	61:38	0:0	8	gbc
arg	61:43	61:44	7	3
water	61:43	0:0	8	3
op	61:46	0:0	6	+
water	61:48	0:0	6	5
water	61:49	0:0	6	;
water	63:12	0:0	6	s
op	63:13	0:0	6	->
water	63:15	0:0	6	spx_dst_end_freq
op	63:32	0:0	6	=
water	63:34	0:0	6	end_freq_inv_tab
op	63:50	0:0	6	[
water	63:51	0:0	6	end_subband
op	63:62	0:0	6	-
water	63:63	0:0	6	5
op	63:64	0:0	6	]
water	63:65	0:0	6	;
if	65:12	66:50	6	(end_subband > 7)
cond	65:16	65:32	7	end_subband > 7
water	65:16	0:0	8	end_subband
op	65:30	0:0	8	>
water	65:32	0:0	8	7
stmts	66:16	66:50	7	
water	66:16	0:0	8	end_subband
op	66:30	0:0	8	+=
water	66:33	0:0	8	end_subband
op	66:47	0:0	8	-
water	66:49	0:0	8	7
water	66:50	0:0	8	;
water	67:12	0:0	6	dst_start_freq
op	67:27	0:0	6	=
water	67:29	0:0	6	dst_start_freq
op	67:44	0:0	6	*
water	67:46	0:0	6	12
op	67:49	0:0	6	+
water	67:51	0:0	6	25
water	67:53	0:0	6	;
water	68:12	0:0	6	src_start_freq
op	68:27	0:0	6	=
water	68:29	0:0	6	start_subband
op	68:44	0:0	6	*
water	68:46	0:0	6	12
op	68:49	0:0	6	+
water	68:51	0:0	6	25
water	68:53	0:0	6	;
water	69:12	0:0	6	dst_end_freq
op	69:27	0:0	6	=
water	69:29	0:0	6	end_subband
op	69:44	0:0	6	*
water	69:46	0:0	6	12
op	69:49	0:0	6	+
water	69:51	0:0	6	25
water	69:53	0:0	6	;
if	71:12	75:12	6	(start_subband >= end_subband)
cond	71:16	71:33	7	start_subband >= end_subband
water	71:16	0:0	8	start_subband
op	71:30	0:0	8	>=
water	71:33	0:0	8	end_subband
stmts	71:46	75:12	7	
water	71:46	0:0	8	{
call	72:16	73:71	8	av_log
arg	72:23	72:31	9	s->avctx
water	72:23	0:0	10	s
op	72:24	0:0	10	->
water	72:26	0:0	10	avctx
arg	72:33	72:45	9	AV_LOG_ERROR
water	72:33	0:0	10	AV_LOG_ERROR
arg	72:47	73:43	9	"invalid spectral extension ""range (%d >= %d)\n"
water	72:47	0:0	10	"invalid spectral extension "
water	73:23	0:0	10	"range (%d >= %d)\n"
arg	73:45	73:58	9	start_subband
water	73:45	0:0	10	start_subband
arg	73:60	73:71	9	end_subband
water	73:60	0:0	10	end_subband
water	73:72	0:0	8	;
return	74:16	74:42	8	AVERROR_INVALIDDATA
water	74:23	0:0	9	AVERROR_INVALIDDATA
water	75:12	0:0	8	}
if	76:12	80:12	6	(dst_start_freq >= src_start_freq)
cond	76:16	76:34	7	dst_start_freq >= src_start_freq
water	76:16	0:0	8	dst_start_freq
op	76:31	0:0	8	>=
water	76:34	0:0	8	src_start_freq
stmts	76:50	80:12	7	
water	76:50	0:0	8	{
call	77:16	78:84	8	av_log
arg	77:23	77:31	9	s->avctx
water	77:23	0:0	10	s
op	77:24	0:0	10	->
water	77:26	0:0	10	avctx
arg	77:33	77:45	9	AV_LOG_ERROR
water	77:33	0:0	10	AV_LOG_ERROR
arg	77:47	78:52	9	"invalid spectral extension ""copy start bin (%d >= %d)\n"
water	77:47	0:0	10	"invalid spectral extension "
water	78:23	0:0	10	"copy start bin (%d >= %d)\n"
arg	78:54	78:68	9	dst_start_freq
water	78:54	0:0	10	dst_start_freq
arg	78:70	78:84	9	src_start_freq
water	78:70	0:0	10	src_start_freq
water	78:85	0:0	8	;
return	79:16	79:42	8	AVERROR_INVALIDDATA
water	79:23	0:0	9	AVERROR_INVALIDDATA
water	80:12	0:0	8	}
water	81:12	0:0	6	s
op	81:13	0:0	6	->
water	81:15	0:0	6	spx_dst_start_freq
op	81:34	0:0	6	=
water	81:36	0:0	6	dst_start_freq
water	81:50	0:0	6	;
water	82:12	0:0	6	s
op	82:13	0:0	6	->
water	82:15	0:0	6	spx_src_start_freq
op	82:34	0:0	6	=
water	82:36	0:0	6	src_start_freq
water	82:50	0:0	6	;
if	83:12	84:52	6	(! USE_FIXED)
cond	83:16	83:17	7	! USE_FIXED
op	83:16	0:0	8	!
water	83:17	0:0	8	USE_FIXED
stmts	84:16	84:52	7	
water	84:16	0:0	8	s
op	84:17	0:0	8	->
water	84:19	0:0	8	spx_dst_end_freq
op	84:38	0:0	8	=
water	84:40	0:0	8	dst_end_freq
water	84:52	0:0	8	;
call	85:12	89:51	6	decode_band_structure
arg	85:34	85:37	7	gbc
water	85:34	0:0	8	gbc
arg	85:39	85:42	7	blk
water	85:39	0:0	8	blk
arg	85:44	85:51	7	s->eac3
water	85:44	0:0	8	s
op	85:45	0:0	8	->
water	85:47	0:0	8	eac3
arg	85:53	85:54	7	0
water	85:53	0:0	8	0
arg	86:34	86:47	7	start_subband
water	86:34	0:0	8	start_subband
arg	86:49	86:60	7	end_subband
water	86:49	0:0	8	end_subband
arg	87:34	87:65	7	ff_eac3_default_spx_band_struct
water	87:34	0:0	8	ff_eac3_default_spx_band_struct
arg	88:34	88:51	7	&s->num_spx_bands
op	88:34	0:0	8	&
water	88:35	0:0	8	s
op	88:36	0:0	8	->
water	88:38	0:0	8	num_spx_bands
arg	89:34	89:51	7	s->spx_band_sizes
water	89:34	0:0	8	s
op	89:35	0:0	8	->
water	89:37	0:0	8	spx_band_sizes
water	89:52	0:0	6	;
water	90:8	0:0	6	}
else	90:10	95:8	4
stmts	90:15	95:8	5	
water	90:15	0:0	6	{
for	91:12	94:12	6	(ch = 1 ;ch <= fbw_channels;ch ++)
forinit	91:17	91:23	7	ch = 1 ;
water	91:17	0:0	8	ch
op	91:20	0:0	8	=
water	91:22	0:0	8	1
water	91:23	0:0	8	;
cond	91:25	91:31	7	ch <= fbw_channels
water	91:25	0:0	8	ch
op	91:28	0:0	8	<=
water	91:31	0:0	8	fbw_channels
forexpr	91:45	91:47	7	ch ++
water	91:45	0:0	8	ch
op	91:47	0:0	8	++
stmts	91:51	94:12	7	
water	91:51	0:0	8	{
water	92:16	0:0	8	s
op	92:17	0:0	8	->
water	92:19	0:0	8	channel_uses_spx
op	92:35	0:0	8	[
water	92:36	0:0	8	ch
op	92:38	0:0	8	]
op	92:40	0:0	8	=
water	92:42	0:0	8	0
water	92:43	0:0	8	;
water	93:16	0:0	8	s
op	93:17	0:0	8	->
water	93:19	0:0	8	first_spx_coords
op	93:35	0:0	8	[
water	93:36	0:0	8	ch
op	93:38	0:0	8	]
op	93:40	0:0	8	=
water	93:42	0:0	8	1
water	93:43	0:0	8	;
water	94:12	0:0	8	}
water	95:8	0:0	6	}
water	96:4	0:0	4	}
if	98:4	163:4	2	(s -> spx_in_use)
cond	98:8	98:11	3	s -> spx_in_use
water	98:8	0:0	4	s
op	98:9	0:0	4	->
water	98:11	0:0	4	spx_in_use
stmts	98:23	163:4	3	
water	98:23	0:0	4	{
for	99:8	162:8	4	(ch = 1 ;ch <= fbw_channels;ch ++)
forinit	99:13	99:19	5	ch = 1 ;
water	99:13	0:0	6	ch
op	99:16	0:0	6	=
water	99:18	0:0	6	1
water	99:19	0:0	6	;
cond	99:21	99:27	5	ch <= fbw_channels
water	99:21	0:0	6	ch
op	99:24	0:0	6	<=
water	99:27	0:0	6	fbw_channels
forexpr	99:41	99:43	5	ch ++
water	99:41	0:0	6	ch
op	99:43	0:0	6	++
stmts	99:47	162:8	5	
water	99:47	0:0	6	{
if	100:12	159:12	6	(s -> channel_uses_spx [ ch ])
cond	100:16	100:38	7	s -> channel_uses_spx [ ch ]
water	100:16	0:0	8	s
op	100:17	0:0	8	->
water	100:19	0:0	8	channel_uses_spx
op	100:35	0:0	8	[
water	100:36	0:0	8	ch
op	100:38	0:0	8	]
stmts	100:41	159:12	7	
water	100:41	0:0	8	{
if	101:16	158:16	8	(s -> first_spx_coords [ ch ] ||get_bits1 (gbc ))
cond	101:20	101:60	9	s -> first_spx_coords [ ch ] ||get_bits1 (gbc )
water	101:20	0:0	10	s
op	101:21	0:0	10	->
water	101:23	0:0	10	first_spx_coords
op	101:39	0:0	10	[
water	101:40	0:0	10	ch
op	101:42	0:0	10	]
op	101:44	0:0	10	||
call	101:47	101:60	10	get_bits1
arg	101:57	101:60	11	gbc
water	101:57	0:0	12	gbc
stmts	101:63	158:16	9	
water	101:63	0:0	10	{
decl	102:20	102:38	10	INTFLOAT	spx_blend
decl	103:20	103:45	10	int	bin
water	103:27	0:0	10	,
decl	103:20	103:45	10	int	master_spx_coord
water	104:20	0:0	10	s
op	104:21	0:0	10	->
water	104:23	0:0	10	first_spx_coords
op	104:39	0:0	10	[
water	104:40	0:0	10	ch
op	104:42	0:0	10	]
op	104:44	0:0	10	=
water	104:46	0:0	10	0
water	104:47	0:0	10	;
water	105:20	0:0	10	spx_blend
op	105:30	0:0	10	=
call	105:32	105:62	10	AC3_SPX_BLEND
arg	105:46	105:62	11	get_bits(gbc,5)
call	105:46	105:61	12	get_bits
arg	105:55	105:58	13	gbc
water	105:55	0:0	14	gbc
arg	105:60	105:61	13	5
water	105:60	0:0	14	5
water	105:63	0:0	10	;
water	106:20	0:0	10	master_spx_coord
op	106:37	0:0	10	=
call	106:39	106:54	10	get_bits
arg	106:48	106:51	11	gbc
water	106:48	0:0	12	gbc
arg	106:53	106:54	11	2
water	106:53	0:0	12	2
op	106:56	0:0	10	*
water	106:58	0:0	10	3
water	106:59	0:0	10	;
water	107:20	0:0	10	bin
op	107:24	0:0	10	=
water	107:26	0:0	10	s
op	107:27	0:0	10	->
water	107:29	0:0	10	spx_src_start_freq
water	107:47	0:0	10	;
for	108:20	157:20	10	(bnd = 0 ;bnd < s -> num_spx_bands;bnd ++)
forinit	108:25	108:32	11	bnd = 0 ;
water	108:25	0:0	12	bnd
op	108:29	0:0	12	=
water	108:31	0:0	12	0
water	108:32	0:0	12	;
cond	108:34	108:43	11	bnd < s -> num_spx_bands
water	108:34	0:0	12	bnd
op	108:38	0:0	12	<
water	108:40	0:0	12	s
op	108:41	0:0	12	->
water	108:43	0:0	12	num_spx_bands
forexpr	108:58	108:61	11	bnd ++
water	108:58	0:0	12	bnd
op	108:61	0:0	12	++
stmts	108:65	157:20	11	
water	108:65	0:0	12	{
decl	109:24	109:61	12	int	bandsize
op	109:37	0:0	12	=
water	109:39	0:0	12	s
op	109:40	0:0	12	->
water	109:42	0:0	12	spx_band_sizes
op	109:56	0:0	12	[
water	109:57	0:0	12	bnd
op	109:60	0:0	12	]
decl	110:24	110:57	12	int	spx_coord_exp
water	110:41	0:0	12	,
decl	110:24	110:57	12	int	spx_coord_mant
decl	111:24	111:55	12	INTFLOAT	nratio
water	111:39	0:0	12	,
decl	111:24	111:55	12	INTFLOAT	sblend
water	111:47	0:0	12	,
decl	111:24	111:55	12	INTFLOAT	nblend
decl	114:24	115:67	12	int64_t	accu
op	114:37	0:0	12	=
water	114:39	0:0	12	(
water	114:40	0:0	12	(
water	114:41	0:0	12	bin
op	114:45	0:0	12	<<
water	114:48	0:0	12	23
water	114:50	0:0	12	)
op	114:52	0:0	12	+
water	114:54	0:0	12	(
water	114:55	0:0	12	bandsize
op	114:64	0:0	12	<<
water	114:67	0:0	12	22
water	114:69	0:0	12	)
water	114:70	0:0	12	)
op	115:37	0:0	12	*
water	115:39	0:0	12	(
water	115:40	0:0	12	int64_t
water	115:47	0:0	12	)
water	115:48	0:0	12	s
op	115:49	0:0	12	->
water	115:51	0:0	12	spx_dst_end_freq
water	116:24	0:0	12	nratio
op	116:31	0:0	12	=
call	116:33	116:49	12	(int)
arg	116:39	116:49	13	accu>>32
water	116:39	0:0	14	accu
op	116:44	0:0	14	>>
water	116:47	0:0	14	32
water	116:50	0:0	12	;
water	117:24	0:0	12	nratio
op	117:31	0:0	12	-=
water	117:34	0:0	12	spx_blend
op	117:44	0:0	12	<<
water	117:47	0:0	12	18
water	117:49	0:0	12	;
if	118:24	121:24	12	(nratio < 0)
cond	118:28	118:37	13	nratio < 0
water	118:28	0:0	14	nratio
op	118:35	0:0	14	<
water	118:37	0:0	14	0
stmts	118:40	121:24	13	
water	118:40	0:0	14	{
water	119:28	0:0	14	nblend
op	119:35	0:0	14	=
water	119:37	0:0	14	0
water	119:38	0:0	14	;
water	120:28	0:0	14	sblend
op	120:35	0:0	14	=
water	120:37	0:0	14	0
water	120:38	0:0	14	x800000
water	120:45	0:0	14	;
water	121:24	0:0	14	}
else	121:26	124:24	12
stmts	121:31	124:24	13	
if	121:31	124:24	14	(nratio > 0 x7fffff)
cond	121:35	121:45	15	nratio > 0 x7fffff
water	121:35	0:0	16	nratio
op	121:42	0:0	16	>
water	121:44	0:0	16	0
water	121:45	0:0	16	x7fffff
stmts	121:54	124:24	15	
water	121:54	0:0	16	{
water	122:28	0:0	16	nblend
op	122:35	0:0	16	=
water	122:37	0:0	16	14529495
water	122:45	0:0	16	;
water	123:28	0:0	16	sblend
op	123:35	0:0	16	=
water	123:37	0:0	16	0
water	123:38	0:0	16	;
water	124:24	0:0	16	}
else	124:26	129:24	12
stmts	124:31	129:24	13	
water	124:31	0:0	14	{
water	125:28	0:0	14	nblend
op	125:35	0:0	14	=
call	125:37	125:58	14	fixed_sqrt
arg	125:48	125:54	15	nratio
water	125:48	0:0	16	nratio
arg	125:56	125:58	15	23
water	125:56	0:0	16	23
water	125:59	0:0	14	;
water	126:28	0:0	14	accu
op	126:33	0:0	14	=
water	126:35	0:0	14	(
water	126:36	0:0	14	int64_t
water	126:43	0:0	14	)
water	126:44	0:0	14	nblend
op	126:51	0:0	14	*
water	126:53	0:0	14	1859775393
water	126:63	0:0	14	;
water	127:28	0:0	14	nblend
op	127:35	0:0	14	=
call	127:37	127:65	14	(int)
arg	127:43	127:65	15	(accu+(1<<29))>>30
water	127:43	0:0	16	(
water	127:44	0:0	16	accu
op	127:49	0:0	16	+
water	127:51	0:0	16	(
water	127:52	0:0	16	1
op	127:53	0:0	16	<<
water	127:55	0:0	16	29
water	127:57	0:0	16	)
water	127:58	0:0	16	)
op	127:60	0:0	16	>>
water	127:63	0:0	16	30
water	127:66	0:0	14	;
water	128:28	0:0	14	sblend
op	128:35	0:0	14	=
call	128:37	128:69	14	fixed_sqrt
arg	128:48	128:65	15	0x800000-nratio
water	128:48	0:0	16	0
water	128:49	0:0	16	x800000
op	128:57	0:0	16	-
water	128:59	0:0	16	nratio
arg	128:67	128:69	15	23
water	128:67	0:0	16	23
water	128:70	0:0	14	;
water	129:24	0:0	14	}
decl	131:24	131:39	12	float	spx_coord
water	133:24	0:0	12	nratio
op	133:31	0:0	12	=
water	133:33	0:0	12	(
call	133:34	133:65	12	(float)
arg	133:42	133:65	13	(bin+(bandsize>>1))
water	133:42	0:0	14	(
water	133:43	0:0	14	bin
op	133:47	0:0	14	+
water	133:49	0:0	14	(
water	133:50	0:0	14	bandsize
op	133:59	0:0	14	>>
water	133:62	0:0	14	1
water	133:63	0:0	14	)
water	133:64	0:0	14	)
op	133:67	0:0	12	/
water	133:69	0:0	12	s
op	133:70	0:0	12	->
water	133:72	0:0	12	spx_dst_end_freq
water	133:88	0:0	12	)
op	133:90	0:0	12	-
water	133:92	0:0	12	spx_blend
water	133:101	0:0	12	;
water	134:24	0:0	12	nratio
op	134:31	0:0	12	=
call	134:33	134:60	12	av_clipf
arg	134:42	134:48	13	nratio
water	134:42	0:0	14	nratio
arg	134:50	134:54	13	0.0f
water	134:50	0:0	14	0
op	134:51	0:0	14	.
water	134:52	0:0	14	0
water	134:53	0:0	14	f
arg	134:56	134:60	13	1.0f
water	134:56	0:0	14	1
op	134:57	0:0	14	.
water	134:58	0:0	14	0
water	134:59	0:0	14	f
water	134:61	0:0	12	;
water	135:24	0:0	12	nblend
op	135:31	0:0	12	=
call	135:33	135:52	12	sqrtf
arg	135:39	135:52	13	3.0f*nratio
water	135:39	0:0	14	3
op	135:40	0:0	14	.
water	135:41	0:0	14	0
water	135:42	0:0	14	f
op	135:44	0:0	14	*
water	135:46	0:0	14	nratio
water	135:53	0:0	12	;
water	137:24	0:0	12	sblend
op	137:31	0:0	12	=
call	137:33	137:52	12	sqrtf
arg	137:39	137:52	13	1.0f-nratio
water	137:39	0:0	14	1
op	137:40	0:0	14	.
water	137:41	0:0	14	0
water	137:42	0:0	14	f
op	137:44	0:0	14	-
water	137:46	0:0	14	nratio
water	137:53	0:0	12	;
water	139:24	0:0	12	bin
op	139:28	0:0	12	+=
water	139:31	0:0	12	bandsize
water	139:39	0:0	12	;
water	141:24	0:0	12	spx_coord_exp
op	141:39	0:0	12	=
call	141:41	141:56	12	get_bits
arg	141:50	141:53	13	gbc
water	141:50	0:0	14	gbc
arg	141:55	141:56	13	4
water	141:55	0:0	14	4
water	141:57	0:0	12	;
water	142:24	0:0	12	spx_coord_mant
op	142:39	0:0	12	=
call	142:41	142:56	12	get_bits
arg	142:50	142:53	13	gbc
water	142:50	0:0	14	gbc
arg	142:55	142:56	13	2
water	142:55	0:0	14	2
water	142:57	0:0	12	;
if	143:24	143:69	12	(spx_coord_exp == 15)
cond	143:28	143:45	13	spx_coord_exp == 15
water	143:28	0:0	14	spx_coord_exp
op	143:42	0:0	14	==
water	143:45	0:0	14	15
stmts	143:49	143:69	13	
water	143:49	0:0	14	spx_coord_mant
op	143:64	0:0	14	<<=
water	143:68	0:0	14	1
water	143:69	0:0	14	;
else	144:24	144:68	12
stmts	144:49	144:68	13	
water	144:49	0:0	14	spx_coord_mant
op	144:64	0:0	14	+=
water	144:67	0:0	14	4
water	144:68	0:0	14	;
water	145:24	0:0	12	spx_coord_mant
op	145:39	0:0	12	<<=
water	145:43	0:0	12	(
water	145:44	0:0	12	25
op	145:47	0:0	12	-
water	145:49	0:0	12	spx_coord_exp
op	145:63	0:0	12	-
water	145:65	0:0	12	master_spx_coord
water	145:81	0:0	12	)
water	145:82	0:0	12	;
water	148:24	0:0	12	accu
op	148:29	0:0	12	=
water	148:31	0:0	12	(
water	148:32	0:0	12	int64_t
water	148:39	0:0	12	)
water	148:40	0:0	12	nblend
op	148:47	0:0	12	*
water	148:49	0:0	12	spx_coord_mant
water	148:63	0:0	12	;
water	149:24	0:0	12	s
op	149:25	0:0	12	->
water	149:27	0:0	12	spx_noise_blend
op	149:42	0:0	12	[
water	149:43	0:0	12	ch
op	149:45	0:0	12	]
op	149:46	0:0	12	[
water	149:47	0:0	12	bnd
op	149:50	0:0	12	]
op	149:53	0:0	12	=
call	149:55	149:83	12	(int)
arg	149:61	149:83	13	(accu+(1<<22))>>23
water	149:61	0:0	14	(
water	149:62	0:0	14	accu
op	149:67	0:0	14	+
water	149:69	0:0	14	(
water	149:70	0:0	14	1
op	149:71	0:0	14	<<
water	149:73	0:0	14	22
water	149:75	0:0	14	)
water	149:76	0:0	14	)
op	149:78	0:0	14	>>
water	149:81	0:0	14	23
water	149:84	0:0	12	;
water	150:24	0:0	12	accu
op	150:29	0:0	12	=
water	150:31	0:0	12	(
water	150:32	0:0	12	int64_t
water	150:39	0:0	12	)
water	150:40	0:0	12	sblend
op	150:47	0:0	12	*
water	150:49	0:0	12	spx_coord_mant
water	150:63	0:0	12	;
water	151:24	0:0	12	s
op	151:25	0:0	12	->
water	151:27	0:0	12	spx_signal_blend
op	151:43	0:0	12	[
water	151:44	0:0	12	ch
op	151:46	0:0	12	]
op	151:47	0:0	12	[
water	151:48	0:0	12	bnd
op	151:51	0:0	12	]
op	151:53	0:0	12	=
call	151:55	151:83	12	(int)
arg	151:61	151:83	13	(accu+(1<<22))>>23
water	151:61	0:0	14	(
water	151:62	0:0	14	accu
op	151:67	0:0	14	+
water	151:69	0:0	14	(
water	151:70	0:0	14	1
op	151:71	0:0	14	<<
water	151:73	0:0	14	22
water	151:75	0:0	14	)
water	151:76	0:0	14	)
op	151:78	0:0	14	>>
water	151:81	0:0	14	23
water	151:84	0:0	12	;
water	153:24	0:0	12	spx_coord
op	153:34	0:0	12	=
water	153:36	0:0	12	spx_coord_mant
op	153:51	0:0	12	*
water	153:53	0:0	12	(
water	153:54	0:0	12	1
op	153:55	0:0	12	.
water	153:56	0:0	12	0
water	153:57	0:0	12	f
op	153:59	0:0	12	/
water	153:61	0:0	12	(
water	153:62	0:0	12	1
op	153:64	0:0	12	<<
water	153:67	0:0	12	23
water	153:69	0:0	12	)
water	153:70	0:0	12	)
water	153:71	0:0	12	;
water	154:24	0:0	12	s
op	154:25	0:0	12	->
water	154:27	0:0	12	spx_noise_blend
op	154:43	0:0	12	[
water	154:44	0:0	12	ch
op	154:46	0:0	12	]
op	154:47	0:0	12	[
water	154:48	0:0	12	bnd
op	154:51	0:0	12	]
op	154:53	0:0	12	=
water	154:55	0:0	12	nblend
op	154:62	0:0	12	*
water	154:64	0:0	12	spx_coord
water	154:73	0:0	12	;
water	155:24	0:0	12	s
op	155:25	0:0	12	->
water	155:27	0:0	12	spx_signal_blend
op	155:43	0:0	12	[
water	155:44	0:0	12	ch
op	155:46	0:0	12	]
op	155:47	0:0	12	[
water	155:48	0:0	12	bnd
op	155:51	0:0	12	]
op	155:53	0:0	12	=
water	155:55	0:0	12	sblend
op	155:62	0:0	12	*
water	155:64	0:0	12	spx_coord
water	155:73	0:0	12	;
water	157:20	0:0	12	}
water	158:16	0:0	10	}
water	159:12	0:0	8	}
else	159:14	161:12	6
stmts	159:19	161:12	7	
water	159:19	0:0	8	{
water	160:16	0:0	8	s
op	160:17	0:0	8	->
water	160:19	0:0	8	first_spx_coords
op	160:35	0:0	8	[
water	160:36	0:0	8	ch
op	160:38	0:0	8	]
op	160:40	0:0	8	=
water	160:42	0:0	8	1
water	160:43	0:0	8	;
water	161:12	0:0	8	}
water	162:8	0:0	6	}
water	163:4	0:0	4	}
if	165:4	217:4	2	(s -> eac3 ? s -> cpl_strategy_exists [ blk ] :get_bits1 (gbc ))
cond	165:8	165:61	3	s -> eac3 ? s -> cpl_strategy_exists [ blk ] :get_bits1 (gbc )
water	165:8	0:0	4	s
op	165:9	0:0	4	->
water	165:11	0:0	4	eac3
water	165:16	0:0	4	?
water	165:18	0:0	4	s
op	165:19	0:0	4	->
water	165:21	0:0	4	cpl_strategy_exists
op	165:40	0:0	4	[
water	165:41	0:0	4	blk
op	165:44	0:0	4	]
water	165:46	0:0	4	:
call	165:48	165:61	4	get_bits1
arg	165:58	165:61	5	gbc
water	165:58	0:0	6	gbc
stmts	165:64	217:4	3	
water	165:64	0:0	4	{
call	166:8	166:52	4	memset
arg	166:15	166:31	5	bit_alloc_stages
water	166:15	0:0	6	bit_alloc_stages
arg	166:33	166:34	5	3
water	166:33	0:0	6	3
arg	166:36	166:52	5	AC3_MAX_CHANNELS
water	166:36	0:0	6	AC3_MAX_CHANNELS
water	166:53	0:0	4	;
if	167:8	168:47	4	(! s -> eac3)
cond	167:12	167:16	5	! s -> eac3
op	167:12	0:0	6	!
water	167:13	0:0	6	s
op	167:14	0:0	6	->
water	167:16	0:0	6	eac3
stmts	168:12	168:47	5	
water	168:12	0:0	6	s
op	168:13	0:0	6	->
water	168:15	0:0	6	cpl_in_use
op	168:25	0:0	6	[
water	168:26	0:0	6	blk
op	168:29	0:0	6	]
op	168:31	0:0	6	=
call	168:33	168:46	6	get_bits1
arg	168:43	168:46	7	gbc
water	168:43	0:0	8	gbc
water	168:47	0:0	6	;
if	169:8	208:8	4	(s -> cpl_in_use [ blk ])
cond	169:12	169:29	5	s -> cpl_in_use [ blk ]
water	169:12	0:0	6	s
op	169:13	0:0	6	->
water	169:15	0:0	6	cpl_in_use
op	169:25	0:0	6	[
water	169:26	0:0	6	blk
op	169:29	0:0	6	]
stmts	169:32	208:8	5	
water	169:32	0:0	6	{
decl	171:12	171:50	6	int	cpl_start_subband
water	171:33	0:0	6	,
decl	171:12	171:50	6	int	cpl_end_subband
if	172:12	175:12	6	(channel_mode < AC3_CHMODE_STEREO)
cond	172:16	172:31	7	channel_mode < AC3_CHMODE_STEREO
water	172:16	0:0	8	channel_mode
op	172:29	0:0	8	<
water	172:31	0:0	8	AC3_CHMODE_STEREO
stmts	172:50	175:12	7	
water	172:50	0:0	8	{
call	173:16	173:92	8	av_log
arg	173:23	173:31	9	s->avctx
water	173:23	0:0	10	s
op	173:24	0:0	10	->
water	173:26	0:0	10	avctx
arg	173:33	173:45	9	AV_LOG_ERROR
water	173:33	0:0	10	AV_LOG_ERROR
arg	173:47	173:92	9	"coupling not allowed in mono or dual-mono\n"
water	173:47	0:0	10	"coupling not allowed in mono or dual-mono\n"
water	173:93	0:0	8	;
return	174:16	174:42	8	AVERROR_INVALIDDATA
water	174:23	0:0	9	AVERROR_INVALIDDATA
water	175:12	0:0	8	}
if	177:12	181:12	6	(s -> eac3 &&get_bits1 (gbc ))
cond	177:16	177:40	7	s -> eac3 &&get_bits1 (gbc )
water	177:16	0:0	8	s
op	177:17	0:0	8	->
water	177:19	0:0	8	eac3
op	177:24	0:0	8	&&
call	177:27	177:40	8	get_bits1
arg	177:37	177:40	9	gbc
water	177:37	0:0	10	gbc
stmts	177:43	181:12	7	
water	177:43	0:0	8	{
call	179:16	179:67	8	avpriv_request_sample
arg	179:38	179:46	9	s->avctx
water	179:38	0:0	10	s
op	179:39	0:0	10	->
water	179:41	0:0	10	avctx
arg	179:48	179:67	9	"Enhanced coupling"
water	179:48	0:0	10	"Enhanced coupling"
water	179:68	0:0	8	;
return	180:16	180:43	8	AVERROR_PATCHWELCOME
water	180:23	0:0	9	AVERROR_PATCHWELCOME
water	181:12	0:0	8	}
if	183:12	186:12	6	(s -> eac3 && s -> channel_mode == AC3_CHMODE_STEREO)
cond	183:16	183:46	7	s -> eac3 && s -> channel_mode == AC3_CHMODE_STEREO
water	183:16	0:0	8	s
op	183:17	0:0	8	->
water	183:19	0:0	8	eac3
op	183:24	0:0	8	&&
water	183:27	0:0	8	s
op	183:28	0:0	8	->
water	183:30	0:0	8	channel_mode
op	183:43	0:0	8	==
water	183:46	0:0	8	AC3_CHMODE_STEREO
stmts	183:65	186:12	7	
water	183:65	0:0	8	{
water	184:16	0:0	8	s
op	184:17	0:0	8	->
water	184:19	0:0	8	channel_in_cpl
op	184:33	0:0	8	[
water	184:34	0:0	8	1
op	184:35	0:0	8	]
op	184:37	0:0	8	=
water	184:39	0:0	8	1
water	184:40	0:0	8	;
water	185:16	0:0	8	s
op	185:17	0:0	8	->
water	185:19	0:0	8	channel_in_cpl
op	185:33	0:0	8	[
water	185:34	0:0	8	2
op	185:35	0:0	8	]
op	185:37	0:0	8	=
water	185:39	0:0	8	1
water	185:40	0:0	8	;
water	186:12	0:0	8	}
else	186:14	189:12	6
stmts	186:19	189:12	7	
water	186:19	0:0	8	{
for	187:16	188:58	8	(ch = 1 ;ch <= fbw_channels;ch ++)
forinit	187:21	187:27	9	ch = 1 ;
water	187:21	0:0	10	ch
op	187:24	0:0	10	=
water	187:26	0:0	10	1
water	187:27	0:0	10	;
cond	187:29	187:35	9	ch <= fbw_channels
water	187:29	0:0	10	ch
op	187:32	0:0	10	<=
water	187:35	0:0	10	fbw_channels
forexpr	187:49	187:51	9	ch ++
water	187:49	0:0	10	ch
op	187:51	0:0	10	++
stmts	188:20	188:58	9	
water	188:20	0:0	10	s
op	188:21	0:0	10	->
water	188:23	0:0	10	channel_in_cpl
op	188:37	0:0	10	[
water	188:38	0:0	10	ch
op	188:40	0:0	10	]
op	188:42	0:0	10	=
call	188:44	188:57	10	get_bits1
arg	188:54	188:57	11	gbc
water	188:54	0:0	12	gbc
water	188:58	0:0	10	;
water	189:12	0:0	8	}
if	191:12	192:54	6	(channel_mode == AC3_CHMODE_STEREO)
cond	191:16	191:32	7	channel_mode == AC3_CHMODE_STEREO
water	191:16	0:0	8	channel_mode
op	191:29	0:0	8	==
water	191:32	0:0	8	AC3_CHMODE_STEREO
stmts	192:16	192:54	7	
water	192:16	0:0	8	s
op	192:17	0:0	8	->
water	192:19	0:0	8	phase_flags_in_use
op	192:38	0:0	8	=
call	192:40	192:53	8	get_bits1
arg	192:50	192:53	9	gbc
water	192:50	0:0	10	gbc
water	192:54	0:0	8	;
water	194:12	0:0	6	cpl_start_subband
op	194:30	0:0	6	=
call	194:32	194:47	6	get_bits
arg	194:41	194:44	7	gbc
water	194:41	0:0	8	gbc
arg	194:46	194:47	7	4
water	194:46	0:0	8	4
water	194:48	0:0	6	;
water	195:12	0:0	6	cpl_end_subband
op	195:28	0:0	6	=
water	195:30	0:0	6	s
op	195:31	0:0	6	->
water	195:33	0:0	6	spx_in_use
water	195:44	0:0	6	?
water	195:46	0:0	6	(
water	195:47	0:0	6	s
op	195:48	0:0	6	->
water	195:50	0:0	6	spx_src_start_freq
op	195:69	0:0	6	-
water	195:71	0:0	6	37
water	195:73	0:0	6	)
op	195:75	0:0	6	/
water	195:77	0:0	6	12
water	195:80	0:0	6	:
call	196:46	196:61	6	get_bits
arg	196:55	196:58	7	gbc
water	196:55	0:0	8	gbc
arg	196:60	196:61	7	4
water	196:60	0:0	8	4
op	196:63	0:0	6	+
water	196:65	0:0	6	3
water	196:66	0:0	6	;
if	197:12	201:12	6	(cpl_start_subband >= cpl_end_subband)
cond	197:16	197:37	7	cpl_start_subband >= cpl_end_subband
water	197:16	0:0	8	cpl_start_subband
op	197:34	0:0	8	>=
water	197:37	0:0	8	cpl_end_subband
stmts	197:54	201:12	7	
water	197:54	0:0	8	{
call	198:16	199:57	8	av_log
arg	198:23	198:31	9	s->avctx
water	198:23	0:0	10	s
op	198:24	0:0	10	->
water	198:26	0:0	10	avctx
arg	198:33	198:45	9	AV_LOG_ERROR
water	198:33	0:0	10	AV_LOG_ERROR
arg	198:47	198:84	9	"invalid coupling range (%d >= %d)\n"
water	198:47	0:0	10	"invalid coupling range (%d >= %d)\n"
arg	199:23	199:40	9	cpl_start_subband
water	199:23	0:0	10	cpl_start_subband
arg	199:42	199:57	9	cpl_end_subband
water	199:42	0:0	10	cpl_end_subband
water	199:58	0:0	8	;
return	200:16	200:42	8	AVERROR_INVALIDDATA
water	200:23	0:0	9	AVERROR_INVALIDDATA
water	201:12	0:0	8	}
water	202:12	0:0	6	s
op	202:13	0:0	6	->
water	202:15	0:0	6	start_freq
op	202:25	0:0	6	[
water	202:26	0:0	6	CPL_CH
op	202:32	0:0	6	]
op	202:34	0:0	6	=
water	202:36	0:0	6	cpl_start_subband
op	202:54	0:0	6	*
water	202:56	0:0	6	12
op	202:59	0:0	6	+
water	202:61	0:0	6	37
water	202:63	0:0	6	;
water	203:12	0:0	6	s
op	203:13	0:0	6	->
water	203:15	0:0	6	end_freq
op	203:23	0:0	6	[
water	203:24	0:0	6	CPL_CH
op	203:30	0:0	6	]
op	203:34	0:0	6	=
water	203:36	0:0	6	cpl_end_subband
op	203:54	0:0	6	*
water	203:56	0:0	6	12
op	203:59	0:0	6	+
water	203:61	0:0	6	37
water	203:63	0:0	6	;
call	204:12	207:70	6	decode_band_structure
arg	204:34	204:37	7	gbc
water	204:34	0:0	8	gbc
arg	204:39	204:42	7	blk
water	204:39	0:0	8	blk
arg	204:44	204:51	7	s->eac3
water	204:44	0:0	8	s
op	204:45	0:0	8	->
water	204:47	0:0	8	eac3
arg	204:53	204:54	7	0
water	204:53	0:0	8	0
arg	204:56	204:73	7	cpl_start_subband
water	204:56	0:0	8	cpl_start_subband
arg	205:34	205:49	7	cpl_end_subband
water	205:34	0:0	8	cpl_end_subband
arg	206:34	206:65	7	ff_eac3_default_cpl_band_struct
water	206:34	0:0	8	ff_eac3_default_cpl_band_struct
arg	207:34	207:51	7	&s->num_cpl_bands
op	207:34	0:0	8	&
water	207:35	0:0	8	s
op	207:36	0:0	8	->
water	207:38	0:0	8	num_cpl_bands
arg	207:53	207:70	7	s->cpl_band_sizes
water	207:53	0:0	8	s
op	207:54	0:0	8	->
water	207:56	0:0	8	cpl_band_sizes
water	207:71	0:0	6	;
water	208:8	0:0	6	}
else	208:10	216:8	4
stmts	208:15	216:8	5	
water	208:15	0:0	6	{
for	210:12	213:12	6	(ch = 1 ;ch <= fbw_channels;ch ++)
forinit	210:17	210:23	7	ch = 1 ;
water	210:17	0:0	8	ch
op	210:20	0:0	8	=
water	210:22	0:0	8	1
water	210:23	0:0	8	;
cond	210:25	210:31	7	ch <= fbw_channels
water	210:25	0:0	8	ch
op	210:28	0:0	8	<=
water	210:31	0:0	8	fbw_channels
forexpr	210:45	210:47	7	ch ++
water	210:45	0:0	8	ch
op	210:47	0:0	8	++
stmts	210:51	213:12	7	
water	210:51	0:0	8	{
water	211:16	0:0	8	s
op	211:17	0:0	8	->
water	211:19	0:0	8	channel_in_cpl
op	211:33	0:0	8	[
water	211:34	0:0	8	ch
op	211:36	0:0	8	]
op	211:38	0:0	8	=
water	211:40	0:0	8	0
water	211:41	0:0	8	;
water	212:16	0:0	8	s
op	212:17	0:0	8	->
water	212:19	0:0	8	first_cpl_coords
op	212:35	0:0	8	[
water	212:36	0:0	8	ch
op	212:38	0:0	8	]
op	212:40	0:0	8	=
water	212:42	0:0	8	1
water	212:43	0:0	8	;
water	213:12	0:0	8	}
water	214:12	0:0	6	s
op	214:13	0:0	6	->
water	214:15	0:0	6	first_cpl_leak
op	214:30	0:0	6	=
water	214:32	0:0	6	s
op	214:33	0:0	6	->
water	214:35	0:0	6	eac3
water	214:39	0:0	6	;
water	215:12	0:0	6	s
op	215:13	0:0	6	->
water	215:15	0:0	6	phase_flags_in_use
op	215:34	0:0	6	=
water	215:36	0:0	6	0
water	215:37	0:0	6	;
water	216:8	0:0	6	}
water	217:4	0:0	4	}
else	217:6	225:4	2
stmts	217:11	225:4	3	
if	217:11	225:4	4	(! s -> eac3)
cond	217:15	217:19	5	! s -> eac3
op	217:15	0:0	6	!
water	217:16	0:0	6	s
op	217:17	0:0	6	->
water	217:19	0:0	6	eac3
stmts	217:25	225:4	5	
water	217:25	0:0	6	{
if	218:8	222:8	6	(! blk)
cond	218:12	218:13	7	! blk
op	218:12	0:0	8	!
water	218:13	0:0	8	blk
stmts	218:18	222:8	7	
water	218:18	0:0	8	{
call	219:12	220:44	8	av_log
arg	219:19	219:27	9	s->avctx
water	219:19	0:0	10	s
op	219:20	0:0	10	->
water	219:22	0:0	10	avctx
arg	219:29	219:41	9	AV_LOG_ERROR
water	219:29	0:0	10	AV_LOG_ERROR
arg	219:43	220:44	9	"new coupling strategy must ""be present in block 0\n"
water	219:43	0:0	10	"new coupling strategy must "
water	220:19	0:0	10	"be present in block 0\n"
water	220:45	0:0	8	;
return	221:12	221:38	8	AVERROR_INVALIDDATA
water	221:19	0:0	9	AVERROR_INVALIDDATA
water	222:8	0:0	8	}
else	222:10	224:8	6
stmts	222:15	224:8	7	
water	222:15	0:0	8	{
water	223:12	0:0	8	s
op	223:13	0:0	8	->
water	223:15	0:0	8	cpl_in_use
op	223:25	0:0	8	[
water	223:26	0:0	8	blk
op	223:29	0:0	8	]
op	223:31	0:0	8	=
water	223:33	0:0	8	s
op	223:34	0:0	8	->
water	223:36	0:0	8	cpl_in_use
op	223:46	0:0	8	[
water	223:47	0:0	8	blk
op	223:50	0:0	8	-
water	223:51	0:0	8	1
op	223:52	0:0	8	]
water	223:53	0:0	8	;
water	224:8	0:0	8	}
water	225:4	0:0	6	}
water	226:4	0:0	2	cpl_in_use
op	226:15	0:0	2	=
water	226:17	0:0	2	s
op	226:18	0:0	2	->
water	226:20	0:0	2	cpl_in_use
op	226:30	0:0	2	[
water	226:31	0:0	2	blk
op	226:34	0:0	2	]
water	226:35	0:0	2	;
if	228:4	262:4	2	(cpl_in_use)
cond	228:8	228:8	3	cpl_in_use
water	228:8	0:0	4	cpl_in_use
stmts	228:20	262:4	3	
water	228:20	0:0	4	{
decl	229:8	229:32	4	int	cpl_coords_exist
op	229:29	0:0	4	=
water	229:31	0:0	4	0
for	230:8	255:8	4	(ch = 1 ;ch <= fbw_channels;ch ++)
forinit	230:13	230:19	5	ch = 1 ;
water	230:13	0:0	6	ch
op	230:16	0:0	6	=
water	230:18	0:0	6	1
water	230:19	0:0	6	;
cond	230:21	230:27	5	ch <= fbw_channels
water	230:21	0:0	6	ch
op	230:24	0:0	6	<=
water	230:27	0:0	6	fbw_channels
forexpr	230:41	230:43	5	ch ++
water	230:41	0:0	6	ch
op	230:43	0:0	6	++
stmts	230:47	255:8	5	
water	230:47	0:0	6	{
if	231:12	251:12	6	(s -> channel_in_cpl [ ch ])
cond	231:16	231:36	7	s -> channel_in_cpl [ ch ]
water	231:16	0:0	8	s
op	231:17	0:0	8	->
water	231:19	0:0	8	channel_in_cpl
op	231:33	0:0	8	[
water	231:34	0:0	8	ch
op	231:36	0:0	8	]
stmts	231:39	251:12	7	
water	231:39	0:0	8	{
if	232:16	246:16	8	(( s -> eac3 && s -> first_cpl_coords [ ch ] ) ||get_bits1 (gbc ))
cond	232:20	232:73	9	( s -> eac3 && s -> first_cpl_coords [ ch ] ) ||get_bits1 (gbc )
water	232:20	0:0	10	(
water	232:21	0:0	10	s
op	232:22	0:0	10	->
water	232:24	0:0	10	eac3
op	232:29	0:0	10	&&
water	232:32	0:0	10	s
op	232:33	0:0	10	->
water	232:35	0:0	10	first_cpl_coords
op	232:51	0:0	10	[
water	232:52	0:0	10	ch
op	232:54	0:0	10	]
water	232:55	0:0	10	)
op	232:57	0:0	10	||
call	232:60	232:73	10	get_bits1
arg	232:70	232:73	11	gbc
water	232:70	0:0	12	gbc
stmts	232:76	246:16	9	
water	232:76	0:0	10	{
decl	233:20	233:71	10	int	master_cpl_coord
water	233:40	0:0	10	,
decl	233:20	233:71	10	int	cpl_coord_exp
water	233:55	0:0	10	,
decl	233:20	233:71	10	int	cpl_coord_mant
water	234:20	0:0	10	s
op	234:21	0:0	10	->
water	234:23	0:0	10	first_cpl_coords
op	234:39	0:0	10	[
water	234:40	0:0	10	ch
op	234:42	0:0	10	]
op	234:44	0:0	10	=
water	234:46	0:0	10	0
water	234:47	0:0	10	;
water	235:20	0:0	10	cpl_coords_exist
op	235:37	0:0	10	=
water	235:39	0:0	10	1
water	235:40	0:0	10	;
water	236:20	0:0	10	master_cpl_coord
op	236:37	0:0	10	=
water	236:39	0:0	10	3
call	236:41	236:58	10	*get_bits
arg	236:52	236:55	11	gbc
water	236:52	0:0	12	gbc
arg	236:57	236:58	11	2
water	236:57	0:0	12	2
water	236:59	0:0	10	;
for	237:20	245:20	10	(bnd = 0 ;bnd < s -> num_cpl_bands;bnd ++)
forinit	237:25	237:32	11	bnd = 0 ;
water	237:25	0:0	12	bnd
op	237:29	0:0	12	=
water	237:31	0:0	12	0
water	237:32	0:0	12	;
cond	237:34	237:43	11	bnd < s -> num_cpl_bands
water	237:34	0:0	12	bnd
op	237:38	0:0	12	<
water	237:40	0:0	12	s
op	237:41	0:0	12	->
water	237:43	0:0	12	num_cpl_bands
forexpr	237:58	237:61	11	bnd ++
water	237:58	0:0	12	bnd
op	237:61	0:0	12	++
stmts	237:65	245:20	11	
water	237:65	0:0	12	{
water	238:24	0:0	12	cpl_coord_exp
op	238:38	0:0	12	=
call	238:40	238:55	12	get_bits
arg	238:49	238:52	13	gbc
water	238:49	0:0	14	gbc
arg	238:54	238:55	13	4
water	238:54	0:0	14	4
water	238:56	0:0	12	;
water	239:24	0:0	12	cpl_coord_mant
op	239:39	0:0	12	=
call	239:41	239:56	12	get_bits
arg	239:50	239:53	13	gbc
water	239:50	0:0	14	gbc
arg	239:55	239:56	13	4
water	239:55	0:0	14	4
water	239:57	0:0	12	;
if	240:24	241:73	12	(cpl_coord_exp == 15)
cond	240:28	240:45	13	cpl_coord_exp == 15
water	240:28	0:0	14	cpl_coord_exp
op	240:42	0:0	14	==
water	240:45	0:0	14	15
stmts	241:28	241:73	13	
water	241:28	0:0	14	s
op	241:29	0:0	14	->
water	241:31	0:0	14	cpl_coords
op	241:41	0:0	14	[
water	241:42	0:0	14	ch
op	241:44	0:0	14	]
op	241:45	0:0	14	[
water	241:46	0:0	14	bnd
op	241:49	0:0	14	]
op	241:51	0:0	14	=
water	241:53	0:0	14	cpl_coord_mant
op	241:68	0:0	14	<<
water	241:71	0:0	14	22
water	241:73	0:0	14	;
else	242:24	243:80	12
stmts	243:28	243:80	13	
water	243:28	0:0	14	s
op	243:29	0:0	14	->
water	243:31	0:0	14	cpl_coords
op	243:41	0:0	14	[
water	243:42	0:0	14	ch
op	243:44	0:0	14	]
op	243:45	0:0	14	[
water	243:46	0:0	14	bnd
op	243:49	0:0	14	]
op	243:51	0:0	14	=
water	243:53	0:0	14	(
water	243:54	0:0	14	cpl_coord_mant
op	243:69	0:0	14	+
water	243:71	0:0	14	16
water	243:73	0:0	14	)
op	243:75	0:0	14	<<
water	243:78	0:0	14	21
water	243:80	0:0	14	;
water	244:24	0:0	12	s
op	244:25	0:0	12	->
water	244:27	0:0	12	cpl_coords
op	244:37	0:0	12	[
water	244:38	0:0	12	ch
op	244:40	0:0	12	]
op	244:41	0:0	12	[
water	244:42	0:0	12	bnd
op	244:45	0:0	12	]
op	244:47	0:0	12	>>=
water	244:51	0:0	12	(
water	244:52	0:0	12	cpl_coord_exp
op	244:66	0:0	12	+
water	244:68	0:0	12	master_cpl_coord
water	244:84	0:0	12	)
water	244:85	0:0	12	;
water	245:20	0:0	12	}
water	246:16	0:0	10	}
else	246:18	250:16	8
stmts	246:23	250:16	9	
if	246:23	250:16	10	(! blk)
cond	246:27	246:28	11	! blk
op	246:27	0:0	12	!
water	246:28	0:0	12	blk
stmts	246:33	250:16	11	
water	246:33	0:0	12	{
call	247:20	248:52	12	av_log
arg	247:27	247:35	13	s->avctx
water	247:27	0:0	14	s
op	247:28	0:0	14	->
water	247:30	0:0	14	avctx
arg	247:37	247:49	13	AV_LOG_ERROR
water	247:37	0:0	14	AV_LOG_ERROR
arg	247:51	248:52	13	"new coupling coordinates must ""be present in block 0\n"
water	247:51	0:0	14	"new coupling coordinates must "
water	248:27	0:0	14	"be present in block 0\n"
water	248:53	0:0	12	;
return	249:20	249:46	12	AVERROR_INVALIDDATA
water	249:27	0:0	13	AVERROR_INVALIDDATA
water	250:16	0:0	12	}
water	251:12	0:0	8	}
else	251:14	254:12	6
stmts	251:19	254:12	7	
water	251:19	0:0	8	{
water	253:16	0:0	8	s
op	253:17	0:0	8	->
water	253:19	0:0	8	first_cpl_coords
op	253:35	0:0	8	[
water	253:36	0:0	8	ch
op	253:38	0:0	8	]
op	253:40	0:0	8	=
water	253:42	0:0	8	1
water	253:43	0:0	8	;
water	254:12	0:0	8	}
water	255:8	0:0	6	}
if	257:8	261:8	4	(channel_mode == AC3_CHMODE_STEREO && cpl_coords_exist)
cond	257:12	257:49	5	channel_mode == AC3_CHMODE_STEREO && cpl_coords_exist
water	257:12	0:0	6	channel_mode
op	257:25	0:0	6	==
water	257:28	0:0	6	AC3_CHMODE_STEREO
op	257:46	0:0	6	&&
water	257:49	0:0	6	cpl_coords_exist
stmts	257:67	261:8	5	
water	257:67	0:0	6	{
for	258:12	260:12	6	(bnd = 0 ;bnd < s -> num_cpl_bands;bnd ++)
forinit	258:17	258:24	7	bnd = 0 ;
water	258:17	0:0	8	bnd
op	258:21	0:0	8	=
water	258:23	0:0	8	0
water	258:24	0:0	8	;
cond	258:26	258:35	7	bnd < s -> num_cpl_bands
water	258:26	0:0	8	bnd
op	258:30	0:0	8	<
water	258:32	0:0	8	s
op	258:33	0:0	8	->
water	258:35	0:0	8	num_cpl_bands
forexpr	258:50	258:53	7	bnd ++
water	258:50	0:0	8	bnd
op	258:53	0:0	8	++
stmts	258:57	260:12	7	
water	258:57	0:0	8	{
water	259:16	0:0	8	s
op	259:17	0:0	8	->
water	259:19	0:0	8	phase_flags
op	259:30	0:0	8	[
water	259:31	0:0	8	bnd
op	259:34	0:0	8	]
op	259:36	0:0	8	=
water	259:38	0:0	8	s
op	259:39	0:0	8	->
water	259:41	0:0	8	phase_flags_in_use
water	259:59	0:0	8	?
call	259:61	259:74	8	get_bits1
arg	259:71	259:74	9	gbc
water	259:71	0:0	10	gbc
water	259:76	0:0	8	:
water	259:78	0:0	8	0
water	259:79	0:0	8	;
water	260:12	0:0	8	}
water	261:8	0:0	6	}
water	262:4	0:0	4	}
if	264:4	279:4	2	(channel_mode == AC3_CHMODE_STEREO)
cond	264:8	264:24	3	channel_mode == AC3_CHMODE_STEREO
water	264:8	0:0	4	channel_mode
op	264:21	0:0	4	==
water	264:24	0:0	4	AC3_CHMODE_STEREO
stmts	264:43	279:4	3	
water	264:43	0:0	4	{
if	265:8	274:8	4	(( s -> eac3 && ! blk ) ||get_bits1 (gbc ))
cond	265:12	265:46	5	( s -> eac3 && ! blk ) ||get_bits1 (gbc )
water	265:12	0:0	6	(
water	265:13	0:0	6	s
op	265:14	0:0	6	->
water	265:16	0:0	6	eac3
op	265:21	0:0	6	&&
op	265:24	0:0	6	!
water	265:25	0:0	6	blk
water	265:28	0:0	6	)
op	265:30	0:0	6	||
call	265:33	265:46	6	get_bits1
arg	265:43	265:46	7	gbc
water	265:43	0:0	8	gbc
stmts	265:49	274:8	5	
water	265:49	0:0	6	{
water	266:12	0:0	6	s
op	266:13	0:0	6	->
water	266:15	0:0	6	num_rematrixing_bands
op	266:37	0:0	6	=
water	266:39	0:0	6	4
water	266:40	0:0	6	;
if	267:12	269:12	6	(cpl_in_use && s -> start_freq [ CPL_CH ] <= 61)
cond	267:16	267:55	7	cpl_in_use && s -> start_freq [ CPL_CH ] <= 61
water	267:16	0:0	8	cpl_in_use
op	267:27	0:0	8	&&
water	267:30	0:0	8	s
op	267:31	0:0	8	->
water	267:33	0:0	8	start_freq
op	267:43	0:0	8	[
water	267:44	0:0	8	CPL_CH
op	267:50	0:0	8	]
op	267:52	0:0	8	<=
water	267:55	0:0	8	61
stmts	267:59	269:12	7	
water	267:59	0:0	8	{
water	268:16	0:0	8	s
op	268:17	0:0	8	->
water	268:19	0:0	8	num_rematrixing_bands
op	268:41	0:0	8	-=
water	268:44	0:0	8	1
op	268:46	0:0	8	+
water	268:48	0:0	8	(
water	268:49	0:0	8	s
op	268:50	0:0	8	->
water	268:52	0:0	8	start_freq
op	268:62	0:0	8	[
water	268:63	0:0	8	CPL_CH
op	268:69	0:0	8	]
op	268:71	0:0	8	==
water	268:74	0:0	8	37
water	268:76	0:0	8	)
water	268:77	0:0	8	;
water	269:12	0:0	8	}
else	269:14	271:12	6
stmts	269:19	271:12	7	
if	269:19	271:12	8	(s -> spx_in_use && s -> spx_src_start_freq <= 61)
cond	269:23	269:65	9	s -> spx_in_use && s -> spx_src_start_freq <= 61
water	269:23	0:0	10	s
op	269:24	0:0	10	->
water	269:26	0:0	10	spx_in_use
op	269:37	0:0	10	&&
water	269:40	0:0	10	s
op	269:41	0:0	10	->
water	269:43	0:0	10	spx_src_start_freq
op	269:62	0:0	10	<=
water	269:65	0:0	10	61
stmts	269:69	271:12	9	
water	269:69	0:0	10	{
water	270:16	0:0	10	s
op	270:17	0:0	10	->
water	270:19	0:0	10	num_rematrixing_bands
op	270:40	0:0	10	--
water	270:42	0:0	10	;
water	271:12	0:0	10	}
for	272:12	273:58	6	(bnd = 0 ;bnd < s -> num_rematrixing_bands;bnd ++)
forinit	272:17	272:24	7	bnd = 0 ;
water	272:17	0:0	8	bnd
op	272:21	0:0	8	=
water	272:23	0:0	8	0
water	272:24	0:0	8	;
cond	272:26	272:35	7	bnd < s -> num_rematrixing_bands
water	272:26	0:0	8	bnd
op	272:30	0:0	8	<
water	272:32	0:0	8	s
op	272:33	0:0	8	->
water	272:35	0:0	8	num_rematrixing_bands
forexpr	272:58	272:61	7	bnd ++
water	272:58	0:0	8	bnd
op	272:61	0:0	8	++
stmts	273:16	273:58	7	
water	273:16	0:0	8	s
op	273:17	0:0	8	->
water	273:19	0:0	8	rematrixing_flags
op	273:36	0:0	8	[
water	273:37	0:0	8	bnd
op	273:40	0:0	8	]
op	273:42	0:0	8	=
call	273:44	273:57	8	get_bits1
arg	273:54	273:57	9	gbc
water	273:54	0:0	10	gbc
water	273:58	0:0	8	;
water	274:8	0:0	6	}
else	274:10	278:8	4
stmts	274:15	278:8	5	
if	274:15	278:8	6	(! blk)
cond	274:19	274:20	7	! blk
op	274:19	0:0	8	!
water	274:20	0:0	8	blk
stmts	274:25	278:8	7	
water	274:25	0:0	8	{
call	275:12	276:70	8	av_log
arg	275:19	275:27	9	s->avctx
water	275:19	0:0	10	s
op	275:20	0:0	10	->
water	275:22	0:0	10	avctx
arg	275:29	275:43	9	AV_LOG_WARNING
water	275:29	0:0	10	AV_LOG_WARNING
arg	275:45	276:70	9	"Warning: ""new rematrixing strategy not present in block 0\n"
water	275:45	0:0	10	"Warning: "
water	276:19	0:0	10	"new rematrixing strategy not present in block 0\n"
water	276:71	0:0	8	;
water	277:12	0:0	8	s
op	277:13	0:0	8	->
water	277:15	0:0	8	num_rematrixing_bands
op	277:37	0:0	8	=
water	277:39	0:0	8	0
water	277:40	0:0	8	;
water	278:8	0:0	8	}
water	279:4	0:0	4	}
for	281:4	286:4	2	(ch = ! cpl_in_use ;ch <= s -> channels;ch ++)
forinit	281:9	281:25	3	ch = ! cpl_in_use ;
water	281:9	0:0	4	ch
op	281:12	0:0	4	=
op	281:14	0:0	4	!
water	281:15	0:0	4	cpl_in_use
water	281:25	0:0	4	;
cond	281:27	281:36	3	ch <= s -> channels
water	281:27	0:0	4	ch
op	281:30	0:0	4	<=
water	281:33	0:0	4	s
op	281:34	0:0	4	->
water	281:36	0:0	4	channels
forexpr	281:46	281:48	3	ch ++
water	281:46	0:0	4	ch
op	281:48	0:0	4	++
stmts	281:52	286:4	3	
water	281:52	0:0	4	{
if	282:8	283:75	4	(! s -> eac3)
cond	282:12	282:16	5	! s -> eac3
op	282:12	0:0	6	!
water	282:13	0:0	6	s
op	282:14	0:0	6	->
water	282:16	0:0	6	eac3
stmts	283:12	283:75	5	
water	283:12	0:0	6	s
op	283:13	0:0	6	->
water	283:15	0:0	6	exp_strategy
op	283:27	0:0	6	[
water	283:28	0:0	6	blk
op	283:31	0:0	6	]
op	283:32	0:0	6	[
water	283:33	0:0	6	ch
op	283:35	0:0	6	]
op	283:37	0:0	6	=
call	283:39	283:74	6	get_bits
arg	283:48	283:51	7	gbc
water	283:48	0:0	8	gbc
arg	283:53	283:74	7	2-(ch==s->lfe_ch)
water	283:53	0:0	8	2
op	283:55	0:0	8	-
water	283:57	0:0	8	(
water	283:58	0:0	8	ch
op	283:61	0:0	8	==
water	283:64	0:0	8	s
op	283:65	0:0	8	->
water	283:67	0:0	8	lfe_ch
water	283:73	0:0	8	)
water	283:75	0:0	6	;
if	284:8	285:36	4	(s -> exp_strategy [ blk ] [ ch ] != EXP_REUSE)
cond	284:12	284:40	5	s -> exp_strategy [ blk ] [ ch ] != EXP_REUSE
water	284:12	0:0	6	s
op	284:13	0:0	6	->
water	284:15	0:0	6	exp_strategy
op	284:27	0:0	6	[
water	284:28	0:0	6	blk
op	284:31	0:0	6	]
op	284:32	0:0	6	[
water	284:33	0:0	6	ch
op	284:35	0:0	6	]
op	284:37	0:0	6	!=
water	284:40	0:0	6	EXP_REUSE
stmts	285:12	285:36	5	
water	285:12	0:0	6	bit_alloc_stages
op	285:28	0:0	6	[
water	285:29	0:0	6	ch
op	285:31	0:0	6	]
op	285:33	0:0	6	=
water	285:35	0:0	6	3
water	285:36	0:0	6	;
water	286:4	0:0	4	}
for	288:4	310:4	2	(ch = 1 ;ch <= fbw_channels;ch ++)
forinit	288:9	288:15	3	ch = 1 ;
water	288:9	0:0	4	ch
op	288:12	0:0	4	=
water	288:14	0:0	4	1
water	288:15	0:0	4	;
cond	288:17	288:23	3	ch <= fbw_channels
water	288:17	0:0	4	ch
op	288:20	0:0	4	<=
water	288:23	0:0	4	fbw_channels
forexpr	288:37	288:39	3	ch ++
water	288:37	0:0	4	ch
op	288:39	0:0	4	++
stmts	288:43	310:4	3	
water	288:43	0:0	4	{
water	289:8	0:0	4	s
op	289:9	0:0	4	->
water	289:11	0:0	4	start_freq
op	289:21	0:0	4	[
water	289:22	0:0	4	ch
op	289:24	0:0	4	]
op	289:26	0:0	4	=
water	289:28	0:0	4	0
water	289:29	0:0	4	;
if	290:8	309:8	4	(s -> exp_strategy [ blk ] [ ch ] != EXP_REUSE)
cond	290:12	290:40	5	s -> exp_strategy [ blk ] [ ch ] != EXP_REUSE
water	290:12	0:0	6	s
op	290:13	0:0	6	->
water	290:15	0:0	6	exp_strategy
op	290:27	0:0	6	[
water	290:28	0:0	6	blk
op	290:31	0:0	6	]
op	290:32	0:0	6	[
water	290:33	0:0	6	ch
op	290:35	0:0	6	]
op	290:37	0:0	6	!=
water	290:40	0:0	6	EXP_REUSE
stmts	290:51	309:8	5	
water	290:51	0:0	6	{
decl	291:12	291:26	6	int	group_size
decl	292:12	292:38	6	int	prev
op	292:21	0:0	6	=
water	292:23	0:0	6	s
op	292:24	0:0	6	->
water	292:26	0:0	6	end_freq
op	292:34	0:0	6	[
water	292:35	0:0	6	ch
op	292:37	0:0	6	]
if	293:12	294:55	6	(s -> channel_in_cpl [ ch ])
cond	293:16	293:36	7	s -> channel_in_cpl [ ch ]
water	293:16	0:0	8	s
op	293:17	0:0	8	->
water	293:19	0:0	8	channel_in_cpl
op	293:33	0:0	8	[
water	293:34	0:0	8	ch
op	293:36	0:0	8	]
stmts	294:16	294:55	7	
water	294:16	0:0	8	s
op	294:17	0:0	8	->
water	294:19	0:0	8	end_freq
op	294:27	0:0	8	[
water	294:28	0:0	8	ch
op	294:30	0:0	8	]
op	294:32	0:0	8	=
water	294:34	0:0	8	s
op	294:35	0:0	8	->
water	294:37	0:0	8	start_freq
op	294:47	0:0	8	[
water	294:48	0:0	8	CPL_CH
op	294:54	0:0	8	]
water	294:55	0:0	8	;
else	295:12	296:55	6
stmts	295:17	296:55	7	
if	295:17	296:55	8	(s -> channel_uses_spx [ ch ])
cond	295:21	295:43	9	s -> channel_uses_spx [ ch ]
water	295:21	0:0	10	s
op	295:22	0:0	10	->
water	295:24	0:0	10	channel_uses_spx
op	295:40	0:0	10	[
water	295:41	0:0	10	ch
op	295:43	0:0	10	]
stmts	296:16	296:55	9	
water	296:16	0:0	10	s
op	296:17	0:0	10	->
water	296:19	0:0	10	end_freq
op	296:27	0:0	10	[
water	296:28	0:0	10	ch
op	296:30	0:0	10	]
op	296:32	0:0	10	=
water	296:34	0:0	10	s
op	296:35	0:0	10	->
water	296:37	0:0	10	spx_src_start_freq
water	296:55	0:0	10	;
else	297:12	304:12	6
stmts	297:17	304:12	7	
water	297:17	0:0	8	{
decl	298:16	298:53	8	int	bandwidth_code
op	298:35	0:0	8	=
call	298:37	298:52	9	get_bits
arg	298:46	298:49	10	gbc
water	298:46	0:0	11	gbc
arg	298:51	298:52	10	6
water	298:51	0:0	11	6
if	299:16	302:16	8	(bandwidth_code > 60)
cond	299:20	299:37	9	bandwidth_code > 60
water	299:20	0:0	10	bandwidth_code
op	299:35	0:0	10	>
water	299:37	0:0	10	60
stmts	299:41	302:16	9	
water	299:41	0:0	10	{
call	300:20	300:95	10	av_log
arg	300:27	300:35	11	s->avctx
water	300:27	0:0	12	s
op	300:28	0:0	12	->
water	300:30	0:0	12	avctx
arg	300:37	300:49	11	AV_LOG_ERROR
water	300:37	0:0	12	AV_LOG_ERROR
arg	300:51	300:79	11	"bandwidth code = %d > 60\n"
water	300:51	0:0	12	"bandwidth code = %d > 60\n"
arg	300:81	300:95	11	bandwidth_code
water	300:81	0:0	12	bandwidth_code
water	300:96	0:0	10	;
return	301:20	301:46	10	AVERROR_INVALIDDATA
water	301:27	0:0	11	AVERROR_INVALIDDATA
water	302:16	0:0	10	}
water	303:16	0:0	8	s
op	303:17	0:0	8	->
water	303:19	0:0	8	end_freq
op	303:27	0:0	8	[
water	303:28	0:0	8	ch
op	303:30	0:0	8	]
op	303:32	0:0	8	=
water	303:34	0:0	8	bandwidth_code
op	303:49	0:0	8	*
water	303:51	0:0	8	3
op	303:53	0:0	8	+
water	303:55	0:0	8	73
water	303:57	0:0	8	;
water	304:12	0:0	8	}
water	305:12	0:0	6	group_size
op	305:23	0:0	6	=
water	305:25	0:0	6	3
op	305:27	0:0	6	<<
water	305:30	0:0	6	(
water	305:31	0:0	6	s
op	305:32	0:0	6	->
water	305:34	0:0	6	exp_strategy
op	305:46	0:0	6	[
water	305:47	0:0	6	blk
op	305:50	0:0	6	]
op	305:51	0:0	6	[
water	305:52	0:0	6	ch
op	305:54	0:0	6	]
op	305:56	0:0	6	-
water	305:58	0:0	6	1
water	305:59	0:0	6	)
water	305:60	0:0	6	;
water	306:12	0:0	6	s
op	306:13	0:0	6	->
water	306:15	0:0	6	num_exp_groups
op	306:29	0:0	6	[
water	306:30	0:0	6	ch
op	306:32	0:0	6	]
op	306:34	0:0	6	=
water	306:36	0:0	6	(
water	306:37	0:0	6	s
op	306:38	0:0	6	->
water	306:40	0:0	6	end_freq
op	306:48	0:0	6	[
water	306:49	0:0	6	ch
op	306:51	0:0	6	]
op	306:53	0:0	6	+
water	306:55	0:0	6	group_size
op	306:65	0:0	6	-
water	306:66	0:0	6	4
water	306:67	0:0	6	)
op	306:69	0:0	6	/
water	306:71	0:0	6	group_size
water	306:81	0:0	6	;
if	307:12	308:61	6	(blk > 0 && s -> end_freq [ ch ] != prev)
cond	307:16	307:46	7	blk > 0 && s -> end_freq [ ch ] != prev
water	307:16	0:0	8	blk
op	307:20	0:0	8	>
water	307:22	0:0	8	0
op	307:24	0:0	8	&&
water	307:27	0:0	8	s
op	307:28	0:0	8	->
water	307:30	0:0	8	end_freq
op	307:38	0:0	8	[
water	307:39	0:0	8	ch
op	307:41	0:0	8	]
op	307:43	0:0	8	!=
water	307:46	0:0	8	prev
stmts	308:16	308:61	7	
call	308:16	308:60	8	memset
arg	308:23	308:39	9	bit_alloc_stages
water	308:23	0:0	10	bit_alloc_stages
arg	308:41	308:42	9	3
water	308:41	0:0	10	3
arg	308:44	308:60	9	AC3_MAX_CHANNELS
water	308:44	0:0	10	AC3_MAX_CHANNELS
water	308:61	0:0	8	;
water	309:8	0:0	6	}
water	310:4	0:0	4	}
if	311:4	314:4	2	(cpl_in_use && s -> exp_strategy [ blk ] [ CPL_CH ] != EXP_REUSE)
cond	311:8	311:54	3	cpl_in_use && s -> exp_strategy [ blk ] [ CPL_CH ] != EXP_REUSE
water	311:8	0:0	4	cpl_in_use
op	311:19	0:0	4	&&
water	311:22	0:0	4	s
op	311:23	0:0	4	->
water	311:25	0:0	4	exp_strategy
op	311:37	0:0	4	[
water	311:38	0:0	4	blk
op	311:41	0:0	4	]
op	311:42	0:0	4	[
water	311:43	0:0	4	CPL_CH
op	311:49	0:0	4	]
op	311:51	0:0	4	!=
water	311:54	0:0	4	EXP_REUSE
stmts	311:65	314:4	3	
water	311:65	0:0	4	{
water	312:8	0:0	4	s
op	312:9	0:0	4	->
water	312:11	0:0	4	num_exp_groups
op	312:25	0:0	4	[
water	312:26	0:0	4	CPL_CH
op	312:32	0:0	4	]
op	312:34	0:0	4	=
water	312:36	0:0	4	(
water	312:37	0:0	4	s
op	312:38	0:0	4	->
water	312:40	0:0	4	end_freq
op	312:48	0:0	4	[
water	312:49	0:0	4	CPL_CH
op	312:55	0:0	4	]
op	312:57	0:0	4	-
water	312:59	0:0	4	s
op	312:60	0:0	4	->
water	312:62	0:0	4	start_freq
op	312:72	0:0	4	[
water	312:73	0:0	4	CPL_CH
op	312:79	0:0	4	]
water	312:80	0:0	4	)
op	312:82	0:0	4	/
water	313:36	0:0	4	(
water	313:37	0:0	4	3
op	313:39	0:0	4	<<
water	313:42	0:0	4	(
water	313:43	0:0	4	s
op	313:44	0:0	4	->
water	313:46	0:0	4	exp_strategy
op	313:58	0:0	4	[
water	313:59	0:0	4	blk
op	313:62	0:0	4	]
op	313:63	0:0	4	[
water	313:64	0:0	4	CPL_CH
op	313:70	0:0	4	]
op	313:72	0:0	4	-
water	313:74	0:0	4	1
water	313:75	0:0	4	)
water	313:76	0:0	4	)
water	313:77	0:0	4	;
water	314:4	0:0	4	}
for	316:4	328:4	2	(ch = ! cpl_in_use ;ch <= s -> channels;ch ++)
forinit	316:9	316:25	3	ch = ! cpl_in_use ;
water	316:9	0:0	4	ch
op	316:12	0:0	4	=
op	316:14	0:0	4	!
water	316:15	0:0	4	cpl_in_use
water	316:25	0:0	4	;
cond	316:27	316:36	3	ch <= s -> channels
water	316:27	0:0	4	ch
op	316:30	0:0	4	<=
water	316:33	0:0	4	s
op	316:34	0:0	4	->
water	316:36	0:0	4	channels
forexpr	316:46	316:48	3	ch ++
water	316:46	0:0	4	ch
op	316:48	0:0	4	++
stmts	316:52	328:4	3	
water	316:52	0:0	4	{
if	317:8	327:8	4	(s -> exp_strategy [ blk ] [ ch ] != EXP_REUSE)
cond	317:12	317:40	5	s -> exp_strategy [ blk ] [ ch ] != EXP_REUSE
water	317:12	0:0	6	s
op	317:13	0:0	6	->
water	317:15	0:0	6	exp_strategy
op	317:27	0:0	6	[
water	317:28	0:0	6	blk
op	317:31	0:0	6	]
op	317:32	0:0	6	[
water	317:33	0:0	6	ch
op	317:35	0:0	6	]
op	317:37	0:0	6	!=
water	317:40	0:0	6	EXP_REUSE
stmts	317:51	327:8	5	
water	317:51	0:0	6	{
water	318:12	0:0	6	s
op	318:13	0:0	6	->
water	318:15	0:0	6	dexps
op	318:20	0:0	6	[
water	318:21	0:0	6	ch
op	318:23	0:0	6	]
op	318:24	0:0	6	[
water	318:25	0:0	6	0
op	318:26	0:0	6	]
op	318:28	0:0	6	=
call	318:30	318:45	6	get_bits
arg	318:39	318:42	7	gbc
water	318:39	0:0	8	gbc
arg	318:44	318:45	7	4
water	318:44	0:0	8	4
op	318:47	0:0	6	<<
op	318:50	0:0	6	!
water	318:51	0:0	6	ch
water	318:53	0:0	6	;
if	319:12	324:12	6	(decode_exponents (gbc ,s -> exp_strategy [ blk ] [ ch ] ,s -> num_exp_groups [ ch ] ,s -> dexps [ ch ] [ 0 ] ,& s -> dexps [ ch ] [ s -> start_freq [ ch ] + ! ! ch ] ))
cond	319:16	321:70	7	decode_exponents (gbc ,s -> exp_strategy [ blk ] [ ch ] ,s -> num_exp_groups [ ch ] ,s -> dexps [ ch ] [ 0 ] ,& s -> dexps [ ch ] [ s -> start_freq [ ch ] + ! ! ch ] )
call	319:16	321:70	8	decode_exponents
arg	319:33	319:36	9	gbc
water	319:33	0:0	10	gbc
arg	319:38	319:62	9	s->exp_strategy[blk][ch]
water	319:38	0:0	10	s
op	319:39	0:0	10	->
water	319:41	0:0	10	exp_strategy
op	319:53	0:0	10	[
water	319:54	0:0	10	blk
op	319:57	0:0	10	]
op	319:58	0:0	10	[
water	319:59	0:0	10	ch
op	319:61	0:0	10	]
arg	320:33	320:54	9	s->num_exp_groups[ch]
water	320:33	0:0	10	s
op	320:34	0:0	10	->
water	320:36	0:0	10	num_exp_groups
op	320:50	0:0	10	[
water	320:51	0:0	10	ch
op	320:53	0:0	10	]
arg	320:56	320:71	9	s->dexps[ch][0]
water	320:56	0:0	10	s
op	320:57	0:0	10	->
water	320:59	0:0	10	dexps
op	320:64	0:0	10	[
water	320:65	0:0	10	ch
op	320:67	0:0	10	]
op	320:68	0:0	10	[
water	320:69	0:0	10	0
op	320:70	0:0	10	]
arg	321:33	321:70	9	&s->dexps[ch][s->start_freq[ch]+!!ch]
op	321:33	0:0	10	&
water	321:34	0:0	10	s
op	321:35	0:0	10	->
water	321:37	0:0	10	dexps
op	321:42	0:0	10	[
water	321:43	0:0	10	ch
op	321:45	0:0	10	]
op	321:46	0:0	10	[
water	321:47	0:0	10	s
op	321:48	0:0	10	->
water	321:50	0:0	10	start_freq
op	321:60	0:0	10	[
water	321:61	0:0	10	ch
op	321:63	0:0	10	]
op	321:64	0:0	10	+
op	321:65	0:0	10	!
op	321:66	0:0	10	!
water	321:67	0:0	10	ch
op	321:69	0:0	10	]
stmts	321:73	324:12	7	
water	321:73	0:0	8	{
call	322:16	322:72	8	av_log
arg	322:23	322:31	9	s->avctx
water	322:23	0:0	10	s
op	322:24	0:0	10	->
water	322:26	0:0	10	avctx
arg	322:33	322:45	9	AV_LOG_ERROR
water	322:33	0:0	10	AV_LOG_ERROR
arg	322:47	322:72	9	"exponent out-of-range\n"
water	322:47	0:0	10	"exponent out-of-range\n"
water	322:73	0:0	8	;
return	323:16	323:42	8	AVERROR_INVALIDDATA
water	323:23	0:0	9	AVERROR_INVALIDDATA
water	324:12	0:0	8	}
if	325:12	326:33	6	(ch != CPL_CH && ch != s -> lfe_ch)
cond	325:16	325:41	7	ch != CPL_CH && ch != s -> lfe_ch
water	325:16	0:0	8	ch
op	325:19	0:0	8	!=
water	325:22	0:0	8	CPL_CH
op	325:29	0:0	8	&&
water	325:32	0:0	8	ch
op	325:35	0:0	8	!=
water	325:38	0:0	8	s
op	325:39	0:0	8	->
water	325:41	0:0	8	lfe_ch
stmts	326:16	326:33	7	
call	326:16	326:32	8	skip_bits
arg	326:26	326:29	9	gbc
water	326:26	0:0	10	gbc
arg	326:31	326:32	9	2
water	326:31	0:0	10	2
water	326:33	0:0	8	;
water	327:8	0:0	6	}
water	328:4	0:0	4	}
if	330:4	344:4	2	(s -> bit_allocation_syntax)
cond	330:8	330:11	3	s -> bit_allocation_syntax
water	330:8	0:0	4	s
op	330:9	0:0	4	->
water	330:11	0:0	4	bit_allocation_syntax
stmts	330:34	344:4	3	
water	330:34	0:0	4	{
if	331:8	339:8	4	(get_bits1 (gbc ))
cond	331:12	331:25	5	get_bits1 (gbc )
call	331:12	331:25	6	get_bits1
arg	331:22	331:25	7	gbc
water	331:22	0:0	8	gbc
stmts	331:28	339:8	5	
water	331:28	0:0	6	{
water	332:12	0:0	6	s
op	332:13	0:0	6	->
water	332:15	0:0	6	bit_alloc_params
op	332:31	0:0	6	.
water	332:32	0:0	6	slow_decay
op	332:43	0:0	6	=
water	332:45	0:0	6	ff_ac3_slow_decay_tab
op	332:66	0:0	6	[
call	332:67	332:82	6	get_bits
arg	332:76	332:79	7	gbc
water	332:76	0:0	8	gbc
arg	332:81	332:82	7	2
water	332:81	0:0	8	2
op	332:83	0:0	6	]
op	332:85	0:0	6	>>
water	332:88	0:0	6	s
op	332:89	0:0	6	->
water	332:91	0:0	6	bit_alloc_params
op	332:107	0:0	6	.
water	332:108	0:0	6	sr_shift
water	332:116	0:0	6	;
water	333:12	0:0	6	s
op	333:13	0:0	6	->
water	333:15	0:0	6	bit_alloc_params
op	333:31	0:0	6	.
water	333:32	0:0	6	fast_decay
op	333:43	0:0	6	=
water	333:45	0:0	6	ff_ac3_fast_decay_tab
op	333:66	0:0	6	[
call	333:67	333:82	6	get_bits
arg	333:76	333:79	7	gbc
water	333:76	0:0	8	gbc
arg	333:81	333:82	7	2
water	333:81	0:0	8	2
op	333:83	0:0	6	]
op	333:85	0:0	6	>>
water	333:88	0:0	6	s
op	333:89	0:0	6	->
water	333:91	0:0	6	bit_alloc_params
op	333:107	0:0	6	.
water	333:108	0:0	6	sr_shift
water	333:116	0:0	6	;
water	334:12	0:0	6	s
op	334:13	0:0	6	->
water	334:15	0:0	6	bit_alloc_params
op	334:31	0:0	6	.
water	334:32	0:0	6	slow_gain
op	334:43	0:0	6	=
water	334:45	0:0	6	ff_ac3_slow_gain_tab
op	334:65	0:0	6	[
call	334:66	334:81	6	get_bits
arg	334:75	334:78	7	gbc
water	334:75	0:0	8	gbc
arg	334:80	334:81	7	2
water	334:80	0:0	8	2
op	334:82	0:0	6	]
water	334:83	0:0	6	;
water	335:12	0:0	6	s
op	335:13	0:0	6	->
water	335:15	0:0	6	bit_alloc_params
op	335:31	0:0	6	.
water	335:32	0:0	6	db_per_bit
op	335:43	0:0	6	=
water	335:45	0:0	6	ff_ac3_db_per_bit_tab
op	335:66	0:0	6	[
call	335:67	335:82	6	get_bits
arg	335:76	335:79	7	gbc
water	335:76	0:0	8	gbc
arg	335:81	335:82	7	2
water	335:81	0:0	8	2
op	335:83	0:0	6	]
water	335:84	0:0	6	;
water	336:12	0:0	6	s
op	336:13	0:0	6	->
water	336:15	0:0	6	bit_alloc_params
op	336:31	0:0	6	.
water	336:32	0:0	6	floor
op	336:39	0:0	6	=
water	336:41	0:0	6	ff_ac3_floor_tab
op	336:57	0:0	6	[
call	336:58	336:73	6	get_bits
arg	336:67	336:70	7	gbc
water	336:67	0:0	8	gbc
arg	336:72	336:73	7	3
water	336:72	0:0	8	3
op	336:74	0:0	6	]
water	336:75	0:0	6	;
for	337:12	338:69	6	(ch = ! cpl_in_use ;ch <= s -> channels;ch ++)
forinit	337:17	337:33	7	ch = ! cpl_in_use ;
water	337:17	0:0	8	ch
op	337:20	0:0	8	=
op	337:22	0:0	8	!
water	337:23	0:0	8	cpl_in_use
water	337:33	0:0	8	;
cond	337:35	337:44	7	ch <= s -> channels
water	337:35	0:0	8	ch
op	337:38	0:0	8	<=
water	337:41	0:0	8	s
op	337:42	0:0	8	->
water	337:44	0:0	8	channels
forexpr	337:54	337:56	7	ch ++
water	337:54	0:0	8	ch
op	337:56	0:0	8	++
stmts	338:16	338:69	7	
water	338:16	0:0	8	bit_alloc_stages
op	338:32	0:0	8	[
water	338:33	0:0	8	ch
op	338:35	0:0	8	]
op	338:37	0:0	8	=
call	338:39	338:68	8	FFMAX
arg	338:45	338:65	9	bit_alloc_stages[ch]
water	338:45	0:0	10	bit_alloc_stages
op	338:61	0:0	10	[
water	338:62	0:0	10	ch
op	338:64	0:0	10	]
arg	338:67	338:68	9	2
water	338:67	0:0	10	2
water	338:69	0:0	8	;
water	339:8	0:0	6	}
else	339:10	343:8	4
stmts	339:15	343:8	5	
if	339:15	343:8	6	(! blk)
cond	339:19	339:20	7	! blk
op	339:19	0:0	8	!
water	339:20	0:0	8	blk
stmts	339:25	343:8	7	
water	339:25	0:0	8	{
call	340:12	341:44	8	av_log
arg	340:19	340:27	9	s->avctx
water	340:19	0:0	10	s
op	340:20	0:0	10	->
water	340:22	0:0	10	avctx
arg	340:29	340:41	9	AV_LOG_ERROR
water	340:29	0:0	10	AV_LOG_ERROR
arg	340:43	341:44	9	"new bit allocation info must ""be present in block 0\n"
water	340:43	0:0	10	"new bit allocation info must "
water	341:19	0:0	10	"be present in block 0\n"
water	341:45	0:0	8	;
return	342:12	342:38	8	AVERROR_INVALIDDATA
water	342:19	0:0	9	AVERROR_INVALIDDATA
water	343:8	0:0	8	}
water	344:4	0:0	4	}
if	346:4	373:4	2	(! s -> eac3 || ! blk)
cond	346:8	346:21	3	! s -> eac3 || ! blk
op	346:8	0:0	4	!
water	346:9	0:0	4	s
op	346:10	0:0	4	->
water	346:12	0:0	4	eac3
op	346:17	0:0	4	||
op	346:20	0:0	4	!
water	346:21	0:0	4	blk
stmts	346:26	373:4	3	
water	346:26	0:0	4	{
if	347:8	369:8	4	(s -> snr_offset_strategy &&get_bits1 (gbc ))
cond	347:12	347:51	5	s -> snr_offset_strategy &&get_bits1 (gbc )
water	347:12	0:0	6	s
op	347:13	0:0	6	->
water	347:15	0:0	6	snr_offset_strategy
op	347:35	0:0	6	&&
call	347:38	347:51	6	get_bits1
arg	347:48	347:51	7	gbc
water	347:48	0:0	8	gbc
stmts	347:54	369:8	5	
water	347:54	0:0	6	{
decl	348:12	348:23	6	int	snr
op	348:20	0:0	6	=
water	348:22	0:0	6	0
decl	349:12	349:20	6	int	csnr
water	350:12	0:0	6	csnr
op	350:17	0:0	6	=
water	350:19	0:0	6	(
call	350:20	350:35	6	get_bits
arg	350:29	350:32	7	gbc
water	350:29	0:0	8	gbc
arg	350:34	350:35	7	6
water	350:34	0:0	8	6
op	350:37	0:0	6	-
water	350:39	0:0	6	15
water	350:41	0:0	6	)
op	350:43	0:0	6	<<
water	350:46	0:0	6	4
water	350:47	0:0	6	;
for	351:12	368:12	6	(i = ch = ! cpl_in_use ;ch <= s -> channels;ch ++)
forinit	351:17	351:37	7	i = ch = ! cpl_in_use ;
water	351:17	0:0	8	i
op	351:19	0:0	8	=
water	351:21	0:0	8	ch
op	351:24	0:0	8	=
op	351:26	0:0	8	!
water	351:27	0:0	8	cpl_in_use
water	351:37	0:0	8	;
cond	351:39	351:48	7	ch <= s -> channels
water	351:39	0:0	8	ch
op	351:42	0:0	8	<=
water	351:45	0:0	8	s
op	351:46	0:0	8	->
water	351:48	0:0	8	channels
forexpr	351:58	351:60	7	ch ++
water	351:58	0:0	8	ch
op	351:60	0:0	8	++
stmts	351:64	368:12	7	
water	351:64	0:0	8	{
if	353:16	354:56	8	(ch == i || s -> snr_offset_strategy == 2)
cond	353:20	353:57	9	ch == i || s -> snr_offset_strategy == 2
water	353:20	0:0	10	ch
op	353:23	0:0	10	==
water	353:26	0:0	10	i
op	353:28	0:0	10	||
water	353:31	0:0	10	s
op	353:32	0:0	10	->
water	353:34	0:0	10	snr_offset_strategy
op	353:54	0:0	10	==
water	353:57	0:0	10	2
stmts	354:20	354:56	9	
water	354:20	0:0	10	snr
op	354:24	0:0	10	=
water	354:26	0:0	10	(
water	354:27	0:0	10	csnr
op	354:32	0:0	10	+
call	354:34	354:49	10	get_bits
arg	354:43	354:46	11	gbc
water	354:43	0:0	12	gbc
arg	354:48	354:49	11	4
water	354:48	0:0	12	4
water	354:50	0:0	10	)
op	354:52	0:0	10	<<
water	354:55	0:0	10	2
water	354:56	0:0	10	;
if	356:16	358:16	8	(blk && s -> snr_offset [ ch ] != snr)
cond	356:20	356:48	9	blk && s -> snr_offset [ ch ] != snr
water	356:20	0:0	10	blk
op	356:24	0:0	10	&&
water	356:27	0:0	10	s
op	356:28	0:0	10	->
water	356:30	0:0	10	snr_offset
op	356:40	0:0	10	[
water	356:41	0:0	10	ch
op	356:43	0:0	10	]
op	356:45	0:0	10	!=
water	356:48	0:0	10	snr
stmts	356:53	358:16	9	
water	356:53	0:0	10	{
water	357:20	0:0	10	bit_alloc_stages
op	357:36	0:0	10	[
water	357:37	0:0	10	ch
op	357:39	0:0	10	]
op	357:41	0:0	10	=
call	357:43	357:72	10	FFMAX
arg	357:49	357:69	11	bit_alloc_stages[ch]
water	357:49	0:0	12	bit_alloc_stages
op	357:65	0:0	12	[
water	357:66	0:0	12	ch
op	357:68	0:0	12	]
arg	357:71	357:72	11	1
water	357:71	0:0	12	1
water	357:73	0:0	10	;
water	358:16	0:0	10	}
water	359:16	0:0	8	s
op	359:17	0:0	8	->
water	359:19	0:0	8	snr_offset
op	359:29	0:0	8	[
water	359:30	0:0	8	ch
op	359:32	0:0	8	]
op	359:34	0:0	8	=
water	359:36	0:0	8	snr
water	359:39	0:0	8	;
if	361:16	367:16	8	(! s -> eac3)
cond	361:20	361:24	9	! s -> eac3
op	361:20	0:0	10	!
water	361:21	0:0	10	s
op	361:22	0:0	10	->
water	361:24	0:0	10	eac3
stmts	361:30	367:16	9	
water	361:30	0:0	10	{
decl	362:20	362:47	10	int	prev
op	362:29	0:0	10	=
water	362:31	0:0	10	s
op	362:32	0:0	10	->
water	362:34	0:0	10	fast_gain
op	362:43	0:0	10	[
water	362:44	0:0	10	ch
op	362:46	0:0	10	]
water	363:20	0:0	10	s
op	363:21	0:0	10	->
water	363:23	0:0	10	fast_gain
op	363:32	0:0	10	[
water	363:33	0:0	10	ch
op	363:35	0:0	10	]
op	363:37	0:0	10	=
water	363:39	0:0	10	ff_ac3_fast_gain_tab
op	363:59	0:0	10	[
call	363:60	363:75	10	get_bits
arg	363:69	363:72	11	gbc
water	363:69	0:0	12	gbc
arg	363:74	363:75	11	3
water	363:74	0:0	12	3
op	363:76	0:0	10	]
water	363:77	0:0	10	;
if	365:20	366:77	10	(blk && prev != s -> fast_gain [ ch ])
cond	365:24	365:54	11	blk && prev != s -> fast_gain [ ch ]
water	365:24	0:0	12	blk
op	365:28	0:0	12	&&
water	365:31	0:0	12	prev
op	365:36	0:0	12	!=
water	365:39	0:0	12	s
op	365:40	0:0	12	->
water	365:42	0:0	12	fast_gain
op	365:51	0:0	12	[
water	365:52	0:0	12	ch
op	365:54	0:0	12	]
stmts	366:24	366:77	11	
water	366:24	0:0	12	bit_alloc_stages
op	366:40	0:0	12	[
water	366:41	0:0	12	ch
op	366:43	0:0	12	]
op	366:45	0:0	12	=
call	366:47	366:76	12	FFMAX
arg	366:53	366:73	13	bit_alloc_stages[ch]
water	366:53	0:0	14	bit_alloc_stages
op	366:69	0:0	14	[
water	366:70	0:0	14	ch
op	366:72	0:0	14	]
arg	366:75	366:76	13	2
water	366:75	0:0	14	2
water	366:77	0:0	12	;
water	367:16	0:0	10	}
water	368:12	0:0	8	}
water	369:8	0:0	6	}
else	369:10	372:8	4
stmts	369:15	372:8	5	
if	369:15	372:8	6	(! s -> eac3 && ! blk)
cond	369:19	369:32	7	! s -> eac3 && ! blk
op	369:19	0:0	8	!
water	369:20	0:0	8	s
op	369:21	0:0	8	->
water	369:23	0:0	8	eac3
op	369:28	0:0	8	&&
op	369:31	0:0	8	!
water	369:32	0:0	8	blk
stmts	369:37	372:8	7	
water	369:37	0:0	8	{
call	370:12	370:89	8	av_log
arg	370:19	370:27	9	s->avctx
water	370:19	0:0	10	s
op	370:20	0:0	10	->
water	370:22	0:0	10	avctx
arg	370:29	370:41	9	AV_LOG_ERROR
water	370:29	0:0	10	AV_LOG_ERROR
arg	370:43	370:89	9	"new snr offsets must be present in block 0\n"
water	370:43	0:0	10	"new snr offsets must be present in block 0\n"
water	370:90	0:0	8	;
return	371:12	371:38	8	AVERROR_INVALIDDATA
water	371:19	0:0	9	AVERROR_INVALIDDATA
water	372:8	0:0	8	}
water	373:4	0:0	4	}
if	375:4	383:4	2	(s -> fast_gain_syntax &&get_bits1 (gbc ))
cond	375:8	375:44	3	s -> fast_gain_syntax &&get_bits1 (gbc )
water	375:8	0:0	4	s
op	375:9	0:0	4	->
water	375:11	0:0	4	fast_gain_syntax
op	375:28	0:0	4	&&
call	375:31	375:44	4	get_bits1
arg	375:41	375:44	5	gbc
water	375:41	0:0	6	gbc
stmts	375:47	383:4	3	
water	375:47	0:0	4	{
for	376:8	382:8	4	(ch = ! cpl_in_use ;ch <= s -> channels;ch ++)
forinit	376:13	376:29	5	ch = ! cpl_in_use ;
water	376:13	0:0	6	ch
op	376:16	0:0	6	=
op	376:18	0:0	6	!
water	376:19	0:0	6	cpl_in_use
water	376:29	0:0	6	;
cond	376:31	376:40	5	ch <= s -> channels
water	376:31	0:0	6	ch
op	376:34	0:0	6	<=
water	376:37	0:0	6	s
op	376:38	0:0	6	->
water	376:40	0:0	6	channels
forexpr	376:50	376:52	5	ch ++
water	376:50	0:0	6	ch
op	376:52	0:0	6	++
stmts	376:56	382:8	5	
water	376:56	0:0	6	{
decl	377:12	377:39	6	int	prev
op	377:21	0:0	6	=
water	377:23	0:0	6	s
op	377:24	0:0	6	->
water	377:26	0:0	6	fast_gain
op	377:35	0:0	6	[
water	377:36	0:0	6	ch
op	377:38	0:0	6	]
water	378:12	0:0	6	s
op	378:13	0:0	6	->
water	378:15	0:0	6	fast_gain
op	378:24	0:0	6	[
water	378:25	0:0	6	ch
op	378:27	0:0	6	]
op	378:29	0:0	6	=
water	378:31	0:0	6	ff_ac3_fast_gain_tab
op	378:51	0:0	6	[
call	378:52	378:67	6	get_bits
arg	378:61	378:64	7	gbc
water	378:61	0:0	8	gbc
arg	378:66	378:67	7	3
water	378:66	0:0	8	3
op	378:68	0:0	6	]
water	378:69	0:0	6	;
if	380:12	381:69	6	(blk && prev != s -> fast_gain [ ch ])
cond	380:16	380:46	7	blk && prev != s -> fast_gain [ ch ]
water	380:16	0:0	8	blk
op	380:20	0:0	8	&&
water	380:23	0:0	8	prev
op	380:28	0:0	8	!=
water	380:31	0:0	8	s
op	380:32	0:0	8	->
water	380:34	0:0	8	fast_gain
op	380:43	0:0	8	[
water	380:44	0:0	8	ch
op	380:46	0:0	8	]
stmts	381:16	381:69	7	
water	381:16	0:0	8	bit_alloc_stages
op	381:32	0:0	8	[
water	381:33	0:0	8	ch
op	381:35	0:0	8	]
op	381:37	0:0	8	=
call	381:39	381:68	8	FFMAX
arg	381:45	381:65	9	bit_alloc_stages[ch]
water	381:45	0:0	10	bit_alloc_stages
op	381:61	0:0	10	[
water	381:62	0:0	10	ch
op	381:64	0:0	10	]
arg	381:67	381:68	9	2
water	381:67	0:0	10	2
water	381:69	0:0	8	;
water	382:8	0:0	6	}
water	383:4	0:0	4	}
else	383:6	386:4	2
stmts	383:11	386:4	3	
if	383:11	386:4	4	(s -> eac3 && ! blk)
cond	383:15	383:27	5	s -> eac3 && ! blk
water	383:15	0:0	6	s
op	383:16	0:0	6	->
water	383:18	0:0	6	eac3
op	383:23	0:0	6	&&
op	383:26	0:0	6	!
water	383:27	0:0	6	blk
stmts	383:32	386:4	5	
water	383:32	0:0	6	{
for	384:8	385:54	6	(ch = ! cpl_in_use ;ch <= s -> channels;ch ++)
forinit	384:13	384:29	7	ch = ! cpl_in_use ;
water	384:13	0:0	8	ch
op	384:16	0:0	8	=
op	384:18	0:0	8	!
water	384:19	0:0	8	cpl_in_use
water	384:29	0:0	8	;
cond	384:31	384:40	7	ch <= s -> channels
water	384:31	0:0	8	ch
op	384:34	0:0	8	<=
water	384:37	0:0	8	s
op	384:38	0:0	8	->
water	384:40	0:0	8	channels
forexpr	384:50	384:52	7	ch ++
water	384:50	0:0	8	ch
op	384:52	0:0	8	++
stmts	385:12	385:54	7	
water	385:12	0:0	8	s
op	385:13	0:0	8	->
water	385:15	0:0	8	fast_gain
op	385:24	0:0	8	[
water	385:25	0:0	8	ch
op	385:27	0:0	8	]
op	385:29	0:0	8	=
water	385:31	0:0	8	ff_ac3_fast_gain_tab
op	385:51	0:0	8	[
water	385:52	0:0	8	4
op	385:53	0:0	8	]
water	385:54	0:0	8	;
water	386:4	0:0	6	}
if	388:4	390:4	2	(s -> frame_type == EAC3_FRAME_TYPE_INDEPENDENT &&get_bits1 (gbc ))
cond	388:8	388:69	3	s -> frame_type == EAC3_FRAME_TYPE_INDEPENDENT &&get_bits1 (gbc )
water	388:8	0:0	4	s
op	388:9	0:0	4	->
water	388:11	0:0	4	frame_type
op	388:22	0:0	4	==
water	388:25	0:0	4	EAC3_FRAME_TYPE_INDEPENDENT
op	388:53	0:0	4	&&
call	388:56	388:69	4	get_bits1
arg	388:66	388:69	5	gbc
water	388:66	0:0	6	gbc
stmts	388:72	390:4	3	
water	388:72	0:0	4	{
call	389:8	389:25	4	skip_bits
arg	389:18	389:21	5	gbc
water	389:18	0:0	6	gbc
arg	389:23	389:25	5	10
water	389:23	0:0	6	10
water	389:26	0:0	4	;
water	390:4	0:0	4	}
if	392:4	410:4	2	(cpl_in_use)
cond	392:8	392:8	3	cpl_in_use
water	392:8	0:0	4	cpl_in_use
stmts	392:20	410:4	3	
water	392:20	0:0	4	{
if	393:8	404:8	4	(s -> first_cpl_leak ||get_bits1 (gbc ))
cond	393:12	393:46	5	s -> first_cpl_leak ||get_bits1 (gbc )
water	393:12	0:0	6	s
op	393:13	0:0	6	->
water	393:15	0:0	6	first_cpl_leak
op	393:30	0:0	6	||
call	393:33	393:46	6	get_bits1
arg	393:43	393:46	7	gbc
water	393:43	0:0	8	gbc
stmts	393:49	404:8	5	
water	393:49	0:0	6	{
decl	394:12	394:37	6	int	fl
op	394:19	0:0	6	=
call	394:21	394:36	7	get_bits
arg	394:30	394:33	8	gbc
water	394:30	0:0	9	gbc
arg	394:35	394:36	8	3
water	394:35	0:0	9	3
decl	395:12	395:37	6	int	sl
op	395:19	0:0	6	=
call	395:21	395:36	7	get_bits
arg	395:30	395:33	8	gbc
water	395:30	0:0	9	gbc
arg	395:35	395:36	8	3
water	395:35	0:0	9	3
if	398:12	401:12	6	(blk && ( fl != s -> bit_alloc_params . cpl_fast_leak || sl != s -> bit_alloc_params . cpl_slow_leak ))
cond	398:16	399:55	7	blk && ( fl != s -> bit_alloc_params . cpl_fast_leak || sl != s -> bit_alloc_params . cpl_slow_leak )
water	398:16	0:0	8	blk
op	398:20	0:0	8	&&
water	398:23	0:0	8	(
water	398:24	0:0	8	fl
op	398:27	0:0	8	!=
water	398:30	0:0	8	s
op	398:31	0:0	8	->
water	398:33	0:0	8	bit_alloc_params
op	398:49	0:0	8	.
water	398:50	0:0	8	cpl_fast_leak
op	398:64	0:0	8	||
water	399:16	0:0	8	sl
op	399:19	0:0	8	!=
water	399:22	0:0	8	s
op	399:23	0:0	8	->
water	399:25	0:0	8	bit_alloc_params
op	399:41	0:0	8	.
water	399:42	0:0	8	cpl_slow_leak
water	399:55	0:0	8	)
stmts	399:58	401:12	7	
water	399:58	0:0	8	{
water	400:16	0:0	8	bit_alloc_stages
op	400:32	0:0	8	[
water	400:33	0:0	8	CPL_CH
op	400:39	0:0	8	]
op	400:41	0:0	8	=
call	400:43	400:76	8	FFMAX
arg	400:49	400:73	9	bit_alloc_stages[CPL_CH]
water	400:49	0:0	10	bit_alloc_stages
op	400:65	0:0	10	[
water	400:66	0:0	10	CPL_CH
op	400:72	0:0	10	]
arg	400:75	400:76	9	2
water	400:75	0:0	10	2
water	400:77	0:0	8	;
water	401:12	0:0	8	}
water	402:12	0:0	6	s
op	402:13	0:0	6	->
water	402:15	0:0	6	bit_alloc_params
op	402:31	0:0	6	.
water	402:32	0:0	6	cpl_fast_leak
op	402:46	0:0	6	=
water	402:48	0:0	6	fl
water	402:50	0:0	6	;
water	403:12	0:0	6	s
op	403:13	0:0	6	->
water	403:15	0:0	6	bit_alloc_params
op	403:31	0:0	6	.
water	403:32	0:0	6	cpl_slow_leak
op	403:46	0:0	6	=
water	403:48	0:0	6	sl
water	403:50	0:0	6	;
water	404:8	0:0	6	}
else	404:10	408:8	4
stmts	404:15	408:8	5	
if	404:15	408:8	6	(! s -> eac3 && ! blk)
cond	404:19	404:32	7	! s -> eac3 && ! blk
op	404:19	0:0	8	!
water	404:20	0:0	8	s
op	404:21	0:0	8	->
water	404:23	0:0	8	eac3
op	404:28	0:0	8	&&
op	404:31	0:0	8	!
water	404:32	0:0	8	blk
stmts	404:37	408:8	7	
water	404:37	0:0	8	{
call	405:12	406:44	8	av_log
arg	405:19	405:27	9	s->avctx
water	405:19	0:0	10	s
op	405:20	0:0	10	->
water	405:22	0:0	10	avctx
arg	405:29	405:41	9	AV_LOG_ERROR
water	405:29	0:0	10	AV_LOG_ERROR
arg	405:43	406:44	9	"new coupling leak info must ""be present in block 0\n"
water	405:43	0:0	10	"new coupling leak info must "
water	406:19	0:0	10	"be present in block 0\n"
water	406:45	0:0	8	;
return	407:12	407:38	8	AVERROR_INVALIDDATA
water	407:19	0:0	9	AVERROR_INVALIDDATA
water	408:8	0:0	8	}
water	409:8	0:0	4	s
op	409:9	0:0	4	->
water	409:11	0:0	4	first_cpl_leak
op	409:26	0:0	4	=
water	409:28	0:0	4	0
water	409:29	0:0	4	;
water	410:4	0:0	4	}
if	412:4	435:4	2	(s -> dba_syntax &&get_bits1 (gbc ))
cond	412:8	412:38	3	s -> dba_syntax &&get_bits1 (gbc )
water	412:8	0:0	4	s
op	412:9	0:0	4	->
water	412:11	0:0	4	dba_syntax
op	412:22	0:0	4	&&
call	412:25	412:38	4	get_bits1
arg	412:35	412:38	5	gbc
water	412:35	0:0	6	gbc
stmts	412:41	435:4	3	
water	412:41	0:0	4	{
for	414:8	421:8	4	(ch = ! cpl_in_use ;ch <= fbw_channels;ch ++)
forinit	414:13	414:29	5	ch = ! cpl_in_use ;
water	414:13	0:0	6	ch
op	414:16	0:0	6	=
op	414:18	0:0	6	!
water	414:19	0:0	6	cpl_in_use
water	414:29	0:0	6	;
cond	414:31	414:37	5	ch <= fbw_channels
water	414:31	0:0	6	ch
op	414:34	0:0	6	<=
water	414:37	0:0	6	fbw_channels
forexpr	414:51	414:53	5	ch ++
water	414:51	0:0	6	ch
op	414:53	0:0	6	++
stmts	414:57	421:8	5	
water	414:57	0:0	6	{
water	415:12	0:0	6	s
op	415:13	0:0	6	->
water	415:15	0:0	6	dba_mode
op	415:23	0:0	6	[
water	415:24	0:0	6	ch
op	415:26	0:0	6	]
op	415:28	0:0	6	=
call	415:30	415:45	6	get_bits
arg	415:39	415:42	7	gbc
water	415:39	0:0	8	gbc
arg	415:44	415:45	7	2
water	415:44	0:0	8	2
water	415:46	0:0	6	;
if	416:12	419:12	6	(s -> dba_mode [ ch ] == DBA_RESERVED)
cond	416:16	416:35	7	s -> dba_mode [ ch ] == DBA_RESERVED
water	416:16	0:0	8	s
op	416:17	0:0	8	->
water	416:19	0:0	8	dba_mode
op	416:27	0:0	8	[
water	416:28	0:0	8	ch
op	416:30	0:0	8	]
op	416:32	0:0	8	==
water	416:35	0:0	8	DBA_RESERVED
stmts	416:49	419:12	7	
water	416:49	0:0	8	{
call	417:16	417:89	8	av_log
arg	417:23	417:31	9	s->avctx
water	417:23	0:0	10	s
op	417:24	0:0	10	->
water	417:26	0:0	10	avctx
arg	417:33	417:45	9	AV_LOG_ERROR
water	417:33	0:0	10	AV_LOG_ERROR
arg	417:47	417:89	9	"delta bit allocation strategy reserved\n"
water	417:47	0:0	10	"delta bit allocation strategy reserved\n"
water	417:90	0:0	8	;
return	418:16	418:42	8	AVERROR_INVALIDDATA
water	418:23	0:0	9	AVERROR_INVALIDDATA
water	419:12	0:0	8	}
water	420:12	0:0	6	bit_alloc_stages
op	420:28	0:0	6	[
water	420:29	0:0	6	ch
op	420:31	0:0	6	]
op	420:33	0:0	6	=
call	420:35	420:64	6	FFMAX
arg	420:41	420:61	7	bit_alloc_stages[ch]
water	420:41	0:0	8	bit_alloc_stages
op	420:57	0:0	8	[
water	420:58	0:0	8	ch
op	420:60	0:0	8	]
arg	420:63	420:64	7	2
water	420:63	0:0	8	2
water	420:65	0:0	6	;
water	421:8	0:0	6	}
for	423:8	434:8	4	(ch = ! cpl_in_use ;ch <= fbw_channels;ch ++)
forinit	423:13	423:29	5	ch = ! cpl_in_use ;
water	423:13	0:0	6	ch
op	423:16	0:0	6	=
op	423:18	0:0	6	!
water	423:19	0:0	6	cpl_in_use
water	423:29	0:0	6	;
cond	423:31	423:37	5	ch <= fbw_channels
water	423:31	0:0	6	ch
op	423:34	0:0	6	<=
water	423:37	0:0	6	fbw_channels
forexpr	423:51	423:53	5	ch ++
water	423:51	0:0	6	ch
op	423:53	0:0	6	++
stmts	423:57	434:8	5	
water	423:57	0:0	6	{
if	424:12	433:12	6	(s -> dba_mode [ ch ] == DBA_NEW)
cond	424:16	424:35	7	s -> dba_mode [ ch ] == DBA_NEW
water	424:16	0:0	8	s
op	424:17	0:0	8	->
water	424:19	0:0	8	dba_mode
op	424:27	0:0	8	[
water	424:28	0:0	8	ch
op	424:30	0:0	8	]
op	424:32	0:0	8	==
water	424:35	0:0	8	DBA_NEW
stmts	424:44	433:12	7	
water	424:44	0:0	8	{
water	425:16	0:0	8	s
op	425:17	0:0	8	->
water	425:19	0:0	8	dba_nsegs
op	425:28	0:0	8	[
water	425:29	0:0	8	ch
op	425:31	0:0	8	]
op	425:33	0:0	8	=
call	425:35	425:50	8	get_bits
arg	425:44	425:47	9	gbc
water	425:44	0:0	10	gbc
arg	425:49	425:50	9	3
water	425:49	0:0	10	3
op	425:52	0:0	8	+
water	425:54	0:0	8	1
water	425:55	0:0	8	;
for	426:16	430:16	8	(seg = 0 ;seg < s -> dba_nsegs [ ch ];seg ++)
forinit	426:21	426:28	9	seg = 0 ;
water	426:21	0:0	10	seg
op	426:25	0:0	10	=
water	426:27	0:0	10	0
water	426:28	0:0	10	;
cond	426:30	426:51	9	seg < s -> dba_nsegs [ ch ]
water	426:30	0:0	10	seg
op	426:34	0:0	10	<
water	426:36	0:0	10	s
op	426:37	0:0	10	->
water	426:39	0:0	10	dba_nsegs
op	426:48	0:0	10	[
water	426:49	0:0	10	ch
op	426:51	0:0	10	]
forexpr	426:54	426:57	9	seg ++
water	426:54	0:0	10	seg
op	426:57	0:0	10	++
stmts	426:61	430:16	9	
water	426:61	0:0	10	{
water	427:20	0:0	10	s
op	427:21	0:0	10	->
water	427:23	0:0	10	dba_offsets
op	427:34	0:0	10	[
water	427:35	0:0	10	ch
op	427:37	0:0	10	]
op	427:38	0:0	10	[
water	427:39	0:0	10	seg
op	427:42	0:0	10	]
op	427:44	0:0	10	=
call	427:46	427:61	10	get_bits
arg	427:55	427:58	11	gbc
water	427:55	0:0	12	gbc
arg	427:60	427:61	11	5
water	427:60	0:0	12	5
water	427:62	0:0	10	;
water	428:20	0:0	10	s
op	428:21	0:0	10	->
water	428:23	0:0	10	dba_lengths
op	428:34	0:0	10	[
water	428:35	0:0	10	ch
op	428:37	0:0	10	]
op	428:38	0:0	10	[
water	428:39	0:0	10	seg
op	428:42	0:0	10	]
op	428:44	0:0	10	=
call	428:46	428:61	10	get_bits
arg	428:55	428:58	11	gbc
water	428:55	0:0	12	gbc
arg	428:60	428:61	11	4
water	428:60	0:0	12	4
water	428:62	0:0	10	;
water	429:20	0:0	10	s
op	429:21	0:0	10	->
water	429:23	0:0	10	dba_values
op	429:33	0:0	10	[
water	429:34	0:0	10	ch
op	429:36	0:0	10	]
op	429:37	0:0	10	[
water	429:38	0:0	10	seg
op	429:41	0:0	10	]
op	429:44	0:0	10	=
call	429:46	429:61	10	get_bits
arg	429:55	429:58	11	gbc
water	429:55	0:0	12	gbc
arg	429:60	429:61	11	3
water	429:60	0:0	12	3
water	429:62	0:0	10	;
water	430:16	0:0	10	}
water	432:16	0:0	8	bit_alloc_stages
op	432:32	0:0	8	[
water	432:33	0:0	8	ch
op	432:35	0:0	8	]
op	432:37	0:0	8	=
call	432:39	432:68	8	FFMAX
arg	432:45	432:65	9	bit_alloc_stages[ch]
water	432:45	0:0	10	bit_alloc_stages
op	432:61	0:0	10	[
water	432:62	0:0	10	ch
op	432:64	0:0	10	]
arg	432:67	432:68	9	2
water	432:67	0:0	10	2
water	432:69	0:0	8	;
water	433:12	0:0	8	}
water	434:8	0:0	6	}
water	435:4	0:0	4	}
else	435:6	439:4	2
stmts	435:11	439:4	3	
if	435:11	439:4	4	(blk == 0)
cond	435:15	435:22	5	blk == 0
water	435:15	0:0	6	blk
op	435:19	0:0	6	==
water	435:22	0:0	6	0
stmts	435:25	439:4	5	
water	435:25	0:0	6	{
for	436:8	438:8	6	(ch = 0 ;ch <= s -> channels;ch ++)
forinit	436:13	436:19	7	ch = 0 ;
water	436:13	0:0	8	ch
op	436:16	0:0	8	=
water	436:18	0:0	8	0
water	436:19	0:0	8	;
cond	436:21	436:30	7	ch <= s -> channels
water	436:21	0:0	8	ch
op	436:24	0:0	8	<=
water	436:27	0:0	8	s
op	436:28	0:0	8	->
water	436:30	0:0	8	channels
forexpr	436:40	436:42	7	ch ++
water	436:40	0:0	8	ch
op	436:42	0:0	8	++
stmts	436:46	438:8	7	
water	436:46	0:0	8	{
water	437:12	0:0	8	s
op	437:13	0:0	8	->
water	437:15	0:0	8	dba_mode
op	437:23	0:0	8	[
water	437:24	0:0	8	ch
op	437:26	0:0	8	]
op	437:28	0:0	8	=
water	437:30	0:0	8	DBA_NONE
water	437:38	0:0	8	;
water	438:8	0:0	8	}
water	439:4	0:0	6	}
for	441:4	471:4	2	(ch = ! cpl_in_use ;ch <= s -> channels;ch ++)
forinit	441:9	441:25	3	ch = ! cpl_in_use ;
water	441:9	0:0	4	ch
op	441:12	0:0	4	=
op	441:14	0:0	4	!
water	441:15	0:0	4	cpl_in_use
water	441:25	0:0	4	;
cond	441:27	441:36	3	ch <= s -> channels
water	441:27	0:0	4	ch
op	441:30	0:0	4	<=
water	441:33	0:0	4	s
op	441:34	0:0	4	->
water	441:36	0:0	4	channels
forexpr	441:46	441:48	3	ch ++
water	441:46	0:0	4	ch
op	441:48	0:0	4	++
stmts	441:52	471:4	3	
water	441:52	0:0	4	{
if	442:8	447:8	4	(bit_alloc_stages [ ch ] > 2)
cond	442:12	442:35	5	bit_alloc_stages [ ch ] > 2
water	442:12	0:0	6	bit_alloc_stages
op	442:28	0:0	6	[
water	442:29	0:0	6	ch
op	442:31	0:0	6	]
op	442:33	0:0	6	>
water	442:35	0:0	6	2
stmts	442:38	447:8	5	
water	442:38	0:0	6	{
call	444:12	446:65	6	ff_ac3_bit_alloc_calc_psd
arg	444:38	444:50	7	s->dexps[ch]
water	444:38	0:0	8	s
op	444:39	0:0	8	->
water	444:41	0:0	8	dexps
op	444:46	0:0	8	[
water	444:47	0:0	8	ch
op	444:49	0:0	8	]
arg	445:38	445:55	7	s->start_freq[ch]
water	445:38	0:0	8	s
op	445:39	0:0	8	->
water	445:41	0:0	8	start_freq
op	445:51	0:0	8	[
water	445:52	0:0	8	ch
op	445:54	0:0	8	]
arg	445:57	445:72	7	s->end_freq[ch]
water	445:57	0:0	8	s
op	445:58	0:0	8	->
water	445:60	0:0	8	end_freq
op	445:68	0:0	8	[
water	445:69	0:0	8	ch
op	445:71	0:0	8	]
arg	446:38	446:48	7	s->psd[ch]
water	446:38	0:0	8	s
op	446:39	0:0	8	->
water	446:41	0:0	8	psd
op	446:44	0:0	8	[
water	446:45	0:0	8	ch
op	446:47	0:0	8	]
arg	446:50	446:65	7	s->band_psd[ch]
water	446:50	0:0	8	s
op	446:51	0:0	8	->
water	446:53	0:0	8	band_psd
op	446:61	0:0	8	[
water	446:62	0:0	8	ch
op	446:64	0:0	8	]
water	446:66	0:0	6	;
water	447:8	0:0	6	}
if	448:8	460:8	4	(bit_alloc_stages [ ch ] > 1)
cond	448:12	448:35	5	bit_alloc_stages [ ch ] > 1
water	448:12	0:0	6	bit_alloc_stages
op	448:28	0:0	6	[
water	448:29	0:0	6	ch
op	448:31	0:0	6	]
op	448:33	0:0	6	>
water	448:35	0:0	6	1
stmts	448:38	460:8	5	
water	448:38	0:0	6	{
if	451:12	459:12	6	(ff_ac3_bit_alloc_calc_mask (& s -> bit_alloc_params ,s -> band_psd [ ch ] ,s -> start_freq [ ch ] ,s -> end_freq [ ch ] ,s -> fast_gain [ ch ] ,( ch == s -> lfe_ch ) ,s -> dba_mode [ ch ] ,s -> dba_nsegs [ ch ] ,s -> dba_offsets [ ch ] ,s -> dba_lengths [ ch ] ,s -> dba_values [ ch ] ,s -> mask [ ch ] ))
cond	451:16	456:74	7	ff_ac3_bit_alloc_calc_mask (& s -> bit_alloc_params ,s -> band_psd [ ch ] ,s -> start_freq [ ch ] ,s -> end_freq [ ch ] ,s -> fast_gain [ ch ] ,( ch == s -> lfe_ch ) ,s -> dba_mode [ ch ] ,s -> dba_nsegs [ ch ] ,s -> dba_offsets [ ch ] ,s -> dba_lengths [ ch ] ,s -> dba_values [ ch ] ,s -> mask [ ch ] )
call	451:16	456:74	8	ff_ac3_bit_alloc_calc_mask
arg	451:43	451:63	9	&s->bit_alloc_params
op	451:43	0:0	10	&
water	451:44	0:0	10	s
op	451:45	0:0	10	->
water	451:47	0:0	10	bit_alloc_params
arg	451:65	451:80	9	s->band_psd[ch]
water	451:65	0:0	10	s
op	451:66	0:0	10	->
water	451:68	0:0	10	band_psd
op	451:76	0:0	10	[
water	451:77	0:0	10	ch
op	451:79	0:0	10	]
arg	452:43	452:60	9	s->start_freq[ch]
water	452:43	0:0	10	s
op	452:44	0:0	10	->
water	452:46	0:0	10	start_freq
op	452:56	0:0	10	[
water	452:57	0:0	10	ch
op	452:59	0:0	10	]
arg	452:63	452:78	9	s->end_freq[ch]
water	452:63	0:0	10	s
op	452:64	0:0	10	->
water	452:66	0:0	10	end_freq
op	452:74	0:0	10	[
water	452:75	0:0	10	ch
op	452:77	0:0	10	]
arg	453:43	453:59	9	s->fast_gain[ch]
water	453:43	0:0	10	s
op	453:44	0:0	10	->
water	453:46	0:0	10	fast_gain
op	453:55	0:0	10	[
water	453:56	0:0	10	ch
op	453:58	0:0	10	]
arg	453:63	453:80	9	(ch==s->lfe_ch)
water	453:63	0:0	10	(
water	453:64	0:0	10	ch
op	453:67	0:0	10	==
water	453:70	0:0	10	s
op	453:71	0:0	10	->
water	453:73	0:0	10	lfe_ch
water	453:79	0:0	10	)
arg	454:43	454:58	9	s->dba_mode[ch]
water	454:43	0:0	10	s
op	454:44	0:0	10	->
water	454:46	0:0	10	dba_mode
op	454:54	0:0	10	[
water	454:55	0:0	10	ch
op	454:57	0:0	10	]
arg	454:63	454:79	9	s->dba_nsegs[ch]
water	454:63	0:0	10	s
op	454:64	0:0	10	->
water	454:66	0:0	10	dba_nsegs
op	454:75	0:0	10	[
water	454:76	0:0	10	ch
op	454:78	0:0	10	]
arg	455:43	455:61	9	s->dba_offsets[ch]
water	455:43	0:0	10	s
op	455:44	0:0	10	->
water	455:46	0:0	10	dba_offsets
op	455:57	0:0	10	[
water	455:58	0:0	10	ch
op	455:60	0:0	10	]
arg	455:63	455:81	9	s->dba_lengths[ch]
water	455:63	0:0	10	s
op	455:64	0:0	10	->
water	455:66	0:0	10	dba_lengths
op	455:77	0:0	10	[
water	455:78	0:0	10	ch
op	455:80	0:0	10	]
arg	456:43	456:60	9	s->dba_values[ch]
water	456:43	0:0	10	s
op	456:44	0:0	10	->
water	456:46	0:0	10	dba_values
op	456:56	0:0	10	[
water	456:57	0:0	10	ch
op	456:59	0:0	10	]
arg	456:63	456:74	9	s->mask[ch]
water	456:63	0:0	10	s
op	456:64	0:0	10	->
water	456:66	0:0	10	mask
op	456:70	0:0	10	[
water	456:71	0:0	10	ch
op	456:73	0:0	10	]
stmts	456:77	459:12	7	
water	456:77	0:0	8	{
call	457:16	457:74	8	av_log
arg	457:23	457:31	9	s->avctx
water	457:23	0:0	10	s
op	457:24	0:0	10	->
water	457:26	0:0	10	avctx
arg	457:33	457:45	9	AV_LOG_ERROR
water	457:33	0:0	10	AV_LOG_ERROR
arg	457:47	457:74	9	"error in bit allocation\n"
water	457:47	0:0	10	"error in bit allocation\n"
water	457:75	0:0	8	;
return	458:16	458:42	8	AVERROR_INVALIDDATA
water	458:23	0:0	9	AVERROR_INVALIDDATA
water	459:12	0:0	8	}
water	460:8	0:0	6	}
if	461:8	470:8	4	(bit_alloc_stages [ ch ] > 0)
cond	461:12	461:35	5	bit_alloc_stages [ ch ] > 0
water	461:12	0:0	6	bit_alloc_stages
op	461:28	0:0	6	[
water	461:29	0:0	6	ch
op	461:31	0:0	6	]
op	461:33	0:0	6	>
water	461:35	0:0	6	0
stmts	461:38	470:8	5	
water	461:38	0:0	6	{
decl	463:12	464:71	6	const uint8_t	*bap_tab
op	463:35	0:0	6	=
water	463:37	0:0	6	s
op	463:38	0:0	6	->
water	463:40	0:0	6	channel_uses_aht
op	463:56	0:0	6	[
water	463:57	0:0	6	ch
op	463:59	0:0	6	]
water	463:61	0:0	6	?
water	464:37	0:0	6	ff_eac3_hebap_tab
water	464:55	0:0	6	:
water	464:57	0:0	6	ff_ac3_bap_tab
call	465:12	469:57	6	s->ac3dsp.bit_alloc_calc_bap
arg	465:41	465:52	7	s->mask[ch]
water	465:41	0:0	8	s
op	465:42	0:0	8	->
water	465:44	0:0	8	mask
op	465:48	0:0	8	[
water	465:49	0:0	8	ch
op	465:51	0:0	8	]
arg	465:54	465:64	7	s->psd[ch]
water	465:54	0:0	8	s
op	465:55	0:0	8	->
water	465:57	0:0	8	psd
op	465:60	0:0	8	[
water	465:61	0:0	8	ch
op	465:63	0:0	8	]
arg	466:38	466:55	7	s->start_freq[ch]
water	466:38	0:0	8	s
op	466:39	0:0	8	->
water	466:41	0:0	8	start_freq
op	466:51	0:0	8	[
water	466:52	0:0	8	ch
op	466:54	0:0	8	]
arg	466:57	466:72	7	s->end_freq[ch]
water	466:57	0:0	8	s
op	466:58	0:0	8	->
water	466:60	0:0	8	end_freq
op	466:68	0:0	8	[
water	466:69	0:0	8	ch
op	466:71	0:0	8	]
arg	467:38	467:55	7	s->snr_offset[ch]
water	467:38	0:0	8	s
op	467:39	0:0	8	->
water	467:41	0:0	8	snr_offset
op	467:51	0:0	8	[
water	467:52	0:0	8	ch
op	467:54	0:0	8	]
arg	468:38	468:63	7	s->bit_alloc_params.floor
water	468:38	0:0	8	s
op	468:39	0:0	8	->
water	468:41	0:0	8	bit_alloc_params
op	468:57	0:0	8	.
water	468:58	0:0	8	floor
arg	469:38	469:45	7	bap_tab
water	469:38	0:0	8	bap_tab
arg	469:47	469:57	7	s->bap[ch]
water	469:47	0:0	8	s
op	469:48	0:0	8	->
water	469:50	0:0	8	bap
op	469:53	0:0	8	[
water	469:54	0:0	8	ch
op	469:56	0:0	8	]
water	469:58	0:0	6	;
water	470:8	0:0	6	}
water	471:4	0:0	4	}
if	473:4	477:4	2	(s -> skip_syntax &&get_bits1 (gbc ))
cond	473:8	473:39	3	s -> skip_syntax &&get_bits1 (gbc )
water	473:8	0:0	4	s
op	473:9	0:0	4	->
water	473:11	0:0	4	skip_syntax
op	473:23	0:0	4	&&
call	473:26	473:39	4	get_bits1
arg	473:36	473:39	5	gbc
water	473:36	0:0	6	gbc
stmts	473:42	477:4	3	
water	473:42	0:0	4	{
decl	474:8	474:36	4	int	skipl
op	474:18	0:0	4	=
call	474:20	474:35	5	get_bits
arg	474:29	474:32	6	gbc
water	474:29	0:0	7	gbc
arg	474:34	474:35	6	9
water	474:34	0:0	7	9
while	475:8	476:29	4	(skipl --)
cond	475:15	475:20	5	skipl --
water	475:15	0:0	6	skipl
op	475:20	0:0	6	--
stmts	476:12	476:29	5	
call	476:12	476:28	6	skip_bits
arg	476:22	476:25	7	gbc
water	476:22	0:0	8	gbc
arg	476:27	476:28	7	8
water	476:27	0:0	8	8
water	476:29	0:0	6	;
water	477:4	0:0	4	}
call	480:4	480:34	2	decode_transform_coeffs
arg	480:28	480:29	3	s
water	480:28	0:0	4	s
arg	480:31	480:34	3	blk
water	480:31	0:0	4	blk
water	480:35	0:0	2	;
if	483:4	484:25	2	(s -> channel_mode == AC3_CHMODE_STEREO)
cond	483:8	483:27	3	s -> channel_mode == AC3_CHMODE_STEREO
water	483:8	0:0	4	s
op	483:9	0:0	4	->
water	483:11	0:0	4	channel_mode
op	483:24	0:0	4	==
water	483:27	0:0	4	AC3_CHMODE_STEREO
stmts	484:8	484:25	3	
call	484:8	484:24	4	do_rematrixing
arg	484:23	484:24	5	s
water	484:23	0:0	6	s
water	484:25	0:0	4	;
for	486:4	504:4	2	(ch = 1 ;ch <= s -> channels;ch ++)
forinit	486:9	486:15	3	ch = 1 ;
water	486:9	0:0	4	ch
op	486:12	0:0	4	=
water	486:14	0:0	4	1
water	486:15	0:0	4	;
cond	486:17	486:26	3	ch <= s -> channels
water	486:17	0:0	4	ch
op	486:20	0:0	4	<=
water	486:23	0:0	4	s
op	486:24	0:0	4	->
water	486:26	0:0	4	channels
forexpr	486:36	486:38	3	ch ++
water	486:36	0:0	4	ch
op	486:38	0:0	4	++
stmts	486:42	504:4	3	
water	486:42	0:0	4	{
decl	487:8	487:29	4	int	audio_channel
op	487:26	0:0	4	=
water	487:28	0:0	4	0
decl	488:8	488:21	4	INTFLOAT	gain
if	489:8	490:32	4	(s -> channel_mode == AC3_CHMODE_DUALMONO)
cond	489:12	489:31	5	s -> channel_mode == AC3_CHMODE_DUALMONO
water	489:12	0:0	6	s
op	489:13	0:0	6	->
water	489:15	0:0	6	channel_mode
op	489:28	0:0	6	==
water	489:31	0:0	6	AC3_CHMODE_DUALMONO
stmts	490:12	490:32	5	
water	490:12	0:0	6	audio_channel
op	490:26	0:0	6	=
water	490:28	0:0	6	2
op	490:29	0:0	6	-
water	490:30	0:0	6	ch
water	490:32	0:0	6	;
if	491:8	492:56	4	(s -> heavy_compression && s -> compression_exists [ audio_channel ])
cond	491:12	491:71	5	s -> heavy_compression && s -> compression_exists [ audio_channel ]
water	491:12	0:0	6	s
op	491:13	0:0	6	->
water	491:15	0:0	6	heavy_compression
op	491:33	0:0	6	&&
water	491:36	0:0	6	s
op	491:37	0:0	6	->
water	491:39	0:0	6	compression_exists
op	491:57	0:0	6	[
water	491:58	0:0	6	audio_channel
op	491:71	0:0	6	]
stmts	492:12	492:56	5	
water	492:12	0:0	6	gain
op	492:17	0:0	6	=
water	492:19	0:0	6	s
op	492:20	0:0	6	->
water	492:22	0:0	6	heavy_dynamic_range
op	492:41	0:0	6	[
water	492:42	0:0	6	audio_channel
op	492:55	0:0	6	]
water	492:56	0:0	6	;
else	493:8	494:50	4
stmts	494:12	494:50	5	
water	494:12	0:0	6	gain
op	494:17	0:0	6	=
water	494:19	0:0	6	s
op	494:20	0:0	6	->
water	494:22	0:0	6	dynamic_range
op	494:35	0:0	6	[
water	494:36	0:0	6	audio_channel
op	494:49	0:0	6	]
water	494:50	0:0	6	;
call	496:8	496:75	4	scale_coefs
arg	496:20	496:43	5	s->transform_coeffs[ch]
water	496:20	0:0	6	s
op	496:21	0:0	6	->
water	496:23	0:0	6	transform_coeffs
op	496:39	0:0	6	[
water	496:40	0:0	6	ch
op	496:42	0:0	6	]
arg	496:45	496:64	5	s->fixed_coeffs[ch]
water	496:45	0:0	6	s
op	496:46	0:0	6	->
water	496:48	0:0	6	fixed_coeffs
op	496:60	0:0	6	[
water	496:61	0:0	6	ch
op	496:63	0:0	6	]
arg	496:66	496:70	5	gain
water	496:66	0:0	6	gain
arg	496:72	496:75	5	256
water	496:72	0:0	6	256
water	496:76	0:0	4	;
if	498:8	499:52	4	(s -> target_level != 0)
cond	498:12	498:31	5	s -> target_level != 0
water	498:12	0:0	6	s
op	498:13	0:0	6	->
water	498:15	0:0	6	target_level
op	498:28	0:0	6	!=
water	498:31	0:0	6	0
stmts	499:10	499:52	5	
water	499:10	0:0	6	gain
op	499:15	0:0	6	=
water	499:17	0:0	6	gain
op	499:22	0:0	6	*
water	499:24	0:0	6	s
op	499:25	0:0	6	->
water	499:27	0:0	6	level_gain
op	499:37	0:0	6	[
water	499:38	0:0	6	audio_channel
op	499:51	0:0	6	]
water	499:52	0:0	6	;
water	500:8	0:0	4	gain
op	500:13	0:0	4	*=
water	500:16	0:0	4	1
op	500:17	0:0	4	.
water	500:18	0:0	4	0
op	500:20	0:0	4	/
water	500:22	0:0	4	4194304
op	500:29	0:0	4	.
water	500:30	0:0	4	0
water	500:31	0:0	4	f
water	500:32	0:0	4	;
call	501:8	502:77	4	s->fmt_conv.int32_to_float_fmul_scalar
arg	501:47	501:70	5	s->transform_coeffs[ch]
water	501:47	0:0	6	s
op	501:48	0:0	6	->
water	501:50	0:0	6	transform_coeffs
op	501:66	0:0	6	[
water	501:67	0:0	6	ch
op	501:69	0:0	6	]
arg	502:47	502:66	5	s->fixed_coeffs[ch]
water	502:47	0:0	6	s
op	502:48	0:0	6	->
water	502:50	0:0	6	fixed_coeffs
op	502:62	0:0	6	[
water	502:63	0:0	6	ch
op	502:65	0:0	6	]
arg	502:68	502:72	5	gain
water	502:68	0:0	6	gain
arg	502:74	502:77	5	256
water	502:74	0:0	6	256
water	502:78	0:0	4	;
water	504:4	0:0	4	}
if	506:4	508:4	2	(CONFIG_EAC3_DECODER && s -> spx_in_use)
cond	506:8	506:34	3	CONFIG_EAC3_DECODER && s -> spx_in_use
water	506:8	0:0	4	CONFIG_EAC3_DECODER
op	506:28	0:0	4	&&
water	506:31	0:0	4	s
op	506:32	0:0	4	->
water	506:34	0:0	4	spx_in_use
stmts	506:46	508:4	3	
water	506:46	0:0	4	{
call	507:8	507:42	4	ff_eac3_apply_spectral_extension
arg	507:41	507:42	5	s
water	507:41	0:0	6	s
water	507:43	0:0	4	;
water	508:4	0:0	4	}
water	512:4	0:0	2	downmix_output
op	512:19	0:0	2	=
water	512:21	0:0	2	s
op	512:22	0:0	2	->
water	512:24	0:0	2	channels
op	512:33	0:0	2	!=
water	512:36	0:0	2	s
op	512:37	0:0	2	->
water	512:39	0:0	2	out_channels
op	512:52	0:0	2	&&
op	513:21	0:0	2	!
water	513:22	0:0	2	(
water	513:23	0:0	2	(
water	513:24	0:0	2	s
op	513:25	0:0	2	->
water	513:27	0:0	2	output_mode
op	513:39	0:0	2	&
water	513:41	0:0	2	AC3_OUTPUT_LFEON
water	513:57	0:0	2	)
op	513:59	0:0	2	&&
water	514:21	0:0	2	s
op	514:22	0:0	2	->
water	514:24	0:0	2	fbw_channels
op	514:37	0:0	2	==
water	514:40	0:0	2	s
op	514:41	0:0	2	->
water	514:43	0:0	2	out_channels
water	514:55	0:0	2	)
water	514:56	0:0	2	;
if	515:4	532:4	2	(different_transforms)
cond	515:8	515:8	3	different_transforms
water	515:8	0:0	4	different_transforms
stmts	515:30	532:4	3	
water	515:30	0:0	4	{
if	518:8	521:8	4	(s -> downmixed)
cond	518:12	518:15	5	s -> downmixed
water	518:12	0:0	6	s
op	518:13	0:0	6	->
water	518:15	0:0	6	downmixed
stmts	518:26	521:8	5	
water	518:26	0:0	6	{
water	519:12	0:0	6	s
op	519:13	0:0	6	->
water	519:15	0:0	6	downmixed
op	519:25	0:0	6	=
water	519:27	0:0	6	0
water	519:28	0:0	6	;
call	520:12	520:29	6	ac3_upmix_delay
arg	520:28	520:29	7	s
water	520:28	0:0	8	s
water	520:30	0:0	6	;
water	521:8	0:0	6	}
call	522:8	522:31	4	do_imdct
arg	522:17	522:18	5	s
water	522:17	0:0	6	s
arg	522:20	522:31	5	s->channels
water	522:20	0:0	6	s
op	522:21	0:0	6	->
water	522:23	0:0	6	channels
water	522:32	0:0	4	;
if	523:8	531:8	4	(downmix_output)
cond	523:12	523:12	5	downmix_output
water	523:12	0:0	6	downmix_output
stmts	523:28	531:8	5	
water	523:28	0:0	6	{
call	525:12	526:67	6	ac3_downmix_c_fixed16
arg	525:34	525:43	7	s->outptr
water	525:34	0:0	8	s
op	525:35	0:0	8	->
water	525:37	0:0	8	outptr
arg	525:45	525:62	7	s->downmix_coeffs
water	525:45	0:0	8	s
op	525:46	0:0	8	->
water	525:48	0:0	8	downmix_coeffs
arg	526:30	526:45	7	s->out_channels
water	526:30	0:0	8	s
op	526:31	0:0	8	->
water	526:33	0:0	8	out_channels
arg	526:47	526:62	7	s->fbw_channels
water	526:47	0:0	8	s
op	526:48	0:0	8	->
water	526:50	0:0	8	fbw_channels
arg	526:64	526:67	7	256
water	526:64	0:0	8	256
water	526:68	0:0	6	;
call	528:12	529:67	6	s->ac3dsp.downmix
arg	528:30	528:39	7	s->outptr
water	528:30	0:0	8	s
op	528:31	0:0	8	->
water	528:33	0:0	8	outptr
arg	528:41	528:58	7	s->downmix_coeffs
water	528:41	0:0	8	s
op	528:42	0:0	8	->
water	528:44	0:0	8	downmix_coeffs
arg	529:30	529:45	7	s->out_channels
water	529:30	0:0	8	s
op	529:31	0:0	8	->
water	529:33	0:0	8	out_channels
arg	529:47	529:62	7	s->fbw_channels
water	529:47	0:0	8	s
op	529:48	0:0	8	->
water	529:50	0:0	8	fbw_channels
arg	529:64	529:67	7	256
water	529:64	0:0	8	256
water	529:68	0:0	6	;
water	531:8	0:0	6	}
water	532:4	0:0	4	}
else	532:6	543:4	2
stmts	532:11	543:4	3	
water	532:11	0:0	4	{
if	533:8	536:8	4	(downmix_output)
cond	533:12	533:12	5	downmix_output
water	533:12	0:0	6	downmix_output
stmts	533:28	536:8	5	
water	533:28	0:0	6	{
call	534:12	534:40	6	s->ac3dsp.AC3_RENAME
arg	534:33	534:40	7	downmix
water	534:33	0:0	8	downmix
water	534:41	0:0	6	(
water	534:42	0:0	6	s
op	534:43	0:0	6	->
water	534:45	0:0	6	xcfptr
op	534:52	0:0	6	+
water	534:54	0:0	6	1
water	534:55	0:0	6	,
water	534:57	0:0	6	s
op	534:58	0:0	6	->
water	534:60	0:0	6	downmix_coeffs
water	534:74	0:0	6	,
water	535:42	0:0	6	s
op	535:43	0:0	6	->
water	535:45	0:0	6	out_channels
water	535:57	0:0	6	,
water	535:59	0:0	6	s
op	535:60	0:0	6	->
water	535:62	0:0	6	fbw_channels
water	535:74	0:0	6	,
water	535:76	0:0	6	256
water	535:79	0:0	6	)
water	535:80	0:0	6	;
water	536:8	0:0	6	}
if	537:8	541:8	4	(downmix_output && ! s -> downmixed)
cond	537:12	537:34	5	downmix_output && ! s -> downmixed
water	537:12	0:0	6	downmix_output
op	537:27	0:0	6	&&
op	537:30	0:0	6	!
water	537:31	0:0	6	s
op	537:32	0:0	6	->
water	537:34	0:0	6	downmixed
stmts	537:45	541:8	5	
water	537:45	0:0	6	{
water	538:12	0:0	6	s
op	538:13	0:0	6	->
water	538:15	0:0	6	downmixed
op	538:25	0:0	6	=
water	538:27	0:0	6	1
water	538:28	0:0	6	;
call	539:12	539:40	6	s->ac3dsp.AC3_RENAME
arg	539:33	539:40	7	downmix
water	539:33	0:0	8	downmix
water	539:41	0:0	6	(
water	539:42	0:0	6	s
op	539:43	0:0	6	->
water	539:45	0:0	6	dlyptr
water	539:51	0:0	6	,
water	539:53	0:0	6	s
op	539:54	0:0	6	->
water	539:56	0:0	6	downmix_coeffs
water	539:70	0:0	6	,
water	540:42	0:0	6	s
op	540:43	0:0	6	->
water	540:45	0:0	6	out_channels
water	540:57	0:0	6	,
water	540:59	0:0	6	s
op	540:60	0:0	6	->
water	540:62	0:0	6	fbw_channels
water	540:74	0:0	6	,
water	540:76	0:0	6	128
water	540:79	0:0	6	)
water	540:80	0:0	6	;
water	541:8	0:0	6	}
call	542:8	542:35	4	do_imdct
arg	542:17	542:18	5	s
water	542:17	0:0	6	s
arg	542:20	542:35	5	s->out_channels
water	542:20	0:0	6	s
op	542:21	0:0	6	->
water	542:23	0:0	6	out_channels
water	542:36	0:0	4	;
water	543:4	0:0	4	}
return	544:4	544:12	2	0
water	544:11	0:0	3	0
