func	1:0	59:0	0	static int	yae_load_frag
params	1:24	0:0	1	
param	1:25	1:46	2	ATempoContext *	atempo
param	2:25	2:48	2	const uint8_t * *	src_ref
param	3:25	3:47	2	const uint8_t *	src_end
stmnts	0:0	58:12	1	
decl	6:4	6:47	2	AudioFragment	*frag
op	6:24	0:0	2	=
call	6:26	6:46	3	yae_curr_frag
arg	6:40	6:46	4	atempo
water	6:40	0:0	5	atempo
decl	7:4	7:16	2	uint8_t	*dst
decl	8:4	8:33	2	int64_t	missing
water	8:19	0:0	2	,
decl	8:4	8:33	2	int64_t	start
water	8:26	0:0	2	,
decl	8:4	8:33	2	int64_t	zeros
decl	9:4	9:21	2	uint32_t	nsamples
decl	10:4	10:24	2	const uint8_t	*a
water	10:20	0:0	2	,
decl	10:4	10:24	2	const uint8_t	*b
decl	11:4	11:30	2	int	i0
water	11:10	0:0	2	,
decl	11:4	11:30	2	int	i1
water	11:14	0:0	2	,
decl	11:4	11:30	2	int	n0
water	11:18	0:0	2	,
decl	11:4	11:30	2	int	n1
water	11:22	0:0	2	,
decl	11:4	11:30	2	int	na
water	11:26	0:0	2	,
decl	11:4	11:30	2	int	nb
decl	12:4	12:58	2	int64_t	stop_here
op	12:22	0:0	2	=
water	12:24	0:0	2	frag
op	12:28	0:0	2	->
water	12:30	0:0	2	position
op	12:38	0:0	2	[
water	12:39	0:0	2	0
op	12:40	0:0	2	]
op	12:42	0:0	2	+
water	12:44	0:0	2	atempo
op	12:50	0:0	2	->
water	12:52	0:0	2	window
if	13:4	15:4	2	(src_ref &&yae_load_data (atempo ,src_ref ,src_end ,stop_here ) != 0)
cond	13:8	13:73	3	src_ref &&yae_load_data (atempo ,src_ref ,src_end ,stop_here ) != 0
water	13:8	0:0	4	src_ref
op	13:16	0:0	4	&&
call	13:19	13:68	4	yae_load_data
arg	13:33	13:39	5	atempo
water	13:33	0:0	6	atempo
arg	13:41	13:48	5	src_ref
water	13:41	0:0	6	src_ref
arg	13:50	13:57	5	src_end
water	13:50	0:0	6	src_end
arg	13:59	13:68	5	stop_here
water	13:59	0:0	6	stop_here
op	13:70	0:0	4	!=
water	13:73	0:0	4	0
stmts	13:76	15:4	3	
water	13:76	0:0	4	{
return	14:8	14:30	4	AVERROR(EAGAIN)
call	14:15	14:29	5	AVERROR
arg	14:23	14:29	6	EAGAIN
water	14:23	0:0	7	EAGAIN
water	15:4	0:0	4	}
water	17:4	0:0	2	missing
op	17:12	0:0	2	=
water	18:8	0:0	2	stop_here
op	18:18	0:0	2	>
water	18:20	0:0	2	atempo
op	18:26	0:0	2	->
water	18:28	0:0	2	position
op	18:36	0:0	2	[
water	18:37	0:0	2	0
op	18:38	0:0	2	]
water	18:40	0:0	2	?
water	19:8	0:0	2	stop_here
op	19:18	0:0	2	-
water	19:20	0:0	2	atempo
op	19:26	0:0	2	->
water	19:28	0:0	2	position
op	19:36	0:0	2	[
water	19:37	0:0	2	0
op	19:38	0:0	2	]
water	19:40	0:0	2	:
water	19:42	0:0	2	0
water	19:43	0:0	2	;
water	20:4	0:0	2	nsamples
op	20:13	0:0	2	=
water	21:8	0:0	2	missing
op	21:16	0:0	2	<
water	21:18	0:0	2	(
water	21:19	0:0	2	int64_t
water	21:26	0:0	2	)
water	21:27	0:0	2	atempo
op	21:33	0:0	2	->
water	21:35	0:0	2	window
water	21:42	0:0	2	?
call	22:8	22:43	2	(uint32_t)
arg	22:19	22:43	3	atempo->window-missing
water	22:19	0:0	4	atempo
op	22:25	0:0	4	->
water	22:27	0:0	4	window
op	22:34	0:0	4	-
water	22:36	0:0	4	missing
water	22:45	0:0	2	:
water	22:47	0:0	2	0
water	22:48	0:0	2	;
water	24:4	0:0	2	frag
op	24:8	0:0	2	->
water	24:10	0:0	2	nsamples
op	24:19	0:0	2	=
water	24:21	0:0	2	nsamples
water	24:29	0:0	2	;
water	25:4	0:0	2	dst
op	25:8	0:0	2	=
water	25:10	0:0	2	frag
op	25:14	0:0	2	->
water	25:16	0:0	2	data
water	25:20	0:0	2	;
water	26:4	0:0	2	start
op	26:10	0:0	2	=
water	26:12	0:0	2	atempo
op	26:18	0:0	2	->
water	26:20	0:0	2	position
op	26:28	0:0	2	[
water	26:29	0:0	2	0
op	26:30	0:0	2	]
op	26:32	0:0	2	-
water	26:34	0:0	2	atempo
op	26:40	0:0	2	->
water	26:42	0:0	2	size
water	26:46	0:0	2	;
water	27:4	0:0	2	zeros
op	27:10	0:0	2	=
water	27:12	0:0	2	0
water	27:13	0:0	2	;
if	28:4	34:4	2	(frag -> position [ 0 ] < start)
cond	28:8	28:28	3	frag -> position [ 0 ] < start
water	28:8	0:0	4	frag
op	28:12	0:0	4	->
water	28:14	0:0	4	position
op	28:22	0:0	4	[
water	28:23	0:0	4	0
op	28:24	0:0	4	]
op	28:26	0:0	4	<
water	28:28	0:0	4	start
stmts	28:35	34:4	3	
water	28:35	0:0	4	{
water	30:8	0:0	4	zeros
op	30:14	0:0	4	=
call	30:16	30:66	4	FFMIN
arg	30:22	30:47	5	start-frag->position[0]
water	30:22	0:0	6	start
op	30:28	0:0	6	-
water	30:30	0:0	6	frag
op	30:34	0:0	6	->
water	30:36	0:0	6	position
op	30:44	0:0	6	[
water	30:45	0:0	6	0
op	30:46	0:0	6	]
arg	30:49	30:66	5	(int64_t)nsamples
water	30:49	0:0	6	(
water	30:50	0:0	6	int64_t
water	30:57	0:0	6	)
water	30:58	0:0	6	nsamples
water	30:67	0:0	4	;
call	31:8	31:36	4	av_assert0
arg	31:19	31:36	5	zeros!=nsamples
water	31:19	0:0	6	zeros
op	31:25	0:0	6	!=
water	31:28	0:0	6	nsamples
water	31:37	0:0	4	;
call	32:8	32:45	4	memset
arg	32:15	32:18	5	dst
water	32:15	0:0	6	dst
arg	32:20	32:21	5	0
water	32:20	0:0	6	0
arg	32:23	32:45	5	zeros*atempo->stride
water	32:23	0:0	6	zeros
op	32:29	0:0	6	*
water	32:31	0:0	6	atempo
op	32:37	0:0	6	->
water	32:39	0:0	6	stride
water	32:46	0:0	4	;
water	33:8	0:0	4	dst
op	33:12	0:0	4	+=
water	33:15	0:0	4	zeros
op	33:21	0:0	4	*
water	33:23	0:0	4	atempo
op	33:29	0:0	4	->
water	33:31	0:0	4	stride
water	33:37	0:0	4	;
water	34:4	0:0	4	}
if	35:4	37:4	2	(zeros == nsamples)
cond	35:8	35:17	3	zeros == nsamples
water	35:8	0:0	4	zeros
op	35:14	0:0	4	==
water	35:17	0:0	4	nsamples
stmts	35:27	37:4	3	
water	35:27	0:0	4	{
return	36:8	36:16	4	0
water	36:15	0:0	5	0
water	37:4	0:0	4	}
water	39:4	0:0	2	na
op	39:7	0:0	2	=
water	39:9	0:0	2	(
water	39:10	0:0	2	atempo
op	39:16	0:0	2	->
water	39:18	0:0	2	head
op	39:23	0:0	2	<
water	39:25	0:0	2	atempo
op	39:31	0:0	2	->
water	39:33	0:0	2	tail
water	39:38	0:0	2	?
water	40:10	0:0	2	atempo
op	40:16	0:0	2	->
water	40:18	0:0	2	tail
op	40:23	0:0	2	-
water	40:25	0:0	2	atempo
op	40:31	0:0	2	->
water	40:33	0:0	2	head
water	40:38	0:0	2	:
water	41:10	0:0	2	atempo
op	41:16	0:0	2	->
water	41:18	0:0	2	ring
op	41:23	0:0	2	-
water	41:25	0:0	2	atempo
op	41:31	0:0	2	->
water	41:33	0:0	2	head
water	41:37	0:0	2	)
water	41:38	0:0	2	;
water	42:4	0:0	2	nb
op	42:7	0:0	2	=
water	42:9	0:0	2	atempo
op	42:15	0:0	2	->
water	42:17	0:0	2	head
op	42:22	0:0	2	<
water	42:24	0:0	2	atempo
op	42:30	0:0	2	->
water	42:32	0:0	2	tail
water	42:37	0:0	2	?
water	42:39	0:0	2	0
water	42:41	0:0	2	:
water	42:43	0:0	2	atempo
op	42:49	0:0	2	->
water	42:51	0:0	2	tail
water	42:55	0:0	2	;
call	44:4	44:42	2	av_assert0
arg	44:15	44:42	3	nsamples<=zeros+na+nb
water	44:15	0:0	4	nsamples
op	44:24	0:0	4	<=
water	44:27	0:0	4	zeros
op	44:33	0:0	4	+
water	44:35	0:0	4	na
op	44:38	0:0	4	+
water	44:40	0:0	4	nb
water	44:43	0:0	2	;
water	45:4	0:0	2	a
op	45:6	0:0	2	=
water	45:8	0:0	2	atempo
op	45:14	0:0	2	->
water	45:16	0:0	2	buffer
op	45:23	0:0	2	+
water	45:25	0:0	2	atempo
op	45:31	0:0	2	->
water	45:33	0:0	2	head
op	45:38	0:0	2	*
water	45:40	0:0	2	atempo
op	45:46	0:0	2	->
water	45:48	0:0	2	stride
water	45:54	0:0	2	;
water	46:4	0:0	2	b
op	46:6	0:0	2	=
water	46:8	0:0	2	atempo
op	46:14	0:0	2	->
water	46:16	0:0	2	buffer
water	46:22	0:0	2	;
water	47:4	0:0	2	i0
op	47:7	0:0	2	=
water	47:9	0:0	2	frag
op	47:13	0:0	2	->
water	47:15	0:0	2	position
op	47:23	0:0	2	[
water	47:24	0:0	2	0
op	47:25	0:0	2	]
op	47:27	0:0	2	+
water	47:29	0:0	2	zeros
op	47:35	0:0	2	-
water	47:37	0:0	2	start
water	47:42	0:0	2	;
water	48:4	0:0	2	i1
op	48:7	0:0	2	=
water	48:9	0:0	2	i0
op	48:12	0:0	2	<
water	48:14	0:0	2	na
water	48:17	0:0	2	?
water	48:19	0:0	2	0
water	48:21	0:0	2	:
water	48:23	0:0	2	i0
op	48:26	0:0	2	-
water	48:28	0:0	2	na
water	48:30	0:0	2	;
water	49:4	0:0	2	n0
op	49:7	0:0	2	=
water	49:9	0:0	2	i0
op	49:12	0:0	2	<
water	49:14	0:0	2	na
water	49:17	0:0	2	?
call	49:19	49:57	2	FFMIN
arg	49:25	49:32	3	na-i0
water	49:25	0:0	4	na
op	49:28	0:0	4	-
water	49:30	0:0	4	i0
arg	49:34	49:57	3	(int)(nsamples-zeros)
call	49:34	49:56	4	(int)
arg	49:40	49:56	5	nsamples-zeros
water	49:40	0:0	6	nsamples
op	49:49	0:0	6	-
water	49:51	0:0	6	zeros
water	49:59	0:0	2	:
water	49:61	0:0	2	0
water	49:62	0:0	2	;
water	50:4	0:0	2	n1
op	50:7	0:0	2	=
water	50:9	0:0	2	nsamples
op	50:18	0:0	2	-
water	50:20	0:0	2	zeros
op	50:26	0:0	2	-
water	50:28	0:0	2	n0
water	50:30	0:0	2	;
if	51:4	54:4	2	(n0)
cond	51:8	51:8	3	n0
water	51:8	0:0	4	n0
stmts	51:12	54:4	3	
water	51:12	0:0	4	{
call	52:8	52:64	4	memcpy
arg	52:15	52:18	5	dst
water	52:15	0:0	6	dst
arg	52:20	52:43	5	a+i0*atempo->stride
water	52:20	0:0	6	a
op	52:22	0:0	6	+
water	52:24	0:0	6	i0
op	52:27	0:0	6	*
water	52:29	0:0	6	atempo
op	52:35	0:0	6	->
water	52:37	0:0	6	stride
arg	52:45	52:64	5	n0*atempo->stride
water	52:45	0:0	6	n0
op	52:48	0:0	6	*
water	52:50	0:0	6	atempo
op	52:56	0:0	6	->
water	52:58	0:0	6	stride
water	52:65	0:0	4	;
water	53:8	0:0	4	dst
op	53:12	0:0	4	+=
water	53:15	0:0	4	n0
op	53:18	0:0	4	*
water	53:20	0:0	4	atempo
op	53:26	0:0	4	->
water	53:28	0:0	4	stride
water	53:34	0:0	4	;
water	54:4	0:0	4	}
if	55:4	57:4	2	(n1)
cond	55:8	55:8	3	n1
water	55:8	0:0	4	n1
stmts	55:12	57:4	3	
water	55:12	0:0	4	{
call	56:8	56:64	4	memcpy
arg	56:15	56:18	5	dst
water	56:15	0:0	6	dst
arg	56:20	56:43	5	b+i1*atempo->stride
water	56:20	0:0	6	b
op	56:22	0:0	6	+
water	56:24	0:0	6	i1
op	56:27	0:0	6	*
water	56:29	0:0	6	atempo
op	56:35	0:0	6	->
water	56:37	0:0	6	stride
arg	56:45	56:64	5	n1*atempo->stride
water	56:45	0:0	6	n1
op	56:48	0:0	6	*
water	56:50	0:0	6	atempo
op	56:56	0:0	6	->
water	56:58	0:0	6	stride
water	56:65	0:0	4	;
water	57:4	0:0	4	}
return	58:4	58:12	2	0
water	58:11	0:0	3	0
