func	1:0	427:0	0	static int	matroska_parse_tracks
params	1:32	0:0	1	
param	1:33	1:51	2	AVFormatContext *	s
stmnts	0:0	426:12	1	
decl	3:4	3:49	2	MatroskaDemuxContext	*matroska
op	3:35	0:0	2	=
water	3:37	0:0	2	s
op	3:38	0:0	2	->
water	3:40	0:0	2	priv_data
decl	4:4	4:49	2	MatroskaTrack	*tracks
op	4:26	0:0	2	=
water	4:28	0:0	2	matroska
op	4:36	0:0	2	->
water	4:38	0:0	2	tracks
op	4:44	0:0	2	.
water	4:45	0:0	2	elem
decl	5:4	5:16	2	AVStream	*st
decl	6:4	6:17	2	int	i
water	6:9	0:0	2	,
decl	6:4	6:17	2	int	j
water	6:12	0:0	2	,
decl	6:4	6:17	2	int	ret
decl	7:4	7:9	2	int	k
for	8:4	425:4	2	(i = 0 ;i < matroska -> tracks . nb_elem;i ++)
forinit	8:9	8:14	3	i = 0 ;
water	8:9	0:0	4	i
op	8:11	0:0	4	=
water	8:13	0:0	4	0
water	8:14	0:0	4	;
cond	8:16	8:37	3	i < matroska -> tracks . nb_elem
water	8:16	0:0	4	i
op	8:18	0:0	4	<
water	8:20	0:0	4	matroska
op	8:28	0:0	4	->
water	8:30	0:0	4	tracks
op	8:36	0:0	4	.
water	8:37	0:0	4	nb_elem
forexpr	8:46	8:47	3	i ++
water	8:46	0:0	4	i
op	8:47	0:0	4	++
stmts	8:51	425:4	3	
water	8:51	0:0	4	{
decl	9:8	9:41	4	MatroskaTrack	*track
op	9:29	0:0	4	=
op	9:31	0:0	4	&
water	9:32	0:0	4	tracks
op	9:38	0:0	4	[
water	9:39	0:0	4	i
op	9:40	0:0	4	]
decl	10:8	10:50	4	enum AVCodecID	codec_id
op	10:32	0:0	4	=
water	10:34	0:0	4	AV_CODEC_ID_NONE
decl	11:8	11:52	4	EbmlList	*encodings_list
op	11:33	0:0	4	=
op	11:35	0:0	4	&
water	11:36	0:0	4	track
op	11:41	0:0	4	->
water	11:43	0:0	4	encodings
decl	12:8	12:63	4	MatroskaTrackEncoding	*encodings
op	12:41	0:0	4	=
water	12:43	0:0	4	encodings_list
op	12:57	0:0	4	->
water	12:59	0:0	4	elem
decl	13:8	13:33	4	uint8_t	*extradata
op	13:27	0:0	4	=
water	13:29	0:0	4	NULL
decl	14:8	14:30	4	int	extradata_size
op	14:27	0:0	4	=
water	14:29	0:0	4	0
decl	15:8	15:32	4	int	extradata_offset
op	15:29	0:0	4	=
water	15:31	0:0	4	0
decl	16:8	16:27	4	uint32_t	fourcc
op	16:24	0:0	4	=
water	16:26	0:0	4	0
decl	17:8	17:21	4	AVIOContext	b
decl	18:8	18:34	4	char	*key_id_base64
op	18:28	0:0	4	=
water	18:30	0:0	4	NULL
decl	19:8	19:26	4	int	bit_depth
op	19:22	0:0	4	=
op	19:24	0:0	4	-
water	19:25	0:0	4	1
if	21:8	29:8	4	(track -> type != MATROSKA_TRACK_TYPE_VIDEO && track -> type != MATROSKA_TRACK_TYPE_AUDIO && track -> type != MATROSKA_TRACK_TYPE_SUBTITLE && track -> type != MATROSKA_TRACK_TYPE_METADATA)
cond	21:12	24:27	5	track -> type != MATROSKA_TRACK_TYPE_VIDEO && track -> type != MATROSKA_TRACK_TYPE_AUDIO && track -> type != MATROSKA_TRACK_TYPE_SUBTITLE && track -> type != MATROSKA_TRACK_TYPE_METADATA
water	21:12	0:0	6	track
op	21:17	0:0	6	->
water	21:19	0:0	6	type
op	21:24	0:0	6	!=
water	21:27	0:0	6	MATROSKA_TRACK_TYPE_VIDEO
op	21:53	0:0	6	&&
water	22:12	0:0	6	track
op	22:17	0:0	6	->
water	22:19	0:0	6	type
op	22:24	0:0	6	!=
water	22:27	0:0	6	MATROSKA_TRACK_TYPE_AUDIO
op	22:53	0:0	6	&&
water	23:12	0:0	6	track
op	23:17	0:0	6	->
water	23:19	0:0	6	type
op	23:24	0:0	6	!=
water	23:27	0:0	6	MATROSKA_TRACK_TYPE_SUBTITLE
op	23:56	0:0	6	&&
water	24:12	0:0	6	track
op	24:17	0:0	6	->
water	24:19	0:0	6	type
op	24:24	0:0	6	!=
water	24:27	0:0	6	MATROSKA_TRACK_TYPE_METADATA
stmts	24:57	29:8	5	
water	24:57	0:0	6	{
call	25:12	27:30	6	av_log
arg	25:19	25:32	7	matroska->ctx
water	25:19	0:0	8	matroska
op	25:27	0:0	8	->
water	25:29	0:0	8	ctx
arg	25:34	25:45	7	AV_LOG_INFO
water	25:34	0:0	8	AV_LOG_INFO
arg	26:19	26:66	7	"Unknown or unsupported track type %"PRIu64"\n"
water	26:19	0:0	8	"Unknown or unsupported track type %"
water	26:56	0:0	8	PRIu64
water	26:62	0:0	8	"\n"
arg	27:19	27:30	7	track->type
water	27:19	0:0	8	track
op	27:24	0:0	8	->
water	27:26	0:0	8	type
water	27:31	0:0	6	;
continue	28:12	28:20	6	
water	29:8	0:0	6	}
if	30:8	31:20	4	(! track -> codec_id)
cond	30:12	30:20	5	! track -> codec_id
op	30:12	0:0	6	!
water	30:13	0:0	6	track
op	30:18	0:0	6	->
water	30:20	0:0	6	codec_id
stmts	31:12	31:20	5	
continue	31:12	31:20	6	
if	32:8	38:8	4	(track -> audio . samplerate < 0 || track -> audio . samplerate > INT_MAX ||isnan (track -> audio . samplerate ))
cond	32:12	33:41	5	track -> audio . samplerate < 0 || track -> audio . samplerate > INT_MAX ||isnan (track -> audio . samplerate )
water	32:12	0:0	6	track
op	32:17	0:0	6	->
water	32:19	0:0	6	audio
op	32:24	0:0	6	.
water	32:25	0:0	6	samplerate
op	32:36	0:0	6	<
water	32:38	0:0	6	0
op	32:40	0:0	6	||
water	32:43	0:0	6	track
op	32:48	0:0	6	->
water	32:50	0:0	6	audio
op	32:55	0:0	6	.
water	32:56	0:0	6	samplerate
op	32:67	0:0	6	>
water	32:69	0:0	6	INT_MAX
op	32:77	0:0	6	||
call	33:12	33:41	6	isnan
arg	33:18	33:41	7	track->audio.samplerate
water	33:18	0:0	8	track
op	33:23	0:0	8	->
water	33:25	0:0	8	audio
op	33:30	0:0	8	.
water	33:31	0:0	8	samplerate
stmts	33:44	38:8	5	
water	33:44	0:0	6	{
call	34:12	36:42	6	av_log
arg	34:19	34:32	7	matroska->ctx
water	34:19	0:0	8	matroska
op	34:27	0:0	8	->
water	34:29	0:0	8	ctx
arg	34:34	34:48	7	AV_LOG_WARNING
water	34:34	0:0	8	AV_LOG_WARNING
arg	35:19	35:74	7	"Invalid sample rate %f, defaulting to 8000 instead.\n"
water	35:19	0:0	8	"Invalid sample rate %f, defaulting to 8000 instead.\n"
arg	36:19	36:42	7	track->audio.samplerate
water	36:19	0:0	8	track
op	36:24	0:0	8	->
water	36:26	0:0	8	audio
op	36:31	0:0	8	.
water	36:32	0:0	8	samplerate
water	36:43	0:0	6	;
water	37:12	0:0	6	track
op	37:17	0:0	6	->
water	37:19	0:0	6	audio
op	37:24	0:0	6	.
water	37:25	0:0	6	samplerate
op	37:36	0:0	6	=
water	37:38	0:0	6	8000
water	37:42	0:0	6	;
water	38:8	0:0	6	}
if	39:8	48:8	4	(track -> type == MATROSKA_TRACK_TYPE_VIDEO)
cond	39:12	39:27	5	track -> type == MATROSKA_TRACK_TYPE_VIDEO
water	39:12	0:0	6	track
op	39:17	0:0	6	->
water	39:19	0:0	6	type
op	39:24	0:0	6	==
water	39:27	0:0	6	MATROSKA_TRACK_TYPE_VIDEO
stmts	39:54	48:8	5	
water	39:54	0:0	6	{
if	40:12	41:78	6	(! track -> default_duration && track -> video . frame_rate > 0)
cond	40:16	40:70	7	! track -> default_duration && track -> video . frame_rate > 0
op	40:16	0:0	8	!
water	40:17	0:0	8	track
op	40:22	0:0	8	->
water	40:24	0:0	8	default_duration
op	40:41	0:0	8	&&
water	40:44	0:0	8	track
op	40:49	0:0	8	->
water	40:51	0:0	8	video
op	40:56	0:0	8	.
water	40:57	0:0	8	frame_rate
op	40:68	0:0	8	>
water	40:70	0:0	8	0
stmts	41:16	41:78	7	
water	41:16	0:0	8	track
op	41:21	0:0	8	->
water	41:23	0:0	8	default_duration
op	41:40	0:0	8	=
water	41:42	0:0	8	1000000000
op	41:53	0:0	8	/
water	41:55	0:0	8	track
op	41:60	0:0	8	->
water	41:62	0:0	8	video
op	41:67	0:0	8	.
water	41:68	0:0	8	frame_rate
water	41:78	0:0	8	;
if	42:12	43:69	6	(track -> video . display_width == - 1)
cond	42:16	42:47	7	track -> video . display_width == - 1
water	42:16	0:0	8	track
op	42:21	0:0	8	->
water	42:23	0:0	8	video
op	42:28	0:0	8	.
water	42:29	0:0	8	display_width
op	42:43	0:0	8	==
op	42:46	0:0	8	-
water	42:47	0:0	8	1
stmts	43:16	43:69	7	
water	43:16	0:0	8	track
op	43:21	0:0	8	->
water	43:23	0:0	8	video
op	43:28	0:0	8	.
water	43:29	0:0	8	display_width
op	43:43	0:0	8	=
water	43:45	0:0	8	track
op	43:50	0:0	8	->
water	43:52	0:0	8	video
op	43:57	0:0	8	.
water	43:58	0:0	8	pixel_width
water	43:69	0:0	8	;
if	44:12	45:71	6	(track -> video . display_height == - 1)
cond	44:16	44:48	7	track -> video . display_height == - 1
water	44:16	0:0	8	track
op	44:21	0:0	8	->
water	44:23	0:0	8	video
op	44:28	0:0	8	.
water	44:29	0:0	8	display_height
op	44:44	0:0	8	==
op	44:47	0:0	8	-
water	44:48	0:0	8	1
stmts	45:16	45:71	7	
water	45:16	0:0	8	track
op	45:21	0:0	8	->
water	45:23	0:0	8	video
op	45:28	0:0	8	.
water	45:29	0:0	8	display_height
op	45:44	0:0	8	=
water	45:46	0:0	8	track
op	45:51	0:0	8	->
water	45:53	0:0	8	video
op	45:58	0:0	8	.
water	45:59	0:0	8	pixel_height
water	45:71	0:0	8	;
if	46:12	47:63	6	(track -> video . color_space . size == 4)
cond	46:16	46:49	7	track -> video . color_space . size == 4
water	46:16	0:0	8	track
op	46:21	0:0	8	->
water	46:23	0:0	8	video
op	46:28	0:0	8	.
water	46:29	0:0	8	color_space
op	46:40	0:0	8	.
water	46:41	0:0	8	size
op	46:46	0:0	8	==
water	46:49	0:0	8	4
stmts	47:16	47:63	7	
water	47:16	0:0	8	fourcc
op	47:23	0:0	8	=
call	47:25	47:62	8	AV_RL32
arg	47:33	47:62	9	track->video.color_space.data
water	47:33	0:0	10	track
op	47:38	0:0	10	->
water	47:40	0:0	10	video
op	47:45	0:0	10	.
water	47:46	0:0	10	color_space
op	47:57	0:0	10	.
water	47:58	0:0	10	data
water	47:63	0:0	8	;
water	48:8	0:0	6	}
else	48:10	51:8	4
stmts	48:15	51:8	5	
if	48:15	51:8	6	(track -> type == MATROSKA_TRACK_TYPE_AUDIO)
cond	48:19	48:34	7	track -> type == MATROSKA_TRACK_TYPE_AUDIO
water	48:19	0:0	8	track
op	48:24	0:0	8	->
water	48:26	0:0	8	type
op	48:31	0:0	8	==
water	48:34	0:0	8	MATROSKA_TRACK_TYPE_AUDIO
stmts	48:61	51:8	7	
water	48:61	0:0	8	{
if	49:12	50:69	8	(! track -> audio . out_samplerate)
cond	49:16	49:30	9	! track -> audio . out_samplerate
op	49:16	0:0	10	!
water	49:17	0:0	10	track
op	49:22	0:0	10	->
water	49:24	0:0	10	audio
op	49:29	0:0	10	.
water	49:30	0:0	10	out_samplerate
stmts	50:16	50:69	9	
water	50:16	0:0	10	track
op	50:21	0:0	10	->
water	50:23	0:0	10	audio
op	50:28	0:0	10	.
water	50:29	0:0	10	out_samplerate
op	50:44	0:0	10	=
water	50:46	0:0	10	track
op	50:51	0:0	10	->
water	50:53	0:0	10	audio
op	50:58	0:0	10	.
water	50:59	0:0	10	samplerate
water	50:69	0:0	10	;
water	51:8	0:0	8	}
if	52:8	55:8	4	(encodings_list -> nb_elem > 1)
cond	52:12	52:38	5	encodings_list -> nb_elem > 1
water	52:12	0:0	6	encodings_list
op	52:26	0:0	6	->
water	52:28	0:0	6	nb_elem
op	52:36	0:0	6	>
water	52:38	0:0	6	1
stmts	52:41	55:8	5	
water	52:41	0:0	6	{
call	53:12	54:62	6	av_log
arg	53:19	53:32	7	matroska->ctx
water	53:19	0:0	8	matroska
op	53:27	0:0	8	->
water	53:29	0:0	8	ctx
arg	53:34	53:46	7	AV_LOG_ERROR
water	53:34	0:0	8	AV_LOG_ERROR
arg	54:19	54:62	7	"Multiple combined encodings not supported"
water	54:19	0:0	8	"Multiple combined encodings not supported"
water	54:63	0:0	6	;
water	55:8	0:0	6	}
else	55:10	100:8	4
stmts	55:15	100:8	5	
if	55:15	100:8	6	(encodings_list -> nb_elem == 1)
cond	55:19	55:46	7	encodings_list -> nb_elem == 1
water	55:19	0:0	8	encodings_list
op	55:33	0:0	8	->
water	55:35	0:0	8	nb_elem
op	55:43	0:0	8	==
water	55:46	0:0	8	1
stmts	55:49	100:8	7	
water	55:49	0:0	8	{
if	56:12	72:12	8	(encodings [ 0 ] . type)
cond	56:16	56:29	9	encodings [ 0 ] . type
water	56:16	0:0	10	encodings
op	56:25	0:0	10	[
water	56:26	0:0	10	0
op	56:27	0:0	10	]
op	56:28	0:0	10	.
water	56:29	0:0	10	type
stmts	56:35	72:12	9	
water	56:35	0:0	10	{
if	57:16	67:16	10	(encodings [ 0 ] . encryption . key_id . size > 0)
cond	57:20	57:58	11	encodings [ 0 ] . encryption . key_id . size > 0
water	57:20	0:0	12	encodings
op	57:29	0:0	12	[
water	57:30	0:0	12	0
op	57:31	0:0	12	]
op	57:32	0:0	12	.
water	57:33	0:0	12	encryption
op	57:43	0:0	12	.
water	57:44	0:0	12	key_id
op	57:50	0:0	12	.
water	57:51	0:0	12	size
op	57:56	0:0	12	>
water	57:58	0:0	12	0
stmts	57:61	67:16	11	
water	57:61	0:0	12	{
decl	60:20	60:92	12	const int	b64_size
op	60:39	0:0	12	=
call	60:41	60:91	13	AV_BASE64_SIZE
arg	60:56	60:91	14	encodings[0].encryption.key_id.size
water	60:56	0:0	15	encodings
op	60:65	0:0	15	[
water	60:66	0:0	15	0
op	60:67	0:0	15	]
op	60:68	0:0	15	.
water	60:69	0:0	15	encryption
op	60:79	0:0	15	.
water	60:80	0:0	15	key_id
op	60:86	0:0	15	.
water	60:87	0:0	15	size
water	61:20	0:0	12	key_id_base64
op	61:34	0:0	12	=
call	61:36	61:54	12	av_malloc
arg	61:46	61:54	13	b64_size
water	61:46	0:0	14	b64_size
water	61:55	0:0	12	;
if	62:20	63:46	12	(key_id_base64 == NULL)
cond	62:24	62:41	13	key_id_base64 == NULL
water	62:24	0:0	14	key_id_base64
op	62:38	0:0	14	==
water	62:41	0:0	14	NULL
stmts	63:24	63:46	13	
return	63:24	63:46	14	AVERROR(ENOMEM)
call	63:31	63:45	15	AVERROR
arg	63:39	63:45	16	ENOMEM
water	63:39	0:0	17	ENOMEM
call	64:20	66:72	12	av_base64_encode
arg	64:37	64:50	13	key_id_base64
water	64:37	0:0	14	key_id_base64
arg	64:52	64:60	13	b64_size
water	64:52	0:0	14	b64_size
arg	65:37	65:72	13	encodings[0].encryption.key_id.data
water	65:37	0:0	14	encodings
op	65:46	0:0	14	[
water	65:47	0:0	14	0
op	65:48	0:0	14	]
op	65:49	0:0	14	.
water	65:50	0:0	14	encryption
op	65:60	0:0	14	.
water	65:61	0:0	14	key_id
op	65:67	0:0	14	.
water	65:68	0:0	14	data
arg	66:37	66:72	13	encodings[0].encryption.key_id.size
water	66:37	0:0	14	encodings
op	66:46	0:0	14	[
water	66:47	0:0	14	0
op	66:48	0:0	14	]
op	66:49	0:0	14	.
water	66:50	0:0	14	encryption
op	66:60	0:0	14	.
water	66:61	0:0	14	key_id
op	66:67	0:0	14	.
water	66:68	0:0	14	size
water	66:73	0:0	12	;
water	67:16	0:0	12	}
else	67:18	71:16	10
stmts	67:23	71:16	11	
water	67:23	0:0	12	{
water	68:20	0:0	12	encodings
op	68:29	0:0	12	[
water	68:30	0:0	12	0
op	68:31	0:0	12	]
op	68:32	0:0	12	.
water	68:33	0:0	12	scope
op	68:39	0:0	12	=
water	68:41	0:0	12	0
water	68:42	0:0	12	;
call	69:20	70:54	12	av_log
arg	69:27	69:40	13	matroska->ctx
water	69:27	0:0	14	matroska
op	69:35	0:0	14	->
water	69:37	0:0	14	ctx
arg	69:42	69:54	13	AV_LOG_ERROR
water	69:42	0:0	14	AV_LOG_ERROR
arg	70:27	70:54	13	"Unsupported encoding type"
water	70:27	0:0	14	"Unsupported encoding type"
water	70:55	0:0	12	;
water	71:16	0:0	12	}
water	72:12	0:0	10	}
else	72:14	86:12	8
stmts	72:19	86:12	9	
if	72:19	86:12	10	(encodings [ 0 ] . compression . algo != MATROSKA_TRACK_ENCODING_COMP_ZLIB && encodings [ 0 ] . compression . algo != MATROSKA_TRACK_ENCODING_COMP_BZLIB && encodings [ 0 ] . compression . algo != MATROSKA_TRACK_ENCODING_COMP_LZO && encodings [ 0 ] . compression . algo != MATROSKA_TRACK_ENCODING_COMP_HEADERSTRIP)
cond	74:17	82:50	11	encodings [ 0 ] . compression . algo != MATROSKA_TRACK_ENCODING_COMP_ZLIB && encodings [ 0 ] . compression . algo != MATROSKA_TRACK_ENCODING_COMP_BZLIB && encodings [ 0 ] . compression . algo != MATROSKA_TRACK_ENCODING_COMP_LZO && encodings [ 0 ] . compression . algo != MATROSKA_TRACK_ENCODING_COMP_HEADERSTRIP
water	74:17	0:0	12	encodings
op	74:26	0:0	12	[
water	74:27	0:0	12	0
op	74:28	0:0	12	]
op	74:29	0:0	12	.
water	74:30	0:0	12	compression
op	74:41	0:0	12	.
water	74:42	0:0	12	algo
op	74:47	0:0	12	!=
water	74:50	0:0	12	MATROSKA_TRACK_ENCODING_COMP_ZLIB
op	74:85	0:0	12	&&
water	77:17	0:0	12	encodings
op	77:26	0:0	12	[
water	77:27	0:0	12	0
op	77:28	0:0	12	]
op	77:29	0:0	12	.
water	77:30	0:0	12	compression
op	77:41	0:0	12	.
water	77:42	0:0	12	algo
op	77:47	0:0	12	!=
water	77:50	0:0	12	MATROSKA_TRACK_ENCODING_COMP_BZLIB
op	77:85	0:0	12	&&
water	80:17	0:0	12	encodings
op	80:26	0:0	12	[
water	80:27	0:0	12	0
op	80:28	0:0	12	]
op	80:29	0:0	12	.
water	80:30	0:0	12	compression
op	80:41	0:0	12	.
water	80:42	0:0	12	algo
op	80:47	0:0	12	!=
water	80:50	0:0	12	MATROSKA_TRACK_ENCODING_COMP_LZO
op	80:85	0:0	12	&&
water	82:17	0:0	12	encodings
op	82:26	0:0	12	[
water	82:27	0:0	12	0
op	82:28	0:0	12	]
op	82:29	0:0	12	.
water	82:30	0:0	12	compression
op	82:41	0:0	12	.
water	82:42	0:0	12	algo
op	82:47	0:0	12	!=
water	82:50	0:0	12	MATROSKA_TRACK_ENCODING_COMP_HEADERSTRIP
stmts	82:92	86:12	11	
water	82:92	0:0	12	{
water	83:16	0:0	12	encodings
op	83:25	0:0	12	[
water	83:26	0:0	12	0
op	83:27	0:0	12	]
op	83:28	0:0	12	.
water	83:29	0:0	12	scope
op	83:35	0:0	12	=
water	83:37	0:0	12	0
water	83:38	0:0	12	;
call	84:16	85:50	12	av_log
arg	84:23	84:36	13	matroska->ctx
water	84:23	0:0	14	matroska
op	84:31	0:0	14	->
water	84:33	0:0	14	ctx
arg	84:38	84:50	13	AV_LOG_ERROR
water	84:38	0:0	14	AV_LOG_ERROR
arg	85:23	85:50	13	"Unsupported encoding type"
water	85:23	0:0	14	"Unsupported encoding type"
water	85:51	0:0	12	;
water	86:12	0:0	12	}
else	86:14	99:12	8
stmts	86:19	99:12	9	
if	86:19	99:12	10	(track -> codec_priv . size && encodings [ 0 ] . scope & 2)
cond	86:23	86:70	11	track -> codec_priv . size && encodings [ 0 ] . scope & 2
water	86:23	0:0	12	track
op	86:28	0:0	12	->
water	86:30	0:0	12	codec_priv
op	86:40	0:0	12	.
water	86:41	0:0	12	size
op	86:46	0:0	12	&&
water	86:49	0:0	12	encodings
op	86:58	0:0	12	[
water	86:59	0:0	12	0
op	86:60	0:0	12	]
op	86:61	0:0	12	.
water	86:62	0:0	12	scope
op	86:68	0:0	12	&
water	86:70	0:0	12	2
stmts	86:73	99:12	11	
water	86:73	0:0	12	{
decl	87:16	87:60	12	uint8_t	*codec_priv
op	87:36	0:0	12	=
water	87:38	0:0	12	track
op	87:43	0:0	12	->
water	87:45	0:0	12	codec_priv
op	87:55	0:0	12	.
water	87:56	0:0	12	data
decl	88:16	90:55	12	int	ret
op	88:24	0:0	12	=
call	88:26	90:54	13	matroska_decode_buffer
arg	88:49	88:72	14	&track->codec_priv.data
op	88:49	0:0	15	&
water	88:50	0:0	15	track
op	88:55	0:0	15	->
water	88:57	0:0	15	codec_priv
op	88:67	0:0	15	.
water	88:68	0:0	15	data
arg	89:49	89:72	14	&track->codec_priv.size
op	89:49	0:0	15	&
water	89:50	0:0	15	track
op	89:55	0:0	15	->
water	89:57	0:0	15	codec_priv
op	89:67	0:0	15	.
water	89:68	0:0	15	size
arg	90:49	90:54	14	track
water	90:49	0:0	15	track
if	91:16	96:16	12	(ret < 0)
cond	91:20	91:26	13	ret < 0
water	91:20	0:0	14	ret
op	91:24	0:0	14	<
water	91:26	0:0	14	0
stmts	91:29	96:16	13	
water	91:29	0:0	14	{
water	92:20	0:0	14	track
op	92:25	0:0	14	->
water	92:27	0:0	14	codec_priv
op	92:37	0:0	14	.
water	92:38	0:0	14	data
op	92:43	0:0	14	=
water	92:45	0:0	14	NULL
water	92:49	0:0	14	;
water	93:20	0:0	14	track
op	93:25	0:0	14	->
water	93:27	0:0	14	codec_priv
op	93:37	0:0	14	.
water	93:38	0:0	14	size
op	93:43	0:0	14	=
water	93:45	0:0	14	0
water	93:46	0:0	14	;
call	94:20	95:66	14	av_log
arg	94:27	94:40	15	matroska->ctx
water	94:27	0:0	16	matroska
op	94:35	0:0	16	->
water	94:37	0:0	16	ctx
arg	94:42	94:54	15	AV_LOG_ERROR
water	94:42	0:0	16	AV_LOG_ERROR
arg	95:27	95:66	15	"Failed to decode codec private data\n"
water	95:27	0:0	16	"Failed to decode codec private data\n"
water	95:67	0:0	14	;
water	96:16	0:0	14	}
if	97:16	98:39	12	(codec_priv != track -> codec_priv . data)
cond	97:20	97:52	13	codec_priv != track -> codec_priv . data
water	97:20	0:0	14	codec_priv
op	97:31	0:0	14	!=
water	97:34	0:0	14	track
op	97:39	0:0	14	->
water	97:41	0:0	14	codec_priv
op	97:51	0:0	14	.
water	97:52	0:0	14	data
stmts	98:20	98:39	13	
call	98:20	98:38	14	av_free
arg	98:28	98:38	15	codec_priv
water	98:28	0:0	16	codec_priv
water	98:39	0:0	14	;
water	99:12	0:0	12	}
water	100:8	0:0	8	}
for	101:8	107:8	4	(j = 0 ;ff_mkv_codec_tags [ j ] . id != AV_CODEC_ID_NONE;j ++)
forinit	101:13	101:18	5	j = 0 ;
water	101:13	0:0	6	j
op	101:15	0:0	6	=
water	101:17	0:0	6	0
water	101:18	0:0	6	;
cond	101:20	101:47	5	ff_mkv_codec_tags [ j ] . id != AV_CODEC_ID_NONE
water	101:20	0:0	6	ff_mkv_codec_tags
op	101:37	0:0	6	[
water	101:38	0:0	6	j
op	101:39	0:0	6	]
op	101:40	0:0	6	.
water	101:41	0:0	6	id
op	101:44	0:0	6	!=
water	101:47	0:0	6	AV_CODEC_ID_NONE
forexpr	101:65	101:66	5	j ++
water	101:65	0:0	6	j
op	101:66	0:0	6	++
stmts	101:70	107:8	5	
water	101:70	0:0	6	{
if	102:12	106:12	6	(!strncmp (ff_mkv_codec_tags [ j ] . str ,track -> codec_id ,strlen (ff_mkv_codec_tags [ j ] . str ) ))
cond	102:16	103:57	7	!strncmp (ff_mkv_codec_tags [ j ] . str ,track -> codec_id ,strlen (ff_mkv_codec_tags [ j ] . str ) )
op	102:16	0:0	8	!
call	102:17	103:57	8	strncmp
arg	102:25	102:49	9	ff_mkv_codec_tags[j].str
water	102:25	0:0	10	ff_mkv_codec_tags
op	102:42	0:0	10	[
water	102:43	0:0	10	j
op	102:44	0:0	10	]
op	102:45	0:0	10	.
water	102:46	0:0	10	str
arg	102:51	102:66	9	track->codec_id
water	102:51	0:0	10	track
op	102:56	0:0	10	->
water	102:58	0:0	10	codec_id
arg	103:25	103:57	9	strlen(ff_mkv_codec_tags[j].str)
call	103:25	103:56	10	strlen
arg	103:32	103:56	11	ff_mkv_codec_tags[j].str
water	103:32	0:0	12	ff_mkv_codec_tags
op	103:49	0:0	12	[
water	103:50	0:0	12	j
op	103:51	0:0	12	]
op	103:52	0:0	12	.
water	103:53	0:0	12	str
stmts	103:60	106:12	7	
water	103:60	0:0	8	{
water	104:16	0:0	8	codec_id
op	104:25	0:0	8	=
water	104:27	0:0	8	ff_mkv_codec_tags
op	104:44	0:0	8	[
water	104:45	0:0	8	j
op	104:46	0:0	8	]
op	104:47	0:0	8	.
water	104:48	0:0	8	id
water	104:50	0:0	8	;
break	105:16	105:21	8	
water	106:12	0:0	8	}
water	107:8	0:0	6	}
water	108:8	0:0	4	st
op	108:11	0:0	4	=
water	108:13	0:0	4	track
op	108:18	0:0	4	->
water	108:20	0:0	4	stream
op	108:27	0:0	4	=
call	108:29	108:56	4	avformat_new_stream
arg	108:49	108:50	5	s
water	108:49	0:0	6	s
arg	108:52	108:56	5	NULL
water	108:52	0:0	6	NULL
water	108:57	0:0	4	;
if	109:8	112:8	4	(! st)
cond	109:12	109:13	5	! st
op	109:12	0:0	6	!
water	109:13	0:0	6	st
stmts	109:17	112:8	5	
water	109:17	0:0	6	{
call	110:12	110:33	6	av_free
arg	110:20	110:33	7	key_id_base64
water	110:20	0:0	8	key_id_base64
water	110:34	0:0	6	;
return	111:12	111:34	6	AVERROR(ENOMEM)
call	111:19	111:33	7	AVERROR
arg	111:27	111:33	8	ENOMEM
water	111:27	0:0	9	ENOMEM
water	112:8	0:0	6	}
if	113:8	117:8	4	(key_id_base64)
cond	113:12	113:12	5	key_id_base64
water	113:12	0:0	6	key_id_base64
stmts	113:27	117:8	5	
water	113:27	0:0	6	{
call	115:12	115:69	6	av_dict_set
arg	115:24	115:37	7	&st->metadata
op	115:24	0:0	8	&
water	115:25	0:0	8	st
op	115:27	0:0	8	->
water	115:29	0:0	8	metadata
arg	115:39	115:51	7	"enc_key_id"
water	115:39	0:0	8	"enc_key_id"
arg	115:53	115:66	7	key_id_base64
water	115:53	0:0	8	key_id_base64
arg	115:68	115:69	7	0
water	115:68	0:0	8	0
water	115:70	0:0	6	;
call	116:12	116:35	6	av_freep
arg	116:21	116:35	7	&key_id_base64
op	116:21	0:0	8	&
water	116:22	0:0	8	key_id_base64
water	116:36	0:0	6	;
water	117:8	0:0	6	}
if	118:8	130:8	4	(!strcmp (track -> codec_id ,"V_MS/VFW/FOURCC" ) && track -> codec_priv . size >= 40 && track -> codec_priv . data)
cond	118:12	120:30	5	!strcmp (track -> codec_id ,"V_MS/VFW/FOURCC" ) && track -> codec_priv . size >= 40 && track -> codec_priv . data
op	118:12	0:0	6	!
call	118:13	118:54	6	strcmp
arg	118:20	118:35	7	track->codec_id
water	118:20	0:0	8	track
op	118:25	0:0	8	->
water	118:27	0:0	8	codec_id
arg	118:37	118:54	7	"V_MS/VFW/FOURCC"
water	118:37	0:0	8	"V_MS/VFW/FOURCC"
op	118:56	0:0	6	&&
water	119:13	0:0	6	track
op	119:18	0:0	6	->
water	119:20	0:0	6	codec_priv
op	119:30	0:0	6	.
water	119:31	0:0	6	size
op	119:36	0:0	6	>=
water	119:39	0:0	6	40
op	119:56	0:0	6	&&
water	120:12	0:0	6	track
op	120:17	0:0	6	->
water	120:19	0:0	6	codec_priv
op	120:29	0:0	6	.
water	120:30	0:0	6	data
stmts	120:36	130:8	5	
water	120:36	0:0	6	{
water	121:12	0:0	6	track
op	121:17	0:0	6	->
water	121:19	0:0	6	ms_compat
op	121:32	0:0	6	=
water	121:34	0:0	6	1
water	121:35	0:0	6	;
water	122:12	0:0	6	bit_depth
op	122:32	0:0	6	=
call	122:34	122:69	6	AV_RL16
arg	122:42	122:69	7	track->codec_priv.data+14
water	122:42	0:0	8	track
op	122:47	0:0	8	->
water	122:49	0:0	8	codec_priv
op	122:59	0:0	8	.
water	122:60	0:0	8	data
op	122:65	0:0	8	+
water	122:67	0:0	8	14
water	122:70	0:0	6	;
water	123:12	0:0	6	fourcc
op	123:32	0:0	6	=
call	123:34	123:69	6	AV_RL32
arg	123:42	123:69	7	track->codec_priv.data+16
water	123:42	0:0	8	track
op	123:47	0:0	8	->
water	123:49	0:0	8	codec_priv
op	123:59	0:0	8	.
water	123:60	0:0	8	data
op	123:65	0:0	8	+
water	123:67	0:0	8	16
water	123:70	0:0	6	;
water	124:12	0:0	6	codec_id
op	124:32	0:0	6	=
call	124:34	125:56	6	ff_codec_get_id
arg	124:50	124:67	7	ff_codec_bmp_tags
water	124:50	0:0	8	ff_codec_bmp_tags
arg	125:50	125:56	7	fourcc
water	125:50	0:0	8	fourcc
water	125:57	0:0	6	;
if	126:12	128:57	6	(! codec_id)
cond	126:16	126:17	7	! codec_id
op	126:16	0:0	8	!
water	126:17	0:0	8	codec_id
stmts	127:16	128:57	7	
water	127:16	0:0	8	codec_id
op	127:32	0:0	8	=
call	127:34	128:56	8	ff_codec_get_id
arg	127:50	127:72	9	ff_codec_movvideo_tags
water	127:50	0:0	10	ff_codec_movvideo_tags
arg	128:50	128:56	9	fourcc
water	128:50	0:0	10	fourcc
water	128:57	0:0	8	;
water	129:12	0:0	6	extradata_offset
op	129:32	0:0	6	=
water	129:34	0:0	6	40
water	129:36	0:0	6	;
water	130:8	0:0	6	}
else	130:10	142:8	4
stmts	130:15	142:8	5	
if	130:15	142:8	6	(!strcmp (track -> codec_id ,"A_MS/ACM" ) && track -> codec_priv . size >= 14 && track -> codec_priv . data)
cond	130:19	132:37	7	!strcmp (track -> codec_id ,"A_MS/ACM" ) && track -> codec_priv . size >= 14 && track -> codec_priv . data
op	130:19	0:0	8	!
call	130:20	130:54	8	strcmp
arg	130:27	130:42	9	track->codec_id
water	130:27	0:0	10	track
op	130:32	0:0	10	->
water	130:34	0:0	10	codec_id
arg	130:44	130:54	9	"A_MS/ACM"
water	130:44	0:0	10	"A_MS/ACM"
op	130:56	0:0	8	&&
water	131:19	0:0	8	track
op	131:24	0:0	8	->
water	131:26	0:0	8	codec_priv
op	131:36	0:0	8	.
water	131:37	0:0	8	size
op	131:42	0:0	8	>=
water	131:45	0:0	8	14
op	131:56	0:0	8	&&
water	132:19	0:0	8	track
op	132:24	0:0	8	->
water	132:26	0:0	8	codec_priv
op	132:36	0:0	8	.
water	132:37	0:0	8	data
stmts	132:43	142:8	7	
water	132:43	0:0	8	{
decl	133:12	133:19	8	int	ret
call	134:12	136:55	8	ffio_init_context
arg	134:30	134:32	9	&b
op	134:30	0:0	10	&
water	134:31	0:0	10	b
arg	134:34	134:56	9	track->codec_priv.data
water	134:34	0:0	10	track
op	134:39	0:0	10	->
water	134:41	0:0	10	codec_priv
op	134:51	0:0	10	.
water	134:52	0:0	10	data
arg	135:30	135:52	9	track->codec_priv.size
water	135:30	0:0	10	track
op	135:35	0:0	10	->
water	135:37	0:0	10	codec_priv
op	135:47	0:0	10	.
water	135:48	0:0	10	size
arg	136:30	136:31	9	0
water	136:30	0:0	10	0
arg	136:33	136:37	9	NULL
water	136:33	0:0	10	NULL
arg	136:39	136:43	9	NULL
water	136:39	0:0	10	NULL
arg	136:45	136:49	9	NULL
water	136:45	0:0	10	NULL
arg	136:51	136:55	9	NULL
water	136:51	0:0	10	NULL
water	136:56	0:0	8	;
water	137:12	0:0	8	ret
op	137:16	0:0	8	=
call	137:18	137:79	8	ff_get_wav_header
arg	137:36	137:37	9	s
water	137:36	0:0	10	s
arg	137:39	137:41	9	&b
op	137:39	0:0	10	&
water	137:40	0:0	10	b
arg	137:43	137:52	9	st->codec
water	137:43	0:0	10	st
op	137:45	0:0	10	->
water	137:47	0:0	10	codec
arg	137:54	137:76	9	track->codec_priv.size
water	137:54	0:0	10	track
op	137:59	0:0	10	->
water	137:61	0:0	10	codec_priv
op	137:71	0:0	10	.
water	137:72	0:0	10	size
arg	137:78	137:79	9	0
water	137:78	0:0	10	0
water	137:80	0:0	8	;
if	138:12	139:26	8	(ret < 0)
cond	138:16	138:22	9	ret < 0
water	138:16	0:0	10	ret
op	138:20	0:0	10	<
water	138:22	0:0	10	0
stmts	139:16	139:26	9	
return	139:16	139:26	10	ret
water	139:23	0:0	11	ret
water	140:12	0:0	8	codec_id
op	140:29	0:0	8	=
water	140:31	0:0	8	st
op	140:33	0:0	8	->
water	140:35	0:0	8	codec
op	140:40	0:0	8	->
water	140:42	0:0	8	codec_id
water	140:50	0:0	8	;
water	141:12	0:0	8	extradata_offset
op	141:29	0:0	8	=
call	141:31	141:63	8	FFMIN
arg	141:37	141:59	9	track->codec_priv.size
water	141:37	0:0	10	track
op	141:42	0:0	10	->
water	141:44	0:0	10	codec_priv
op	141:54	0:0	10	.
water	141:55	0:0	10	size
arg	141:61	141:63	9	18
water	141:61	0:0	10	18
water	141:64	0:0	8	;
water	142:8	0:0	8	}
else	142:10	151:8	4
stmts	142:15	151:8	5	
if	142:15	151:8	6	(!strcmp (track -> codec_id ,"A_QUICKTIME" ) && ( track -> codec_priv . size >= 86 ) && ( track -> codec_priv . data ))
cond	142:19	144:45	7	!strcmp (track -> codec_id ,"A_QUICKTIME" ) && ( track -> codec_priv . size >= 86 ) && ( track -> codec_priv . data )
op	142:19	0:0	8	!
call	142:20	142:57	8	strcmp
arg	142:27	142:42	9	track->codec_id
water	142:27	0:0	10	track
op	142:32	0:0	10	->
water	142:34	0:0	10	codec_id
arg	142:44	142:57	9	"A_QUICKTIME"
water	142:44	0:0	10	"A_QUICKTIME"
op	143:19	0:0	8	&&
water	143:22	0:0	8	(
water	143:23	0:0	8	track
op	143:28	0:0	8	->
water	143:30	0:0	8	codec_priv
op	143:40	0:0	8	.
water	143:41	0:0	8	size
op	143:46	0:0	8	>=
water	143:49	0:0	8	86
water	143:51	0:0	8	)
op	144:19	0:0	8	&&
water	144:22	0:0	8	(
water	144:23	0:0	8	track
op	144:28	0:0	8	->
water	144:30	0:0	8	codec_priv
op	144:40	0:0	8	.
water	144:41	0:0	8	data
water	144:45	0:0	8	)
stmts	144:48	151:8	7	
water	144:48	0:0	8	{
water	145:12	0:0	8	fourcc
op	145:19	0:0	8	=
call	145:21	145:55	8	AV_RL32
arg	145:29	145:55	9	track->codec_priv.data+4
water	145:29	0:0	10	track
op	145:34	0:0	10	->
water	145:36	0:0	10	codec_priv
op	145:46	0:0	10	.
water	145:47	0:0	10	data
op	145:52	0:0	10	+
water	145:54	0:0	10	4
water	145:56	0:0	8	;
water	146:12	0:0	8	codec_id
op	146:21	0:0	8	=
call	146:23	146:69	8	ff_codec_get_id
arg	146:39	146:61	9	ff_codec_movaudio_tags
water	146:39	0:0	10	ff_codec_movaudio_tags
arg	146:63	146:69	9	fourcc
water	146:63	0:0	10	fourcc
water	146:70	0:0	8	;
if	147:12	150:12	8	(ff_codec_get_id (ff_codec_movaudio_tags ,AV_RL32 (track -> codec_priv . data ) ))
cond	147:16	147:87	9	ff_codec_get_id (ff_codec_movaudio_tags ,AV_RL32 (track -> codec_priv . data ) )
call	147:16	147:87	10	ff_codec_get_id
arg	147:32	147:54	11	ff_codec_movaudio_tags
water	147:32	0:0	12	ff_codec_movaudio_tags
arg	147:56	147:87	11	AV_RL32(track->codec_priv.data)
call	147:56	147:86	12	AV_RL32
arg	147:64	147:86	13	track->codec_priv.data
water	147:64	0:0	14	track
op	147:69	0:0	14	->
water	147:71	0:0	14	codec_priv
op	147:81	0:0	14	.
water	147:82	0:0	14	data
stmts	147:90	150:12	9	
water	147:90	0:0	10	{
water	148:16	0:0	10	fourcc
op	148:23	0:0	10	=
call	148:25	148:55	10	AV_RL32
arg	148:33	148:55	11	track->codec_priv.data
water	148:33	0:0	12	track
op	148:38	0:0	12	->
water	148:40	0:0	12	codec_priv
op	148:50	0:0	12	.
water	148:51	0:0	12	data
water	148:56	0:0	10	;
water	149:16	0:0	10	codec_id
op	149:25	0:0	10	=
call	149:27	149:73	10	ff_codec_get_id
arg	149:43	149:65	11	ff_codec_movaudio_tags
water	149:43	0:0	12	ff_codec_movaudio_tags
arg	149:67	149:73	11	fourcc
water	149:67	0:0	12	fourcc
water	149:74	0:0	10	;
water	150:12	0:0	10	}
water	151:8	0:0	8	}
else	151:10	168:8	4
stmts	151:15	168:8	5	
if	151:15	168:8	6	(!strcmp (track -> codec_id ,"V_QUICKTIME" ) && ( track -> codec_priv . size >= 21 ) && ( track -> codec_priv . data ))
cond	151:19	153:42	7	!strcmp (track -> codec_id ,"V_QUICKTIME" ) && ( track -> codec_priv . size >= 21 ) && ( track -> codec_priv . data )
op	151:19	0:0	8	!
call	151:20	151:57	8	strcmp
arg	151:27	151:42	9	track->codec_id
water	151:27	0:0	10	track
op	151:32	0:0	10	->
water	151:34	0:0	10	codec_id
arg	151:44	151:57	9	"V_QUICKTIME"
water	151:44	0:0	10	"V_QUICKTIME"
op	151:59	0:0	8	&&
water	152:19	0:0	8	(
water	152:20	0:0	8	track
op	152:25	0:0	8	->
water	152:27	0:0	8	codec_priv
op	152:37	0:0	8	.
water	152:38	0:0	8	size
op	152:43	0:0	8	>=
water	152:46	0:0	8	21
water	152:48	0:0	8	)
op	152:59	0:0	8	&&
water	153:19	0:0	8	(
water	153:20	0:0	8	track
op	153:25	0:0	8	->
water	153:27	0:0	8	codec_priv
op	153:37	0:0	8	.
water	153:38	0:0	8	data
water	153:42	0:0	8	)
stmts	153:45	168:8	7	
water	153:45	0:0	8	{
water	154:12	0:0	8	fourcc
op	154:21	0:0	8	=
call	154:23	154:57	8	AV_RL32
arg	154:31	154:57	9	track->codec_priv.data+4
water	154:31	0:0	10	track
op	154:36	0:0	10	->
water	154:38	0:0	10	codec_priv
op	154:48	0:0	10	.
water	154:49	0:0	10	data
op	154:54	0:0	10	+
water	154:56	0:0	10	4
water	154:58	0:0	8	;
water	155:12	0:0	8	codec_id
op	155:21	0:0	8	=
call	155:23	155:69	8	ff_codec_get_id
arg	155:39	155:61	9	ff_codec_movvideo_tags
water	155:39	0:0	10	ff_codec_movvideo_tags
arg	155:63	155:69	9	fourcc
water	155:63	0:0	10	fourcc
water	155:70	0:0	8	;
if	156:12	159:12	8	(ff_codec_get_id (ff_codec_movvideo_tags ,AV_RL32 (track -> codec_priv . data ) ))
cond	156:16	156:87	9	ff_codec_get_id (ff_codec_movvideo_tags ,AV_RL32 (track -> codec_priv . data ) )
call	156:16	156:87	10	ff_codec_get_id
arg	156:32	156:54	11	ff_codec_movvideo_tags
water	156:32	0:0	12	ff_codec_movvideo_tags
arg	156:56	156:87	11	AV_RL32(track->codec_priv.data)
call	156:56	156:86	12	AV_RL32
arg	156:64	156:86	13	track->codec_priv.data
water	156:64	0:0	14	track
op	156:69	0:0	14	->
water	156:71	0:0	14	codec_priv
op	156:81	0:0	14	.
water	156:82	0:0	14	data
stmts	156:90	159:12	9	
water	156:90	0:0	10	{
water	157:16	0:0	10	fourcc
op	157:25	0:0	10	=
call	157:27	157:57	10	AV_RL32
arg	157:35	157:57	11	track->codec_priv.data
water	157:35	0:0	12	track
op	157:40	0:0	12	->
water	157:42	0:0	12	codec_priv
op	157:52	0:0	12	.
water	157:53	0:0	12	data
water	157:58	0:0	10	;
water	158:16	0:0	10	codec_id
op	158:25	0:0	10	=
call	158:27	158:73	10	ff_codec_get_id
arg	158:43	158:65	11	ff_codec_movvideo_tags
water	158:43	0:0	12	ff_codec_movvideo_tags
arg	158:67	158:73	11	fourcc
water	158:67	0:0	12	fourcc
water	158:74	0:0	10	;
water	159:12	0:0	10	}
if	160:12	161:43	8	(codec_id == AV_CODEC_ID_NONE &&AV_RL32 (track -> codec_priv . data + 4 ) ==AV_RL32 ("SMI " ))
cond	160:16	160:99	9	codec_id == AV_CODEC_ID_NONE &&AV_RL32 (track -> codec_priv . data + 4 ) ==AV_RL32 ("SMI " )
water	160:16	0:0	10	codec_id
op	160:25	0:0	10	==
water	160:28	0:0	10	AV_CODEC_ID_NONE
op	160:45	0:0	10	&&
call	160:48	160:80	10	AV_RL32
arg	160:56	160:80	11	track->codec_priv.data+4
water	160:56	0:0	12	track
op	160:61	0:0	12	->
water	160:63	0:0	12	codec_priv
op	160:73	0:0	12	.
water	160:74	0:0	12	data
op	160:78	0:0	12	+
water	160:79	0:0	12	4
op	160:82	0:0	10	==
call	160:85	160:99	10	AV_RL32
arg	160:93	160:99	11	"SMI "
water	160:93	0:0	12	"SMI "
stmts	161:16	161:43	9	
water	161:16	0:0	10	codec_id
op	161:25	0:0	10	=
water	161:27	0:0	10	AV_CODEC_ID_SVQ3
water	161:43	0:0	10	;
if	162:12	167:12	8	(codec_id == AV_CODEC_ID_NONE)
cond	162:16	162:28	9	codec_id == AV_CODEC_ID_NONE
water	162:16	0:0	10	codec_id
op	162:25	0:0	10	==
water	162:28	0:0	10	AV_CODEC_ID_NONE
stmts	162:46	167:12	9	
water	162:46	0:0	10	{
decl	163:16	163:28	10	char	buf[32]
call	164:16	164:64	10	av_get_codec_tag_string
arg	164:40	164:43	11	buf
water	164:40	0:0	12	buf
arg	164:45	164:56	11	sizeof(buf)
op	164:45	0:0	12	sizeof
water	164:51	0:0	12	(
water	164:52	0:0	12	buf
water	164:55	0:0	12	)
arg	164:58	164:64	11	fourcc
water	164:58	0:0	12	fourcc
water	164:65	0:0	10	;
call	165:16	166:56	10	av_log
arg	165:23	165:36	11	matroska->ctx
water	165:23	0:0	12	matroska
op	165:31	0:0	12	->
water	165:33	0:0	12	ctx
arg	165:38	165:50	11	AV_LOG_ERROR
water	165:38	0:0	12	AV_LOG_ERROR
arg	166:23	166:51	11	"mov FourCC not found %s.\n"
water	166:23	0:0	12	"mov FourCC not found %s.\n"
arg	166:53	166:56	11	buf
water	166:53	0:0	12	buf
water	166:57	0:0	10	;
water	167:12	0:0	10	}
water	168:8	0:0	8	}
else	168:10	180:8	4
stmts	168:15	180:8	5	
if	168:15	180:8	6	(codec_id == AV_CODEC_ID_PCM_S16BE)
cond	168:19	168:31	7	codec_id == AV_CODEC_ID_PCM_S16BE
water	168:19	0:0	8	codec_id
op	168:28	0:0	8	==
water	168:31	0:0	8	AV_CODEC_ID_PCM_S16BE
stmts	168:54	180:8	7	
water	168:54	0:0	8	{
switch	169:12	179:12	8	(track -> audio . bitdepth)
cond	169:20	169:33	9	track -> audio . bitdepth
water	169:20	0:0	10	track
op	169:25	0:0	10	->
water	169:27	0:0	10	audio
op	169:32	0:0	10	.
water	169:33	0:0	10	bitdepth
stmts	169:43	179:12	9	
water	169:43	0:0	10	{
label	170:12	170:19	10	case 8 :
water	171:16	0:0	10	codec_id
op	171:25	0:0	10	=
water	171:27	0:0	10	AV_CODEC_ID_PCM_U8
water	171:45	0:0	10	;
break	172:16	172:21	10	
label	173:12	173:19	10	case 24 :
water	174:16	0:0	10	codec_id
op	174:25	0:0	10	=
water	174:27	0:0	10	AV_CODEC_ID_PCM_S24BE
water	174:48	0:0	10	;
break	175:16	175:21	10	
label	176:12	176:19	10	case 32 :
water	177:16	0:0	10	codec_id
op	177:25	0:0	10	=
water	177:27	0:0	10	AV_CODEC_ID_PCM_S32BE
water	177:48	0:0	10	;
break	178:16	178:21	10	
water	179:12	0:0	10	}
water	180:8	0:0	8	}
else	180:10	192:8	4
stmts	180:15	192:8	5	
if	180:15	192:8	6	(codec_id == AV_CODEC_ID_PCM_S16LE)
cond	180:19	180:31	7	codec_id == AV_CODEC_ID_PCM_S16LE
water	180:19	0:0	8	codec_id
op	180:28	0:0	8	==
water	180:31	0:0	8	AV_CODEC_ID_PCM_S16LE
stmts	180:54	192:8	7	
water	180:54	0:0	8	{
switch	181:12	191:12	8	(track -> audio . bitdepth)
cond	181:20	181:33	9	track -> audio . bitdepth
water	181:20	0:0	10	track
op	181:25	0:0	10	->
water	181:27	0:0	10	audio
op	181:32	0:0	10	.
water	181:33	0:0	10	bitdepth
stmts	181:43	191:12	9	
water	181:43	0:0	10	{
label	182:12	182:19	10	case 8 :
water	183:16	0:0	10	codec_id
op	183:25	0:0	10	=
water	183:27	0:0	10	AV_CODEC_ID_PCM_U8
water	183:45	0:0	10	;
break	184:16	184:21	10	
label	185:12	185:19	10	case 24 :
water	186:16	0:0	10	codec_id
op	186:25	0:0	10	=
water	186:27	0:0	10	AV_CODEC_ID_PCM_S24LE
water	186:48	0:0	10	;
break	187:16	187:21	10	
label	188:12	188:19	10	case 32 :
water	189:16	0:0	10	codec_id
op	189:25	0:0	10	=
water	189:27	0:0	10	AV_CODEC_ID_PCM_S32LE
water	189:48	0:0	10	;
break	190:16	190:21	10	
water	191:12	0:0	10	}
water	192:8	0:0	8	}
else	192:10	195:8	4
stmts	192:15	195:8	5	
if	192:15	195:8	6	(codec_id == AV_CODEC_ID_PCM_F32LE && track -> audio . bitdepth == 64)
cond	192:19	193:44	7	codec_id == AV_CODEC_ID_PCM_F32LE && track -> audio . bitdepth == 64
water	192:19	0:0	8	codec_id
op	192:28	0:0	8	==
water	192:31	0:0	8	AV_CODEC_ID_PCM_F32LE
op	192:53	0:0	8	&&
water	193:19	0:0	8	track
op	193:24	0:0	8	->
water	193:26	0:0	8	audio
op	193:31	0:0	8	.
water	193:32	0:0	8	bitdepth
op	193:41	0:0	8	==
water	193:44	0:0	8	64
stmts	193:48	195:8	7	
water	193:48	0:0	8	{
water	194:12	0:0	8	codec_id
op	194:21	0:0	8	=
water	194:23	0:0	8	AV_CODEC_ID_PCM_F64LE
water	194:44	0:0	8	;
water	195:8	0:0	8	}
else	195:10	211:8	4
stmts	195:15	211:8	5	
if	195:15	211:8	6	(codec_id == AV_CODEC_ID_AAC && ! track -> codec_priv . size)
cond	195:19	195:69	7	codec_id == AV_CODEC_ID_AAC && ! track -> codec_priv . size
water	195:19	0:0	8	codec_id
op	195:28	0:0	8	==
water	195:31	0:0	8	AV_CODEC_ID_AAC
op	195:47	0:0	8	&&
op	195:50	0:0	8	!
water	195:51	0:0	8	track
op	195:56	0:0	8	->
water	195:58	0:0	8	codec_priv
op	195:68	0:0	8	.
water	195:69	0:0	8	size
stmts	195:75	211:8	7	
water	195:75	0:0	8	{
decl	196:12	196:63	8	int	profile
op	196:24	0:0	8	=
call	196:26	196:62	9	matroska_aac_profile
arg	196:47	196:62	10	track->codec_id
water	196:47	0:0	11	track
op	196:52	0:0	11	->
water	196:54	0:0	11	codec_id
decl	197:12	197:67	8	int	sri
op	197:24	0:0	8	=
call	197:26	197:66	9	matroska_aac_sri
arg	197:43	197:66	10	track->audio.samplerate
water	197:43	0:0	11	track
op	197:48	0:0	11	->
water	197:50	0:0	11	audio
op	197:55	0:0	11	.
water	197:56	0:0	11	samplerate
water	198:12	0:0	8	extradata
op	198:24	0:0	8	=
call	198:26	198:69	8	av_mallocz
arg	198:37	198:69	9	5+AV_INPUT_BUFFER_PADDING_SIZE
water	198:37	0:0	10	5
op	198:39	0:0	10	+
water	198:41	0:0	10	AV_INPUT_BUFFER_PADDING_SIZE
water	198:70	0:0	8	;
if	199:12	200:38	8	(! extradata)
cond	199:16	199:17	9	! extradata
op	199:16	0:0	10	!
water	199:17	0:0	10	extradata
stmts	200:16	200:38	9	
return	200:16	200:38	10	AVERROR(ENOMEM)
call	200:23	200:37	11	AVERROR
arg	200:31	200:37	12	ENOMEM
water	200:31	0:0	13	ENOMEM
water	201:12	0:0	8	extradata
op	201:21	0:0	8	[
water	201:22	0:0	8	0
op	201:23	0:0	8	]
op	201:25	0:0	8	=
water	201:27	0:0	8	(
water	201:28	0:0	8	profile
op	201:36	0:0	8	<<
water	201:39	0:0	8	3
water	201:40	0:0	8	)
op	201:42	0:0	8	|
water	201:44	0:0	8	(
water	201:45	0:0	8	(
water	201:46	0:0	8	sri
op	201:50	0:0	8	&
water	201:52	0:0	8	0
water	201:53	0:0	8	x0E
water	201:56	0:0	8	)
op	201:58	0:0	8	>>
water	201:61	0:0	8	1
water	201:62	0:0	8	)
water	201:63	0:0	8	;
water	202:12	0:0	8	extradata
op	202:21	0:0	8	[
water	202:22	0:0	8	1
op	202:23	0:0	8	]
op	202:25	0:0	8	=
water	202:27	0:0	8	(
water	202:28	0:0	8	(
water	202:29	0:0	8	sri
op	202:33	0:0	8	&
water	202:35	0:0	8	0
water	202:36	0:0	8	x01
water	202:39	0:0	8	)
op	202:41	0:0	8	<<
water	202:44	0:0	8	7
water	202:45	0:0	8	)
op	202:47	0:0	8	|
water	202:49	0:0	8	(
water	202:50	0:0	8	track
op	202:55	0:0	8	->
water	202:57	0:0	8	audio
op	202:62	0:0	8	.
water	202:63	0:0	8	channels
op	202:72	0:0	8	<<
water	202:75	0:0	8	3
water	202:76	0:0	8	)
water	202:77	0:0	8	;
if	203:12	209:12	8	(strstr (track -> codec_id ,"SBR" ))
cond	203:16	203:45	9	strstr (track -> codec_id ,"SBR" )
call	203:16	203:45	10	strstr
arg	203:23	203:38	11	track->codec_id
water	203:23	0:0	12	track
op	203:28	0:0	12	->
water	203:30	0:0	12	codec_id
arg	203:40	203:45	11	"SBR"
water	203:40	0:0	12	"SBR"
stmts	203:48	209:12	9	
water	203:48	0:0	10	{
water	204:16	0:0	10	sri
op	204:31	0:0	10	=
call	204:33	204:77	10	matroska_aac_sri
arg	204:50	204:77	11	track->audio.out_samplerate
water	204:50	0:0	12	track
op	204:55	0:0	12	->
water	204:57	0:0	12	audio
op	204:62	0:0	12	.
water	204:63	0:0	12	out_samplerate
water	204:78	0:0	10	;
water	205:16	0:0	10	extradata
op	205:25	0:0	10	[
water	205:26	0:0	10	2
op	205:27	0:0	10	]
op	205:31	0:0	10	=
water	205:33	0:0	10	0
water	205:34	0:0	10	x56
water	205:37	0:0	10	;
water	206:16	0:0	10	extradata
op	206:25	0:0	10	[
water	206:26	0:0	10	3
op	206:27	0:0	10	]
op	206:31	0:0	10	=
water	206:33	0:0	10	0
water	206:34	0:0	10	xE5
water	206:37	0:0	10	;
water	207:16	0:0	10	extradata
op	207:25	0:0	10	[
water	207:26	0:0	10	4
op	207:27	0:0	10	]
op	207:31	0:0	10	=
water	207:33	0:0	10	0
water	207:34	0:0	10	x80
op	207:38	0:0	10	|
water	207:40	0:0	10	(
water	207:41	0:0	10	sri
op	207:45	0:0	10	<<
water	207:48	0:0	10	3
water	207:49	0:0	10	)
water	207:50	0:0	10	;
water	208:16	0:0	10	extradata_size
op	208:31	0:0	10	=
water	208:33	0:0	10	5
water	208:34	0:0	10	;
water	209:12	0:0	10	}
else	209:14	210:34	8
stmts	210:16	210:34	9	
water	210:16	0:0	10	extradata_size
op	210:31	0:0	10	=
water	210:33	0:0	10	2
water	210:34	0:0	10	;
water	211:8	0:0	8	}
else	211:10	225:8	4
stmts	211:15	225:8	5	
if	211:15	225:8	6	(codec_id == AV_CODEC_ID_ALAC && track -> codec_priv . size && track -> codec_priv . size < INT_MAX - 12 - AV_INPUT_BUFFER_PADDING_SIZE)
cond	211:19	211:117	7	codec_id == AV_CODEC_ID_ALAC && track -> codec_priv . size && track -> codec_priv . size < INT_MAX - 12 - AV_INPUT_BUFFER_PADDING_SIZE
water	211:19	0:0	8	codec_id
op	211:28	0:0	8	==
water	211:31	0:0	8	AV_CODEC_ID_ALAC
op	211:48	0:0	8	&&
water	211:51	0:0	8	track
op	211:56	0:0	8	->
water	211:58	0:0	8	codec_priv
op	211:68	0:0	8	.
water	211:69	0:0	8	size
op	211:74	0:0	8	&&
water	211:77	0:0	8	track
op	211:82	0:0	8	->
water	211:84	0:0	8	codec_priv
op	211:94	0:0	8	.
water	211:95	0:0	8	size
op	211:100	0:0	8	<
water	211:102	0:0	8	INT_MAX
op	211:110	0:0	8	-
water	211:112	0:0	8	12
op	211:115	0:0	8	-
water	211:117	0:0	8	AV_INPUT_BUFFER_PADDING_SIZE
stmts	211:147	225:8	7	
water	211:147	0:0	8	{
water	215:12	0:0	8	extradata_size
op	215:27	0:0	8	=
water	215:29	0:0	8	12
op	215:32	0:0	8	+
water	215:34	0:0	8	track
op	215:39	0:0	8	->
water	215:41	0:0	8	codec_priv
op	215:51	0:0	8	.
water	215:52	0:0	8	size
water	215:56	0:0	8	;
water	216:12	0:0	8	extradata
op	216:27	0:0	8	=
call	216:29	217:68	8	av_mallocz
arg	216:40	217:68	9	extradata_size+AV_INPUT_BUFFER_PADDING_SIZE
water	216:40	0:0	10	extradata_size
op	216:55	0:0	10	+
water	217:40	0:0	10	AV_INPUT_BUFFER_PADDING_SIZE
water	217:69	0:0	8	;
if	218:12	219:38	8	(! extradata)
cond	218:16	218:17	9	! extradata
op	218:16	0:0	10	!
water	218:17	0:0	10	extradata
stmts	219:16	219:38	9	
return	219:16	219:38	10	AVERROR(ENOMEM)
call	219:23	219:37	11	AVERROR
arg	219:31	219:37	12	ENOMEM
water	219:31	0:0	13	ENOMEM
call	220:12	220:45	8	AV_WB32
arg	220:20	220:29	9	extradata
water	220:20	0:0	10	extradata
arg	220:31	220:45	9	extradata_size
water	220:31	0:0	10	extradata_size
water	220:46	0:0	8	;
call	221:12	221:43	8	memcpy
arg	221:19	221:32	9	&extradata[4]
op	221:19	0:0	10	&
water	221:20	0:0	10	extradata
op	221:29	0:0	10	[
water	221:30	0:0	10	4
op	221:31	0:0	10	]
arg	221:34	221:40	9	"alac"
water	221:34	0:0	10	"alac"
arg	221:42	221:43	9	4
water	221:42	0:0	10	4
water	221:44	0:0	8	;
call	222:12	222:36	8	AV_WB32
arg	222:20	222:33	9	&extradata[8]
op	222:20	0:0	10	&
water	222:21	0:0	10	extradata
op	222:30	0:0	10	[
water	222:31	0:0	10	8
op	222:32	0:0	10	]
arg	222:35	222:36	9	0
water	222:35	0:0	10	0
water	222:37	0:0	8	;
call	223:12	224:41	8	memcpy
arg	223:19	223:33	9	&extradata[12]
op	223:19	0:0	10	&
water	223:20	0:0	10	extradata
op	223:29	0:0	10	[
water	223:30	0:0	10	12
op	223:32	0:0	10	]
arg	223:35	223:57	9	track->codec_priv.data
water	223:35	0:0	10	track
op	223:40	0:0	10	->
water	223:42	0:0	10	codec_priv
op	223:52	0:0	10	.
water	223:53	0:0	10	data
arg	224:19	224:41	9	track->codec_priv.size
water	224:19	0:0	10	track
op	224:24	0:0	10	->
water	224:26	0:0	10	codec_priv
op	224:36	0:0	10	.
water	224:37	0:0	10	size
water	224:42	0:0	8	;
water	225:8	0:0	8	}
else	225:10	254:8	4
stmts	225:15	254:8	5	
if	225:15	254:8	6	(codec_id == AV_CODEC_ID_TTA)
cond	225:19	225:31	7	codec_id == AV_CODEC_ID_TTA
water	225:19	0:0	8	codec_id
op	225:28	0:0	8	==
water	225:31	0:0	8	AV_CODEC_ID_TTA
stmts	225:48	254:8	7	
water	225:48	0:0	8	{
water	226:12	0:0	8	extradata_size
op	226:27	0:0	8	=
water	226:29	0:0	8	30
water	226:31	0:0	8	;
water	227:12	0:0	8	extradata
op	227:27	0:0	8	=
call	227:29	227:85	8	av_mallocz
arg	227:40	227:85	9	extradata_size+AV_INPUT_BUFFER_PADDING_SIZE
water	227:40	0:0	10	extradata_size
op	227:55	0:0	10	+
water	227:57	0:0	10	AV_INPUT_BUFFER_PADDING_SIZE
water	227:86	0:0	8	;
if	228:12	229:38	8	(! extradata)
cond	228:16	228:17	9	! extradata
op	228:16	0:0	10	!
water	228:17	0:0	10	extradata
stmts	229:16	229:38	9	
return	229:16	229:38	10	AVERROR(ENOMEM)
call	229:23	229:37	11	AVERROR
arg	229:31	229:37	12	ENOMEM
water	229:31	0:0	13	ENOMEM
call	230:12	231:52	8	ffio_init_context
arg	230:30	230:32	9	&b
op	230:30	0:0	10	&
water	230:31	0:0	10	b
arg	230:34	230:43	9	extradata
water	230:34	0:0	10	extradata
arg	230:45	230:59	9	extradata_size
water	230:45	0:0	10	extradata_size
arg	230:61	230:62	9	1
water	230:61	0:0	10	1
arg	231:30	231:34	9	NULL
water	231:30	0:0	10	NULL
arg	231:36	231:40	9	NULL
water	231:36	0:0	10	NULL
arg	231:42	231:46	9	NULL
water	231:42	0:0	10	NULL
arg	231:48	231:52	9	NULL
water	231:48	0:0	10	NULL
water	231:53	0:0	8	;
call	232:12	232:36	8	avio_write
arg	232:23	232:25	9	&b
op	232:23	0:0	10	&
water	232:24	0:0	10	b
arg	232:27	232:33	9	"TTA1"
water	232:27	0:0	10	"TTA1"
arg	232:35	232:36	9	4
water	232:35	0:0	10	4
water	232:37	0:0	8	;
call	233:12	233:27	8	avio_wl16
arg	233:22	233:24	9	&b
op	233:22	0:0	10	&
water	233:23	0:0	10	b
arg	233:26	233:27	9	1
water	233:26	0:0	10	1
water	233:28	0:0	8	;
if	234:12	245:12	8	(track -> audio . channels > UINT16_MAX || track -> audio . bitdepth > UINT16_MAX)
cond	234:16	235:40	9	track -> audio . channels > UINT16_MAX || track -> audio . bitdepth > UINT16_MAX
water	234:16	0:0	10	track
op	234:21	0:0	10	->
water	234:23	0:0	10	audio
op	234:28	0:0	10	.
water	234:29	0:0	10	channels
op	234:38	0:0	10	>
water	234:40	0:0	10	UINT16_MAX
op	234:51	0:0	10	||
water	235:16	0:0	10	track
op	235:21	0:0	10	->
water	235:23	0:0	10	audio
op	235:28	0:0	10	.
water	235:29	0:0	10	bitdepth
op	235:38	0:0	10	>
water	235:40	0:0	10	UINT16_MAX
stmts	235:52	245:12	9	
water	235:52	0:0	10	{
call	236:16	239:67	10	av_log
arg	236:23	236:36	11	matroska->ctx
water	236:23	0:0	12	matroska
op	236:31	0:0	12	->
water	236:33	0:0	12	ctx
arg	236:38	236:52	11	AV_LOG_WARNING
water	236:38	0:0	12	AV_LOG_WARNING
arg	237:23	238:66	11	"Too large audio channel number %"PRIu64" or bitdepth %"PRIu64". Skipping track.\n"
water	237:23	0:0	12	"Too large audio channel number %"
water	237:57	0:0	12	PRIu64
water	238:23	0:0	12	" or bitdepth %"
water	238:39	0:0	12	PRIu64
water	238:45	0:0	12	". Skipping track.\n"
arg	239:23	239:44	11	track->audio.channels
water	239:23	0:0	12	track
op	239:28	0:0	12	->
water	239:30	0:0	12	audio
op	239:35	0:0	12	.
water	239:36	0:0	12	channels
arg	239:46	239:67	11	track->audio.bitdepth
water	239:46	0:0	12	track
op	239:51	0:0	12	->
water	239:53	0:0	12	audio
op	239:58	0:0	12	.
water	239:59	0:0	12	bitdepth
water	239:68	0:0	10	;
call	240:16	240:35	10	av_freep
arg	240:25	240:35	11	&extradata
op	240:25	0:0	12	&
water	240:26	0:0	12	extradata
water	240:36	0:0	10	;
if	241:16	242:46	10	(matroska -> ctx -> error_recognition & AV_EF_EXPLODE)
cond	241:20	241:55	11	matroska -> ctx -> error_recognition & AV_EF_EXPLODE
water	241:20	0:0	12	matroska
op	241:28	0:0	12	->
water	241:30	0:0	12	ctx
op	241:33	0:0	12	->
water	241:35	0:0	12	error_recognition
op	241:53	0:0	12	&
water	241:55	0:0	12	AV_EF_EXPLODE
stmts	242:20	242:46	11	
return	242:20	242:46	12	AVERROR_INVALIDDATA
water	242:27	0:0	13	AVERROR_INVALIDDATA
else	243:16	244:28	10
stmts	244:20	244:28	11	
continue	244:20	244:28	12	
water	245:12	0:0	10	}
call	246:12	246:47	8	avio_wl16
arg	246:22	246:24	9	&b
op	246:22	0:0	10	&
water	246:23	0:0	10	b
arg	246:26	246:47	9	track->audio.channels
water	246:26	0:0	10	track
op	246:31	0:0	10	->
water	246:33	0:0	10	audio
op	246:38	0:0	10	.
water	246:39	0:0	10	channels
water	246:48	0:0	8	;
call	247:12	247:47	8	avio_wl16
arg	247:22	247:24	9	&b
op	247:22	0:0	10	&
water	247:23	0:0	10	b
arg	247:26	247:47	9	track->audio.bitdepth
water	247:26	0:0	10	track
op	247:31	0:0	10	->
water	247:33	0:0	10	audio
op	247:38	0:0	10	.
water	247:39	0:0	10	bitdepth
water	247:48	0:0	8	;
if	248:12	249:42	8	(track -> audio . out_samplerate < 0 || track -> audio . out_samplerate > INT_MAX)
cond	248:16	248:81	9	track -> audio . out_samplerate < 0 || track -> audio . out_samplerate > INT_MAX
water	248:16	0:0	10	track
op	248:21	0:0	10	->
water	248:23	0:0	10	audio
op	248:28	0:0	10	.
water	248:29	0:0	10	out_samplerate
op	248:44	0:0	10	<
water	248:46	0:0	10	0
op	248:48	0:0	10	||
water	248:51	0:0	10	track
op	248:56	0:0	10	->
water	248:58	0:0	10	audio
op	248:63	0:0	10	.
water	248:64	0:0	10	out_samplerate
op	248:79	0:0	10	>
water	248:81	0:0	10	INT_MAX
stmts	249:16	249:42	9	
return	249:16	249:42	10	AVERROR_INVALIDDATA
water	249:23	0:0	11	AVERROR_INVALIDDATA
call	250:12	250:53	8	avio_wl32
arg	250:22	250:24	9	&b
op	250:22	0:0	10	&
water	250:23	0:0	10	b
arg	250:26	250:53	9	track->audio.out_samplerate
water	250:26	0:0	10	track
op	250:31	0:0	10	->
water	250:33	0:0	10	audio
op	250:38	0:0	10	.
water	250:39	0:0	10	out_samplerate
water	250:54	0:0	8	;
call	251:12	253:57	8	avio_wl32
arg	251:22	251:24	9	&b
op	251:22	0:0	10	&
water	251:23	0:0	10	b
arg	251:26	253:57	9	av_rescale((matroska->duration*matroska->time_scale),track->audio.out_samplerate,AV_TIME_BASE*1000)
call	251:26	253:56	10	av_rescale
arg	251:37	251:80	11	(matroska->duration*matroska->time_scale)
water	251:37	0:0	12	(
water	251:38	0:0	12	matroska
op	251:46	0:0	12	->
water	251:48	0:0	12	duration
op	251:57	0:0	12	*
water	251:59	0:0	12	matroska
op	251:67	0:0	12	->
water	251:69	0:0	12	time_scale
water	251:79	0:0	12	)
arg	252:37	252:64	11	track->audio.out_samplerate
water	252:37	0:0	12	track
op	252:42	0:0	12	->
water	252:44	0:0	12	audio
op	252:49	0:0	12	.
water	252:50	0:0	12	out_samplerate
arg	253:37	253:56	11	AV_TIME_BASE*1000
water	253:37	0:0	12	AV_TIME_BASE
op	253:50	0:0	12	*
water	253:52	0:0	12	1000
water	253:58	0:0	8	;
water	254:8	0:0	8	}
else	254:10	259:8	4
stmts	254:15	259:8	5	
if	254:15	259:8	6	(codec_id == AV_CODEC_ID_RV10 || codec_id == AV_CODEC_ID_RV20 || codec_id == AV_CODEC_ID_RV30 || codec_id == AV_CODEC_ID_RV40)
cond	254:19	257:31	7	codec_id == AV_CODEC_ID_RV10 || codec_id == AV_CODEC_ID_RV20 || codec_id == AV_CODEC_ID_RV30 || codec_id == AV_CODEC_ID_RV40
water	254:19	0:0	8	codec_id
op	254:28	0:0	8	==
water	254:31	0:0	8	AV_CODEC_ID_RV10
op	254:48	0:0	8	||
water	255:19	0:0	8	codec_id
op	255:28	0:0	8	==
water	255:31	0:0	8	AV_CODEC_ID_RV20
op	255:48	0:0	8	||
water	256:19	0:0	8	codec_id
op	256:28	0:0	8	==
water	256:31	0:0	8	AV_CODEC_ID_RV30
op	256:48	0:0	8	||
water	257:19	0:0	8	codec_id
op	257:28	0:0	8	==
water	257:31	0:0	8	AV_CODEC_ID_RV40
stmts	257:49	259:8	7	
water	257:49	0:0	8	{
water	258:12	0:0	8	extradata_offset
op	258:29	0:0	8	=
water	258:31	0:0	8	26
water	258:33	0:0	8	;
water	259:8	0:0	8	}
else	259:10	262:8	4
stmts	259:15	262:8	5	
if	259:15	262:8	6	(codec_id == AV_CODEC_ID_RA_144)
cond	259:19	259:31	7	codec_id == AV_CODEC_ID_RA_144
water	259:19	0:0	8	codec_id
op	259:28	0:0	8	==
water	259:31	0:0	8	AV_CODEC_ID_RA_144
stmts	259:51	262:8	7	
water	259:51	0:0	8	{
water	260:12	0:0	8	track
op	260:17	0:0	8	->
water	260:19	0:0	8	audio
op	260:24	0:0	8	.
water	260:25	0:0	8	out_samplerate
op	260:40	0:0	8	=
water	260:42	0:0	8	8000
water	260:46	0:0	8	;
water	261:12	0:0	8	track
op	261:17	0:0	8	->
water	261:19	0:0	8	audio
op	261:24	0:0	8	.
water	261:25	0:0	8	channels
op	261:40	0:0	8	=
water	261:42	0:0	8	1
water	261:43	0:0	8	;
water	262:8	0:0	8	}
else	262:10	300:8	4
stmts	262:15	300:8	5	
if	262:15	300:8	6	(( codec_id == AV_CODEC_ID_RA_288 || codec_id == AV_CODEC_ID_COOK || codec_id == AV_CODEC_ID_ATRAC3 || codec_id == AV_CODEC_ID_SIPR ) && track -> codec_priv . data)
cond	262:19	266:43	7	( codec_id == AV_CODEC_ID_RA_288 || codec_id == AV_CODEC_ID_COOK || codec_id == AV_CODEC_ID_ATRAC3 || codec_id == AV_CODEC_ID_SIPR ) && track -> codec_priv . data
water	262:19	0:0	8	(
water	262:20	0:0	8	codec_id
op	262:29	0:0	8	==
water	262:32	0:0	8	AV_CODEC_ID_RA_288
op	262:51	0:0	8	||
water	263:20	0:0	8	codec_id
op	263:29	0:0	8	==
water	263:32	0:0	8	AV_CODEC_ID_COOK
op	263:51	0:0	8	||
water	264:20	0:0	8	codec_id
op	264:29	0:0	8	==
water	264:32	0:0	8	AV_CODEC_ID_ATRAC3
op	264:51	0:0	8	||
water	265:20	0:0	8	codec_id
op	265:29	0:0	8	==
water	265:32	0:0	8	AV_CODEC_ID_SIPR
water	265:48	0:0	8	)
op	266:22	0:0	8	&&
water	266:25	0:0	8	track
op	266:30	0:0	8	->
water	266:32	0:0	8	codec_priv
op	266:42	0:0	8	.
water	266:43	0:0	8	data
stmts	266:49	300:8	7	
water	266:49	0:0	8	{
decl	267:12	267:22	8	int	flavor
call	268:12	270:55	8	ffio_init_context
arg	268:30	268:32	9	&b
op	268:30	0:0	10	&
water	268:31	0:0	10	b
arg	268:34	268:56	9	track->codec_priv.data
water	268:34	0:0	10	track
op	268:39	0:0	10	->
water	268:41	0:0	10	codec_priv
op	268:51	0:0	10	.
water	268:52	0:0	10	data
arg	269:30	269:52	9	track->codec_priv.size
water	269:30	0:0	10	track
op	269:35	0:0	10	->
water	269:37	0:0	10	codec_priv
op	269:47	0:0	10	.
water	269:48	0:0	10	size
arg	270:30	270:31	9	0
water	270:30	0:0	10	0
arg	270:33	270:37	9	NULL
water	270:33	0:0	10	NULL
arg	270:39	270:43	9	NULL
water	270:39	0:0	10	NULL
arg	270:45	270:49	9	NULL
water	270:45	0:0	10	NULL
arg	270:51	270:55	9	NULL
water	270:51	0:0	10	NULL
water	270:56	0:0	8	;
call	271:12	271:28	8	avio_skip
arg	271:22	271:24	9	&b
op	271:22	0:0	10	&
water	271:23	0:0	10	b
arg	271:26	271:28	9	22
water	271:26	0:0	10	22
water	271:29	0:0	8	;
water	272:12	0:0	8	flavor
op	272:41	0:0	8	=
call	272:43	272:55	8	avio_rb16
arg	272:53	272:55	9	&b
op	272:53	0:0	10	&
water	272:54	0:0	10	b
water	272:56	0:0	8	;
water	273:12	0:0	8	track
op	273:17	0:0	8	->
water	273:19	0:0	8	audio
op	273:24	0:0	8	.
water	273:25	0:0	8	coded_framesize
op	273:41	0:0	8	=
call	273:43	273:55	8	avio_rb32
arg	273:53	273:55	9	&b
op	273:53	0:0	10	&
water	273:54	0:0	10	b
water	273:56	0:0	8	;
call	274:12	274:28	8	avio_skip
arg	274:22	274:24	9	&b
op	274:22	0:0	10	&
water	274:23	0:0	10	b
arg	274:26	274:28	9	12
water	274:26	0:0	10	12
water	274:29	0:0	8	;
water	275:12	0:0	8	track
op	275:17	0:0	8	->
water	275:19	0:0	8	audio
op	275:24	0:0	8	.
water	275:25	0:0	8	sub_packet_h
op	275:41	0:0	8	=
call	275:43	275:55	8	avio_rb16
arg	275:53	275:55	9	&b
op	275:53	0:0	10	&
water	275:54	0:0	10	b
water	275:56	0:0	8	;
water	276:12	0:0	8	track
op	276:17	0:0	8	->
water	276:19	0:0	8	audio
op	276:24	0:0	8	.
water	276:25	0:0	8	frame_size
op	276:41	0:0	8	=
call	276:43	276:55	8	avio_rb16
arg	276:53	276:55	9	&b
op	276:53	0:0	10	&
water	276:54	0:0	10	b
water	276:56	0:0	8	;
water	277:12	0:0	8	track
op	277:17	0:0	8	->
water	277:19	0:0	8	audio
op	277:24	0:0	8	.
water	277:25	0:0	8	sub_packet_size
op	277:41	0:0	8	=
call	277:43	277:55	8	avio_rb16
arg	277:53	277:55	9	&b
op	277:53	0:0	10	&
water	277:54	0:0	10	b
water	277:56	0:0	8	;
if	278:12	283:42	8	(flavor < 0 || track -> audio . coded_framesize <= 0 || track -> audio . sub_packet_h <= 0 || track -> audio . frame_size <= 0 || track -> audio . sub_packet_size <= 0)
cond	278:16	282:48	9	flavor < 0 || track -> audio . coded_framesize <= 0 || track -> audio . sub_packet_h <= 0 || track -> audio . frame_size <= 0 || track -> audio . sub_packet_size <= 0
water	278:16	0:0	10	flavor
op	278:46	0:0	10	<
water	278:48	0:0	10	0
op	278:50	0:0	10	||
water	279:16	0:0	10	track
op	279:21	0:0	10	->
water	279:23	0:0	10	audio
op	279:28	0:0	10	.
water	279:29	0:0	10	coded_framesize
op	279:45	0:0	10	<=
water	279:48	0:0	10	0
op	279:50	0:0	10	||
water	280:16	0:0	10	track
op	280:21	0:0	10	->
water	280:23	0:0	10	audio
op	280:28	0:0	10	.
water	280:29	0:0	10	sub_packet_h
op	280:45	0:0	10	<=
water	280:48	0:0	10	0
op	280:50	0:0	10	||
water	281:16	0:0	10	track
op	281:21	0:0	10	->
water	281:23	0:0	10	audio
op	281:28	0:0	10	.
water	281:29	0:0	10	frame_size
op	281:45	0:0	10	<=
water	281:48	0:0	10	0
op	281:50	0:0	10	||
water	282:16	0:0	10	track
op	282:21	0:0	10	->
water	282:23	0:0	10	audio
op	282:28	0:0	10	.
water	282:29	0:0	10	sub_packet_size
op	282:45	0:0	10	<=
water	282:48	0:0	10	0
stmts	283:16	283:42	9	
return	283:16	283:42	10	AVERROR_INVALIDDATA
water	283:23	0:0	11	AVERROR_INVALIDDATA
water	284:12	0:0	8	track
op	284:17	0:0	8	->
water	284:19	0:0	8	audio
op	284:24	0:0	8	.
water	284:25	0:0	8	buf
op	284:29	0:0	8	=
call	284:31	285:70	8	av_malloc_array
arg	284:47	284:72	9	track->audio.sub_packet_h
water	284:47	0:0	10	track
op	284:52	0:0	10	->
water	284:54	0:0	10	audio
op	284:59	0:0	10	.
water	284:60	0:0	10	sub_packet_h
arg	285:47	285:70	9	track->audio.frame_size
water	285:47	0:0	10	track
op	285:52	0:0	10	->
water	285:54	0:0	10	audio
op	285:59	0:0	10	.
water	285:60	0:0	10	frame_size
water	285:71	0:0	8	;
if	286:12	287:38	8	(! track -> audio . buf)
cond	286:16	286:30	9	! track -> audio . buf
op	286:16	0:0	10	!
water	286:17	0:0	10	track
op	286:22	0:0	10	->
water	286:24	0:0	10	audio
op	286:29	0:0	10	.
water	286:30	0:0	10	buf
stmts	287:16	287:38	9	
return	287:16	287:38	10	AVERROR(ENOMEM)
call	287:23	287:37	11	AVERROR
arg	287:31	287:37	12	ENOMEM
water	287:31	0:0	13	ENOMEM
if	288:12	291:12	8	(codec_id == AV_CODEC_ID_RA_288)
cond	288:16	288:28	9	codec_id == AV_CODEC_ID_RA_288
water	288:16	0:0	10	codec_id
op	288:25	0:0	10	==
water	288:28	0:0	10	AV_CODEC_ID_RA_288
stmts	288:48	291:12	9	
water	288:48	0:0	10	{
water	289:16	0:0	10	st
op	289:18	0:0	10	->
water	289:20	0:0	10	codec
op	289:25	0:0	10	->
water	289:27	0:0	10	block_align
op	289:39	0:0	10	=
water	289:41	0:0	10	track
op	289:46	0:0	10	->
water	289:48	0:0	10	audio
op	289:53	0:0	10	.
water	289:54	0:0	10	coded_framesize
water	289:69	0:0	10	;
water	290:16	0:0	10	track
op	290:21	0:0	10	->
water	290:23	0:0	10	codec_priv
op	290:33	0:0	10	.
water	290:34	0:0	10	size
op	290:39	0:0	10	=
water	290:41	0:0	10	0
water	290:42	0:0	10	;
water	291:12	0:0	10	}
else	291:14	299:12	8
stmts	291:19	299:12	9	
water	291:19	0:0	10	{
if	292:16	296:16	10	(codec_id == AV_CODEC_ID_SIPR && flavor < 4)
cond	292:20	292:61	11	codec_id == AV_CODEC_ID_SIPR && flavor < 4
water	292:20	0:0	12	codec_id
op	292:29	0:0	12	==
water	292:32	0:0	12	AV_CODEC_ID_SIPR
op	292:49	0:0	12	&&
water	292:52	0:0	12	flavor
op	292:59	0:0	12	<
water	292:61	0:0	12	4
stmts	292:64	296:16	11	
water	292:64	0:0	12	{
water	293:20	0:0	12	static
water	293:27	0:0	12	const
water	293:33	0:0	12	int
water	293:37	0:0	12	sipr_bit_rate
op	293:50	0:0	12	[
water	293:51	0:0	12	4
op	293:52	0:0	12	]
op	293:54	0:0	12	=
water	293:56	0:0	12	{
water	293:58	0:0	12	6504
water	293:62	0:0	12	,
water	293:64	0:0	12	8496
water	293:68	0:0	12	,
water	293:70	0:0	12	5000
water	293:74	0:0	12	,
water	293:76	0:0	12	16000
water	293:82	0:0	12	}
water	293:83	0:0	12	;
water	294:20	0:0	12	track
op	294:25	0:0	12	->
water	294:27	0:0	12	audio
op	294:32	0:0	12	.
water	294:33	0:0	12	sub_packet_size
op	294:49	0:0	12	=
water	294:51	0:0	12	ff_sipr_subpk_size
op	294:69	0:0	12	[
water	294:70	0:0	12	flavor
op	294:76	0:0	12	]
water	294:77	0:0	12	;
water	295:20	0:0	12	st
op	295:22	0:0	12	->
water	295:24	0:0	12	codec
op	295:29	0:0	12	->
water	295:31	0:0	12	bit_rate
op	295:49	0:0	12	=
water	295:51	0:0	12	sipr_bit_rate
op	295:64	0:0	12	[
water	295:65	0:0	12	flavor
op	295:71	0:0	12	]
water	295:72	0:0	12	;
water	296:16	0:0	12	}
water	297:16	0:0	10	st
op	297:18	0:0	10	->
water	297:20	0:0	10	codec
op	297:25	0:0	10	->
water	297:27	0:0	10	block_align
op	297:39	0:0	10	=
water	297:41	0:0	10	track
op	297:46	0:0	10	->
water	297:48	0:0	10	audio
op	297:53	0:0	10	.
water	297:54	0:0	10	sub_packet_size
water	297:69	0:0	10	;
water	298:16	0:0	10	extradata_offset
op	298:39	0:0	10	=
water	298:41	0:0	10	78
water	298:43	0:0	10	;
water	299:12	0:0	10	}
water	300:8	0:0	8	}
else	300:10	304:8	4
stmts	300:15	304:8	5	
if	300:15	304:8	6	(codec_id == AV_CODEC_ID_FLAC && track -> codec_priv . size)
cond	300:19	300:69	7	codec_id == AV_CODEC_ID_FLAC && track -> codec_priv . size
water	300:19	0:0	8	codec_id
op	300:28	0:0	8	==
water	300:31	0:0	8	AV_CODEC_ID_FLAC
op	300:48	0:0	8	&&
water	300:51	0:0	8	track
op	300:56	0:0	8	->
water	300:58	0:0	8	codec_priv
op	300:68	0:0	8	.
water	300:69	0:0	8	size
stmts	300:75	304:8	7	
water	300:75	0:0	8	{
water	301:12	0:0	8	ret
op	301:16	0:0	8	=
call	301:18	301:65	8	matroska_parse_flac
arg	301:38	301:39	9	s
water	301:38	0:0	10	s
arg	301:41	301:46	9	track
water	301:41	0:0	10	track
arg	301:48	301:65	9	&extradata_offset
op	301:48	0:0	10	&
water	301:49	0:0	10	extradata_offset
water	301:66	0:0	8	;
if	302:12	303:26	8	(ret < 0)
cond	302:16	302:22	9	ret < 0
water	302:16	0:0	10	ret
op	302:20	0:0	10	<
water	302:22	0:0	10	0
stmts	303:16	303:26	9	
return	303:16	303:26	10	ret
water	303:23	0:0	11	ret
water	304:8	0:0	8	}
else	304:10	306:8	4
stmts	304:15	306:8	5	
if	304:15	306:8	6	(codec_id == AV_CODEC_ID_PRORES && track -> codec_priv . size == 4)
cond	304:19	304:79	7	codec_id == AV_CODEC_ID_PRORES && track -> codec_priv . size == 4
water	304:19	0:0	8	codec_id
op	304:28	0:0	8	==
water	304:31	0:0	8	AV_CODEC_ID_PRORES
op	304:50	0:0	8	&&
water	304:53	0:0	8	track
op	304:58	0:0	8	->
water	304:60	0:0	8	codec_priv
op	304:70	0:0	8	.
water	304:71	0:0	8	size
op	304:76	0:0	8	==
water	304:79	0:0	8	4
stmts	304:82	306:8	7	
water	304:82	0:0	8	{
water	305:12	0:0	8	fourcc
op	305:19	0:0	8	=
call	305:21	305:51	8	AV_RL32
arg	305:29	305:51	9	track->codec_priv.data
water	305:29	0:0	10	track
op	305:34	0:0	10	->
water	305:36	0:0	10	codec_priv
op	305:46	0:0	10	.
water	305:47	0:0	10	data
water	305:52	0:0	8	;
water	306:8	0:0	8	}
water	307:8	0:0	4	track
op	307:13	0:0	4	->
water	307:15	0:0	4	codec_priv
op	307:25	0:0	4	.
water	307:26	0:0	4	size
op	307:31	0:0	4	-=
water	307:34	0:0	4	extradata_offset
water	307:50	0:0	4	;
if	308:8	310:74	4	(codec_id == AV_CODEC_ID_NONE)
cond	308:12	308:24	5	codec_id == AV_CODEC_ID_NONE
water	308:12	0:0	6	codec_id
op	308:21	0:0	6	==
water	308:24	0:0	6	AV_CODEC_ID_NONE
stmts	309:12	310:74	5	
call	309:12	310:73	6	av_log
arg	309:19	309:32	7	matroska->ctx
water	309:19	0:0	8	matroska
op	309:27	0:0	8	->
water	309:29	0:0	8	ctx
arg	309:34	309:45	7	AV_LOG_INFO
water	309:34	0:0	8	AV_LOG_INFO
arg	310:19	310:56	7	"Unknown/unsupported AVCodecID %s.\n"
water	310:19	0:0	8	"Unknown/unsupported AVCodecID %s.\n"
arg	310:58	310:73	7	track->codec_id
water	310:58	0:0	8	track
op	310:63	0:0	8	->
water	310:65	0:0	8	codec_id
water	310:74	0:0	6	;
if	311:8	312:35	4	(track -> time_scale < 0 . 01)
cond	311:12	311:34	5	track -> time_scale < 0 . 01
water	311:12	0:0	6	track
op	311:17	0:0	6	->
water	311:19	0:0	6	time_scale
op	311:30	0:0	6	<
water	311:32	0:0	6	0
op	311:33	0:0	6	.
water	311:34	0:0	6	01
stmts	312:12	312:35	5	
water	312:12	0:0	6	track
op	312:17	0:0	6	->
water	312:19	0:0	6	time_scale
op	312:30	0:0	6	=
water	312:32	0:0	6	1
op	312:33	0:0	6	.
water	312:34	0:0	6	0
water	312:35	0:0	6	;
call	313:8	314:46	4	avpriv_set_pts_info
arg	313:28	313:30	5	st
water	313:28	0:0	6	st
arg	313:32	313:34	5	64
water	313:32	0:0	6	64
arg	313:36	313:76	5	matroska->time_scale*track->time_scale
water	313:36	0:0	6	matroska
op	313:44	0:0	6	->
water	313:46	0:0	6	time_scale
op	313:57	0:0	6	*
water	313:59	0:0	6	track
op	313:64	0:0	6	->
water	313:66	0:0	6	time_scale
arg	314:28	314:46	5	1000*1000*1000
water	314:28	0:0	6	1000
op	314:33	0:0	6	*
water	314:35	0:0	6	1000
op	314:40	0:0	6	*
water	314:42	0:0	6	1000
water	314:47	0:0	4	;
water	316:8	0:0	4	track
op	316:13	0:0	4	->
water	316:15	0:0	4	codec_delay
op	316:27	0:0	4	=
call	316:29	318:55	4	av_rescale_q
arg	316:42	316:60	5	track->codec_delay
water	316:42	0:0	6	track
op	316:47	0:0	6	->
water	316:49	0:0	6	codec_delay
arg	317:42	317:71	5	(AVRational){1,1000000000}
water	317:42	0:0	6	(
water	317:43	0:0	6	AVRational
water	317:53	0:0	6	)
water	317:54	0:0	6	{
water	317:56	0:0	6	1
water	317:57	0:0	6	,
water	317:59	0:0	6	1000000000
water	317:70	0:0	6	}
arg	318:42	318:55	5	st->time_base
water	318:42	0:0	6	st
op	318:44	0:0	6	->
water	318:46	0:0	6	time_base
water	318:56	0:0	4	;
water	319:8	0:0	4	st
op	319:10	0:0	4	->
water	319:12	0:0	4	codec
op	319:17	0:0	4	->
water	319:19	0:0	4	codec_id
op	319:28	0:0	4	=
water	319:30	0:0	4	codec_id
water	319:38	0:0	4	;
if	320:8	321:70	4	(strcmp (track -> language ,"und" ))
cond	320:12	320:41	5	strcmp (track -> language ,"und" )
call	320:12	320:41	6	strcmp
arg	320:19	320:34	7	track->language
water	320:19	0:0	8	track
op	320:24	0:0	8	->
water	320:26	0:0	8	language
arg	320:36	320:41	7	"und"
water	320:36	0:0	8	"und"
stmts	321:12	321:70	5	
call	321:12	321:69	6	av_dict_set
arg	321:24	321:37	7	&st->metadata
op	321:24	0:0	8	&
water	321:25	0:0	8	st
op	321:27	0:0	8	->
water	321:29	0:0	8	metadata
arg	321:39	321:49	7	"language"
water	321:39	0:0	8	"language"
arg	321:51	321:66	7	track->language
water	321:51	0:0	8	track
op	321:56	0:0	8	->
water	321:58	0:0	8	language
arg	321:68	321:69	7	0
water	321:68	0:0	8	0
water	321:70	0:0	6	;
call	322:8	322:58	4	av_dict_set
arg	322:20	322:33	5	&st->metadata
op	322:20	0:0	6	&
water	322:21	0:0	6	st
op	322:23	0:0	6	->
water	322:25	0:0	6	metadata
arg	322:35	322:42	5	"title"
water	322:35	0:0	6	"title"
arg	322:44	322:55	5	track->name
water	322:44	0:0	6	track
op	322:49	0:0	6	->
water	322:51	0:0	6	name
arg	322:57	322:58	5	0
water	322:57	0:0	6	0
water	322:59	0:0	4	;
if	323:8	324:53	4	(track -> flag_default)
cond	323:12	323:19	5	track -> flag_default
water	323:12	0:0	6	track
op	323:17	0:0	6	->
water	323:19	0:0	6	flag_default
stmts	324:12	324:53	5	
water	324:12	0:0	6	st
op	324:14	0:0	6	->
water	324:16	0:0	6	disposition
op	324:28	0:0	6	|=
water	324:31	0:0	6	AV_DISPOSITION_DEFAULT
water	324:53	0:0	6	;
if	325:8	326:52	4	(track -> flag_forced)
cond	325:12	325:19	5	track -> flag_forced
water	325:12	0:0	6	track
op	325:17	0:0	6	->
water	325:19	0:0	6	flag_forced
stmts	326:12	326:52	5	
water	326:12	0:0	6	st
op	326:14	0:0	6	->
water	326:16	0:0	6	disposition
op	326:28	0:0	6	|=
water	326:31	0:0	6	AV_DISPOSITION_FORCED
water	326:52	0:0	6	;
if	327:8	338:8	4	(! st -> codec -> extradata)
cond	327:12	327:24	5	! st -> codec -> extradata
op	327:12	0:0	6	!
water	327:13	0:0	6	st
op	327:15	0:0	6	->
water	327:17	0:0	6	codec
op	327:22	0:0	6	->
water	327:24	0:0	6	extradata
stmts	327:35	338:8	5	
water	327:35	0:0	6	{
if	328:12	331:12	6	(extradata)
cond	328:16	328:16	7	extradata
water	328:16	0:0	8	extradata
stmts	328:27	331:12	7	
water	328:27	0:0	8	{
water	329:16	0:0	8	st
op	329:18	0:0	8	->
water	329:20	0:0	8	codec
op	329:25	0:0	8	->
water	329:27	0:0	8	extradata
op	329:42	0:0	8	=
water	329:44	0:0	8	extradata
water	329:53	0:0	8	;
water	330:16	0:0	8	st
op	330:18	0:0	8	->
water	330:20	0:0	8	codec
op	330:25	0:0	8	->
water	330:27	0:0	8	extradata_size
op	330:42	0:0	8	=
water	330:44	0:0	8	extradata_size
water	330:58	0:0	8	;
water	331:12	0:0	8	}
else	331:14	337:12	6
stmts	331:19	337:12	7	
if	331:19	337:12	8	(track -> codec_priv . data && track -> codec_priv . size > 0)
cond	331:23	331:74	9	track -> codec_priv . data && track -> codec_priv . size > 0
water	331:23	0:0	10	track
op	331:28	0:0	10	->
water	331:30	0:0	10	codec_priv
op	331:40	0:0	10	.
water	331:41	0:0	10	data
op	331:46	0:0	10	&&
water	331:49	0:0	10	track
op	331:54	0:0	10	->
water	331:56	0:0	10	codec_priv
op	331:66	0:0	10	.
water	331:67	0:0	10	size
op	331:72	0:0	10	>
water	331:74	0:0	10	0
stmts	331:77	337:12	9	
water	331:77	0:0	10	{
if	332:16	333:42	10	(ff_alloc_extradata (st -> codec ,track -> codec_priv . size ))
cond	332:20	332:72	11	ff_alloc_extradata (st -> codec ,track -> codec_priv . size )
call	332:20	332:72	12	ff_alloc_extradata
arg	332:39	332:48	13	st->codec
water	332:39	0:0	14	st
op	332:41	0:0	14	->
water	332:43	0:0	14	codec
arg	332:50	332:72	13	track->codec_priv.size
water	332:50	0:0	14	track
op	332:55	0:0	14	->
water	332:57	0:0	14	codec_priv
op	332:67	0:0	14	.
water	332:68	0:0	14	size
stmts	333:20	333:42	11	
return	333:20	333:42	12	AVERROR(ENOMEM)
call	333:27	333:41	13	AVERROR
arg	333:35	333:41	14	ENOMEM
water	333:35	0:0	15	ENOMEM
call	334:16	336:45	10	memcpy
arg	334:23	334:43	11	st->codec->extradata
water	334:23	0:0	12	st
op	334:25	0:0	12	->
water	334:27	0:0	12	codec
op	334:32	0:0	12	->
water	334:34	0:0	12	extradata
arg	335:23	335:64	11	track->codec_priv.data+extradata_offset
water	335:23	0:0	12	track
op	335:28	0:0	12	->
water	335:30	0:0	12	codec_priv
op	335:40	0:0	12	.
water	335:41	0:0	12	data
op	335:46	0:0	12	+
water	335:48	0:0	12	extradata_offset
arg	336:23	336:45	11	track->codec_priv.size
water	336:23	0:0	12	track
op	336:28	0:0	12	->
water	336:30	0:0	12	codec_priv
op	336:40	0:0	12	.
water	336:41	0:0	12	size
water	336:46	0:0	10	;
water	337:12	0:0	10	}
water	338:8	0:0	6	}
if	339:8	390:8	4	(track -> type == MATROSKA_TRACK_TYPE_VIDEO)
cond	339:12	339:27	5	track -> type == MATROSKA_TRACK_TYPE_VIDEO
water	339:12	0:0	6	track
op	339:17	0:0	6	->
water	339:19	0:0	6	type
op	339:24	0:0	6	==
water	339:27	0:0	6	MATROSKA_TRACK_TYPE_VIDEO
stmts	339:54	390:8	5	
water	339:54	0:0	6	{
decl	340:12	340:77	6	MatroskaTrackPlane	*planes
op	340:39	0:0	6	=
water	340:41	0:0	6	track
op	340:46	0:0	6	->
water	340:48	0:0	6	operation
op	340:57	0:0	6	.
water	340:58	0:0	6	combine_planes
op	340:72	0:0	6	.
water	340:73	0:0	6	elem
water	341:12	0:0	6	st
op	341:14	0:0	6	->
water	341:16	0:0	6	codec
op	341:21	0:0	6	->
water	341:23	0:0	6	codec_type
op	341:34	0:0	6	=
water	341:36	0:0	6	AVMEDIA_TYPE_VIDEO
water	341:54	0:0	6	;
water	342:12	0:0	6	st
op	342:14	0:0	6	->
water	342:16	0:0	6	codec
op	342:21	0:0	6	->
water	342:23	0:0	6	codec_tag
op	342:34	0:0	6	=
water	342:36	0:0	6	fourcc
water	342:42	0:0	6	;
if	343:12	344:60	6	(bit_depth >= 0)
cond	343:16	343:29	7	bit_depth >= 0
water	343:16	0:0	8	bit_depth
op	343:26	0:0	8	>=
water	343:29	0:0	8	0
stmts	344:16	344:60	7	
water	344:16	0:0	8	st
op	344:18	0:0	8	->
water	344:20	0:0	8	codec
op	344:25	0:0	8	->
water	344:27	0:0	8	bits_per_coded_sample
op	344:49	0:0	8	=
water	344:51	0:0	8	bit_depth
water	344:60	0:0	8	;
water	345:12	0:0	6	st
op	345:14	0:0	6	->
water	345:16	0:0	6	codec
op	345:21	0:0	6	->
water	345:23	0:0	6	width
op	345:34	0:0	6	=
water	345:36	0:0	6	track
op	345:41	0:0	6	->
water	345:43	0:0	6	video
op	345:48	0:0	6	.
water	345:49	0:0	6	pixel_width
water	345:60	0:0	6	;
water	346:12	0:0	6	st
op	346:14	0:0	6	->
water	346:16	0:0	6	codec
op	346:21	0:0	6	->
water	346:23	0:0	6	height
op	346:34	0:0	6	=
water	346:36	0:0	6	track
op	346:41	0:0	6	->
water	346:43	0:0	6	video
op	346:48	0:0	6	.
water	346:49	0:0	6	pixel_height
water	346:61	0:0	6	;
call	347:12	351:25	6	av_reduce
arg	347:22	347:50	7	&st->sample_aspect_ratio.num
op	347:22	0:0	8	&
water	347:23	0:0	8	st
op	347:25	0:0	8	->
water	347:27	0:0	8	sample_aspect_ratio
op	347:46	0:0	8	.
water	347:47	0:0	8	num
arg	348:22	348:50	7	&st->sample_aspect_ratio.den
op	348:22	0:0	8	&
water	348:23	0:0	8	st
op	348:25	0:0	8	->
water	348:27	0:0	8	sample_aspect_ratio
op	348:46	0:0	8	.
water	348:47	0:0	8	den
arg	349:22	349:68	7	st->codec->height*track->video.display_width
water	349:22	0:0	8	st
op	349:24	0:0	8	->
water	349:26	0:0	8	codec
op	349:31	0:0	8	->
water	349:33	0:0	8	height
op	349:40	0:0	8	*
water	349:42	0:0	8	track
op	349:47	0:0	8	->
water	349:49	0:0	8	video
op	349:54	0:0	8	.
water	349:55	0:0	8	display_width
arg	350:22	350:69	7	st->codec->width*track->video.display_height
water	350:22	0:0	8	st
op	350:24	0:0	8	->
water	350:26	0:0	8	codec
op	350:31	0:0	8	->
water	350:33	0:0	8	width
op	350:40	0:0	8	*
water	350:42	0:0	8	track
op	350:47	0:0	8	->
water	350:49	0:0	8	video
op	350:54	0:0	8	.
water	350:55	0:0	8	display_height
arg	351:22	351:25	7	255
water	351:22	0:0	8	255
water	351:26	0:0	6	;
if	352:12	353:57	6	(st -> codec -> codec_id != AV_CODEC_ID_HEVC)
cond	352:16	352:39	7	st -> codec -> codec_id != AV_CODEC_ID_HEVC
water	352:16	0:0	8	st
op	352:18	0:0	8	->
water	352:20	0:0	8	codec
op	352:25	0:0	8	->
water	352:27	0:0	8	codec_id
op	352:36	0:0	8	!=
water	352:39	0:0	8	AV_CODEC_ID_HEVC
stmts	353:16	353:57	7	
water	353:16	0:0	8	st
op	353:18	0:0	8	->
water	353:20	0:0	8	need_parsing
op	353:33	0:0	8	=
water	353:35	0:0	8	AVSTREAM_PARSE_HEADERS
water	353:57	0:0	8	;
if	354:12	362:12	6	(track -> default_duration)
cond	354:16	354:23	7	track -> default_duration
water	354:16	0:0	8	track
op	354:21	0:0	8	->
water	354:23	0:0	8	default_duration
stmts	354:41	362:12	7	
water	354:41	0:0	8	{
call	355:16	356:68	8	av_reduce
arg	355:26	355:49	9	&st->avg_frame_rate.num
op	355:26	0:0	10	&
water	355:27	0:0	10	st
op	355:29	0:0	10	->
water	355:31	0:0	10	avg_frame_rate
op	355:45	0:0	10	.
water	355:46	0:0	10	num
arg	355:51	355:74	9	&st->avg_frame_rate.den
op	355:51	0:0	10	&
water	355:52	0:0	10	st
op	355:54	0:0	10	->
water	355:56	0:0	10	avg_frame_rate
op	355:70	0:0	10	.
water	355:71	0:0	10	den
arg	356:26	356:36	9	1000000000
water	356:26	0:0	10	1000000000
arg	356:38	356:61	9	track->default_duration
water	356:38	0:0	10	track
op	356:43	0:0	10	->
water	356:45	0:0	10	default_duration
arg	356:63	356:68	9	30000
water	356:63	0:0	10	30000
water	356:69	0:0	8	;
if	358:16	360:57	8	(st -> avg_frame_rate . num < st -> avg_frame_rate . den * 1000 LL && st -> avg_frame_rate . num > st -> avg_frame_rate . den * 5 LL)
cond	358:23	359:74	9	st -> avg_frame_rate . num < st -> avg_frame_rate . den * 1000 LL && st -> avg_frame_rate . num > st -> avg_frame_rate . den * 5 LL
water	358:23	0:0	10	st
op	358:25	0:0	10	->
water	358:27	0:0	10	avg_frame_rate
op	358:41	0:0	10	.
water	358:42	0:0	10	num
op	358:46	0:0	10	<
water	358:48	0:0	10	st
op	358:50	0:0	10	->
water	358:52	0:0	10	avg_frame_rate
op	358:66	0:0	10	.
water	358:67	0:0	10	den
op	358:71	0:0	10	*
water	358:73	0:0	10	1000
water	358:77	0:0	10	LL
op	359:20	0:0	10	&&
water	359:23	0:0	10	st
op	359:25	0:0	10	->
water	359:27	0:0	10	avg_frame_rate
op	359:41	0:0	10	.
water	359:42	0:0	10	num
op	359:46	0:0	10	>
water	359:48	0:0	10	st
op	359:50	0:0	10	->
water	359:52	0:0	10	avg_frame_rate
op	359:66	0:0	10	.
water	359:67	0:0	10	den
op	359:71	0:0	10	*
water	359:73	0:0	10	5
water	359:74	0:0	10	LL
stmts	360:20	360:57	9	
water	360:20	0:0	10	st
op	360:22	0:0	10	->
water	360:24	0:0	10	r_frame_rate
op	360:37	0:0	10	=
water	360:39	0:0	10	st
op	360:41	0:0	10	->
water	360:43	0:0	10	avg_frame_rate
water	360:57	0:0	10	;
water	362:12	0:0	8	}
if	364:12	365:117	6	(track -> video . stereo_mode && track -> video . stereo_mode < MATROSKA_VIDEO_STEREOMODE_TYPE_NB)
cond	364:16	364:71	7	track -> video . stereo_mode && track -> video . stereo_mode < MATROSKA_VIDEO_STEREOMODE_TYPE_NB
water	364:16	0:0	8	track
op	364:21	0:0	8	->
water	364:23	0:0	8	video
op	364:28	0:0	8	.
water	364:29	0:0	8	stereo_mode
op	364:41	0:0	8	&&
water	364:44	0:0	8	track
op	364:49	0:0	8	->
water	364:51	0:0	8	video
op	364:56	0:0	8	.
water	364:57	0:0	8	stereo_mode
op	364:69	0:0	8	<
water	364:71	0:0	8	MATROSKA_VIDEO_STEREOMODE_TYPE_NB
stmts	365:16	365:117	7	
call	365:16	365:116	8	av_dict_set
arg	365:28	365:41	9	&st->metadata
op	365:28	0:0	10	&
water	365:29	0:0	10	st
op	365:31	0:0	10	->
water	365:33	0:0	10	metadata
arg	365:43	365:56	9	"stereo_mode"
water	365:43	0:0	10	"stereo_mode"
arg	365:58	365:113	9	ff_matroska_video_stereo_mode[track->video.stereo_mode]
water	365:58	0:0	10	ff_matroska_video_stereo_mode
op	365:87	0:0	10	[
water	365:88	0:0	10	track
op	365:93	0:0	10	->
water	365:95	0:0	10	video
op	365:100	0:0	10	.
water	365:101	0:0	10	stereo_mode
op	365:112	0:0	10	]
arg	365:115	365:116	9	0
water	365:115	0:0	10	0
water	365:117	0:0	8	;
if	367:12	368:64	6	(track -> video . alpha_mode)
cond	367:16	367:29	7	track -> video . alpha_mode
water	367:16	0:0	8	track
op	367:21	0:0	8	->
water	367:23	0:0	8	video
op	367:28	0:0	8	.
water	367:29	0:0	8	alpha_mode
stmts	368:16	368:64	7	
call	368:16	368:63	8	av_dict_set
arg	368:28	368:41	9	&st->metadata
op	368:28	0:0	10	&
water	368:29	0:0	10	st
op	368:31	0:0	10	->
water	368:33	0:0	10	metadata
arg	368:43	368:55	9	"alpha_mode"
water	368:43	0:0	10	"alpha_mode"
arg	368:57	368:60	9	"1"
water	368:57	0:0	10	"1"
arg	368:62	368:63	9	0
water	368:62	0:0	10	0
water	368:64	0:0	8	;
for	370:12	382:12	6	(j = 0 ;j < track -> operation . combine_planes . nb_elem;j ++)
forinit	370:17	370:20	7	j = 0 ;
water	370:17	0:0	8	j
op	370:18	0:0	8	=
water	370:19	0:0	8	0
water	370:20	0:0	8	;
cond	370:22	370:58	7	j < track -> operation . combine_planes . nb_elem
water	370:22	0:0	8	j
op	370:24	0:0	8	<
water	370:26	0:0	8	track
op	370:31	0:0	8	->
water	370:33	0:0	8	operation
op	370:42	0:0	8	.
water	370:43	0:0	8	combine_planes
op	370:57	0:0	8	.
water	370:58	0:0	8	nb_elem
forexpr	370:67	370:68	7	j ++
water	370:67	0:0	8	j
op	370:68	0:0	8	++
stmts	370:72	382:12	7	
water	370:72	0:0	8	{
decl	371:16	371:28	8	char	buf[32]
if	372:16	373:28	8	(planes [ j ] . type >= MATROSKA_VIDEO_STEREO_PLANE_COUNT)
cond	372:20	372:38	9	planes [ j ] . type >= MATROSKA_VIDEO_STEREO_PLANE_COUNT
water	372:20	0:0	10	planes
op	372:26	0:0	10	[
water	372:27	0:0	10	j
op	372:28	0:0	10	]
op	372:29	0:0	10	.
water	372:30	0:0	10	type
op	372:35	0:0	10	>=
water	372:38	0:0	10	MATROSKA_VIDEO_STEREO_PLANE_COUNT
stmts	373:20	373:28	9	
continue	373:20	373:28	10	
call	374:16	375:74	8	snprintf
arg	374:25	374:28	9	buf
water	374:25	0:0	10	buf
arg	374:30	374:41	9	sizeof(buf)
op	374:30	0:0	10	sizeof
water	374:36	0:0	10	(
water	374:37	0:0	10	buf
water	374:40	0:0	10	)
arg	374:43	374:50	9	"%s_%d"
water	374:43	0:0	10	"%s_%d"
arg	375:25	375:71	9	ff_matroska_video_stereo_plane[planes[j].type]
water	375:25	0:0	10	ff_matroska_video_stereo_plane
op	375:55	0:0	10	[
water	375:56	0:0	10	planes
op	375:62	0:0	10	[
water	375:63	0:0	10	j
op	375:64	0:0	10	]
op	375:65	0:0	10	.
water	375:66	0:0	10	type
op	375:70	0:0	10	]
arg	375:73	375:74	9	i
water	375:73	0:0	10	i
water	375:75	0:0	8	;
for	376:16	381:20	8	(k = 0 ;k < matroska -> tracks . nb_elem;k ++)
forinit	376:21	376:24	9	k = 0 ;
water	376:21	0:0	10	k
op	376:22	0:0	10	=
water	376:23	0:0	10	0
water	376:24	0:0	10	;
cond	376:26	376:47	9	k < matroska -> tracks . nb_elem
water	376:26	0:0	10	k
op	376:28	0:0	10	<
water	376:30	0:0	10	matroska
op	376:38	0:0	10	->
water	376:40	0:0	10	tracks
op	376:46	0:0	10	.
water	376:47	0:0	10	nb_elem
forexpr	376:56	376:57	9	k ++
water	376:56	0:0	10	k
op	376:57	0:0	10	++
stmts	377:20	381:20	9	
if	377:20	381:20	10	(planes [ j ] . uid == tracks [ k ] . uid && tracks [ k ] . stream)
cond	377:24	377:68	11	planes [ j ] . uid == tracks [ k ] . uid && tracks [ k ] . stream
water	377:24	0:0	12	planes
op	377:30	0:0	12	[
water	377:31	0:0	12	j
op	377:32	0:0	12	]
op	377:33	0:0	12	.
water	377:34	0:0	12	uid
op	377:38	0:0	12	==
water	377:41	0:0	12	tracks
op	377:47	0:0	12	[
water	377:48	0:0	12	k
op	377:49	0:0	12	]
op	377:50	0:0	12	.
water	377:51	0:0	12	uid
op	377:55	0:0	12	&&
water	377:58	0:0	12	tracks
op	377:64	0:0	12	[
water	377:65	0:0	12	k
op	377:66	0:0	12	]
op	377:67	0:0	12	.
water	377:68	0:0	12	stream
stmts	377:76	381:20	11	
water	377:76	0:0	12	{
call	378:24	379:57	12	av_dict_set
arg	378:36	378:63	13	&tracks[k].stream->metadata
op	378:36	0:0	14	&
water	378:37	0:0	14	tracks
op	378:43	0:0	14	[
water	378:44	0:0	14	k
op	378:45	0:0	14	]
op	378:46	0:0	14	.
water	378:47	0:0	14	stream
op	378:53	0:0	14	->
water	378:55	0:0	14	metadata
arg	379:36	379:49	13	"stereo_mode"
water	379:36	0:0	14	"stereo_mode"
arg	379:51	379:54	13	buf
water	379:51	0:0	14	buf
arg	379:56	379:57	13	0
water	379:56	0:0	14	0
water	379:58	0:0	12	;
break	380:24	380:29	12	
water	381:20	0:0	12	}
water	382:12	0:0	8	}
if	384:12	389:12	6	(track -> video . stereo_mode < MATROSKA_VIDEO_STEREOMODE_TYPE_NB && track -> video . stereo_mode != 10 && track -> video . stereo_mode != 12)
cond	384:16	385:78	7	track -> video . stereo_mode < MATROSKA_VIDEO_STEREOMODE_TYPE_NB && track -> video . stereo_mode != 10 && track -> video . stereo_mode != 12
water	384:16	0:0	8	track
op	384:21	0:0	8	->
water	384:23	0:0	8	video
op	384:28	0:0	8	.
water	384:29	0:0	8	stereo_mode
op	384:41	0:0	8	<
water	384:43	0:0	8	MATROSKA_VIDEO_STEREOMODE_TYPE_NB
op	384:77	0:0	8	&&
water	385:16	0:0	8	track
op	385:21	0:0	8	->
water	385:23	0:0	8	video
op	385:28	0:0	8	.
water	385:29	0:0	8	stereo_mode
op	385:41	0:0	8	!=
water	385:44	0:0	8	10
op	385:47	0:0	8	&&
water	385:50	0:0	8	track
op	385:55	0:0	8	->
water	385:57	0:0	8	video
op	385:62	0:0	8	.
water	385:63	0:0	8	stereo_mode
op	385:75	0:0	8	!=
water	385:78	0:0	8	12
stmts	385:82	389:12	7	
water	385:82	0:0	8	{
decl	386:16	386:76	8	int	ret
op	386:24	0:0	8	=
call	386:26	386:75	9	ff_mkv_stereo3d_conv
arg	386:47	386:49	10	st
water	386:47	0:0	11	st
arg	386:51	386:75	10	track->video.stereo_mode
water	386:51	0:0	11	track
op	386:56	0:0	11	->
water	386:58	0:0	11	video
op	386:63	0:0	11	.
water	386:64	0:0	11	stereo_mode
if	387:16	388:30	8	(ret < 0)
cond	387:20	387:26	9	ret < 0
water	387:20	0:0	10	ret
op	387:24	0:0	10	<
water	387:26	0:0	10	0
stmts	388:20	388:30	9	
return	388:20	388:30	10	ret
water	388:27	0:0	11	ret
water	389:12	0:0	8	}
water	390:8	0:0	6	}
else	390:10	411:8	4
stmts	390:15	411:8	5	
if	390:15	411:8	6	(track -> type == MATROSKA_TRACK_TYPE_AUDIO)
cond	390:19	390:34	7	track -> type == MATROSKA_TRACK_TYPE_AUDIO
water	390:19	0:0	8	track
op	390:24	0:0	8	->
water	390:26	0:0	8	type
op	390:31	0:0	8	==
water	390:34	0:0	8	MATROSKA_TRACK_TYPE_AUDIO
stmts	390:61	411:8	7	
water	390:61	0:0	8	{
water	391:12	0:0	8	st
op	391:14	0:0	8	->
water	391:16	0:0	8	codec
op	391:21	0:0	8	->
water	391:23	0:0	8	codec_type
op	391:35	0:0	8	=
water	391:37	0:0	8	AVMEDIA_TYPE_AUDIO
water	391:55	0:0	8	;
water	392:12	0:0	8	st
op	392:14	0:0	8	->
water	392:16	0:0	8	codec
op	392:21	0:0	8	->
water	392:23	0:0	8	sample_rate
op	392:35	0:0	8	=
water	392:37	0:0	8	track
op	392:42	0:0	8	->
water	392:44	0:0	8	audio
op	392:49	0:0	8	.
water	392:50	0:0	8	out_samplerate
water	392:64	0:0	8	;
water	393:12	0:0	8	st
op	393:14	0:0	8	->
water	393:16	0:0	8	codec
op	393:21	0:0	8	->
water	393:23	0:0	8	channels
op	393:35	0:0	8	=
water	393:37	0:0	8	track
op	393:42	0:0	8	->
water	393:44	0:0	8	audio
op	393:49	0:0	8	.
water	393:50	0:0	8	channels
water	393:58	0:0	8	;
if	394:12	395:72	8	(! st -> codec -> bits_per_coded_sample)
cond	394:16	394:28	9	! st -> codec -> bits_per_coded_sample
op	394:16	0:0	10	!
water	394:17	0:0	10	st
op	394:19	0:0	10	->
water	394:21	0:0	10	codec
op	394:26	0:0	10	->
water	394:28	0:0	10	bits_per_coded_sample
stmts	395:16	395:72	9	
water	395:16	0:0	10	st
op	395:18	0:0	10	->
water	395:20	0:0	10	codec
op	395:25	0:0	10	->
water	395:27	0:0	10	bits_per_coded_sample
op	395:49	0:0	10	=
water	395:51	0:0	10	track
op	395:56	0:0	10	->
water	395:58	0:0	10	audio
op	395:63	0:0	10	.
water	395:64	0:0	10	bitdepth
water	395:72	0:0	10	;
if	396:12	397:54	8	(st -> codec -> codec_id == AV_CODEC_ID_MP3)
cond	396:16	396:39	9	st -> codec -> codec_id == AV_CODEC_ID_MP3
water	396:16	0:0	10	st
op	396:18	0:0	10	->
water	396:20	0:0	10	codec
op	396:25	0:0	10	->
water	396:27	0:0	10	codec_id
op	396:36	0:0	10	==
water	396:39	0:0	10	AV_CODEC_ID_MP3
stmts	397:16	397:54	9	
water	397:16	0:0	10	st
op	397:18	0:0	10	->
water	397:20	0:0	10	need_parsing
op	397:33	0:0	10	=
water	397:35	0:0	10	AVSTREAM_PARSE_FULL
water	397:54	0:0	10	;
else	398:12	399:57	8
stmts	398:17	399:57	9	
if	398:17	399:57	10	(st -> codec -> codec_id != AV_CODEC_ID_AAC)
cond	398:21	398:44	11	st -> codec -> codec_id != AV_CODEC_ID_AAC
water	398:21	0:0	12	st
op	398:23	0:0	12	->
water	398:25	0:0	12	codec
op	398:30	0:0	12	->
water	398:32	0:0	12	codec_id
op	398:41	0:0	12	!=
water	398:44	0:0	12	AV_CODEC_ID_AAC
stmts	399:16	399:57	11	
water	399:16	0:0	12	st
op	399:18	0:0	12	->
water	399:20	0:0	12	need_parsing
op	399:33	0:0	12	=
water	399:35	0:0	12	AVSTREAM_PARSE_HEADERS
water	399:57	0:0	12	;
if	400:12	404:12	8	(track -> codec_delay > 0)
cond	400:16	400:37	9	track -> codec_delay > 0
water	400:16	0:0	10	track
op	400:21	0:0	10	->
water	400:23	0:0	10	codec_delay
op	400:35	0:0	10	>
water	400:37	0:0	10	0
stmts	400:40	404:12	9	
water	400:40	0:0	10	{
water	401:16	0:0	10	st
op	401:18	0:0	10	->
water	401:20	0:0	10	codec
op	401:25	0:0	10	->
water	401:27	0:0	10	delay
op	401:33	0:0	10	=
call	401:35	403:87	10	av_rescale_q
arg	401:48	401:66	11	track->codec_delay
water	401:48	0:0	12	track
op	401:53	0:0	12	->
water	401:55	0:0	12	codec_delay
arg	402:48	402:61	11	st->time_base
water	402:48	0:0	12	st
op	402:50	0:0	12	->
water	402:52	0:0	12	time_base
arg	403:48	403:87	11	(AVRational){1,st->codec->sample_rate}
water	403:48	0:0	12	(
water	403:49	0:0	12	AVRational
water	403:59	0:0	12	)
water	403:60	0:0	12	{
water	403:61	0:0	12	1
water	403:62	0:0	12	,
water	403:64	0:0	12	st
op	403:66	0:0	12	->
water	403:68	0:0	12	codec
op	403:73	0:0	12	->
water	403:75	0:0	12	sample_rate
water	403:86	0:0	12	}
water	403:88	0:0	10	;
water	404:12	0:0	10	}
if	405:12	410:12	8	(track -> seek_preroll > 0)
cond	405:16	405:38	9	track -> seek_preroll > 0
water	405:16	0:0	10	track
op	405:21	0:0	10	->
water	405:23	0:0	10	seek_preroll
op	405:36	0:0	10	>
water	405:38	0:0	10	0
stmts	405:41	410:12	9	
water	405:41	0:0	10	{
call	406:16	409:95	10	av_codec_set_seek_preroll
arg	406:42	406:51	11	st->codec
water	406:42	0:0	12	st
op	406:44	0:0	12	->
water	406:46	0:0	12	codec
arg	407:42	409:95	11	av_rescale_q(track->seek_preroll,(AVRational){1,1000000000},(AVRational){1,st->codec->sample_rate})
call	407:42	409:94	12	av_rescale_q
arg	407:55	407:74	13	track->seek_preroll
water	407:55	0:0	14	track
op	407:60	0:0	14	->
water	407:62	0:0	14	seek_preroll
arg	408:55	408:82	13	(AVRational){1,1000000000}
water	408:55	0:0	14	(
water	408:56	0:0	14	AVRational
water	408:66	0:0	14	)
water	408:67	0:0	14	{
water	408:68	0:0	14	1
water	408:69	0:0	14	,
water	408:71	0:0	14	1000000000
water	408:81	0:0	14	}
arg	409:55	409:94	13	(AVRational){1,st->codec->sample_rate}
water	409:55	0:0	14	(
water	409:56	0:0	14	AVRational
water	409:66	0:0	14	)
water	409:67	0:0	14	{
water	409:68	0:0	14	1
water	409:69	0:0	14	,
water	409:71	0:0	14	st
op	409:73	0:0	14	->
water	409:75	0:0	14	codec
op	409:80	0:0	14	->
water	409:82	0:0	14	sample_rate
water	409:93	0:0	14	}
water	409:96	0:0	10	;
water	410:12	0:0	10	}
water	411:8	0:0	8	}
else	411:10	420:8	4
stmts	411:15	420:8	5	
if	411:15	420:8	6	(codec_id == AV_CODEC_ID_WEBVTT)
cond	411:19	411:31	7	codec_id == AV_CODEC_ID_WEBVTT
water	411:19	0:0	8	codec_id
op	411:28	0:0	8	==
water	411:31	0:0	8	AV_CODEC_ID_WEBVTT
stmts	411:51	420:8	7	
water	411:51	0:0	8	{
water	412:12	0:0	8	st
op	412:14	0:0	8	->
water	412:16	0:0	8	codec
op	412:21	0:0	8	->
water	412:23	0:0	8	codec_type
op	412:34	0:0	8	=
water	412:36	0:0	8	AVMEDIA_TYPE_SUBTITLE
water	412:57	0:0	8	;
if	413:12	415:12	8	(!strcmp (track -> codec_id ,"D_WEBVTT/CAPTIONS" ))
cond	413:16	413:60	9	!strcmp (track -> codec_id ,"D_WEBVTT/CAPTIONS" )
op	413:16	0:0	10	!
call	413:17	413:60	10	strcmp
arg	413:24	413:39	11	track->codec_id
water	413:24	0:0	12	track
op	413:29	0:0	12	->
water	413:31	0:0	12	codec_id
arg	413:41	413:60	11	"D_WEBVTT/CAPTIONS"
water	413:41	0:0	12	"D_WEBVTT/CAPTIONS"
stmts	413:63	415:12	9	
water	413:63	0:0	10	{
water	414:16	0:0	10	st
op	414:18	0:0	10	->
water	414:20	0:0	10	disposition
op	414:32	0:0	10	|=
water	414:35	0:0	10	AV_DISPOSITION_CAPTIONS
water	414:58	0:0	10	;
water	415:12	0:0	10	}
else	415:14	417:12	8
stmts	415:19	417:12	9	
if	415:19	417:12	10	(!strcmp (track -> codec_id ,"D_WEBVTT/DESCRIPTIONS" ))
cond	415:23	415:71	11	!strcmp (track -> codec_id ,"D_WEBVTT/DESCRIPTIONS" )
op	415:23	0:0	12	!
call	415:24	415:71	12	strcmp
arg	415:31	415:46	13	track->codec_id
water	415:31	0:0	14	track
op	415:36	0:0	14	->
water	415:38	0:0	14	codec_id
arg	415:48	415:71	13	"D_WEBVTT/DESCRIPTIONS"
water	415:48	0:0	14	"D_WEBVTT/DESCRIPTIONS"
stmts	415:74	417:12	11	
water	415:74	0:0	12	{
water	416:16	0:0	12	st
op	416:18	0:0	12	->
water	416:20	0:0	12	disposition
op	416:32	0:0	12	|=
water	416:35	0:0	12	AV_DISPOSITION_DESCRIPTIONS
water	416:62	0:0	12	;
water	417:12	0:0	12	}
else	417:14	419:12	8
stmts	417:19	419:12	9	
if	417:19	419:12	10	(!strcmp (track -> codec_id ,"D_WEBVTT/METADATA" ))
cond	417:23	417:67	11	!strcmp (track -> codec_id ,"D_WEBVTT/METADATA" )
op	417:23	0:0	12	!
call	417:24	417:67	12	strcmp
arg	417:31	417:46	13	track->codec_id
water	417:31	0:0	14	track
op	417:36	0:0	14	->
water	417:38	0:0	14	codec_id
arg	417:48	417:67	13	"D_WEBVTT/METADATA"
water	417:48	0:0	14	"D_WEBVTT/METADATA"
stmts	417:70	419:12	11	
water	417:70	0:0	12	{
water	418:16	0:0	12	st
op	418:18	0:0	12	->
water	418:20	0:0	12	disposition
op	418:32	0:0	12	|=
water	418:35	0:0	12	AV_DISPOSITION_METADATA
water	418:58	0:0	12	;
water	419:12	0:0	12	}
water	420:8	0:0	8	}
else	420:10	424:8	4
stmts	420:15	424:8	5	
if	420:15	424:8	6	(track -> type == MATROSKA_TRACK_TYPE_SUBTITLE)
cond	420:19	420:34	7	track -> type == MATROSKA_TRACK_TYPE_SUBTITLE
water	420:19	0:0	8	track
op	420:24	0:0	8	->
water	420:26	0:0	8	type
op	420:31	0:0	8	==
water	420:34	0:0	8	MATROSKA_TRACK_TYPE_SUBTITLE
stmts	420:64	424:8	7	
water	420:64	0:0	8	{
water	421:12	0:0	8	st
op	421:14	0:0	8	->
water	421:16	0:0	8	codec
op	421:21	0:0	8	->
water	421:23	0:0	8	codec_type
op	421:34	0:0	8	=
water	421:36	0:0	8	AVMEDIA_TYPE_SUBTITLE
water	421:57	0:0	8	;
if	422:12	423:42	8	(st -> codec -> codec_id == AV_CODEC_ID_ASS)
cond	422:16	422:39	9	st -> codec -> codec_id == AV_CODEC_ID_ASS
water	422:16	0:0	10	st
op	422:18	0:0	10	->
water	422:20	0:0	10	codec
op	422:25	0:0	10	->
water	422:27	0:0	10	codec_id
op	422:36	0:0	10	==
water	422:39	0:0	10	AV_CODEC_ID_ASS
stmts	423:16	423:42	9	
water	423:16	0:0	10	matroska
op	423:24	0:0	10	->
water	423:26	0:0	10	contains_ssa
op	423:39	0:0	10	=
water	423:41	0:0	10	1
water	423:42	0:0	10	;
water	424:8	0:0	8	}
water	425:4	0:0	4	}
return	426:4	426:12	2	0
water	426:11	0:0	3	0
