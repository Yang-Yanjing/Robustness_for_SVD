func	1:0	304:0	0	static int	decode_chunks
params	1:24	0:0	1	
param	1:25	1:46	2	AVCodecContext *	avctx
param	1:48	1:64	2	AVFrame *	picture
param	2:25	2:40	2	int *	got_output
param	2:42	2:60	2	const uint8_t *	buf
param	2:62	2:74	2	int	buf_size
stmnts	0:0	303:4	1	
decl	4:4	4:38	2	Mpeg1Context	*s
op	4:20	0:0	2	=
water	4:22	0:0	2	avctx
op	4:27	0:0	2	->
water	4:29	0:0	2	priv_data
decl	5:4	5:41	2	MpegEncContext	*s2
op	5:23	0:0	2	=
op	5:25	0:0	2	&
water	5:26	0:0	2	s
op	5:27	0:0	2	->
water	5:29	0:0	2	mpeg_enc_ctx
decl	6:4	6:32	2	const uint8_t	*buf_ptr
op	6:27	0:0	2	=
water	6:29	0:0	2	buf
decl	7:4	7:43	2	const uint8_t	*buf_end
op	7:27	0:0	2	=
water	7:29	0:0	2	buf
op	7:33	0:0	2	+
water	7:35	0:0	2	buf_size
decl	8:4	8:23	2	int	ret
water	8:11	0:0	2	,
decl	8:4	8:23	2	int	input_size
decl	9:4	9:37	2	int	last_code
op	9:18	0:0	2	=
water	9:20	0:0	2	0
water	9:21	0:0	2	,
decl	9:4	9:37	2	int	skip_frame
op	9:34	0:0	2	=
water	9:36	0:0	2	0
decl	10:4	10:35	2	int	picture_start_code_seen
op	10:32	0:0	2	=
water	10:34	0:0	2	0
for	11:4	303:4	2	(;;)
forinit	11:9	11:9	3	;
water	11:9	0:0	4	;
cond	0:0	0:0	3	
forexpr	0:0	0:0	3	
stmts	11:13	303:4	3	
water	11:13	0:0	4	{
decl	13:8	13:32	4	uint32_t	start_code
op	13:28	0:0	4	=
op	13:30	0:0	4	-
water	13:31	0:0	4	1
water	14:8	0:0	4	buf_ptr
op	14:16	0:0	4	=
call	14:18	14:70	4	avpriv_find_start_code
arg	14:41	14:48	5	buf_ptr
water	14:41	0:0	6	buf_ptr
arg	14:50	14:57	5	buf_end
water	14:50	0:0	6	buf_end
arg	14:59	14:70	5	&start_code
op	14:59	0:0	6	&
water	14:60	0:0	6	start_code
water	14:71	0:0	4	;
if	15:8	46:8	4	(start_code > 0 x1ff)
cond	15:12	15:26	5	start_code > 0 x1ff
water	15:12	0:0	6	start_code
op	15:23	0:0	6	>
water	15:25	0:0	6	0
water	15:26	0:0	6	x1ff
stmts	15:32	46:8	5	
water	15:32	0:0	6	{
if	16:12	41:12	6	(! skip_frame)
cond	16:16	16:17	7	! skip_frame
op	16:16	0:0	8	!
water	16:17	0:0	8	skip_frame
stmts	16:29	41:12	7	
water	16:29	0:0	8	{
if	17:16	27:16	8	(HAVE_THREADS && ( avctx -> active_thread_type & FF_THREAD_SLICE ) && ! avctx -> hwaccel)
cond	17:20	19:28	9	HAVE_THREADS && ( avctx -> active_thread_type & FF_THREAD_SLICE ) && ! avctx -> hwaccel
water	17:20	0:0	10	HAVE_THREADS
op	17:33	0:0	10	&&
water	18:20	0:0	10	(
water	18:21	0:0	10	avctx
op	18:26	0:0	10	->
water	18:28	0:0	10	active_thread_type
op	18:47	0:0	10	&
water	18:49	0:0	10	FF_THREAD_SLICE
water	18:64	0:0	10	)
op	18:66	0:0	10	&&
op	19:20	0:0	10	!
water	19:21	0:0	10	avctx
op	19:26	0:0	10	->
water	19:28	0:0	10	hwaccel
stmts	19:37	27:16	9	
water	19:37	0:0	10	{
decl	20:20	20:25	10	int	i
call	21:20	21:54	10	av_assert0
arg	21:31	21:54	11	avctx->thread_count>1
water	21:31	0:0	12	avctx
op	21:36	0:0	12	->
water	21:38	0:0	12	thread_count
op	21:51	0:0	12	>
water	21:53	0:0	12	1
water	21:55	0:0	10	;
call	22:20	24:65	10	avctx->execute
arg	22:35	22:40	11	avctx
water	22:35	0:0	12	avctx
arg	22:42	22:61	11	slice_decode_thread
water	22:42	0:0	12	slice_decode_thread
arg	23:35	23:57	11	&s2->thread_context[0]
op	23:35	0:0	12	&
water	23:36	0:0	12	s2
op	23:38	0:0	12	->
water	23:40	0:0	12	thread_context
op	23:54	0:0	12	[
water	23:55	0:0	12	0
op	23:56	0:0	12	]
arg	23:59	23:63	11	NULL
water	23:59	0:0	12	NULL
arg	24:35	24:49	11	s->slice_count
water	24:35	0:0	12	s
op	24:36	0:0	12	->
water	24:38	0:0	12	slice_count
arg	24:51	24:65	11	sizeof(void*)
op	24:51	0:0	12	sizeof
water	24:57	0:0	12	(
water	24:58	0:0	12	void
op	24:63	0:0	12	*
water	24:64	0:0	12	)
water	24:66	0:0	10	;
for	25:20	26:83	10	(i = 0 ;i < s -> slice_count;i ++)
forinit	25:25	25:30	11	i = 0 ;
water	25:25	0:0	12	i
op	25:27	0:0	12	=
water	25:29	0:0	12	0
water	25:30	0:0	12	;
cond	25:32	25:39	11	i < s -> slice_count
water	25:32	0:0	12	i
op	25:34	0:0	12	<
water	25:36	0:0	12	s
op	25:37	0:0	12	->
water	25:39	0:0	12	slice_count
forexpr	25:52	25:53	11	i ++
water	25:52	0:0	12	i
op	25:53	0:0	12	++
stmts	26:24	26:83	11	
water	26:24	0:0	12	s2
op	26:26	0:0	12	->
water	26:28	0:0	12	er
op	26:30	0:0	12	.
water	26:31	0:0	12	error_count
op	26:43	0:0	12	+=
water	26:46	0:0	12	s2
op	26:48	0:0	12	->
water	26:50	0:0	12	thread_context
op	26:64	0:0	12	[
water	26:65	0:0	12	i
op	26:66	0:0	12	]
op	26:67	0:0	12	->
water	26:69	0:0	12	er
op	26:71	0:0	12	.
water	26:72	0:0	12	error_count
water	26:83	0:0	12	;
water	27:16	0:0	10	}
if	29:16	31:85	8	(( CONFIG_MPEG_VDPAU_DECODER || CONFIG_MPEG1_VDPAU_DECODER ) &&uses_vdpau (avctx ))
cond	29:20	30:39	9	( CONFIG_MPEG_VDPAU_DECODER || CONFIG_MPEG1_VDPAU_DECODER ) &&uses_vdpau (avctx )
water	29:20	0:0	10	(
water	29:21	0:0	10	CONFIG_MPEG_VDPAU_DECODER
op	29:47	0:0	10	||
water	29:50	0:0	10	CONFIG_MPEG1_VDPAU_DECODER
water	29:76	0:0	10	)
op	30:20	0:0	10	&&
call	30:23	30:39	10	uses_vdpau
arg	30:34	30:39	11	avctx
water	30:34	0:0	12	avctx
stmts	31:20	31:85	9	
call	31:20	31:84	10	ff_vdpau_mpeg_picture_complete
arg	31:51	31:53	11	s2
water	31:51	0:0	12	s2
arg	31:55	31:58	11	buf
water	31:55	0:0	12	buf
arg	31:60	31:68	11	buf_size
water	31:60	0:0	12	buf_size
arg	31:70	31:84	11	s->slice_count
water	31:70	0:0	12	s
op	31:71	0:0	12	->
water	31:73	0:0	12	slice_count
water	31:85	0:0	10	;
water	33:16	0:0	8	ret
op	33:20	0:0	8	=
call	33:22	33:46	8	slice_end
arg	33:32	33:37	9	avctx
water	33:32	0:0	10	avctx
arg	33:39	33:46	9	picture
water	33:39	0:0	10	picture
water	33:47	0:0	8	;
if	34:16	35:30	8	(ret < 0)
cond	34:20	34:26	9	ret < 0
water	34:20	0:0	10	ret
op	34:24	0:0	10	<
water	34:26	0:0	10	0
stmts	35:20	35:30	9	
return	35:20	35:30	10	ret
water	35:27	0:0	11	ret
else	36:16	40:16	8
stmts	36:21	40:16	9	
if	36:21	40:16	10	(ret)
cond	36:25	36:25	11	ret
water	36:25	0:0	12	ret
stmts	36:30	40:16	11	
water	36:30	0:0	12	{
if	38:20	39:39	12	(s2 -> last_picture_ptr || s2 -> low_delay)
cond	38:24	38:52	13	s2 -> last_picture_ptr || s2 -> low_delay
water	38:24	0:0	14	s2
op	38:26	0:0	14	->
water	38:28	0:0	14	last_picture_ptr
op	38:45	0:0	14	||
water	38:48	0:0	14	s2
op	38:50	0:0	14	->
water	38:52	0:0	14	low_delay
stmts	39:24	39:39	13	
op	39:24	0:0	14	*
water	39:25	0:0	14	got_output
op	39:36	0:0	14	=
water	39:38	0:0	14	1
water	39:39	0:0	14	;
water	40:16	0:0	12	}
water	41:12	0:0	8	}
water	42:12	0:0	6	s2
op	42:14	0:0	6	->
water	42:16	0:0	6	pict_type
op	42:26	0:0	6	=
water	42:28	0:0	6	0
water	42:29	0:0	6	;
if	43:12	44:42	6	(avctx -> err_recognition & AV_EF_EXPLODE && s2 -> er . error_count)
cond	43:16	43:65	7	avctx -> err_recognition & AV_EF_EXPLODE && s2 -> er . error_count
water	43:16	0:0	8	avctx
op	43:21	0:0	8	->
water	43:23	0:0	8	err_recognition
op	43:39	0:0	8	&
water	43:41	0:0	8	AV_EF_EXPLODE
op	43:55	0:0	8	&&
water	43:58	0:0	8	s2
op	43:60	0:0	8	->
water	43:62	0:0	8	er
op	43:64	0:0	8	.
water	43:65	0:0	8	error_count
stmts	44:16	44:42	7	
return	44:16	44:42	8	AVERROR_INVALIDDATA
water	44:23	0:0	9	AVERROR_INVALIDDATA
return	45:12	45:73	6	FFMAX(0,buf_ptr-buf-s2->parse_context.last_index)
call	45:19	45:72	7	FFMAX
arg	45:25	45:26	8	0
water	45:25	0:0	9	0
arg	45:28	45:72	8	buf_ptr-buf-s2->parse_context.last_index
water	45:28	0:0	9	buf_ptr
op	45:36	0:0	9	-
water	45:38	0:0	9	buf
op	45:42	0:0	9	-
water	45:44	0:0	9	s2
op	45:46	0:0	9	->
water	45:48	0:0	9	parse_context
op	45:61	0:0	9	.
water	45:62	0:0	9	last_index
water	46:8	0:0	6	}
water	47:8	0:0	4	input_size
op	47:19	0:0	4	=
water	47:21	0:0	4	buf_end
op	47:29	0:0	4	-
water	47:31	0:0	4	buf_ptr
water	47:38	0:0	4	;
if	48:8	50:57	4	(avctx -> debug & FF_DEBUG_STARTCODE)
cond	48:12	48:27	5	avctx -> debug & FF_DEBUG_STARTCODE
water	48:12	0:0	6	avctx
op	48:17	0:0	6	->
water	48:19	0:0	6	debug
op	48:25	0:0	6	&
water	48:27	0:0	6	FF_DEBUG_STARTCODE
stmts	49:12	50:57	5	
call	49:12	50:56	6	av_log
arg	49:19	49:24	7	avctx
water	49:19	0:0	8	avctx
arg	49:26	49:38	7	AV_LOG_DEBUG
water	49:26	0:0	8	AV_LOG_DEBUG
arg	49:40	49:86	7	"%3"PRIX32" at %"PTRDIFF_SPECIFIER" left %d\n"
water	49:40	0:0	8	"%3"
water	49:44	0:0	8	PRIX32
water	49:50	0:0	8	" at %"
water	49:57	0:0	8	PTRDIFF_SPECIFIER
water	49:74	0:0	8	" left %d\n"
arg	50:19	50:29	7	start_code
water	50:19	0:0	8	start_code
arg	50:31	50:44	7	buf_ptr-buf
water	50:31	0:0	8	buf_ptr
op	50:39	0:0	8	-
water	50:41	0:0	8	buf
arg	50:46	50:56	7	input_size
water	50:46	0:0	8	input_size
water	50:57	0:0	6	;
switch	52:8	302:8	4	(start_code)
cond	52:16	52:16	5	start_code
water	52:16	0:0	6	start_code
stmts	52:28	302:8	5	
water	52:28	0:0	6	{
label	53:8	53:27	6	case SEQ_START_CODE :
if	54:12	58:12	6	(last_code == 0)
cond	54:16	54:29	7	last_code == 0
water	54:16	0:0	8	last_code
op	54:26	0:0	8	==
water	54:29	0:0	8	0
stmts	54:32	58:12	7	
water	54:32	0:0	8	{
call	55:16	55:64	8	mpeg1_decode_sequence
arg	55:38	55:43	9	avctx
water	55:38	0:0	10	avctx
arg	55:45	55:52	9	buf_ptr
water	55:45	0:0	10	buf_ptr
arg	55:54	55:64	9	input_size
water	55:54	0:0	10	input_size
water	55:65	0:0	8	;
if	56:16	57:31	8	(buf != avctx -> extradata)
cond	56:20	56:34	9	buf != avctx -> extradata
water	56:20	0:0	10	buf
op	56:24	0:0	10	!=
water	56:27	0:0	10	avctx
op	56:32	0:0	10	->
water	56:34	0:0	10	extradata
stmts	57:20	57:31	9	
water	57:20	0:0	10	s
op	57:21	0:0	10	->
water	57:23	0:0	10	sync
op	57:28	0:0	10	=
water	57:30	0:0	10	1
water	57:31	0:0	10	;
water	58:12	0:0	8	}
else	58:14	63:12	6
stmts	58:19	63:12	7	
water	58:19	0:0	8	{
call	59:16	60:70	8	av_log
arg	59:23	59:28	9	avctx
water	59:23	0:0	10	avctx
arg	59:30	59:42	9	AV_LOG_ERROR
water	59:30	0:0	10	AV_LOG_ERROR
arg	60:23	60:59	9	"ignoring SEQ_START_CODE after %X\n"
water	60:23	0:0	10	"ignoring SEQ_START_CODE after %X\n"
arg	60:61	60:70	9	last_code
water	60:61	0:0	10	last_code
water	60:71	0:0	8	;
if	61:16	62:46	8	(avctx -> err_recognition & AV_EF_EXPLODE)
cond	61:20	61:45	9	avctx -> err_recognition & AV_EF_EXPLODE
water	61:20	0:0	10	avctx
op	61:25	0:0	10	->
water	61:27	0:0	10	err_recognition
op	61:43	0:0	10	&
water	61:45	0:0	10	AV_EF_EXPLODE
stmts	62:20	62:46	9	
return	62:20	62:46	10	AVERROR_INVALIDDATA
water	62:27	0:0	11	AVERROR_INVALIDDATA
water	63:12	0:0	8	}
break	64:12	64:17	6	
label	65:8	65:31	6	case PICTURE_START_CODE :
if	66:12	71:12	6	(picture_start_code_seen && s2 -> picture_structure == PICT_FRAME)
cond	66:16	66:68	7	picture_start_code_seen && s2 -> picture_structure == PICT_FRAME
water	66:16	0:0	8	picture_start_code_seen
op	66:40	0:0	8	&&
water	66:43	0:0	8	s2
op	66:45	0:0	8	->
water	66:47	0:0	8	picture_structure
op	66:65	0:0	8	==
water	66:68	0:0	8	PICT_FRAME
stmts	66:80	71:12	7	
water	66:80	0:0	8	{
call	69:15	69:97	8	av_log
arg	69:22	69:27	9	avctx
water	69:22	0:0	10	avctx
arg	69:29	69:43	9	AV_LOG_WARNING
water	69:29	0:0	10	AV_LOG_WARNING
arg	69:45	69:97	9	"ignoring extra picture following a frame-picture\n"
water	69:45	0:0	10	"ignoring extra picture following a frame-picture\n"
water	69:98	0:0	8	;
break	70:15	70:20	8	
water	71:12	0:0	8	}
water	72:12	0:0	6	picture_start_code_seen
op	72:36	0:0	6	=
water	72:38	0:0	6	1
water	72:39	0:0	6	;
if	73:12	77:12	6	(s2 -> width <= 0 || s2 -> height <= 0)
cond	73:16	73:48	7	s2 -> width <= 0 || s2 -> height <= 0
water	73:16	0:0	8	s2
op	73:18	0:0	8	->
water	73:20	0:0	8	width
op	73:26	0:0	8	<=
water	73:29	0:0	8	0
op	73:31	0:0	8	||
water	73:34	0:0	8	s2
op	73:36	0:0	8	->
water	73:38	0:0	8	height
op	73:45	0:0	8	<=
water	73:48	0:0	8	0
stmts	73:51	77:12	7	
water	73:51	0:0	8	{
call	74:16	75:44	8	av_log
arg	74:23	74:28	9	avctx
water	74:23	0:0	10	avctx
arg	74:30	74:42	9	AV_LOG_ERROR
water	74:30	0:0	10	AV_LOG_ERROR
arg	74:44	74:79	9	"Invalid frame dimensions %dx%d.\n"
water	74:44	0:0	10	"Invalid frame dimensions %dx%d.\n"
arg	75:23	75:32	9	s2->width
water	75:23	0:0	10	s2
op	75:25	0:0	10	->
water	75:27	0:0	10	width
arg	75:34	75:44	9	s2->height
water	75:34	0:0	10	s2
op	75:36	0:0	10	->
water	75:38	0:0	10	height
water	75:45	0:0	8	;
return	76:16	76:42	8	AVERROR_INVALIDDATA
water	76:23	0:0	9	AVERROR_INVALIDDATA
water	77:12	0:0	8	}
if	78:12	81:12	6	(s -> tmpgexs)
cond	78:16	78:19	7	s -> tmpgexs
water	78:16	0:0	8	s
op	78:17	0:0	8	->
water	78:19	0:0	8	tmpgexs
stmts	78:27	81:12	7	
water	78:27	0:0	8	{
water	79:16	0:0	8	s2
op	79:18	0:0	8	->
water	79:20	0:0	8	intra_dc_precision
op	79:38	0:0	8	=
water	79:40	0:0	8	3
water	79:41	0:0	8	;
water	80:16	0:0	8	s2
op	80:18	0:0	8	->
water	80:20	0:0	8	intra_matrix
op	80:32	0:0	8	[
water	80:33	0:0	8	0
op	80:34	0:0	8	]
op	80:35	0:0	8	=
water	80:37	0:0	8	1
water	80:38	0:0	8	;
water	81:12	0:0	8	}
if	82:12	91:12	6	(HAVE_THREADS && ( avctx -> active_thread_type & FF_THREAD_SLICE ) && ! avctx -> hwaccel && s -> slice_count)
cond	82:16	83:38	7	HAVE_THREADS && ( avctx -> active_thread_type & FF_THREAD_SLICE ) && ! avctx -> hwaccel && s -> slice_count
water	82:16	0:0	8	HAVE_THREADS
op	82:29	0:0	8	&&
water	82:32	0:0	8	(
water	82:33	0:0	8	avctx
op	82:38	0:0	8	->
water	82:40	0:0	8	active_thread_type
op	82:59	0:0	8	&
water	82:61	0:0	8	FF_THREAD_SLICE
water	82:76	0:0	8	)
op	82:78	0:0	8	&&
op	83:16	0:0	8	!
water	83:17	0:0	8	avctx
op	83:22	0:0	8	->
water	83:24	0:0	8	hwaccel
op	83:32	0:0	8	&&
water	83:35	0:0	8	s
op	83:36	0:0	8	->
water	83:38	0:0	8	slice_count
stmts	83:51	91:12	7	
water	83:51	0:0	8	{
decl	84:16	84:21	8	int	i
call	85:16	87:61	8	avctx->execute
arg	85:31	85:36	9	avctx
water	85:31	0:0	10	avctx
arg	85:38	85:57	9	slice_decode_thread
water	85:38	0:0	10	slice_decode_thread
arg	86:31	86:49	9	s2->thread_context
water	86:31	0:0	10	s2
op	86:33	0:0	10	->
water	86:35	0:0	10	thread_context
arg	86:51	86:55	9	NULL
water	86:51	0:0	10	NULL
arg	87:31	87:45	9	s->slice_count
water	87:31	0:0	10	s
op	87:32	0:0	10	->
water	87:34	0:0	10	slice_count
arg	87:47	87:61	9	sizeof(void*)
op	87:47	0:0	10	sizeof
water	87:53	0:0	10	(
water	87:54	0:0	10	void
op	87:59	0:0	10	*
water	87:60	0:0	10	)
water	87:62	0:0	8	;
for	88:16	89:79	8	(i = 0 ;i < s -> slice_count;i ++)
forinit	88:21	88:26	9	i = 0 ;
water	88:21	0:0	10	i
op	88:23	0:0	10	=
water	88:25	0:0	10	0
water	88:26	0:0	10	;
cond	88:28	88:35	9	i < s -> slice_count
water	88:28	0:0	10	i
op	88:30	0:0	10	<
water	88:32	0:0	10	s
op	88:33	0:0	10	->
water	88:35	0:0	10	slice_count
forexpr	88:48	88:49	9	i ++
water	88:48	0:0	10	i
op	88:49	0:0	10	++
stmts	89:20	89:79	9	
water	89:20	0:0	10	s2
op	89:22	0:0	10	->
water	89:24	0:0	10	er
op	89:26	0:0	10	.
water	89:27	0:0	10	error_count
op	89:39	0:0	10	+=
water	89:42	0:0	10	s2
op	89:44	0:0	10	->
water	89:46	0:0	10	thread_context
op	89:60	0:0	10	[
water	89:61	0:0	10	i
op	89:62	0:0	10	]
op	89:63	0:0	10	->
water	89:65	0:0	10	er
op	89:67	0:0	10	.
water	89:68	0:0	10	error_count
water	89:79	0:0	10	;
water	90:16	0:0	8	s
op	90:17	0:0	8	->
water	90:19	0:0	8	slice_count
op	90:31	0:0	8	=
water	90:33	0:0	8	0
water	90:34	0:0	8	;
water	91:12	0:0	8	}
if	92:12	104:12	6	(last_code == 0 || last_code == SLICE_MIN_START_CODE)
cond	92:16	92:47	7	last_code == 0 || last_code == SLICE_MIN_START_CODE
water	92:16	0:0	8	last_code
op	92:26	0:0	8	==
water	92:29	0:0	8	0
op	92:31	0:0	8	||
water	92:34	0:0	8	last_code
op	92:44	0:0	8	==
water	92:47	0:0	8	SLICE_MIN_START_CODE
stmts	92:69	104:12	7	
water	92:69	0:0	8	{
water	93:16	0:0	8	ret
op	93:20	0:0	8	=
call	93:22	93:48	8	mpeg_decode_postinit
arg	93:43	93:48	9	avctx
water	93:43	0:0	10	avctx
water	93:49	0:0	8	;
if	94:16	98:16	8	(ret < 0)
cond	94:20	94:26	9	ret < 0
water	94:20	0:0	10	ret
op	94:24	0:0	10	<
water	94:26	0:0	10	0
stmts	94:29	98:16	9	
water	94:29	0:0	10	{
call	95:20	96:61	10	av_log
arg	95:27	95:32	11	avctx
water	95:27	0:0	12	avctx
arg	95:34	95:46	11	AV_LOG_ERROR
water	95:34	0:0	12	AV_LOG_ERROR
arg	96:27	96:61	11	"mpeg_decode_postinit() failure\n"
water	96:27	0:0	12	"mpeg_decode_postinit() failure\n"
water	96:62	0:0	10	;
return	97:20	97:30	10	ret
water	97:27	0:0	11	ret
water	98:16	0:0	10	}
if	100:16	101:37	8	(mpeg1_decode_picture (avctx ,buf_ptr ,input_size ) < 0)
cond	100:20	100:71	9	mpeg1_decode_picture (avctx ,buf_ptr ,input_size ) < 0
call	100:20	100:67	10	mpeg1_decode_picture
arg	100:41	100:46	11	avctx
water	100:41	0:0	12	avctx
arg	100:48	100:55	11	buf_ptr
water	100:48	0:0	12	buf_ptr
arg	100:57	100:67	11	input_size
water	100:57	0:0	12	input_size
op	100:69	0:0	10	<
water	100:71	0:0	10	0
stmts	101:20	101:37	9	
water	101:20	0:0	10	s2
op	101:22	0:0	10	->
water	101:24	0:0	10	pict_type
op	101:34	0:0	10	=
water	101:36	0:0	10	0
water	101:37	0:0	10	;
water	102:16	0:0	8	s
op	102:17	0:0	8	->
water	102:19	0:0	8	first_slice
op	102:31	0:0	8	=
water	102:33	0:0	8	1
water	102:34	0:0	8	;
water	103:16	0:0	8	last_code
op	103:31	0:0	8	=
water	103:33	0:0	8	PICTURE_START_CODE
water	103:51	0:0	8	;
water	104:12	0:0	8	}
else	104:14	109:12	6
stmts	104:19	109:12	7	
water	104:19	0:0	8	{
call	105:16	106:59	8	av_log
arg	105:23	105:28	9	avctx
water	105:23	0:0	10	avctx
arg	105:30	105:42	9	AV_LOG_ERROR
water	105:30	0:0	10	AV_LOG_ERROR
arg	106:23	106:48	9	"ignoring pic after %X\n"
water	106:23	0:0	10	"ignoring pic after %X\n"
arg	106:50	106:59	9	last_code
water	106:50	0:0	10	last_code
water	106:60	0:0	8	;
if	107:16	108:46	8	(avctx -> err_recognition & AV_EF_EXPLODE)
cond	107:20	107:45	9	avctx -> err_recognition & AV_EF_EXPLODE
water	107:20	0:0	10	avctx
op	107:25	0:0	10	->
water	107:27	0:0	10	err_recognition
op	107:43	0:0	10	&
water	107:45	0:0	10	AV_EF_EXPLODE
stmts	108:20	108:46	9	
return	108:20	108:46	10	AVERROR_INVALIDDATA
water	108:27	0:0	11	AVERROR_INVALIDDATA
water	109:12	0:0	8	}
break	110:12	110:17	6	
label	111:8	111:27	6	case EXT_START_CODE :
call	112:12	112:58	6	init_get_bits
arg	112:26	112:33	7	&s2->gb
op	112:26	0:0	8	&
water	112:27	0:0	8	s2
op	112:29	0:0	8	->
water	112:31	0:0	8	gb
arg	112:35	112:42	7	buf_ptr
water	112:35	0:0	8	buf_ptr
arg	112:44	112:58	7	input_size*8
water	112:44	0:0	8	input_size
op	112:55	0:0	8	*
water	112:57	0:0	8	8
water	112:59	0:0	6	;
switch	113:12	143:12	6	(get_bits (& s2 -> gb ,4 ))
cond	113:20	113:39	7	get_bits (& s2 -> gb ,4 )
call	113:20	113:39	8	get_bits
arg	113:29	113:36	9	&s2->gb
op	113:29	0:0	10	&
water	113:30	0:0	10	s2
op	113:32	0:0	10	->
water	113:34	0:0	10	gb
arg	113:38	113:39	9	4
water	113:38	0:0	10	4
stmts	113:42	143:12	7	
water	113:42	0:0	8	{
label	114:12	114:20	8	case 0 x1 :
if	115:16	117:16	8	(last_code == 0)
cond	115:20	115:33	9	last_code == 0
water	115:20	0:0	10	last_code
op	115:30	0:0	10	==
water	115:33	0:0	10	0
stmts	115:36	117:16	9	
water	115:36	0:0	10	{
call	116:20	116:52	10	mpeg_decode_sequence_extension
arg	116:51	116:52	11	s
water	116:51	0:0	12	s
water	116:53	0:0	10	;
water	117:16	0:0	10	}
else	117:18	122:16	8
stmts	117:23	122:16	9	
water	117:23	0:0	10	{
call	118:20	119:67	10	av_log
arg	118:27	118:32	11	avctx
water	118:27	0:0	12	avctx
arg	118:34	118:46	11	AV_LOG_ERROR
water	118:34	0:0	12	AV_LOG_ERROR
arg	119:27	119:56	11	"ignoring seq ext after %X\n"
water	119:27	0:0	12	"ignoring seq ext after %X\n"
arg	119:58	119:67	11	last_code
water	119:58	0:0	12	last_code
water	119:68	0:0	10	;
if	120:20	121:50	10	(avctx -> err_recognition & AV_EF_EXPLODE)
cond	120:24	120:49	11	avctx -> err_recognition & AV_EF_EXPLODE
water	120:24	0:0	12	avctx
op	120:29	0:0	12	->
water	120:31	0:0	12	err_recognition
op	120:47	0:0	12	&
water	120:49	0:0	12	AV_EF_EXPLODE
stmts	121:24	121:50	11	
return	121:24	121:50	12	AVERROR_INVALIDDATA
water	121:31	0:0	13	AVERROR_INVALIDDATA
water	122:16	0:0	10	}
break	123:16	123:21	8	
label	124:12	124:20	8	case 0 x2 :
call	125:16	125:56	8	mpeg_decode_sequence_display_extension
arg	125:55	125:56	9	s
water	125:55	0:0	10	s
water	125:57	0:0	8	;
break	126:16	126:21	8	
label	127:12	127:20	8	case 0 x3 :
call	128:16	128:53	8	mpeg_decode_quant_matrix_extension
arg	128:51	128:53	9	s2
water	128:51	0:0	10	s2
water	128:54	0:0	8	;
break	129:16	129:21	8	
label	130:12	130:20	8	case 0 x7 :
call	131:16	131:55	8	mpeg_decode_picture_display_extension
arg	131:54	131:55	9	s
water	131:54	0:0	10	s
water	131:56	0:0	8	;
break	132:16	132:21	8	
label	133:12	133:20	8	case 0 x8 :
if	134:16	136:16	8	(last_code == PICTURE_START_CODE)
cond	134:20	134:33	9	last_code == PICTURE_START_CODE
water	134:20	0:0	10	last_code
op	134:30	0:0	10	==
water	134:33	0:0	10	PICTURE_START_CODE
stmts	134:53	136:16	9	
water	134:53	0:0	10	{
call	135:20	135:58	10	mpeg_decode_picture_coding_extension
arg	135:57	135:58	11	s
water	135:57	0:0	12	s
water	135:59	0:0	10	;
water	136:16	0:0	10	}
else	136:18	141:16	8
stmts	136:23	141:16	9	
water	136:23	0:0	10	{
call	137:20	138:71	10	av_log
arg	137:27	137:32	11	avctx
water	137:27	0:0	12	avctx
arg	137:34	137:46	11	AV_LOG_ERROR
water	137:34	0:0	12	AV_LOG_ERROR
arg	138:27	138:60	11	"ignoring pic cod ext after %X\n"
water	138:27	0:0	12	"ignoring pic cod ext after %X\n"
arg	138:62	138:71	11	last_code
water	138:62	0:0	12	last_code
water	138:72	0:0	10	;
if	139:20	140:50	10	(avctx -> err_recognition & AV_EF_EXPLODE)
cond	139:24	139:49	11	avctx -> err_recognition & AV_EF_EXPLODE
water	139:24	0:0	12	avctx
op	139:29	0:0	12	->
water	139:31	0:0	12	err_recognition
op	139:47	0:0	12	&
water	139:49	0:0	12	AV_EF_EXPLODE
stmts	140:24	140:50	11	
return	140:24	140:50	12	AVERROR_INVALIDDATA
water	140:31	0:0	13	AVERROR_INVALIDDATA
water	141:16	0:0	10	}
break	142:16	142:21	8	
water	143:12	0:0	8	}
break	144:12	144:17	6	
label	145:8	145:28	6	case USER_START_CODE :
call	146:12	146:60	6	mpeg_decode_user_data
arg	146:34	146:39	7	avctx
water	146:34	0:0	8	avctx
arg	146:41	146:48	7	buf_ptr
water	146:41	0:0	8	buf_ptr
arg	146:50	146:60	7	input_size
water	146:50	0:0	8	input_size
water	146:61	0:0	6	;
break	147:12	147:17	6	
label	148:8	148:27	6	case GOP_START_CODE :
if	149:12	153:12	6	(last_code == 0)
cond	149:16	149:29	7	last_code == 0
water	149:16	0:0	8	last_code
op	149:26	0:0	8	==
water	149:29	0:0	8	0
stmts	149:32	153:12	7	
water	149:32	0:0	8	{
water	150:16	0:0	8	s2
op	150:18	0:0	8	->
water	150:20	0:0	8	first_field
op	150:32	0:0	8	=
water	150:34	0:0	8	0
water	150:35	0:0	8	;
call	151:16	151:58	8	mpeg_decode_gop
arg	151:32	151:37	9	avctx
water	151:32	0:0	10	avctx
arg	151:39	151:46	9	buf_ptr
water	151:39	0:0	10	buf_ptr
arg	151:48	151:58	9	input_size
water	151:48	0:0	10	input_size
water	151:59	0:0	8	;
water	152:16	0:0	8	s
op	152:17	0:0	8	->
water	152:19	0:0	8	sync
op	152:24	0:0	8	=
water	152:26	0:0	8	1
water	152:27	0:0	8	;
water	153:12	0:0	8	}
else	153:14	158:12	6
stmts	153:19	158:12	7	
water	153:19	0:0	8	{
call	154:16	155:70	8	av_log
arg	154:23	154:28	9	avctx
water	154:23	0:0	10	avctx
arg	154:30	154:42	9	AV_LOG_ERROR
water	154:30	0:0	10	AV_LOG_ERROR
arg	155:23	155:59	9	"ignoring GOP_START_CODE after %X\n"
water	155:23	0:0	10	"ignoring GOP_START_CODE after %X\n"
arg	155:61	155:70	9	last_code
water	155:61	0:0	10	last_code
water	155:71	0:0	8	;
if	156:16	157:46	8	(avctx -> err_recognition & AV_EF_EXPLODE)
cond	156:20	156:45	9	avctx -> err_recognition & AV_EF_EXPLODE
water	156:20	0:0	10	avctx
op	156:25	0:0	10	->
water	156:27	0:0	10	err_recognition
op	156:43	0:0	10	&
water	156:45	0:0	10	AV_EF_EXPLODE
stmts	157:20	157:46	9	
return	157:20	157:46	10	AVERROR_INVALIDDATA
water	157:27	0:0	11	AVERROR_INVALIDDATA
water	158:12	0:0	8	}
break	159:12	159:17	6	
label	160:8	160:15	6	default :
if	161:12	185:12	6	(start_code >= SLICE_MIN_START_CODE && start_code <= SLICE_MAX_START_CODE && last_code == PICTURE_START_CODE)
cond	161:16	162:67	7	start_code >= SLICE_MIN_START_CODE && start_code <= SLICE_MAX_START_CODE && last_code == PICTURE_START_CODE
water	161:16	0:0	8	start_code
op	161:27	0:0	8	>=
water	161:30	0:0	8	SLICE_MIN_START_CODE
op	161:51	0:0	8	&&
water	162:16	0:0	8	start_code
op	162:27	0:0	8	<=
water	162:30	0:0	8	SLICE_MAX_START_CODE
op	162:51	0:0	8	&&
water	162:54	0:0	8	last_code
op	162:64	0:0	8	==
water	162:67	0:0	8	PICTURE_START_CODE
stmts	162:87	185:12	7	
water	162:87	0:0	8	{
if	163:16	167:16	8	(s2 -> progressive_sequence && ! s2 -> progressive_frame)
cond	163:20	163:53	9	s2 -> progressive_sequence && ! s2 -> progressive_frame
water	163:20	0:0	10	s2
op	163:22	0:0	10	->
water	163:24	0:0	10	progressive_sequence
op	163:45	0:0	10	&&
op	163:48	0:0	10	!
water	163:49	0:0	10	s2
op	163:51	0:0	10	->
water	163:53	0:0	10	progressive_frame
stmts	163:72	167:16	9	
water	163:72	0:0	10	{
water	164:20	0:0	10	s2
op	164:22	0:0	10	->
water	164:24	0:0	10	progressive_frame
op	164:42	0:0	10	=
water	164:44	0:0	10	1
water	164:45	0:0	10	;
call	165:20	166:81	10	av_log
arg	165:27	165:36	11	s2->avctx
water	165:27	0:0	12	s2
op	165:29	0:0	12	->
water	165:31	0:0	12	avctx
arg	165:38	165:50	11	AV_LOG_ERROR
water	165:38	0:0	12	AV_LOG_ERROR
arg	166:27	166:81	11	"interlaced frame in progressive sequence, ignoring\n"
water	166:27	0:0	12	"interlaced frame in progressive sequence, ignoring\n"
water	166:82	0:0	10	;
water	167:16	0:0	10	}
if	168:16	174:16	8	(s2 -> picture_structure == 0 || ( s2 -> progressive_frame && s2 -> picture_structure != PICT_FRAME ))
cond	168:20	169:81	9	s2 -> picture_structure == 0 || ( s2 -> progressive_frame && s2 -> picture_structure != PICT_FRAME )
water	168:20	0:0	10	s2
op	168:22	0:0	10	->
water	168:24	0:0	10	picture_structure
op	168:42	0:0	10	==
water	168:45	0:0	10	0
op	168:47	0:0	10	||
water	169:20	0:0	10	(
water	169:21	0:0	10	s2
op	169:23	0:0	10	->
water	169:25	0:0	10	progressive_frame
op	169:43	0:0	10	&&
water	169:46	0:0	10	s2
op	169:48	0:0	10	->
water	169:50	0:0	10	picture_structure
op	169:68	0:0	10	!=
water	169:71	0:0	10	PICT_FRAME
water	169:81	0:0	10	)
stmts	169:84	174:16	9	
water	169:84	0:0	10	{
call	170:20	172:48	10	av_log
arg	170:27	170:36	11	s2->avctx
water	170:27	0:0	12	s2
op	170:29	0:0	12	->
water	170:31	0:0	12	avctx
arg	170:38	170:50	11	AV_LOG_ERROR
water	170:38	0:0	12	AV_LOG_ERROR
arg	171:27	171:69	11	"picture_structure %d invalid, ignoring\n"
water	171:27	0:0	12	"picture_structure %d invalid, ignoring\n"
arg	172:27	172:48	11	s2->picture_structure
water	172:27	0:0	12	s2
op	172:29	0:0	12	->
water	172:31	0:0	12	picture_structure
water	172:49	0:0	10	;
water	173:20	0:0	10	s2
op	173:22	0:0	10	->
water	173:24	0:0	10	picture_structure
op	173:42	0:0	10	=
water	173:44	0:0	10	PICT_FRAME
water	173:54	0:0	10	;
water	174:16	0:0	10	}
if	175:16	176:87	8	(s2 -> progressive_sequence && ! s2 -> frame_pred_frame_dct)
cond	175:20	175:53	9	s2 -> progressive_sequence && ! s2 -> frame_pred_frame_dct
water	175:20	0:0	10	s2
op	175:22	0:0	10	->
water	175:24	0:0	10	progressive_sequence
op	175:45	0:0	10	&&
op	175:48	0:0	10	!
water	175:49	0:0	10	s2
op	175:51	0:0	10	->
water	175:53	0:0	10	frame_pred_frame_dct
stmts	176:20	176:87	9	
call	176:20	176:86	10	av_log
arg	176:27	176:36	11	s2->avctx
water	176:27	0:0	12	s2
op	176:29	0:0	12	->
water	176:31	0:0	12	avctx
arg	176:38	176:52	11	AV_LOG_WARNING
water	176:38	0:0	12	AV_LOG_WARNING
arg	176:54	176:86	11	"invalid frame_pred_frame_dct\n"
water	176:54	0:0	12	"invalid frame_pred_frame_dct\n"
water	176:87	0:0	10	;
if	177:16	180:16	8	(s2 -> picture_structure == PICT_FRAME)
cond	177:20	177:45	9	s2 -> picture_structure == PICT_FRAME
water	177:20	0:0	10	s2
op	177:22	0:0	10	->
water	177:24	0:0	10	picture_structure
op	177:42	0:0	10	==
water	177:45	0:0	10	PICT_FRAME
stmts	177:57	180:16	9	
water	177:57	0:0	10	{
water	178:20	0:0	10	s2
op	178:22	0:0	10	->
water	178:24	0:0	10	first_field
op	178:36	0:0	10	=
water	178:38	0:0	10	0
water	178:39	0:0	10	;
water	179:20	0:0	10	s2
op	179:22	0:0	10	->
water	179:24	0:0	10	v_edge_pos
op	179:36	0:0	10	=
water	179:38	0:0	10	16
op	179:41	0:0	10	*
water	179:43	0:0	10	s2
op	179:45	0:0	10	->
water	179:47	0:0	10	mb_height
water	179:56	0:0	10	;
water	180:16	0:0	10	}
else	180:18	184:16	8
stmts	180:23	184:16	9	
water	180:23	0:0	10	{
water	181:20	0:0	10	s2
op	181:22	0:0	10	->
water	181:24	0:0	10	first_field
op	181:36	0:0	10	^=
water	181:39	0:0	10	1
water	181:40	0:0	10	;
water	182:20	0:0	10	s2
op	182:22	0:0	10	->
water	182:24	0:0	10	v_edge_pos
op	182:37	0:0	10	=
water	182:39	0:0	10	8
op	182:41	0:0	10	*
water	182:43	0:0	10	s2
op	182:45	0:0	10	->
water	182:47	0:0	10	mb_height
water	182:56	0:0	10	;
call	183:20	183:77	10	memset
arg	183:27	183:43	11	s2->mbskip_table
water	183:27	0:0	12	s2
op	183:29	0:0	12	->
water	183:31	0:0	12	mbskip_table
arg	183:45	183:46	11	0
water	183:45	0:0	12	0
arg	183:48	183:77	11	s2->mb_stride*s2->mb_height
water	183:48	0:0	12	s2
op	183:50	0:0	12	->
water	183:52	0:0	12	mb_stride
op	183:62	0:0	12	*
water	183:64	0:0	12	s2
op	183:66	0:0	12	->
water	183:68	0:0	12	mb_height
water	183:78	0:0	10	;
water	184:16	0:0	10	}
water	185:12	0:0	8	}
if	186:12	300:12	6	(start_code >= SLICE_MIN_START_CODE && start_code <= SLICE_MAX_START_CODE && last_code != 0)
cond	186:16	187:67	7	start_code >= SLICE_MIN_START_CODE && start_code <= SLICE_MAX_START_CODE && last_code != 0
water	186:16	0:0	8	start_code
op	186:27	0:0	8	>=
water	186:30	0:0	8	SLICE_MIN_START_CODE
op	186:51	0:0	8	&&
water	187:16	0:0	8	start_code
op	187:27	0:0	8	<=
water	187:30	0:0	8	SLICE_MAX_START_CODE
op	187:51	0:0	8	&&
water	187:54	0:0	8	last_code
op	187:64	0:0	8	!=
water	187:67	0:0	8	0
stmts	187:70	300:12	7	
water	187:70	0:0	8	{
decl	188:16	188:73	8	const int	field_pic
op	188:36	0:0	8	=
water	188:38	0:0	8	s2
op	188:40	0:0	8	->
water	188:42	0:0	8	picture_structure
op	188:60	0:0	8	!=
water	188:63	0:0	8	PICT_FRAME
decl	189:16	189:60	8	int	mb_y
op	189:25	0:0	8	=
water	189:27	0:0	8	start_code
op	189:38	0:0	8	-
water	189:40	0:0	8	SLICE_MIN_START_CODE
water	190:16	0:0	8	last_code
op	190:26	0:0	8	=
water	190:28	0:0	8	SLICE_MIN_START_CODE
water	190:48	0:0	8	;
if	191:16	192:46	8	(s2 -> codec_id != AV_CODEC_ID_MPEG1VIDEO && s2 -> mb_height > 2800 / 16)
cond	191:20	191:83	9	s2 -> codec_id != AV_CODEC_ID_MPEG1VIDEO && s2 -> mb_height > 2800 / 16
water	191:20	0:0	10	s2
op	191:22	0:0	10	->
water	191:24	0:0	10	codec_id
op	191:33	0:0	10	!=
water	191:36	0:0	10	AV_CODEC_ID_MPEG1VIDEO
op	191:59	0:0	10	&&
water	191:62	0:0	10	s2
op	191:64	0:0	10	->
water	191:66	0:0	10	mb_height
op	191:76	0:0	10	>
water	191:78	0:0	10	2800
op	191:82	0:0	10	/
water	191:83	0:0	10	16
stmts	192:20	192:46	9	
water	192:20	0:0	10	mb_y
op	192:25	0:0	10	+=
water	192:28	0:0	10	(
op	192:29	0:0	10	*
water	192:30	0:0	10	buf_ptr
op	192:37	0:0	10	&
water	192:38	0:0	10	0
water	192:39	0:0	10	xE0
water	192:42	0:0	10	)
op	192:43	0:0	10	<<
water	192:45	0:0	10	2
water	192:46	0:0	10	;
water	193:16	0:0	8	mb_y
op	193:21	0:0	8	<<=
water	193:25	0:0	8	field_pic
water	193:34	0:0	8	;
if	194:16	195:26	8	(s2 -> picture_structure == PICT_BOTTOM_FIELD)
cond	194:20	194:45	9	s2 -> picture_structure == PICT_BOTTOM_FIELD
water	194:20	0:0	10	s2
op	194:22	0:0	10	->
water	194:24	0:0	10	picture_structure
op	194:42	0:0	10	==
water	194:45	0:0	10	PICT_BOTTOM_FIELD
stmts	195:20	195:26	9	
water	195:20	0:0	10	mb_y
op	195:24	0:0	10	++
water	195:26	0:0	10	;
if	196:16	199:16	8	(buf_end - buf_ptr < 2)
cond	196:20	196:40	9	buf_end - buf_ptr < 2
water	196:20	0:0	10	buf_end
op	196:28	0:0	10	-
water	196:30	0:0	10	buf_ptr
op	196:38	0:0	10	<
water	196:40	0:0	10	2
stmts	196:43	199:16	9	
water	196:43	0:0	10	{
call	197:20	197:71	10	av_log
arg	197:27	197:36	11	s2->avctx
water	197:27	0:0	12	s2
op	197:29	0:0	12	->
water	197:31	0:0	12	avctx
arg	197:38	197:50	11	AV_LOG_ERROR
water	197:38	0:0	12	AV_LOG_ERROR
arg	197:52	197:71	11	"slice too small\n"
water	197:52	0:0	12	"slice too small\n"
water	197:72	0:0	10	;
return	198:20	198:46	10	AVERROR_INVALIDDATA
water	198:27	0:0	11	AVERROR_INVALIDDATA
water	199:16	0:0	10	}
if	200:16	204:16	8	(mb_y >= s2 -> mb_height)
cond	200:20	200:32	9	mb_y >= s2 -> mb_height
water	200:20	0:0	10	mb_y
op	200:25	0:0	10	>=
water	200:28	0:0	10	s2
op	200:30	0:0	10	->
water	200:32	0:0	10	mb_height
stmts	200:43	204:16	9	
water	200:43	0:0	10	{
call	201:20	202:80	10	av_log
arg	201:27	201:36	11	s2->avctx
water	201:27	0:0	12	s2
op	201:29	0:0	12	->
water	201:31	0:0	12	avctx
arg	201:38	201:50	11	AV_LOG_ERROR
water	201:38	0:0	12	AV_LOG_ERROR
arg	202:27	202:59	11	"slice below image (%d >= %d)\n"
water	202:27	0:0	12	"slice below image (%d >= %d)\n"
arg	202:61	202:65	11	mb_y
water	202:61	0:0	12	mb_y
arg	202:67	202:80	11	s2->mb_height
water	202:67	0:0	12	s2
op	202:69	0:0	12	->
water	202:71	0:0	12	mb_height
water	202:81	0:0	10	;
return	203:20	203:46	10	AVERROR_INVALIDDATA
water	203:27	0:0	11	AVERROR_INVALIDDATA
water	204:16	0:0	10	}
if	205:16	214:16	8	(! s2 -> last_picture_ptr)
cond	205:20	205:25	9	! s2 -> last_picture_ptr
op	205:20	0:0	10	!
water	205:21	0:0	10	s2
op	205:23	0:0	10	->
water	205:25	0:0	10	last_picture_ptr
stmts	205:43	214:16	9	
water	205:43	0:0	10	{
if	208:20	213:20	10	(s2 -> pict_type == AV_PICTURE_TYPE_B)
cond	208:24	208:41	11	s2 -> pict_type == AV_PICTURE_TYPE_B
water	208:24	0:0	12	s2
op	208:26	0:0	12	->
water	208:28	0:0	12	pict_type
op	208:38	0:0	12	==
water	208:41	0:0	12	AV_PICTURE_TYPE_B
stmts	208:60	213:20	11	
water	208:60	0:0	12	{
if	209:24	212:24	12	(! s2 -> closed_gop)
cond	209:28	209:33	13	! s2 -> closed_gop
op	209:28	0:0	14	!
water	209:29	0:0	14	s2
op	209:31	0:0	14	->
water	209:33	0:0	14	closed_gop
stmts	209:45	212:24	13	
water	209:45	0:0	14	{
water	210:28	0:0	14	skip_frame
op	210:39	0:0	14	=
water	210:41	0:0	14	1
water	210:42	0:0	14	;
break	211:28	211:33	14	
water	212:24	0:0	14	}
water	213:20	0:0	12	}
water	214:16	0:0	10	}
if	215:16	216:31	8	(s2 -> pict_type == AV_PICTURE_TYPE_I || ( s2 -> avctx -> flags2 & AV_CODEC_FLAG2_SHOW_ALL ))
cond	215:20	215:102	9	s2 -> pict_type == AV_PICTURE_TYPE_I || ( s2 -> avctx -> flags2 & AV_CODEC_FLAG2_SHOW_ALL )
water	215:20	0:0	10	s2
op	215:22	0:0	10	->
water	215:24	0:0	10	pict_type
op	215:34	0:0	10	==
water	215:37	0:0	10	AV_PICTURE_TYPE_I
op	215:55	0:0	10	||
water	215:58	0:0	10	(
water	215:59	0:0	10	s2
op	215:61	0:0	10	->
water	215:63	0:0	10	avctx
op	215:68	0:0	10	->
water	215:70	0:0	10	flags2
op	215:77	0:0	10	&
water	215:79	0:0	10	AV_CODEC_FLAG2_SHOW_ALL
water	215:102	0:0	10	)
stmts	216:20	216:31	9	
water	216:20	0:0	10	s
op	216:21	0:0	10	->
water	216:23	0:0	10	sync
op	216:28	0:0	10	=
water	216:30	0:0	10	1
water	216:31	0:0	10	;
if	217:16	224:16	8	(! s2 -> next_picture_ptr)
cond	217:20	217:25	9	! s2 -> next_picture_ptr
op	217:20	0:0	10	!
water	217:21	0:0	10	s2
op	217:23	0:0	10	->
water	217:25	0:0	10	next_picture_ptr
stmts	217:43	224:16	9	
water	217:43	0:0	10	{
if	220:20	223:20	10	(s2 -> pict_type == AV_PICTURE_TYPE_P && ! s -> sync)
cond	220:24	220:66	11	s2 -> pict_type == AV_PICTURE_TYPE_P && ! s -> sync
water	220:24	0:0	12	s2
op	220:26	0:0	12	->
water	220:28	0:0	12	pict_type
op	220:38	0:0	12	==
water	220:41	0:0	12	AV_PICTURE_TYPE_P
op	220:59	0:0	12	&&
op	220:62	0:0	12	!
water	220:63	0:0	12	s
op	220:64	0:0	12	->
water	220:66	0:0	12	sync
stmts	220:72	223:20	11	
water	220:72	0:0	12	{
water	221:24	0:0	12	skip_frame
op	221:35	0:0	12	=
water	221:37	0:0	12	1
water	221:38	0:0	12	;
break	222:24	222:29	12	
water	223:20	0:0	12	}
water	224:16	0:0	10	}
if	225:16	232:16	8	(( avctx -> skip_frame >= AVDISCARD_NONREF && s2 -> pict_type == AV_PICTURE_TYPE_B ) || ( avctx -> skip_frame >= AVDISCARD_NONKEY && s2 -> pict_type != AV_PICTURE_TYPE_I ) || avctx -> skip_frame >= AVDISCARD_ALL)
cond	225:20	229:41	9	( avctx -> skip_frame >= AVDISCARD_NONREF && s2 -> pict_type == AV_PICTURE_TYPE_B ) || ( avctx -> skip_frame >= AVDISCARD_NONKEY && s2 -> pict_type != AV_PICTURE_TYPE_I ) || avctx -> skip_frame >= AVDISCARD_ALL
water	225:20	0:0	10	(
water	225:21	0:0	10	avctx
op	225:26	0:0	10	->
water	225:28	0:0	10	skip_frame
op	225:39	0:0	10	>=
water	225:42	0:0	10	AVDISCARD_NONREF
op	225:59	0:0	10	&&
water	226:21	0:0	10	s2
op	226:23	0:0	10	->
water	226:25	0:0	10	pict_type
op	226:35	0:0	10	==
water	226:38	0:0	10	AV_PICTURE_TYPE_B
water	226:55	0:0	10	)
op	226:57	0:0	10	||
water	227:20	0:0	10	(
water	227:21	0:0	10	avctx
op	227:26	0:0	10	->
water	227:28	0:0	10	skip_frame
op	227:39	0:0	10	>=
water	227:42	0:0	10	AVDISCARD_NONKEY
op	227:59	0:0	10	&&
water	228:21	0:0	10	s2
op	228:23	0:0	10	->
water	228:25	0:0	10	pict_type
op	228:35	0:0	10	!=
water	228:38	0:0	10	AV_PICTURE_TYPE_I
water	228:55	0:0	10	)
op	228:57	0:0	10	||
water	229:20	0:0	10	avctx
op	229:25	0:0	10	->
water	229:27	0:0	10	skip_frame
op	229:38	0:0	10	>=
water	229:41	0:0	10	AVDISCARD_ALL
stmts	229:56	232:16	9	
water	229:56	0:0	10	{
water	230:20	0:0	10	skip_frame
op	230:31	0:0	10	=
water	230:33	0:0	10	1
water	230:34	0:0	10	;
break	231:20	231:25	10	
water	232:16	0:0	10	}
if	233:16	234:25	8	(! s -> mpeg_enc_ctx_allocated)
cond	233:20	233:24	9	! s -> mpeg_enc_ctx_allocated
op	233:20	0:0	10	!
water	233:21	0:0	10	s
op	233:22	0:0	10	->
water	233:24	0:0	10	mpeg_enc_ctx_allocated
stmts	234:20	234:25	9	
break	234:20	234:25	10	
if	235:16	239:16	8	(s2 -> codec_id == AV_CODEC_ID_MPEG2VIDEO)
cond	235:20	235:36	9	s2 -> codec_id == AV_CODEC_ID_MPEG2VIDEO
water	235:20	0:0	10	s2
op	235:22	0:0	10	->
water	235:24	0:0	10	codec_id
op	235:33	0:0	10	==
water	235:36	0:0	10	AV_CODEC_ID_MPEG2VIDEO
stmts	235:60	239:16	9	
water	235:60	0:0	10	{
if	236:20	238:29	10	(mb_y < avctx -> skip_top || mb_y >= s2 -> mb_height - avctx -> skip_bottom)
cond	236:24	237:55	11	mb_y < avctx -> skip_top || mb_y >= s2 -> mb_height - avctx -> skip_bottom
water	236:24	0:0	12	mb_y
op	236:29	0:0	12	<
water	236:31	0:0	12	avctx
op	236:36	0:0	12	->
water	236:38	0:0	12	skip_top
op	236:47	0:0	12	||
water	237:24	0:0	12	mb_y
op	237:29	0:0	12	>=
water	237:32	0:0	12	s2
op	237:34	0:0	12	->
water	237:36	0:0	12	mb_height
op	237:46	0:0	12	-
water	237:48	0:0	12	avctx
op	237:53	0:0	12	->
water	237:55	0:0	12	skip_bottom
stmts	238:24	238:29	11	
break	238:24	238:29	12	
water	239:16	0:0	10	}
if	240:16	245:16	8	(! s2 -> pict_type)
cond	240:20	240:25	9	! s2 -> pict_type
op	240:20	0:0	10	!
water	240:21	0:0	10	s2
op	240:23	0:0	10	->
water	240:25	0:0	10	pict_type
stmts	240:36	245:16	9	
water	240:36	0:0	10	{
call	241:20	241:78	10	av_log
arg	241:27	241:32	11	avctx
water	241:27	0:0	12	avctx
arg	241:34	241:46	11	AV_LOG_ERROR
water	241:34	0:0	12	AV_LOG_ERROR
arg	241:48	241:78	11	"Missing picture start code\n"
water	241:48	0:0	12	"Missing picture start code\n"
water	241:79	0:0	10	;
if	242:20	243:50	10	(avctx -> err_recognition & AV_EF_EXPLODE)
cond	242:24	242:49	11	avctx -> err_recognition & AV_EF_EXPLODE
water	242:24	0:0	12	avctx
op	242:29	0:0	12	->
water	242:31	0:0	12	err_recognition
op	242:47	0:0	12	&
water	242:49	0:0	12	AV_EF_EXPLODE
stmts	243:24	243:50	11	
return	243:24	243:50	12	AVERROR_INVALIDDATA
water	243:31	0:0	13	AVERROR_INVALIDDATA
break	244:20	244:25	10	
water	245:16	0:0	10	}
if	246:16	251:16	8	(s -> first_slice)
cond	246:20	246:23	9	s -> first_slice
water	246:20	0:0	10	s
op	246:21	0:0	10	->
water	246:23	0:0	10	first_slice
stmts	246:36	251:16	9	
water	246:36	0:0	10	{
water	247:20	0:0	10	skip_frame
op	247:35	0:0	10	=
water	247:37	0:0	10	0
water	247:38	0:0	10	;
water	248:20	0:0	10	s
op	248:21	0:0	10	->
water	248:23	0:0	10	first_slice
op	248:35	0:0	10	=
water	248:37	0:0	10	0
water	248:38	0:0	10	;
if	249:20	250:34	10	(( ret =mpeg_field_start (s2 ,buf ,buf_size ) ) < 0)
cond	249:24	249:70	11	( ret =mpeg_field_start (s2 ,buf ,buf_size ) ) < 0
water	249:24	0:0	12	(
water	249:25	0:0	12	ret
op	249:29	0:0	12	=
call	249:31	249:65	12	mpeg_field_start
arg	249:48	249:50	13	s2
water	249:48	0:0	14	s2
arg	249:52	249:55	13	buf
water	249:52	0:0	14	buf
arg	249:57	249:65	13	buf_size
water	249:57	0:0	14	buf_size
water	249:66	0:0	12	)
op	249:68	0:0	12	<
water	249:70	0:0	12	0
stmts	250:24	250:34	11	
return	250:24	250:34	12	ret
water	250:31	0:0	13	ret
water	251:16	0:0	10	}
if	252:16	256:16	8	(! s2 -> current_picture_ptr)
cond	252:20	252:25	9	! s2 -> current_picture_ptr
op	252:20	0:0	10	!
water	252:21	0:0	10	s2
op	252:23	0:0	10	->
water	252:25	0:0	10	current_picture_ptr
stmts	252:46	256:16	9	
water	252:46	0:0	10	{
call	253:20	254:62	10	av_log
arg	253:27	253:32	11	avctx
water	253:27	0:0	12	avctx
arg	253:34	253:46	11	AV_LOG_ERROR
water	253:34	0:0	12	AV_LOG_ERROR
arg	254:27	254:62	11	"current_picture not initialized\n"
water	254:27	0:0	12	"current_picture not initialized\n"
water	254:63	0:0	10	;
return	255:20	255:46	10	AVERROR_INVALIDDATA
water	255:27	0:0	11	AVERROR_INVALIDDATA
water	256:16	0:0	10	}
if	258:16	261:16	8	(uses_vdpau (avctx ))
cond	258:20	258:36	9	uses_vdpau (avctx )
call	258:20	258:36	10	uses_vdpau
arg	258:31	258:36	11	avctx
water	258:31	0:0	12	avctx
stmts	258:39	261:16	9	
water	258:39	0:0	10	{
water	259:20	0:0	10	s
op	259:21	0:0	10	->
water	259:23	0:0	10	slice_count
op	259:34	0:0	10	++
water	259:36	0:0	10	;
break	260:20	260:25	10	
water	261:16	0:0	10	}
if	263:16	284:16	8	(HAVE_THREADS && ( avctx -> active_thread_type & FF_THREAD_SLICE ) && ! avctx -> hwaccel)
cond	263:20	265:28	9	HAVE_THREADS && ( avctx -> active_thread_type & FF_THREAD_SLICE ) && ! avctx -> hwaccel
water	263:20	0:0	10	HAVE_THREADS
op	263:33	0:0	10	&&
water	264:20	0:0	10	(
water	264:21	0:0	10	avctx
op	264:26	0:0	10	->
water	264:28	0:0	10	active_thread_type
op	264:47	0:0	10	&
water	264:49	0:0	10	FF_THREAD_SLICE
water	264:64	0:0	10	)
op	264:66	0:0	10	&&
op	265:20	0:0	10	!
water	265:21	0:0	10	avctx
op	265:26	0:0	10	->
water	265:28	0:0	10	hwaccel
stmts	265:37	284:16	9	
water	265:37	0:0	10	{
decl	266:20	268:59	10	int	threshold
op	266:34	0:0	10	=
water	266:36	0:0	10	(
water	266:37	0:0	10	s2
op	266:39	0:0	10	->
water	266:41	0:0	10	mb_height
op	266:51	0:0	10	*
water	266:53	0:0	10	s
op	266:54	0:0	10	->
water	266:56	0:0	10	slice_count
op	266:68	0:0	10	+
water	267:37	0:0	10	s2
op	267:39	0:0	10	->
water	267:41	0:0	10	slice_context_count
op	267:61	0:0	10	/
water	267:63	0:0	10	2
water	267:64	0:0	10	)
op	267:66	0:0	10	/
water	268:36	0:0	10	s2
op	268:38	0:0	10	->
water	268:40	0:0	10	slice_context_count
call	269:20	269:54	10	av_assert0
arg	269:31	269:54	11	avctx->thread_count>1
water	269:31	0:0	12	avctx
op	269:36	0:0	12	->
water	269:38	0:0	12	thread_count
op	269:51	0:0	12	>
water	269:53	0:0	12	1
water	269:55	0:0	10	;
if	270:20	282:20	10	(threshold <= mb_y)
cond	270:24	270:37	11	threshold <= mb_y
water	270:24	0:0	12	threshold
op	270:34	0:0	12	<=
water	270:37	0:0	12	mb_y
stmts	270:43	282:20	11	
water	270:43	0:0	12	{
decl	271:24	271:91	12	MpegEncContext	*thread_context
op	271:55	0:0	12	=
water	271:57	0:0	12	s2
op	271:59	0:0	12	->
water	271:61	0:0	12	thread_context
op	271:75	0:0	12	[
water	271:76	0:0	12	s
op	271:77	0:0	12	->
water	271:79	0:0	12	slice_count
op	271:90	0:0	12	]
water	272:24	0:0	12	thread_context
op	272:38	0:0	12	->
water	272:40	0:0	12	start_mb_y
op	272:51	0:0	12	=
water	272:53	0:0	12	mb_y
water	272:57	0:0	12	;
water	273:24	0:0	12	thread_context
op	273:38	0:0	12	->
water	273:40	0:0	12	end_mb_y
op	273:51	0:0	12	=
water	273:53	0:0	12	s2
op	273:55	0:0	12	->
water	273:57	0:0	12	mb_height
water	273:66	0:0	12	;
if	274:24	279:24	12	(s -> slice_count)
cond	274:28	274:31	13	s -> slice_count
water	274:28	0:0	14	s
op	274:29	0:0	14	->
water	274:31	0:0	14	slice_count
stmts	274:44	279:24	13	
water	274:44	0:0	14	{
water	275:28	0:0	14	s2
op	275:30	0:0	14	->
water	275:32	0:0	14	thread_context
op	275:46	0:0	14	[
water	275:47	0:0	14	s
op	275:48	0:0	14	->
water	275:50	0:0	14	slice_count
op	275:62	0:0	14	-
water	275:64	0:0	14	1
op	275:65	0:0	14	]
op	275:66	0:0	14	->
water	275:68	0:0	14	end_mb_y
op	275:77	0:0	14	=
water	275:79	0:0	14	mb_y
water	275:83	0:0	14	;
water	276:28	0:0	14	ret
op	276:32	0:0	14	=
call	276:34	276:80	14	ff_update_duplicate_context
arg	276:62	276:76	15	thread_context
water	276:62	0:0	16	thread_context
arg	276:78	276:80	15	s2
water	276:78	0:0	16	s2
water	276:81	0:0	14	;
if	277:28	278:42	14	(ret < 0)
cond	277:32	277:38	15	ret < 0
water	277:32	0:0	16	ret
op	277:36	0:0	16	<
water	277:38	0:0	16	0
stmts	278:32	278:42	15	
return	278:32	278:42	16	ret
water	278:39	0:0	17	ret
water	279:24	0:0	14	}
call	280:24	280:82	12	init_get_bits
arg	280:38	280:57	13	&thread_context->gb
op	280:38	0:0	14	&
water	280:39	0:0	14	thread_context
op	280:53	0:0	14	->
water	280:55	0:0	14	gb
arg	280:59	280:66	13	buf_ptr
water	280:59	0:0	14	buf_ptr
arg	280:68	280:82	13	input_size*8
water	280:68	0:0	14	input_size
op	280:79	0:0	14	*
water	280:81	0:0	14	8
water	280:83	0:0	12	;
water	281:24	0:0	12	s
op	281:25	0:0	12	->
water	281:27	0:0	12	slice_count
op	281:38	0:0	12	++
water	281:40	0:0	12	;
water	282:20	0:0	12	}
water	283:20	0:0	10	buf_ptr
op	283:28	0:0	10	+=
water	283:31	0:0	10	2
water	283:32	0:0	10	;
water	284:16	0:0	10	}
else	284:18	299:16	8
stmts	284:23	299:16	9	
water	284:23	0:0	10	{
water	285:20	0:0	10	ret
op	285:24	0:0	10	=
call	285:26	285:74	10	mpeg_decode_slice
arg	285:44	285:46	11	s2
water	285:44	0:0	12	s2
arg	285:48	285:52	11	mb_y
water	285:48	0:0	12	mb_y
arg	285:54	285:62	11	&buf_ptr
op	285:54	0:0	12	&
water	285:55	0:0	12	buf_ptr
arg	285:64	285:74	11	input_size
water	285:64	0:0	12	input_size
water	285:75	0:0	10	;
call	286:20	286:27	10	emms_c
water	286:28	0:0	10	;
if	287:20	294:20	10	(ret < 0)
cond	287:24	287:30	11	ret < 0
water	287:24	0:0	12	ret
op	287:28	0:0	12	<
water	287:30	0:0	12	0
stmts	287:33	294:20	11	
water	287:33	0:0	12	{
if	288:24	289:38	12	(avctx -> err_recognition & AV_EF_EXPLODE)
cond	288:28	288:53	13	avctx -> err_recognition & AV_EF_EXPLODE
water	288:28	0:0	14	avctx
op	288:33	0:0	14	->
water	288:35	0:0	14	err_recognition
op	288:51	0:0	14	&
water	288:53	0:0	14	AV_EF_EXPLODE
stmts	289:28	289:38	13	
return	289:28	289:38	14	ret
water	289:35	0:0	15	ret
if	290:24	293:84	12	(s2 -> resync_mb_x >= 0 && s2 -> resync_mb_y >= 0)
cond	290:28	290:71	13	s2 -> resync_mb_x >= 0 && s2 -> resync_mb_y >= 0
water	290:28	0:0	14	s2
op	290:30	0:0	14	->
water	290:32	0:0	14	resync_mb_x
op	290:44	0:0	14	>=
water	290:47	0:0	14	0
op	290:49	0:0	14	&&
water	290:52	0:0	14	s2
op	290:54	0:0	14	->
water	290:56	0:0	14	resync_mb_y
op	290:68	0:0	14	>=
water	290:71	0:0	14	0
stmts	291:28	293:84	13	
call	291:28	293:83	14	ff_er_add_slice
arg	291:44	291:51	15	&s2->er
op	291:44	0:0	16	&
water	291:45	0:0	16	s2
op	291:47	0:0	16	->
water	291:49	0:0	16	er
arg	291:53	291:68	15	s2->resync_mb_x
water	291:53	0:0	16	s2
op	291:55	0:0	16	->
water	291:57	0:0	16	resync_mb_x
arg	292:44	292:59	15	s2->resync_mb_y
water	292:44	0:0	16	s2
op	292:46	0:0	16	->
water	292:48	0:0	16	resync_mb_y
arg	292:61	292:69	15	s2->mb_x
water	292:61	0:0	16	s2
op	292:63	0:0	16	->
water	292:65	0:0	16	mb_x
arg	292:71	292:79	15	s2->mb_y
water	292:71	0:0	16	s2
op	292:73	0:0	16	->
water	292:75	0:0	16	mb_y
arg	293:44	293:83	15	ER_AC_ERROR|ER_DC_ERROR|ER_MV_ERROR
water	293:44	0:0	16	ER_AC_ERROR
op	293:56	0:0	16	|
water	293:58	0:0	16	ER_DC_ERROR
op	293:70	0:0	16	|
water	293:72	0:0	16	ER_MV_ERROR
water	293:84	0:0	14	;
water	294:20	0:0	12	}
else	294:22	298:20	10
stmts	294:27	298:20	11	
water	294:27	0:0	12	{
call	295:24	297:73	12	ff_er_add_slice
arg	295:40	295:47	13	&s2->er
op	295:40	0:0	14	&
water	295:41	0:0	14	s2
op	295:43	0:0	14	->
water	295:45	0:0	14	er
arg	295:49	295:64	13	s2->resync_mb_x
water	295:49	0:0	14	s2
op	295:51	0:0	14	->
water	295:53	0:0	14	resync_mb_x
arg	296:40	296:55	13	s2->resync_mb_y
water	296:40	0:0	14	s2
op	296:42	0:0	14	->
water	296:44	0:0	14	resync_mb_y
arg	296:57	296:69	13	s2->mb_x-1
water	296:57	0:0	14	s2
op	296:59	0:0	14	->
water	296:61	0:0	14	mb_x
op	296:66	0:0	14	-
water	296:68	0:0	14	1
arg	296:71	296:79	13	s2->mb_y
water	296:71	0:0	14	s2
op	296:73	0:0	14	->
water	296:75	0:0	14	mb_y
arg	297:40	297:73	13	ER_AC_END|ER_DC_END|ER_MV_END
water	297:40	0:0	14	ER_AC_END
op	297:50	0:0	14	|
water	297:52	0:0	14	ER_DC_END
op	297:62	0:0	14	|
water	297:64	0:0	14	ER_MV_END
water	297:74	0:0	12	;
water	298:20	0:0	12	}
water	299:16	0:0	10	}
water	300:12	0:0	8	}
break	301:12	301:17	6	
water	302:8	0:0	6	}
water	303:4	0:0	4	}
