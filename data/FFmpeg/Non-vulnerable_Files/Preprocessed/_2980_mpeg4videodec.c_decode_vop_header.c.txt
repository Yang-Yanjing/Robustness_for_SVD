func	1:0	239:0	0	static int	decode_vop_header
params	1:28	0:0	1	
param	1:29	1:49	2	Mpeg4DecContext *	ctx
param	1:51	1:68	2	GetBitContext *	gb
stmnts	0:0	238:12	1	
decl	3:4	3:31	2	MpegEncContext	*s
op	3:22	0:0	2	=
op	3:24	0:0	2	&
water	3:25	0:0	2	ctx
op	3:28	0:0	2	->
water	3:30	0:0	2	m
decl	4:4	4:33	2	int	time_incr
water	4:17	0:0	2	,
decl	4:4	4:33	2	int	time_increment
decl	5:4	5:15	2	int64_t	pts
water	6:4	0:0	2	s
op	6:5	0:0	2	->
water	6:7	0:0	2	pict_type
op	6:17	0:0	2	=
call	6:19	6:33	2	get_bits
arg	6:28	6:30	3	gb
water	6:28	0:0	4	gb
arg	6:32	6:33	3	2
water	6:32	0:0	4	2
op	6:35	0:0	2	+
water	6:37	0:0	2	AV_PICTURE_TYPE_I
water	6:54	0:0	2	;
if	7:4	11:4	2	(s -> pict_type == AV_PICTURE_TYPE_B && s -> low_delay && ctx -> vol_control_parameters == 0 && ! ( s -> avctx -> flags & AV_CODEC_FLAG_LOW_DELAY ))
cond	7:8	8:87	3	s -> pict_type == AV_PICTURE_TYPE_B && s -> low_delay && ctx -> vol_control_parameters == 0 && ! ( s -> avctx -> flags & AV_CODEC_FLAG_LOW_DELAY )
water	7:8	0:0	4	s
op	7:9	0:0	4	->
water	7:11	0:0	4	pict_type
op	7:21	0:0	4	==
water	7:24	0:0	4	AV_PICTURE_TYPE_B
op	7:42	0:0	4	&&
water	7:45	0:0	4	s
op	7:46	0:0	4	->
water	7:48	0:0	4	low_delay
op	7:58	0:0	4	&&
water	8:8	0:0	4	ctx
op	8:11	0:0	4	->
water	8:13	0:0	4	vol_control_parameters
op	8:36	0:0	4	==
water	8:39	0:0	4	0
op	8:41	0:0	4	&&
op	8:44	0:0	4	!
water	8:45	0:0	4	(
water	8:46	0:0	4	s
op	8:47	0:0	4	->
water	8:49	0:0	4	avctx
op	8:54	0:0	4	->
water	8:56	0:0	4	flags
op	8:62	0:0	4	&
water	8:64	0:0	4	AV_CODEC_FLAG_LOW_DELAY
water	8:87	0:0	4	)
stmts	8:90	11:4	3	
water	8:90	0:0	4	{
call	9:8	9:86	4	av_log
arg	9:15	9:23	5	s->avctx
water	9:15	0:0	6	s
op	9:16	0:0	6	->
water	9:18	0:0	6	avctx
arg	9:25	9:37	5	AV_LOG_ERROR
water	9:25	0:0	6	AV_LOG_ERROR
arg	9:39	9:86	5	"low_delay flag set incorrectly, clearing it\n"
water	9:39	0:0	6	"low_delay flag set incorrectly, clearing it\n"
water	9:87	0:0	4	;
water	10:8	0:0	4	s
op	10:9	0:0	4	->
water	10:11	0:0	4	low_delay
op	10:21	0:0	4	=
water	10:23	0:0	4	0
water	10:24	0:0	4	;
water	11:4	0:0	4	}
water	12:4	0:0	2	s
op	12:5	0:0	2	->
water	12:7	0:0	2	partitioned_frame
op	12:25	0:0	2	=
water	12:27	0:0	2	s
op	12:28	0:0	2	->
water	12:30	0:0	2	data_partitioning
op	12:48	0:0	2	&&
water	12:51	0:0	2	s
op	12:52	0:0	2	->
water	12:54	0:0	2	pict_type
op	12:64	0:0	2	!=
water	12:67	0:0	2	AV_PICTURE_TYPE_B
water	12:84	0:0	2	;
if	13:4	14:50	2	(s -> partitioned_frame)
cond	13:8	13:11	3	s -> partitioned_frame
water	13:8	0:0	4	s
op	13:9	0:0	4	->
water	13:11	0:0	4	partitioned_frame
stmts	14:8	14:50	3	
water	14:8	0:0	4	s
op	14:9	0:0	4	->
water	14:11	0:0	4	decode_mb
op	14:21	0:0	4	=
water	14:23	0:0	4	mpeg4_decode_partitioned_mb
water	14:50	0:0	4	;
else	15:4	16:38	2
stmts	16:8	16:38	3	
water	16:8	0:0	4	s
op	16:9	0:0	4	->
water	16:11	0:0	4	decode_mb
op	16:21	0:0	4	=
water	16:23	0:0	4	mpeg4_decode_mb
water	16:38	0:0	4	;
water	17:4	0:0	2	time_incr
op	17:14	0:0	2	=
water	17:16	0:0	2	0
water	17:17	0:0	2	;
while	18:4	19:19	2	(get_bits1 (gb ) != 0)
cond	18:11	18:28	3	get_bits1 (gb ) != 0
call	18:11	18:23	4	get_bits1
arg	18:21	18:23	5	gb
water	18:21	0:0	6	gb
op	18:25	0:0	4	!=
water	18:28	0:0	4	0
stmts	19:8	19:19	3	
water	19:8	0:0	4	time_incr
op	19:17	0:0	4	++
water	19:19	0:0	4	;
call	20:4	20:44	2	check_marker
arg	20:17	20:19	3	gb
water	20:17	0:0	4	gb
arg	20:21	20:44	3	"before time_increment"
water	20:21	0:0	4	"before time_increment"
water	20:45	0:0	2	;
if	21:4	42:4	2	(ctx -> time_increment_bits == 0 || ! (show_bits (gb ,ctx -> time_increment_bits + 1 ) & 1 ))
cond	21:8	22:57	3	ctx -> time_increment_bits == 0 || ! (show_bits (gb ,ctx -> time_increment_bits + 1 ) & 1 )
water	21:8	0:0	4	ctx
op	21:11	0:0	4	->
water	21:13	0:0	4	time_increment_bits
op	21:33	0:0	4	==
water	21:36	0:0	4	0
op	21:38	0:0	4	||
op	22:8	0:0	4	!
water	22:9	0:0	4	(
call	22:10	22:52	4	show_bits
arg	22:20	22:22	5	gb
water	22:20	0:0	6	gb
arg	22:24	22:52	5	ctx->time_increment_bits+1
water	22:24	0:0	6	ctx
op	22:27	0:0	6	->
water	22:29	0:0	6	time_increment_bits
op	22:49	0:0	6	+
water	22:51	0:0	6	1
op	22:54	0:0	4	&
water	22:56	0:0	4	1
water	22:57	0:0	4	)
stmts	22:60	42:4	3	
water	22:60	0:0	4	{
call	23:8	24:162	4	av_log
arg	23:15	23:23	5	s->avctx
water	23:15	0:0	6	s
op	23:16	0:0	6	->
water	23:18	0:0	6	avctx
arg	23:25	23:39	5	AV_LOG_WARNING
water	23:25	0:0	6	AV_LOG_WARNING
arg	24:15	24:136	5	"time_increment_bits %d is invalid in relation to the current bitstream, this is likely caused by a missing VOL header\n"
water	24:15	0:0	6	"time_increment_bits %d is invalid in relation to the current bitstream, this is likely caused by a missing VOL header\n"
arg	24:138	24:162	5	ctx->time_increment_bits
water	24:138	0:0	6	ctx
op	24:141	0:0	6	->
water	24:143	0:0	6	time_increment_bits
water	24:163	0:0	4	;
for	25:8	35:8	4	(ctx -> time_increment_bits = 1 ;ctx -> time_increment_bits < 16;ctx -> time_increment_bits ++)
forinit	25:13	25:41	5	ctx -> time_increment_bits = 1 ;
water	25:13	0:0	6	ctx
op	25:16	0:0	6	->
water	25:18	0:0	6	time_increment_bits
op	25:38	0:0	6	=
water	25:40	0:0	6	1
water	25:41	0:0	6	;
cond	26:13	26:40	5	ctx -> time_increment_bits < 16
water	26:13	0:0	6	ctx
op	26:16	0:0	6	->
water	26:18	0:0	6	time_increment_bits
op	26:38	0:0	6	<
water	26:40	0:0	6	16
forexpr	27:13	27:37	5	ctx -> time_increment_bits ++
water	27:13	0:0	6	ctx
op	27:16	0:0	6	->
water	27:18	0:0	6	time_increment_bits
op	27:37	0:0	6	++
stmts	27:41	35:8	5	
water	27:41	0:0	6	{
if	28:12	33:12	6	(s -> pict_type == AV_PICTURE_TYPE_P || ( s -> pict_type == AV_PICTURE_TYPE_S && ctx -> vol_sprite_usage == GMC_SPRITE ))
cond	28:16	30:52	7	s -> pict_type == AV_PICTURE_TYPE_P || ( s -> pict_type == AV_PICTURE_TYPE_S && ctx -> vol_sprite_usage == GMC_SPRITE )
water	28:16	0:0	8	s
op	28:17	0:0	8	->
water	28:19	0:0	8	pict_type
op	28:29	0:0	8	==
water	28:32	0:0	8	AV_PICTURE_TYPE_P
op	28:50	0:0	8	||
water	29:16	0:0	8	(
water	29:17	0:0	8	s
op	29:18	0:0	8	->
water	29:20	0:0	8	pict_type
op	29:30	0:0	8	==
water	29:33	0:0	8	AV_PICTURE_TYPE_S
op	29:51	0:0	8	&&
water	30:17	0:0	8	ctx
op	30:20	0:0	8	->
water	30:22	0:0	8	vol_sprite_usage
op	30:39	0:0	8	==
water	30:42	0:0	8	GMC_SPRITE
water	30:52	0:0	8	)
stmts	30:55	33:12	7	
water	30:55	0:0	8	{
if	31:16	32:25	8	((show_bits (gb ,ctx -> time_increment_bits + 6 ) & 0 x37 ) == 0 x30)
cond	31:20	31:77	9	(show_bits (gb ,ctx -> time_increment_bits + 6 ) & 0 x37 ) == 0 x30
water	31:20	0:0	10	(
call	31:21	31:63	10	show_bits
arg	31:31	31:33	11	gb
water	31:31	0:0	12	gb
arg	31:35	31:63	11	ctx->time_increment_bits+6
water	31:35	0:0	12	ctx
op	31:38	0:0	12	->
water	31:40	0:0	12	time_increment_bits
op	31:60	0:0	12	+
water	31:62	0:0	12	6
op	31:65	0:0	10	&
water	31:67	0:0	10	0
water	31:68	0:0	10	x37
water	31:71	0:0	10	)
op	31:73	0:0	10	==
water	31:76	0:0	10	0
water	31:77	0:0	10	x30
stmts	32:20	32:25	9	
break	32:20	32:25	10	
water	33:12	0:0	8	}
else	33:14	34:21	6
stmts	33:19	34:21	7	
if	33:19	34:21	8	((show_bits (gb ,ctx -> time_increment_bits + 5 ) & 0 x1F ) == 0 x18)
cond	33:23	33:80	9	(show_bits (gb ,ctx -> time_increment_bits + 5 ) & 0 x1F ) == 0 x18
water	33:23	0:0	10	(
call	33:24	33:66	10	show_bits
arg	33:34	33:36	11	gb
water	33:34	0:0	12	gb
arg	33:38	33:66	11	ctx->time_increment_bits+5
water	33:38	0:0	12	ctx
op	33:41	0:0	12	->
water	33:43	0:0	12	time_increment_bits
op	33:63	0:0	12	+
water	33:65	0:0	12	5
op	33:68	0:0	10	&
water	33:70	0:0	10	0
water	33:71	0:0	10	x1F
water	33:74	0:0	10	)
op	33:76	0:0	10	==
water	33:79	0:0	10	0
water	33:80	0:0	10	x18
stmts	34:16	34:21	9	
break	34:16	34:21	10	
water	35:8	0:0	6	}
call	36:8	37:108	4	av_log
arg	36:15	36:23	5	s->avctx
water	36:15	0:0	6	s
op	36:16	0:0	6	->
water	36:18	0:0	6	avctx
arg	36:25	36:39	5	AV_LOG_WARNING
water	36:25	0:0	6	AV_LOG_WARNING
arg	37:15	37:82	5	"time_increment_bits set to %d bits, based on bitstream analysis\n"
water	37:15	0:0	6	"time_increment_bits set to %d bits, based on bitstream analysis\n"
arg	37:84	37:108	5	ctx->time_increment_bits
water	37:84	0:0	6	ctx
op	37:87	0:0	6	->
water	37:89	0:0	6	time_increment_bits
water	37:109	0:0	4	;
if	38:8	41:8	4	(s -> avctx -> framerate . num && 4 * s -> avctx -> framerate . num < 1 << ctx -> time_increment_bits)
cond	38:12	38:75	5	s -> avctx -> framerate . num && 4 * s -> avctx -> framerate . num < 1 << ctx -> time_increment_bits
water	38:12	0:0	6	s
op	38:13	0:0	6	->
water	38:15	0:0	6	avctx
op	38:20	0:0	6	->
water	38:22	0:0	6	framerate
op	38:31	0:0	6	.
water	38:32	0:0	6	num
op	38:36	0:0	6	&&
water	38:39	0:0	6	4
op	38:40	0:0	6	*
water	38:41	0:0	6	s
op	38:42	0:0	6	->
water	38:44	0:0	6	avctx
op	38:49	0:0	6	->
water	38:51	0:0	6	framerate
op	38:60	0:0	6	.
water	38:61	0:0	6	num
op	38:65	0:0	6	<
water	38:67	0:0	6	1
op	38:68	0:0	6	<<
water	38:70	0:0	6	ctx
op	38:73	0:0	6	->
water	38:75	0:0	6	time_increment_bits
stmts	38:96	41:8	5	
water	38:96	0:0	6	{
water	39:12	0:0	6	s
op	39:13	0:0	6	->
water	39:15	0:0	6	avctx
op	39:20	0:0	6	->
water	39:22	0:0	6	framerate
op	39:31	0:0	6	.
water	39:32	0:0	6	num
op	39:36	0:0	6	=
water	39:38	0:0	6	1
op	39:39	0:0	6	<<
water	39:41	0:0	6	ctx
op	39:44	0:0	6	->
water	39:46	0:0	6	time_increment_bits
water	39:65	0:0	6	;
water	40:12	0:0	6	s
op	40:13	0:0	6	->
water	40:15	0:0	6	avctx
op	40:20	0:0	6	->
water	40:22	0:0	6	time_base
op	40:32	0:0	6	=
call	40:34	40:116	6	av_inv_q
arg	40:43	40:116	7	av_mul_q(s->avctx->framerate,(AVRational){s->avctx->ticks_per_frame,1})
call	40:43	40:115	8	av_mul_q
arg	40:52	40:71	9	s->avctx->framerate
water	40:52	0:0	10	s
op	40:53	0:0	10	->
water	40:55	0:0	10	avctx
op	40:60	0:0	10	->
water	40:62	0:0	10	framerate
arg	40:73	40:115	9	(AVRational){s->avctx->ticks_per_frame,1}
water	40:73	0:0	10	(
water	40:74	0:0	10	AVRational
water	40:84	0:0	10	)
water	40:85	0:0	10	{
water	40:86	0:0	10	s
op	40:87	0:0	10	->
water	40:89	0:0	10	avctx
op	40:94	0:0	10	->
water	40:96	0:0	10	ticks_per_frame
water	40:111	0:0	10	,
water	40:113	0:0	10	1
water	40:114	0:0	10	}
water	40:117	0:0	6	;
water	41:8	0:0	6	}
water	42:4	0:0	4	}
if	43:4	44:38	2	(IS_3IV1)
cond	43:8	43:8	3	IS_3IV1
water	43:8	0:0	4	IS_3IV1
stmts	44:8	44:38	3	
water	44:8	0:0	4	time_increment
op	44:23	0:0	4	=
call	44:25	44:37	4	get_bits1
arg	44:35	44:37	5	gb
water	44:35	0:0	6	gb
water	44:38	0:0	4	;
else	45:4	46:63	2
stmts	46:8	46:63	3	
water	46:8	0:0	4	time_increment
op	46:23	0:0	4	=
call	46:25	46:62	4	get_bits
arg	46:34	46:36	5	gb
water	46:34	0:0	6	gb
arg	46:38	46:62	5	ctx->time_increment_bits
water	46:38	0:0	6	ctx
op	46:41	0:0	6	->
water	46:43	0:0	6	time_increment_bits
water	46:63	0:0	4	;
if	47:4	61:4	2	(s -> pict_type != AV_PICTURE_TYPE_B)
cond	47:8	47:24	3	s -> pict_type != AV_PICTURE_TYPE_B
water	47:8	0:0	4	s
op	47:9	0:0	4	->
water	47:11	0:0	4	pict_type
op	47:21	0:0	4	!=
water	47:24	0:0	4	AV_PICTURE_TYPE_B
stmts	47:43	61:4	3	
water	47:43	0:0	4	{
water	48:8	0:0	4	s
op	48:9	0:0	4	->
water	48:11	0:0	4	last_time_base
op	48:26	0:0	4	=
water	48:28	0:0	4	s
op	48:29	0:0	4	->
water	48:31	0:0	4	time_base
water	48:40	0:0	4	;
water	49:8	0:0	4	s
op	49:9	0:0	4	->
water	49:11	0:0	4	time_base
op	49:25	0:0	4	+=
water	49:28	0:0	4	time_incr
water	49:37	0:0	4	;
water	50:8	0:0	4	s
op	50:9	0:0	4	->
water	50:11	0:0	4	time
op	50:16	0:0	4	=
water	50:18	0:0	4	s
op	50:19	0:0	4	->
water	50:21	0:0	4	time_base
op	50:31	0:0	4	*
water	50:33	0:0	4	s
op	50:34	0:0	4	->
water	50:36	0:0	4	avctx
op	50:41	0:0	4	->
water	50:43	0:0	4	framerate
op	50:52	0:0	4	.
water	50:53	0:0	4	num
op	50:57	0:0	4	+
water	50:59	0:0	4	time_increment
water	50:73	0:0	4	;
if	51:8	58:8	4	(s -> workaround_bugs & FF_BUG_UMP4)
cond	51:12	51:33	5	s -> workaround_bugs & FF_BUG_UMP4
water	51:12	0:0	6	s
op	51:13	0:0	6	->
water	51:15	0:0	6	workaround_bugs
op	51:31	0:0	6	&
water	51:33	0:0	6	FF_BUG_UMP4
stmts	51:46	58:8	5	
water	51:46	0:0	6	{
if	52:12	57:12	6	(s -> time < s -> last_non_b_time)
cond	52:16	52:29	7	s -> time < s -> last_non_b_time
water	52:16	0:0	8	s
op	52:17	0:0	8	->
water	52:19	0:0	8	time
op	52:24	0:0	8	<
water	52:26	0:0	8	s
op	52:27	0:0	8	->
water	52:29	0:0	8	last_non_b_time
stmts	52:46	57:12	7	
water	52:46	0:0	8	{
water	55:16	0:0	8	s
op	55:17	0:0	8	->
water	55:19	0:0	8	time_base
op	55:28	0:0	8	++
water	55:30	0:0	8	;
water	56:16	0:0	8	s
op	56:17	0:0	8	->
water	56:19	0:0	8	time
op	56:24	0:0	8	+=
water	56:27	0:0	8	s
op	56:28	0:0	8	->
water	56:30	0:0	8	avctx
op	56:35	0:0	8	->
water	56:37	0:0	8	framerate
op	56:46	0:0	8	.
water	56:47	0:0	8	num
water	56:50	0:0	8	;
water	57:12	0:0	8	}
water	58:8	0:0	6	}
water	59:8	0:0	4	s
op	59:9	0:0	4	->
water	59:11	0:0	4	pp_time
op	59:27	0:0	4	=
water	59:29	0:0	4	s
op	59:30	0:0	4	->
water	59:32	0:0	4	time
op	59:37	0:0	4	-
water	59:39	0:0	4	s
op	59:40	0:0	4	->
water	59:42	0:0	4	last_non_b_time
water	59:57	0:0	4	;
water	60:8	0:0	4	s
op	60:9	0:0	4	->
water	60:11	0:0	4	last_non_b_time
op	60:27	0:0	4	=
water	60:29	0:0	4	s
op	60:30	0:0	4	->
water	60:32	0:0	4	time
water	60:36	0:0	4	;
water	61:4	0:0	4	}
else	61:6	85:4	2
stmts	61:11	85:4	3	
water	61:11	0:0	4	{
water	62:8	0:0	4	s
op	62:9	0:0	4	->
water	62:11	0:0	4	time
op	62:19	0:0	4	=
water	62:21	0:0	4	(
water	62:22	0:0	4	s
op	62:23	0:0	4	->
water	62:25	0:0	4	last_time_base
op	62:40	0:0	4	+
water	62:42	0:0	4	time_incr
water	62:51	0:0	4	)
op	62:53	0:0	4	*
water	62:55	0:0	4	s
op	62:56	0:0	4	->
water	62:58	0:0	4	avctx
op	62:63	0:0	4	->
water	62:65	0:0	4	framerate
op	62:74	0:0	4	.
water	62:75	0:0	4	num
op	62:79	0:0	4	+
water	62:81	0:0	4	time_increment
water	62:95	0:0	4	;
water	63:8	0:0	4	s
op	63:9	0:0	4	->
water	63:11	0:0	4	pb_time
op	63:19	0:0	4	=
water	63:21	0:0	4	s
op	63:22	0:0	4	->
water	63:24	0:0	4	pp_time
op	63:32	0:0	4	-
water	63:34	0:0	4	(
water	63:35	0:0	4	s
op	63:36	0:0	4	->
water	63:38	0:0	4	last_non_b_time
op	63:54	0:0	4	-
water	63:56	0:0	4	s
op	63:57	0:0	4	->
water	63:59	0:0	4	time
water	63:63	0:0	4	)
water	63:64	0:0	4	;
if	64:8	69:8	4	(s -> pp_time <= s -> pb_time || s -> pp_time <= s -> pp_time - s -> pb_time || s -> pp_time <= 0)
cond	64:12	66:26	5	s -> pp_time <= s -> pb_time || s -> pp_time <= s -> pp_time - s -> pb_time || s -> pp_time <= 0
water	64:12	0:0	6	s
op	64:13	0:0	6	->
water	64:15	0:0	6	pp_time
op	64:23	0:0	6	<=
water	64:26	0:0	6	s
op	64:27	0:0	6	->
water	64:29	0:0	6	pb_time
op	64:37	0:0	6	||
water	65:12	0:0	6	s
op	65:13	0:0	6	->
water	65:15	0:0	6	pp_time
op	65:23	0:0	6	<=
water	65:26	0:0	6	s
op	65:27	0:0	6	->
water	65:29	0:0	6	pp_time
op	65:37	0:0	6	-
water	65:39	0:0	6	s
op	65:40	0:0	6	->
water	65:42	0:0	6	pb_time
op	65:50	0:0	6	||
water	66:12	0:0	6	s
op	66:13	0:0	6	->
water	66:15	0:0	6	pp_time
op	66:23	0:0	6	<=
water	66:26	0:0	6	0
stmts	66:29	69:8	5	
water	66:29	0:0	6	{
return	68:12	68:32	6	FRAME_SKIPPED
water	68:19	0:0	7	FRAME_SKIPPED
water	69:8	0:0	6	}
call	70:8	70:33	4	ff_mpeg4_init_direct_mv
arg	70:32	70:33	5	s
water	70:32	0:0	6	s
water	70:34	0:0	4	;
if	71:8	72:37	4	(ctx -> t_frame == 0)
cond	71:12	71:28	5	ctx -> t_frame == 0
water	71:12	0:0	6	ctx
op	71:15	0:0	6	->
water	71:17	0:0	6	t_frame
op	71:25	0:0	6	==
water	71:28	0:0	6	0
stmts	72:12	72:37	5	
water	72:12	0:0	6	ctx
op	72:15	0:0	6	->
water	72:17	0:0	6	t_frame
op	72:25	0:0	6	=
water	72:27	0:0	6	s
op	72:28	0:0	6	->
water	72:30	0:0	6	pb_time
water	72:37	0:0	6	;
if	73:8	74:28	4	(ctx -> t_frame == 0)
cond	73:12	73:28	5	ctx -> t_frame == 0
water	73:12	0:0	6	ctx
op	73:15	0:0	6	->
water	73:17	0:0	6	t_frame
op	73:25	0:0	6	==
water	73:28	0:0	6	0
stmts	74:12	74:28	5	
water	74:12	0:0	6	ctx
op	74:15	0:0	6	->
water	74:17	0:0	6	t_frame
op	74:25	0:0	6	=
water	74:27	0:0	6	1
water	74:28	0:0	6	;
water	75:8	0:0	4	s
op	75:9	0:0	4	->
water	75:11	0:0	4	pp_field_time
op	75:25	0:0	4	=
water	75:27	0:0	4	(
call	75:28	75:72	4	ROUNDED_DIV
arg	75:40	75:58	5	s->last_non_b_time
water	75:40	0:0	6	s
op	75:41	0:0	6	->
water	75:43	0:0	6	last_non_b_time
arg	75:60	75:72	5	ctx->t_frame
water	75:60	0:0	6	ctx
op	75:63	0:0	6	->
water	75:65	0:0	6	t_frame
op	75:74	0:0	4	-
call	76:28	76:85	4	ROUNDED_DIV
arg	76:40	76:71	5	s->last_non_b_time-s->pp_time
water	76:40	0:0	6	s
op	76:41	0:0	6	->
water	76:43	0:0	6	last_non_b_time
op	76:59	0:0	6	-
water	76:61	0:0	6	s
op	76:62	0:0	6	->
water	76:64	0:0	6	pp_time
arg	76:73	76:85	5	ctx->t_frame
water	76:73	0:0	6	ctx
op	76:76	0:0	6	->
water	76:78	0:0	6	t_frame
water	76:86	0:0	4	)
op	76:88	0:0	4	*
water	76:90	0:0	4	2
water	76:91	0:0	4	;
water	77:8	0:0	4	s
op	77:9	0:0	4	->
water	77:11	0:0	4	pb_field_time
op	77:25	0:0	4	=
water	77:27	0:0	4	(
call	77:28	77:61	4	ROUNDED_DIV
arg	77:40	77:47	5	s->time
water	77:40	0:0	6	s
op	77:41	0:0	6	->
water	77:43	0:0	6	time
arg	77:49	77:61	5	ctx->t_frame
water	77:49	0:0	6	ctx
op	77:52	0:0	6	->
water	77:54	0:0	6	t_frame
op	77:63	0:0	4	-
call	78:28	78:85	4	ROUNDED_DIV
arg	78:40	78:71	5	s->last_non_b_time-s->pp_time
water	78:40	0:0	6	s
op	78:41	0:0	6	->
water	78:43	0:0	6	last_non_b_time
op	78:59	0:0	6	-
water	78:61	0:0	6	s
op	78:62	0:0	6	->
water	78:64	0:0	6	pp_time
arg	78:73	78:85	5	ctx->t_frame
water	78:73	0:0	6	ctx
op	78:76	0:0	6	->
water	78:78	0:0	6	t_frame
water	78:86	0:0	4	)
op	78:88	0:0	4	*
water	78:90	0:0	4	2
water	78:91	0:0	4	;
if	79:8	84:8	4	(s -> pp_field_time <= s -> pb_field_time || s -> pb_field_time <= 1)
cond	79:12	79:72	5	s -> pp_field_time <= s -> pb_field_time || s -> pb_field_time <= 1
water	79:12	0:0	6	s
op	79:13	0:0	6	->
water	79:15	0:0	6	pp_field_time
op	79:29	0:0	6	<=
water	79:32	0:0	6	s
op	79:33	0:0	6	->
water	79:35	0:0	6	pb_field_time
op	79:49	0:0	6	||
water	79:52	0:0	6	s
op	79:53	0:0	6	->
water	79:55	0:0	6	pb_field_time
op	79:69	0:0	6	<=
water	79:72	0:0	6	1
stmts	79:75	84:8	5	
water	79:75	0:0	6	{
water	80:12	0:0	6	s
op	80:13	0:0	6	->
water	80:15	0:0	6	pb_field_time
op	80:29	0:0	6	=
water	80:31	0:0	6	2
water	80:32	0:0	6	;
water	81:12	0:0	6	s
op	81:13	0:0	6	->
water	81:15	0:0	6	pp_field_time
op	81:29	0:0	6	=
water	81:31	0:0	6	4
water	81:32	0:0	6	;
if	82:12	83:36	6	(! s -> progressive_sequence)
cond	82:16	82:20	7	! s -> progressive_sequence
op	82:16	0:0	8	!
water	82:17	0:0	8	s
op	82:18	0:0	8	->
water	82:20	0:0	8	progressive_sequence
stmts	83:16	83:36	7	
return	83:16	83:36	8	FRAME_SKIPPED
water	83:23	0:0	9	FRAME_SKIPPED
water	84:8	0:0	6	}
water	85:4	0:0	4	}
if	86:4	87:59	2	(s -> avctx -> framerate . den)
cond	86:8	86:28	3	s -> avctx -> framerate . den
water	86:8	0:0	4	s
op	86:9	0:0	4	->
water	86:11	0:0	4	avctx
op	86:16	0:0	4	->
water	86:18	0:0	4	framerate
op	86:27	0:0	4	.
water	86:28	0:0	4	den
stmts	87:8	87:59	3	
water	87:8	0:0	4	pts
op	87:12	0:0	4	=
call	87:14	87:58	4	ROUNDED_DIV
arg	87:26	87:33	5	s->time
water	87:26	0:0	6	s
op	87:27	0:0	6	->
water	87:29	0:0	6	time
arg	87:35	87:58	5	s->avctx->framerate.den
water	87:35	0:0	6	s
op	87:36	0:0	6	->
water	87:38	0:0	6	avctx
op	87:43	0:0	6	->
water	87:45	0:0	6	framerate
op	87:54	0:0	6	.
water	87:55	0:0	6	den
water	87:59	0:0	4	;
else	88:4	89:28	2
stmts	89:8	89:28	3	
water	89:8	0:0	4	pts
op	89:12	0:0	4	=
water	89:14	0:0	4	AV_NOPTS_VALUE
water	89:28	0:0	4	;
call	90:4	90:51	2	ff_dlog
arg	90:12	90:20	3	s->avctx
water	90:12	0:0	4	s
op	90:13	0:0	4	->
water	90:15	0:0	4	avctx
arg	90:22	90:46	3	"MPEG4 PTS: %"PRId64"\n"
water	90:22	0:0	4	"MPEG4 PTS: %"
water	90:36	0:0	4	PRId64
water	90:42	0:0	4	"\n"
arg	90:48	90:51	3	pts
water	90:48	0:0	4	pts
water	90:52	0:0	2	;
call	91:4	91:39	2	check_marker
arg	91:17	91:19	3	gb
water	91:17	0:0	4	gb
arg	91:21	91:39	3	"before vop_coded"
water	91:21	0:0	4	"before vop_coded"
water	91:40	0:0	2	;
if	93:4	97:4	2	(get_bits1 (gb ) != 1)
cond	93:8	93:25	3	get_bits1 (gb ) != 1
call	93:8	93:20	4	get_bits1
arg	93:18	93:20	5	gb
water	93:18	0:0	6	gb
op	93:22	0:0	4	!=
water	93:25	0:0	4	1
stmts	93:28	97:4	3	
water	93:28	0:0	4	{
if	94:8	95:61	4	(s -> avctx -> debug & FF_DEBUG_PICT_INFO)
cond	94:12	94:30	5	s -> avctx -> debug & FF_DEBUG_PICT_INFO
water	94:12	0:0	6	s
op	94:13	0:0	6	->
water	94:15	0:0	6	avctx
op	94:20	0:0	6	->
water	94:22	0:0	6	debug
op	94:28	0:0	6	&
water	94:30	0:0	6	FF_DEBUG_PICT_INFO
stmts	95:12	95:61	5	
call	95:12	95:60	6	av_log
arg	95:19	95:27	7	s->avctx
water	95:19	0:0	8	s
op	95:20	0:0	8	->
water	95:22	0:0	8	avctx
arg	95:29	95:41	7	AV_LOG_ERROR
water	95:29	0:0	8	AV_LOG_ERROR
arg	95:43	95:60	7	"vop not coded\n"
water	95:43	0:0	8	"vop not coded\n"
water	95:61	0:0	6	;
return	96:8	96:28	4	FRAME_SKIPPED
water	96:15	0:0	5	FRAME_SKIPPED
water	97:4	0:0	4	}
if	98:4	99:32	2	(ctx -> new_pred)
cond	98:8	98:13	3	ctx -> new_pred
water	98:8	0:0	4	ctx
op	98:11	0:0	4	->
water	98:13	0:0	4	new_pred
stmts	99:8	99:32	3	
call	99:8	99:31	4	decode_new_pred
arg	99:24	99:27	5	ctx
water	99:24	0:0	6	ctx
arg	99:29	99:31	5	gb
water	99:29	0:0	6	gb
water	99:32	0:0	4	;
if	100:4	106:4	2	(ctx -> shape != BIN_ONLY_SHAPE && ( s -> pict_type == AV_PICTURE_TYPE_P || ( s -> pict_type == AV_PICTURE_TYPE_S && ctx -> vol_sprite_usage == GMC_SPRITE ) ))
cond	100:8	103:58	3	ctx -> shape != BIN_ONLY_SHAPE && ( s -> pict_type == AV_PICTURE_TYPE_P || ( s -> pict_type == AV_PICTURE_TYPE_S && ctx -> vol_sprite_usage == GMC_SPRITE ) )
water	100:8	0:0	4	ctx
op	100:11	0:0	4	->
water	100:13	0:0	4	shape
op	100:19	0:0	4	!=
water	100:22	0:0	4	BIN_ONLY_SHAPE
op	100:37	0:0	4	&&
water	101:20	0:0	4	(
water	101:21	0:0	4	s
op	101:22	0:0	4	->
water	101:24	0:0	4	pict_type
op	101:34	0:0	4	==
water	101:37	0:0	4	AV_PICTURE_TYPE_P
op	101:55	0:0	4	||
water	102:21	0:0	4	(
water	102:22	0:0	4	s
op	102:23	0:0	4	->
water	102:25	0:0	4	pict_type
op	102:35	0:0	4	==
water	102:38	0:0	4	AV_PICTURE_TYPE_S
op	102:56	0:0	4	&&
water	103:22	0:0	4	ctx
op	103:25	0:0	4	->
water	103:27	0:0	4	vol_sprite_usage
op	103:44	0:0	4	==
water	103:47	0:0	4	GMC_SPRITE
water	103:57	0:0	4	)
water	103:58	0:0	4	)
stmts	103:61	106:4	3	
water	103:61	0:0	4	{
water	105:8	0:0	4	s
op	105:9	0:0	4	->
water	105:11	0:0	4	no_rounding
op	105:23	0:0	4	=
call	105:25	105:37	4	get_bits1
arg	105:35	105:37	5	gb
water	105:35	0:0	6	gb
water	105:38	0:0	4	;
water	106:4	0:0	4	}
else	106:6	108:4	2
stmts	106:11	108:4	3	
water	106:11	0:0	4	{
water	107:8	0:0	4	s
op	107:9	0:0	4	->
water	107:11	0:0	4	no_rounding
op	107:23	0:0	4	=
water	107:25	0:0	4	0
water	107:26	0:0	4	;
water	108:4	0:0	4	}
if	110:4	123:4	2	(ctx -> shape != RECT_SHAPE)
cond	110:8	110:22	3	ctx -> shape != RECT_SHAPE
water	110:8	0:0	4	ctx
op	110:11	0:0	4	->
water	110:13	0:0	4	shape
op	110:19	0:0	4	!=
water	110:22	0:0	4	RECT_SHAPE
stmts	110:34	123:4	3	
water	110:34	0:0	4	{
if	111:8	119:8	4	(ctx -> vol_sprite_usage != 1 || s -> pict_type != AV_PICTURE_TYPE_I)
cond	111:12	111:58	5	ctx -> vol_sprite_usage != 1 || s -> pict_type != AV_PICTURE_TYPE_I
water	111:12	0:0	6	ctx
op	111:15	0:0	6	->
water	111:17	0:0	6	vol_sprite_usage
op	111:34	0:0	6	!=
water	111:37	0:0	6	1
op	111:39	0:0	6	||
water	111:42	0:0	6	s
op	111:43	0:0	6	->
water	111:45	0:0	6	pict_type
op	111:55	0:0	6	!=
water	111:58	0:0	6	AV_PICTURE_TYPE_I
stmts	111:77	119:8	5	
water	111:77	0:0	6	{
call	112:12	112:28	6	skip_bits
arg	112:22	112:24	7	gb
water	112:22	0:0	8	gb
arg	112:26	112:28	7	13
water	112:26	0:0	8	13
water	112:29	0:0	6	;
call	113:12	113:42	6	check_marker
arg	113:25	113:27	7	gb
water	113:25	0:0	8	gb
arg	113:29	113:42	7	"after width"
water	113:29	0:0	8	"after width"
water	113:43	0:0	6	;
call	114:12	114:28	6	skip_bits
arg	114:22	114:24	7	gb
water	114:22	0:0	8	gb
arg	114:26	114:28	7	13
water	114:26	0:0	8	13
water	114:29	0:0	6	;
call	115:12	115:43	6	check_marker
arg	115:25	115:27	7	gb
water	115:25	0:0	8	gb
arg	115:29	115:43	7	"after height"
water	115:29	0:0	8	"after height"
water	115:44	0:0	6	;
call	116:12	116:28	6	skip_bits
arg	116:22	116:24	7	gb
water	116:22	0:0	8	gb
arg	116:26	116:28	7	13
water	116:26	0:0	8	13
water	116:29	0:0	6	;
call	117:12	117:49	6	check_marker
arg	117:25	117:27	7	gb
water	117:25	0:0	8	gb
arg	117:29	117:49	7	"after hor_spat_ref"
water	117:29	0:0	8	"after hor_spat_ref"
water	117:50	0:0	6	;
call	118:12	118:28	6	skip_bits
arg	118:22	118:24	7	gb
water	118:22	0:0	8	gb
arg	118:26	118:28	7	13
water	118:26	0:0	8	13
water	118:29	0:0	6	;
water	119:8	0:0	6	}
call	120:8	120:21	4	skip_bits1
arg	120:19	120:21	5	gb
water	120:19	0:0	6	gb
water	120:22	0:0	4	;
if	121:8	122:28	4	(get_bits1 (gb ) != 0)
cond	121:12	121:29	5	get_bits1 (gb ) != 0
call	121:12	121:24	6	get_bits1
arg	121:22	121:24	7	gb
water	121:22	0:0	8	gb
op	121:26	0:0	6	!=
water	121:29	0:0	6	0
stmts	122:12	122:28	5	
call	122:12	122:27	6	skip_bits
arg	122:22	122:24	7	gb
water	122:22	0:0	8	gb
arg	122:26	122:27	7	8
water	122:26	0:0	8	8
water	122:28	0:0	6	;
water	123:4	0:0	4	}
if	125:4	141:4	2	(ctx -> shape != BIN_ONLY_SHAPE)
cond	125:8	125:22	3	ctx -> shape != BIN_ONLY_SHAPE
water	125:8	0:0	4	ctx
op	125:11	0:0	4	->
water	125:13	0:0	4	shape
op	125:19	0:0	4	!=
water	125:22	0:0	4	BIN_ONLY_SHAPE
stmts	125:38	141:4	3	
water	125:38	0:0	4	{
call	126:8	126:55	4	skip_bits_long
arg	126:23	126:25	5	gb
water	126:23	0:0	6	gb
arg	126:27	126:55	5	ctx->cplx_estimation_trash_i
water	126:27	0:0	6	ctx
op	126:30	0:0	6	->
water	126:32	0:0	6	cplx_estimation_trash_i
water	126:56	0:0	4	;
if	127:8	128:60	4	(s -> pict_type != AV_PICTURE_TYPE_I)
cond	127:12	127:28	5	s -> pict_type != AV_PICTURE_TYPE_I
water	127:12	0:0	6	s
op	127:13	0:0	6	->
water	127:15	0:0	6	pict_type
op	127:25	0:0	6	!=
water	127:28	0:0	6	AV_PICTURE_TYPE_I
stmts	128:12	128:60	5	
call	128:12	128:59	6	skip_bits_long
arg	128:27	128:29	7	gb
water	128:27	0:0	8	gb
arg	128:31	128:59	7	ctx->cplx_estimation_trash_p
water	128:31	0:0	8	ctx
op	128:34	0:0	8	->
water	128:36	0:0	8	cplx_estimation_trash_p
water	128:60	0:0	6	;
if	129:8	130:60	4	(s -> pict_type == AV_PICTURE_TYPE_B)
cond	129:12	129:28	5	s -> pict_type == AV_PICTURE_TYPE_B
water	129:12	0:0	6	s
op	129:13	0:0	6	->
water	129:15	0:0	6	pict_type
op	129:25	0:0	6	==
water	129:28	0:0	6	AV_PICTURE_TYPE_B
stmts	130:12	130:60	5	
call	130:12	130:59	6	skip_bits_long
arg	130:27	130:29	7	gb
water	130:27	0:0	8	gb
arg	130:31	130:59	7	ctx->cplx_estimation_trash_b
water	130:31	0:0	8	ctx
op	130:34	0:0	8	->
water	130:36	0:0	8	cplx_estimation_trash_b
water	130:60	0:0	6	;
if	131:8	134:8	4	(get_bits_left (gb ) < 3)
cond	131:12	131:32	5	get_bits_left (gb ) < 3
call	131:12	131:28	6	get_bits_left
arg	131:26	131:28	7	gb
water	131:26	0:0	8	gb
op	131:30	0:0	6	<
water	131:32	0:0	6	3
stmts	131:35	134:8	5	
water	131:35	0:0	6	{
call	132:12	132:63	6	av_log
arg	132:19	132:27	7	s->avctx
water	132:19	0:0	8	s
op	132:20	0:0	8	->
water	132:22	0:0	8	avctx
arg	132:29	132:41	7	AV_LOG_ERROR
water	132:29	0:0	8	AV_LOG_ERROR
arg	132:43	132:63	7	"Header truncated\n"
water	132:43	0:0	8	"Header truncated\n"
water	132:64	0:0	6	;
return	133:12	133:38	6	AVERROR_INVALIDDATA
water	133:19	0:0	7	AVERROR_INVALIDDATA
water	134:8	0:0	6	}
water	135:8	0:0	4	ctx
op	135:11	0:0	4	->
water	135:13	0:0	4	intra_dc_threshold
op	135:32	0:0	4	=
water	135:34	0:0	4	ff_mpeg4_dc_threshold
op	135:55	0:0	4	[
call	135:56	135:70	4	get_bits
arg	135:65	135:67	5	gb
water	135:65	0:0	6	gb
arg	135:69	135:70	5	3
water	135:69	0:0	6	3
op	135:71	0:0	4	]
water	135:72	0:0	4	;
if	136:8	139:8	4	(! s -> progressive_sequence)
cond	136:12	136:16	5	! s -> progressive_sequence
op	136:12	0:0	6	!
water	136:13	0:0	6	s
op	136:14	0:0	6	->
water	136:16	0:0	6	progressive_sequence
stmts	136:38	139:8	5	
water	136:38	0:0	6	{
water	137:12	0:0	6	s
op	137:13	0:0	6	->
water	137:15	0:0	6	top_field_first
op	137:31	0:0	6	=
call	137:33	137:45	6	get_bits1
arg	137:43	137:45	7	gb
water	137:43	0:0	8	gb
water	137:46	0:0	6	;
water	138:12	0:0	6	s
op	138:13	0:0	6	->
water	138:15	0:0	6	alternate_scan
op	138:31	0:0	6	=
call	138:33	138:45	6	get_bits1
arg	138:43	138:45	7	gb
water	138:43	0:0	8	gb
water	138:46	0:0	6	;
water	139:8	0:0	6	}
else	139:10	140:33	4
stmts	140:12	140:33	5	
water	140:12	0:0	6	s
op	140:13	0:0	6	->
water	140:15	0:0	6	alternate_scan
op	140:30	0:0	6	=
water	140:32	0:0	6	0
water	140:33	0:0	6	;
water	141:4	0:0	4	}
if	142:4	147:4	2	(s -> alternate_scan)
cond	142:8	142:11	3	s -> alternate_scan
water	142:8	0:0	4	s
op	142:9	0:0	4	->
water	142:11	0:0	4	alternate_scan
stmts	142:27	147:4	3	
water	142:27	0:0	4	{
call	143:8	143:101	4	ff_init_scantable
arg	143:26	143:50	5	s->idsp.idct_permutation
water	143:26	0:0	6	s
op	143:27	0:0	6	->
water	143:29	0:0	6	idsp
op	143:33	0:0	6	.
water	143:34	0:0	6	idct_permutation
arg	143:52	143:71	5	&s->inter_scantable
op	143:52	0:0	6	&
water	143:53	0:0	6	s
op	143:54	0:0	6	->
water	143:56	0:0	6	inter_scantable
arg	143:75	143:101	5	ff_alternate_vertical_scan
water	143:75	0:0	6	ff_alternate_vertical_scan
water	143:102	0:0	4	;
call	144:8	144:101	4	ff_init_scantable
arg	144:26	144:50	5	s->idsp.idct_permutation
water	144:26	0:0	6	s
op	144:27	0:0	6	->
water	144:29	0:0	6	idsp
op	144:33	0:0	6	.
water	144:34	0:0	6	idct_permutation
arg	144:52	144:71	5	&s->intra_scantable
op	144:52	0:0	6	&
water	144:53	0:0	6	s
op	144:54	0:0	6	->
water	144:56	0:0	6	intra_scantable
arg	144:75	144:101	5	ff_alternate_vertical_scan
water	144:75	0:0	6	ff_alternate_vertical_scan
water	144:102	0:0	4	;
call	145:8	145:101	4	ff_init_scantable
arg	145:26	145:50	5	s->idsp.idct_permutation
water	145:26	0:0	6	s
op	145:27	0:0	6	->
water	145:29	0:0	6	idsp
op	145:33	0:0	6	.
water	145:34	0:0	6	idct_permutation
arg	145:52	145:73	5	&s->intra_h_scantable
op	145:52	0:0	6	&
water	145:53	0:0	6	s
op	145:54	0:0	6	->
water	145:56	0:0	6	intra_h_scantable
arg	145:75	145:101	5	ff_alternate_vertical_scan
water	145:75	0:0	6	ff_alternate_vertical_scan
water	145:102	0:0	4	;
call	146:8	146:101	4	ff_init_scantable
arg	146:26	146:50	5	s->idsp.idct_permutation
water	146:26	0:0	6	s
op	146:27	0:0	6	->
water	146:29	0:0	6	idsp
op	146:33	0:0	6	.
water	146:34	0:0	6	idct_permutation
arg	146:52	146:73	5	&s->intra_v_scantable
op	146:52	0:0	6	&
water	146:53	0:0	6	s
op	146:54	0:0	6	->
water	146:56	0:0	6	intra_v_scantable
arg	146:75	146:101	5	ff_alternate_vertical_scan
water	146:75	0:0	6	ff_alternate_vertical_scan
water	146:102	0:0	4	;
water	147:4	0:0	4	}
else	147:6	152:4	2
stmts	147:11	152:4	3	
water	147:11	0:0	4	{
call	148:8	148:91	4	ff_init_scantable
arg	148:26	148:50	5	s->idsp.idct_permutation
water	148:26	0:0	6	s
op	148:27	0:0	6	->
water	148:29	0:0	6	idsp
op	148:33	0:0	6	.
water	148:34	0:0	6	idct_permutation
arg	148:52	148:71	5	&s->inter_scantable
op	148:52	0:0	6	&
water	148:53	0:0	6	s
op	148:54	0:0	6	->
water	148:56	0:0	6	inter_scantable
arg	148:75	148:91	5	ff_zigzag_direct
water	148:75	0:0	6	ff_zigzag_direct
water	148:92	0:0	4	;
call	149:8	149:91	4	ff_init_scantable
arg	149:26	149:50	5	s->idsp.idct_permutation
water	149:26	0:0	6	s
op	149:27	0:0	6	->
water	149:29	0:0	6	idsp
op	149:33	0:0	6	.
water	149:34	0:0	6	idct_permutation
arg	149:52	149:71	5	&s->intra_scantable
op	149:52	0:0	6	&
water	149:53	0:0	6	s
op	149:54	0:0	6	->
water	149:56	0:0	6	intra_scantable
arg	149:75	149:91	5	ff_zigzag_direct
water	149:75	0:0	6	ff_zigzag_direct
water	149:92	0:0	4	;
call	150:8	150:103	4	ff_init_scantable
arg	150:26	150:50	5	s->idsp.idct_permutation
water	150:26	0:0	6	s
op	150:27	0:0	6	->
water	150:29	0:0	6	idsp
op	150:33	0:0	6	.
water	150:34	0:0	6	idct_permutation
arg	150:52	150:73	5	&s->intra_h_scantable
op	150:52	0:0	6	&
water	150:53	0:0	6	s
op	150:54	0:0	6	->
water	150:56	0:0	6	intra_h_scantable
arg	150:75	150:103	5	ff_alternate_horizontal_scan
water	150:75	0:0	6	ff_alternate_horizontal_scan
water	150:104	0:0	4	;
call	151:8	151:101	4	ff_init_scantable
arg	151:26	151:50	5	s->idsp.idct_permutation
water	151:26	0:0	6	s
op	151:27	0:0	6	->
water	151:29	0:0	6	idsp
op	151:33	0:0	6	.
water	151:34	0:0	6	idct_permutation
arg	151:52	151:73	5	&s->intra_v_scantable
op	151:52	0:0	6	&
water	151:53	0:0	6	s
op	151:54	0:0	6	->
water	151:56	0:0	6	intra_v_scantable
arg	151:75	151:101	5	ff_alternate_vertical_scan
water	151:75	0:0	6	ff_alternate_vertical_scan
water	151:102	0:0	4	;
water	152:4	0:0	4	}
if	153:4	163:4	2	(s -> pict_type == AV_PICTURE_TYPE_S && ( ctx -> vol_sprite_usage == STATIC_SPRITE || ctx -> vol_sprite_usage == GMC_SPRITE ))
cond	153:8	155:44	3	s -> pict_type == AV_PICTURE_TYPE_S && ( ctx -> vol_sprite_usage == STATIC_SPRITE || ctx -> vol_sprite_usage == GMC_SPRITE )
water	153:8	0:0	4	s
op	153:9	0:0	4	->
water	153:11	0:0	4	pict_type
op	153:21	0:0	4	==
water	153:24	0:0	4	AV_PICTURE_TYPE_S
op	153:42	0:0	4	&&
water	154:8	0:0	4	(
water	154:9	0:0	4	ctx
op	154:12	0:0	4	->
water	154:14	0:0	4	vol_sprite_usage
op	154:31	0:0	4	==
water	154:34	0:0	4	STATIC_SPRITE
op	154:48	0:0	4	||
water	155:9	0:0	4	ctx
op	155:12	0:0	4	->
water	155:14	0:0	4	vol_sprite_usage
op	155:31	0:0	4	==
water	155:34	0:0	4	GMC_SPRITE
water	155:44	0:0	4	)
stmts	155:47	163:4	3	
water	155:47	0:0	4	{
if	156:8	157:38	4	(mpeg4_decode_sprite_trajectory (ctx ,gb ) < 0)
cond	156:12	156:54	5	mpeg4_decode_sprite_trajectory (ctx ,gb ) < 0
call	156:12	156:50	6	mpeg4_decode_sprite_trajectory
arg	156:43	156:46	7	ctx
water	156:43	0:0	8	ctx
arg	156:48	156:50	7	gb
water	156:48	0:0	8	gb
op	156:52	0:0	6	<
water	156:54	0:0	6	0
stmts	157:12	157:38	5	
return	157:12	157:38	6	AVERROR_INVALIDDATA
water	157:19	0:0	7	AVERROR_INVALIDDATA
if	158:8	160:62	4	(ctx -> sprite_brightness_change)
cond	158:12	158:17	5	ctx -> sprite_brightness_change
water	158:12	0:0	6	ctx
op	158:15	0:0	6	->
water	158:17	0:0	6	sprite_brightness_change
stmts	159:12	160:62	5	
call	159:12	160:61	6	av_log
arg	159:19	159:27	7	s->avctx
water	159:19	0:0	8	s
op	159:20	0:0	8	->
water	159:22	0:0	8	avctx
arg	159:29	159:41	7	AV_LOG_ERROR
water	159:29	0:0	8	AV_LOG_ERROR
arg	160:19	160:61	7	"sprite_brightness_change not supported\n"
water	160:19	0:0	8	"sprite_brightness_change not supported\n"
water	160:62	0:0	6	;
if	161:8	162:75	4	(ctx -> vol_sprite_usage == STATIC_SPRITE)
cond	161:12	161:37	5	ctx -> vol_sprite_usage == STATIC_SPRITE
water	161:12	0:0	6	ctx
op	161:15	0:0	6	->
water	161:17	0:0	6	vol_sprite_usage
op	161:34	0:0	6	==
water	161:37	0:0	6	STATIC_SPRITE
stmts	162:12	162:75	5	
call	162:12	162:74	6	av_log
arg	162:19	162:27	7	s->avctx
water	162:19	0:0	8	s
op	162:20	0:0	8	->
water	162:22	0:0	8	avctx
arg	162:29	162:41	7	AV_LOG_ERROR
water	162:29	0:0	8	AV_LOG_ERROR
arg	162:43	162:74	7	"static sprite not supported\n"
water	162:43	0:0	8	"static sprite not supported\n"
water	162:75	0:0	6	;
water	163:4	0:0	4	}
if	164:4	220:4	2	(ctx -> shape != BIN_ONLY_SHAPE)
cond	164:8	164:22	3	ctx -> shape != BIN_ONLY_SHAPE
water	164:8	0:0	4	ctx
op	164:11	0:0	4	->
water	164:13	0:0	4	shape
op	164:19	0:0	4	!=
water	164:22	0:0	4	BIN_ONLY_SHAPE
stmts	164:38	220:4	3	
water	164:38	0:0	4	{
water	165:8	0:0	4	s
op	165:9	0:0	4	->
water	165:11	0:0	4	chroma_qscale
op	165:25	0:0	4	=
water	165:27	0:0	4	s
op	165:28	0:0	4	->
water	165:30	0:0	4	qscale
op	165:37	0:0	4	=
call	165:39	165:70	4	get_bits
arg	165:48	165:50	5	gb
water	165:48	0:0	6	gb
arg	165:52	165:70	5	s->quant_precision
water	165:52	0:0	6	s
op	165:53	0:0	6	->
water	165:55	0:0	6	quant_precision
water	165:71	0:0	4	;
if	166:8	170:8	4	(s -> qscale == 0)
cond	166:12	166:25	5	s -> qscale == 0
water	166:12	0:0	6	s
op	166:13	0:0	6	->
water	166:15	0:0	6	qscale
op	166:22	0:0	6	==
water	166:25	0:0	6	0
stmts	166:28	170:8	5	
water	166:28	0:0	6	{
call	167:12	168:75	6	av_log
arg	167:19	167:27	7	s->avctx
water	167:19	0:0	8	s
op	167:20	0:0	8	->
water	167:22	0:0	8	avctx
arg	167:29	167:41	7	AV_LOG_ERROR
water	167:29	0:0	8	AV_LOG_ERROR
arg	168:19	168:75	7	"Error, header damaged or not MPEG4 header (qscale=0)\n"
water	168:19	0:0	8	"Error, header damaged or not MPEG4 header (qscale=0)\n"
water	168:76	0:0	6	;
return	169:12	169:38	6	AVERROR_INVALIDDATA
water	169:19	0:0	7	AVERROR_INVALIDDATA
water	170:8	0:0	6	}
if	171:8	179:8	4	(s -> pict_type != AV_PICTURE_TYPE_I)
cond	171:12	171:28	5	s -> pict_type != AV_PICTURE_TYPE_I
water	171:12	0:0	6	s
op	171:13	0:0	6	->
water	171:15	0:0	6	pict_type
op	171:25	0:0	6	!=
water	171:28	0:0	6	AV_PICTURE_TYPE_I
stmts	171:47	179:8	5	
water	171:47	0:0	6	{
water	172:12	0:0	6	s
op	172:13	0:0	6	->
water	172:15	0:0	6	f_code
op	172:22	0:0	6	=
call	172:24	172:38	6	get_bits
arg	172:33	172:35	7	gb
water	172:33	0:0	8	gb
arg	172:37	172:38	7	3
water	172:37	0:0	8	3
water	172:39	0:0	6	;
if	173:12	178:12	6	(s -> f_code == 0)
cond	173:16	173:29	7	s -> f_code == 0
water	173:16	0:0	8	s
op	173:17	0:0	8	->
water	173:19	0:0	8	f_code
op	173:26	0:0	8	==
water	173:29	0:0	8	0
stmts	173:32	178:12	7	
water	173:32	0:0	8	{
call	174:16	175:79	8	av_log
arg	174:23	174:31	9	s->avctx
water	174:23	0:0	10	s
op	174:24	0:0	10	->
water	174:26	0:0	10	avctx
arg	174:33	174:45	9	AV_LOG_ERROR
water	174:33	0:0	10	AV_LOG_ERROR
arg	175:23	175:79	9	"Error, header damaged or not MPEG4 header (f_code=0)\n"
water	175:23	0:0	10	"Error, header damaged or not MPEG4 header (f_code=0)\n"
water	175:80	0:0	8	;
water	176:16	0:0	8	s
op	176:17	0:0	8	->
water	176:19	0:0	8	f_code
op	176:26	0:0	8	=
water	176:28	0:0	8	1
water	176:29	0:0	8	;
return	177:16	177:42	8	AVERROR_INVALIDDATA
water	177:23	0:0	9	AVERROR_INVALIDDATA
water	178:12	0:0	8	}
water	179:8	0:0	6	}
else	179:10	180:25	4
stmts	180:12	180:25	5	
water	180:12	0:0	6	s
op	180:13	0:0	6	->
water	180:15	0:0	6	f_code
op	180:22	0:0	6	=
water	180:24	0:0	6	1
water	180:25	0:0	6	;
if	181:8	189:8	4	(s -> pict_type == AV_PICTURE_TYPE_B)
cond	181:12	181:28	5	s -> pict_type == AV_PICTURE_TYPE_B
water	181:12	0:0	6	s
op	181:13	0:0	6	->
water	181:15	0:0	6	pict_type
op	181:25	0:0	6	==
water	181:28	0:0	6	AV_PICTURE_TYPE_B
stmts	181:47	189:8	5	
water	181:47	0:0	6	{
water	182:12	0:0	6	s
op	182:13	0:0	6	->
water	182:15	0:0	6	b_code
op	182:22	0:0	6	=
call	182:24	182:38	6	get_bits
arg	182:33	182:35	7	gb
water	182:33	0:0	8	gb
arg	182:37	182:38	7	3
water	182:37	0:0	8	3
water	182:39	0:0	6	;
if	183:12	188:12	6	(s -> b_code == 0)
cond	183:16	183:29	7	s -> b_code == 0
water	183:16	0:0	8	s
op	183:17	0:0	8	->
water	183:19	0:0	8	b_code
op	183:26	0:0	8	==
water	183:29	0:0	8	0
stmts	183:32	188:12	7	
water	183:32	0:0	8	{
call	184:16	185:79	8	av_log
arg	184:23	184:31	9	s->avctx
water	184:23	0:0	10	s
op	184:24	0:0	10	->
water	184:26	0:0	10	avctx
arg	184:33	184:45	9	AV_LOG_ERROR
water	184:33	0:0	10	AV_LOG_ERROR
arg	185:23	185:79	9	"Error, header damaged or not MPEG4 header (b_code=0)\n"
water	185:23	0:0	10	"Error, header damaged or not MPEG4 header (b_code=0)\n"
water	185:80	0:0	8	;
water	186:16	0:0	8	s
op	186:17	0:0	8	->
water	186:19	0:0	8	b_code
op	186:25	0:0	8	=
water	186:26	0:0	8	1
water	186:27	0:0	8	;
return	187:16	187:42	8	AVERROR_INVALIDDATA
water	187:23	0:0	9	AVERROR_INVALIDDATA
water	188:12	0:0	8	}
water	189:8	0:0	6	}
else	189:10	190:25	4
stmts	190:12	190:25	5	
water	190:12	0:0	6	s
op	190:13	0:0	6	->
water	190:15	0:0	6	b_code
op	190:22	0:0	6	=
water	190:24	0:0	6	1
water	190:25	0:0	6	;
if	191:8	207:8	4	(s -> avctx -> debug & FF_DEBUG_PICT_INFO)
cond	191:12	191:30	5	s -> avctx -> debug & FF_DEBUG_PICT_INFO
water	191:12	0:0	6	s
op	191:13	0:0	6	->
water	191:15	0:0	6	avctx
op	191:20	0:0	6	->
water	191:22	0:0	6	debug
op	191:28	0:0	6	&
water	191:30	0:0	6	FF_DEBUG_PICT_INFO
stmts	191:50	207:8	5	
water	191:50	0:0	6	{
call	192:12	206:18	6	av_log
arg	192:19	192:27	7	s->avctx
water	192:19	0:0	8	s
op	192:20	0:0	8	->
water	192:22	0:0	8	avctx
arg	192:29	192:41	7	AV_LOG_DEBUG
water	192:29	0:0	8	AV_LOG_DEBUG
arg	193:19	193:161	7	"qp:%d fc:%d,%d %s size:%d pro:%d alt:%d top:%d %spel part:%d resync:%d w:%d a:%d rnd:%d vot:%d%s dc:%d ce:%d/%d/%d time:%"PRId64" tincr:%d\n"
water	193:19	0:0	8	"qp:%d fc:%d,%d %s size:%d pro:%d alt:%d top:%d %spel part:%d resync:%d w:%d a:%d rnd:%d vot:%d%s dc:%d ce:%d/%d/%d time:%"
water	193:142	0:0	8	PRId64
water	193:148	0:0	8	" tincr:%d\n"
arg	194:19	194:28	7	s->qscale
water	194:19	0:0	8	s
op	194:20	0:0	8	->
water	194:22	0:0	8	qscale
arg	194:30	194:39	7	s->f_code
water	194:30	0:0	8	s
op	194:31	0:0	8	->
water	194:33	0:0	8	f_code
arg	194:41	194:50	7	s->b_code
water	194:41	0:0	8	s
op	194:42	0:0	8	->
water	194:44	0:0	8	b_code
arg	195:19	195:152	7	s->pict_type==AV_PICTURE_TYPE_I?"I":(s->pict_type==AV_PICTURE_TYPE_P?"P":(s->pict_type==AV_PICTURE_TYPE_B?"B":"S"))
water	195:19	0:0	8	s
op	195:20	0:0	8	->
water	195:22	0:0	8	pict_type
op	195:32	0:0	8	==
water	195:35	0:0	8	AV_PICTURE_TYPE_I
water	195:53	0:0	8	?
water	195:55	0:0	8	"I"
water	195:59	0:0	8	:
water	195:61	0:0	8	(
water	195:62	0:0	8	s
op	195:63	0:0	8	->
water	195:65	0:0	8	pict_type
op	195:75	0:0	8	==
water	195:78	0:0	8	AV_PICTURE_TYPE_P
water	195:96	0:0	8	?
water	195:98	0:0	8	"P"
water	195:102	0:0	8	:
water	195:104	0:0	8	(
water	195:105	0:0	8	s
op	195:106	0:0	8	->
water	195:108	0:0	8	pict_type
op	195:118	0:0	8	==
water	195:121	0:0	8	AV_PICTURE_TYPE_B
water	195:139	0:0	8	?
water	195:141	0:0	8	"B"
water	195:145	0:0	8	:
water	195:147	0:0	8	"S"
water	195:150	0:0	8	)
water	195:151	0:0	8	)
arg	196:19	196:35	7	gb->size_in_bits
water	196:19	0:0	8	gb
op	196:21	0:0	8	->
water	196:23	0:0	8	size_in_bits
arg	196:36	196:59	7	s->progressive_sequence
water	196:36	0:0	8	s
op	196:37	0:0	8	->
water	196:39	0:0	8	progressive_sequence
arg	196:61	196:78	7	s->alternate_scan
water	196:61	0:0	8	s
op	196:62	0:0	8	->
water	196:64	0:0	8	alternate_scan
arg	197:19	197:37	7	s->top_field_first
water	197:19	0:0	8	s
op	197:20	0:0	8	->
water	197:22	0:0	8	top_field_first
arg	197:39	197:68	7	s->quarter_sample?"q":"h"
water	197:39	0:0	8	s
op	197:40	0:0	8	->
water	197:42	0:0	8	quarter_sample
water	197:57	0:0	8	?
water	197:59	0:0	8	"q"
water	197:63	0:0	8	:
water	197:65	0:0	8	"h"
arg	198:19	198:39	7	s->data_partitioning
water	198:19	0:0	8	s
op	198:20	0:0	8	->
water	198:22	0:0	8	data_partitioning
arg	198:41	198:59	7	ctx->resync_marker
water	198:41	0:0	8	ctx
op	198:44	0:0	8	->
water	198:46	0:0	8	resync_marker
arg	199:19	199:49	7	ctx->num_sprite_warping_points
water	199:19	0:0	8	ctx
op	199:22	0:0	8	->
water	199:24	0:0	8	num_sprite_warping_points
arg	199:51	199:77	7	s->sprite_warping_accuracy
water	199:51	0:0	8	s
op	199:52	0:0	8	->
water	199:54	0:0	8	sprite_warping_accuracy
arg	200:19	200:37	7	1-s->no_rounding
water	200:19	0:0	8	1
op	200:21	0:0	8	-
water	200:23	0:0	8	s
op	200:24	0:0	8	->
water	200:26	0:0	8	no_rounding
arg	200:39	200:49	7	s->vo_type
water	200:39	0:0	8	s
op	200:40	0:0	8	->
water	200:42	0:0	8	vo_type
arg	201:19	201:62	7	ctx->vol_control_parameters?" VOLC":" "
water	201:19	0:0	8	ctx
op	201:22	0:0	8	->
water	201:24	0:0	8	vol_control_parameters
water	201:47	0:0	8	?
water	201:49	0:0	8	" VOLC"
water	201:57	0:0	8	:
water	201:59	0:0	8	" "
arg	201:64	201:87	7	ctx->intra_dc_threshold
water	201:64	0:0	8	ctx
op	201:67	0:0	8	->
water	201:69	0:0	8	intra_dc_threshold
arg	202:19	202:47	7	ctx->cplx_estimation_trash_i
water	202:19	0:0	8	ctx
op	202:22	0:0	8	->
water	202:24	0:0	8	cplx_estimation_trash_i
arg	202:49	202:77	7	ctx->cplx_estimation_trash_p
water	202:49	0:0	8	ctx
op	202:52	0:0	8	->
water	202:54	0:0	8	cplx_estimation_trash_p
arg	203:19	203:47	7	ctx->cplx_estimation_trash_b
water	203:19	0:0	8	ctx
op	203:22	0:0	8	->
water	203:24	0:0	8	cplx_estimation_trash_b
arg	204:19	204:26	7	s->time
water	204:19	0:0	8	s
op	204:20	0:0	8	->
water	204:22	0:0	8	time
arg	205:19	206:18	7	time_increment
water	205:19	0:0	8	time_increment
water	206:19	0:0	6	;
water	207:8	0:0	6	}
if	208:8	211:8	4	(! ctx -> scalability)
cond	208:12	208:18	5	! ctx -> scalability
op	208:12	0:0	6	!
water	208:13	0:0	6	ctx
op	208:16	0:0	6	->
water	208:18	0:0	6	scalability
stmts	208:31	211:8	5	
water	208:31	0:0	6	{
if	209:12	210:30	6	(ctx -> shape != RECT_SHAPE && s -> pict_type != AV_PICTURE_TYPE_I)
cond	209:16	209:60	7	ctx -> shape != RECT_SHAPE && s -> pict_type != AV_PICTURE_TYPE_I
water	209:16	0:0	8	ctx
op	209:19	0:0	8	->
water	209:21	0:0	8	shape
op	209:27	0:0	8	!=
water	209:30	0:0	8	RECT_SHAPE
op	209:41	0:0	8	&&
water	209:44	0:0	8	s
op	209:45	0:0	8	->
water	209:47	0:0	8	pict_type
op	209:57	0:0	8	!=
water	209:60	0:0	8	AV_PICTURE_TYPE_I
stmts	210:16	210:30	7	
call	210:16	210:29	8	skip_bits1
arg	210:27	210:29	9	gb
water	210:27	0:0	10	gb
water	210:30	0:0	8	;
water	211:8	0:0	6	}
else	211:10	219:8	4
stmts	211:15	219:8	5	
water	211:15	0:0	6	{
if	212:12	217:12	6	(ctx -> enhancement_type)
cond	212:16	212:21	7	ctx -> enhancement_type
water	212:16	0:0	8	ctx
op	212:19	0:0	8	->
water	212:21	0:0	8	enhancement_type
stmts	212:39	217:12	7	
water	212:39	0:0	8	{
decl	213:16	213:55	8	int	load_backward_shape
op	213:40	0:0	8	=
call	213:42	213:54	9	get_bits1
arg	213:52	213:54	10	gb
water	213:52	0:0	11	gb
if	214:16	216:67	8	(load_backward_shape)
cond	214:20	214:20	9	load_backward_shape
water	214:20	0:0	10	load_backward_shape
stmts	215:20	216:67	9	
call	215:20	216:66	10	av_log
arg	215:27	215:35	11	s->avctx
water	215:27	0:0	12	s
op	215:28	0:0	12	->
water	215:30	0:0	12	avctx
arg	215:37	215:49	11	AV_LOG_ERROR
water	215:37	0:0	12	AV_LOG_ERROR
arg	216:27	216:66	11	"load backward shape isn't supported\n"
water	216:27	0:0	12	"load backward shape isn't supported\n"
water	216:67	0:0	10	;
water	217:12	0:0	8	}
call	218:12	218:27	6	skip_bits
arg	218:22	218:24	7	gb
water	218:22	0:0	8	gb
arg	218:26	218:27	7	2
water	218:26	0:0	8	2
water	218:28	0:0	6	;
water	219:8	0:0	6	}
water	220:4	0:0	4	}
if	224:4	229:4	2	(s -> vo_type == 0 && ctx -> vol_control_parameters == 0 && ctx -> divx_version == - 1 && s -> picture_number == 0)
cond	224:8	225:56	3	s -> vo_type == 0 && ctx -> vol_control_parameters == 0 && ctx -> divx_version == - 1 && s -> picture_number == 0
water	224:8	0:0	4	s
op	224:9	0:0	4	->
water	224:11	0:0	4	vo_type
op	224:19	0:0	4	==
water	224:22	0:0	4	0
op	224:24	0:0	4	&&
water	224:27	0:0	4	ctx
op	224:30	0:0	4	->
water	224:32	0:0	4	vol_control_parameters
op	224:55	0:0	4	==
water	224:58	0:0	4	0
op	224:60	0:0	4	&&
water	225:8	0:0	4	ctx
op	225:11	0:0	4	->
water	225:13	0:0	4	divx_version
op	225:26	0:0	4	==
op	225:29	0:0	4	-
water	225:30	0:0	4	1
op	225:32	0:0	4	&&
water	225:35	0:0	4	s
op	225:36	0:0	4	->
water	225:38	0:0	4	picture_number
op	225:53	0:0	4	==
water	225:56	0:0	4	0
stmts	225:59	229:4	3	
water	225:59	0:0	4	{
call	226:8	227:109	4	av_log
arg	226:15	226:23	5	s->avctx
water	226:15	0:0	6	s
op	226:16	0:0	6	->
water	226:18	0:0	6	avctx
arg	226:25	226:39	5	AV_LOG_WARNING
water	226:25	0:0	6	AV_LOG_WARNING
arg	227:15	227:109	5	"looks like this file was encoded with (divx4/(old)xvid/opendivx) -> forcing low_delay flag\n"
water	227:15	0:0	6	"looks like this file was encoded with (divx4/(old)xvid/opendivx) -> forcing low_delay flag\n"
water	227:110	0:0	4	;
water	228:8	0:0	4	s
op	228:9	0:0	4	->
water	228:11	0:0	4	low_delay
op	228:21	0:0	4	=
water	228:23	0:0	4	1
water	228:24	0:0	4	;
water	229:4	0:0	4	}
water	230:4	0:0	2	s
op	230:5	0:0	2	->
water	230:7	0:0	2	picture_number
op	230:21	0:0	2	++
water	230:23	0:0	2	;
water	232:4	0:0	2	s
op	232:5	0:0	2	->
water	232:7	0:0	2	y_dc_scale_table
op	232:24	0:0	2	=
water	232:26	0:0	2	ff_mpeg4_y_dc_scale_table
water	232:51	0:0	2	;
water	233:4	0:0	2	s
op	233:5	0:0	2	->
water	233:7	0:0	2	c_dc_scale_table
op	233:24	0:0	2	=
water	233:26	0:0	2	ff_mpeg4_c_dc_scale_table
water	233:51	0:0	2	;
if	234:4	237:4	2	(s -> workaround_bugs & FF_BUG_EDGE)
cond	234:8	234:29	3	s -> workaround_bugs & FF_BUG_EDGE
water	234:8	0:0	4	s
op	234:9	0:0	4	->
water	234:11	0:0	4	workaround_bugs
op	234:27	0:0	4	&
water	234:29	0:0	4	FF_BUG_EDGE
stmts	234:42	237:4	3	
water	234:42	0:0	4	{
water	235:8	0:0	4	s
op	235:9	0:0	4	->
water	235:11	0:0	4	h_edge_pos
op	235:22	0:0	4	=
water	235:24	0:0	4	s
op	235:25	0:0	4	->
water	235:27	0:0	4	width
water	235:32	0:0	4	;
water	236:8	0:0	4	s
op	236:9	0:0	4	->
water	236:11	0:0	4	v_edge_pos
op	236:22	0:0	4	=
water	236:24	0:0	4	s
op	236:25	0:0	4	->
water	236:27	0:0	4	height
water	236:33	0:0	4	;
water	237:4	0:0	4	}
return	238:4	238:12	2	0
water	238:11	0:0	3	0
