func	1:0	306:0	0	static int	decode_vol_header
params	1:28	0:0	1	
param	1:29	1:49	2	Mpeg4DecContext *	ctx
param	1:51	1:68	2	GetBitContext *	gb
stmnts	0:0	305:12	1	
decl	3:4	3:31	2	MpegEncContext	*s
op	3:22	0:0	2	=
op	3:24	0:0	2	&
water	3:25	0:0	2	ctx
op	3:28	0:0	2	->
water	3:30	0:0	2	m
decl	4:4	4:32	2	int	width
water	4:13	0:0	2	,
decl	4:4	4:32	2	int	height
water	4:21	0:0	2	,
decl	4:4	4:32	2	int	vo_ver_id
call	6:4	6:19	2	skip_bits
arg	6:14	6:16	3	gb
water	6:14	0:0	4	gb
arg	6:18	6:19	3	1
water	6:18	0:0	4	1
water	6:20	0:0	2	;
water	7:4	0:0	2	s
op	7:5	0:0	2	->
water	7:7	0:0	2	vo_type
op	7:15	0:0	2	=
call	7:17	7:31	2	get_bits
arg	7:26	7:28	3	gb
water	7:26	0:0	4	gb
arg	7:30	7:31	3	8
water	7:30	0:0	4	8
water	7:32	0:0	2	;
if	8:4	11:4	2	(get_bits1 (gb ) != 0)
cond	8:8	8:25	3	get_bits1 (gb ) != 0
call	8:8	8:20	4	get_bits1
arg	8:18	8:20	5	gb
water	8:18	0:0	6	gb
op	8:22	0:0	4	!=
water	8:25	0:0	4	0
stmts	8:28	11:4	3	
water	8:28	0:0	4	{
water	9:8	0:0	4	vo_ver_id
op	9:18	0:0	4	=
call	9:20	9:34	4	get_bits
arg	9:29	9:31	5	gb
water	9:29	0:0	6	gb
arg	9:33	9:34	5	4
water	9:33	0:0	6	4
water	9:35	0:0	4	;
call	10:8	10:23	4	skip_bits
arg	10:18	10:20	5	gb
water	10:18	0:0	6	gb
arg	10:22	10:23	5	3
water	10:22	0:0	6	3
water	10:24	0:0	4	;
water	11:4	0:0	4	}
else	11:6	13:4	2
stmts	11:11	13:4	3	
water	11:11	0:0	4	{
water	12:8	0:0	4	vo_ver_id
op	12:18	0:0	4	=
water	12:20	0:0	4	1
water	12:21	0:0	4	;
water	13:4	0:0	4	}
water	14:4	0:0	2	s
op	14:5	0:0	2	->
water	14:7	0:0	2	aspect_ratio_info
op	14:25	0:0	2	=
call	14:27	14:41	2	get_bits
arg	14:36	14:38	3	gb
water	14:36	0:0	4	gb
arg	14:40	14:41	3	4
water	14:40	0:0	4	4
water	14:42	0:0	2	;
if	15:4	18:4	2	(s -> aspect_ratio_info == FF_ASPECT_EXTENDED)
cond	15:8	15:32	3	s -> aspect_ratio_info == FF_ASPECT_EXTENDED
water	15:8	0:0	4	s
op	15:9	0:0	4	->
water	15:11	0:0	4	aspect_ratio_info
op	15:29	0:0	4	==
water	15:32	0:0	4	FF_ASPECT_EXTENDED
stmts	15:52	18:4	3	
water	15:52	0:0	4	{
water	16:8	0:0	4	s
op	16:9	0:0	4	->
water	16:11	0:0	4	avctx
op	16:16	0:0	4	->
water	16:18	0:0	4	sample_aspect_ratio
op	16:37	0:0	4	.
water	16:38	0:0	4	num
op	16:42	0:0	4	=
call	16:44	16:58	4	get_bits
arg	16:53	16:55	5	gb
water	16:53	0:0	6	gb
arg	16:57	16:58	5	8
water	16:57	0:0	6	8
water	16:59	0:0	4	;
water	17:8	0:0	4	s
op	17:9	0:0	4	->
water	17:11	0:0	4	avctx
op	17:16	0:0	4	->
water	17:18	0:0	4	sample_aspect_ratio
op	17:37	0:0	4	.
water	17:38	0:0	4	den
op	17:42	0:0	4	=
call	17:44	17:58	4	get_bits
arg	17:53	17:55	5	gb
water	17:53	0:0	6	gb
arg	17:57	17:58	5	8
water	17:57	0:0	6	8
water	17:59	0:0	4	;
water	18:4	0:0	4	}
else	18:6	20:4	2
stmts	18:11	20:4	3	
water	18:11	0:0	4	{
water	19:8	0:0	4	s
op	19:9	0:0	4	->
water	19:11	0:0	4	avctx
op	19:16	0:0	4	->
water	19:18	0:0	4	sample_aspect_ratio
op	19:38	0:0	4	=
water	19:40	0:0	4	ff_h263_pixel_aspect
op	19:60	0:0	4	[
water	19:61	0:0	4	s
op	19:62	0:0	4	->
water	19:64	0:0	4	aspect_ratio_info
op	19:81	0:0	4	]
water	19:82	0:0	4	;
water	20:4	0:0	4	}
if	21:4	39:4	2	(( ctx -> vol_control_parameters =get_bits1 (gb ) ))
cond	21:8	21:52	3	( ctx -> vol_control_parameters =get_bits1 (gb ) )
water	21:8	0:0	4	(
water	21:9	0:0	4	ctx
op	21:12	0:0	4	->
water	21:14	0:0	4	vol_control_parameters
op	21:37	0:0	4	=
call	21:39	21:51	4	get_bits1
arg	21:49	21:51	5	gb
water	21:49	0:0	6	gb
water	21:52	0:0	4	)
stmts	21:55	39:4	3	
water	21:55	0:0	4	{
decl	22:8	22:43	4	int	chroma_format
op	22:26	0:0	4	=
call	22:28	22:42	5	get_bits
arg	22:37	22:39	6	gb
water	22:37	0:0	7	gb
arg	22:41	22:42	6	2
water	22:41	0:0	7	2
if	23:8	24:69	4	(chroma_format != CHROMA_420)
cond	23:12	23:29	5	chroma_format != CHROMA_420
water	23:12	0:0	6	chroma_format
op	23:26	0:0	6	!=
water	23:29	0:0	6	CHROMA_420
stmts	24:12	24:69	5	
call	24:12	24:68	6	av_log
arg	24:19	24:27	7	s->avctx
water	24:19	0:0	8	s
op	24:20	0:0	8	->
water	24:22	0:0	8	avctx
arg	24:29	24:41	7	AV_LOG_ERROR
water	24:29	0:0	8	AV_LOG_ERROR
arg	24:43	24:68	7	"illegal chroma format\n"
water	24:43	0:0	8	"illegal chroma format\n"
water	24:69	0:0	6	;
water	25:8	0:0	4	s
op	25:9	0:0	4	->
water	25:11	0:0	4	low_delay
op	25:21	0:0	4	=
call	25:23	25:35	4	get_bits1
arg	25:33	25:35	5	gb
water	25:33	0:0	6	gb
water	25:36	0:0	4	;
if	26:8	38:8	4	(get_bits1 (gb ))
cond	26:12	26:24	5	get_bits1 (gb )
call	26:12	26:24	6	get_bits1
arg	26:22	26:24	7	gb
water	26:22	0:0	8	gb
stmts	26:27	38:8	5	
water	26:27	0:0	6	{
call	27:12	27:27	6	get_bits
arg	27:21	27:23	7	gb
water	27:21	0:0	8	gb
arg	27:25	27:27	7	15
water	27:25	0:0	8	15
water	27:28	0:0	6	;
call	28:12	28:55	6	check_marker
arg	28:25	28:27	7	gb
water	28:25	0:0	8	gb
arg	28:29	28:55	7	"after first_half_bitrate"
water	28:29	0:0	8	"after first_half_bitrate"
water	28:56	0:0	6	;
call	29:12	29:27	6	get_bits
arg	29:21	29:23	7	gb
water	29:21	0:0	8	gb
arg	29:25	29:27	7	15
water	29:25	0:0	8	15
water	29:28	0:0	6	;
call	30:12	30:56	6	check_marker
arg	30:25	30:27	7	gb
water	30:25	0:0	8	gb
arg	30:29	30:56	7	"after latter_half_bitrate"
water	30:29	0:0	8	"after latter_half_bitrate"
water	30:57	0:0	6	;
call	31:12	31:27	6	get_bits
arg	31:21	31:23	7	gb
water	31:21	0:0	8	gb
arg	31:25	31:27	7	15
water	31:25	0:0	8	15
water	31:28	0:0	6	;
call	32:12	32:63	6	check_marker
arg	32:25	32:27	7	gb
water	32:25	0:0	8	gb
arg	32:29	32:63	7	"after first_half_vbv_buffer_size"
water	32:29	0:0	8	"after first_half_vbv_buffer_size"
water	32:64	0:0	6	;
call	33:12	33:26	6	get_bits
arg	33:21	33:23	7	gb
water	33:21	0:0	8	gb
arg	33:25	33:26	7	3
water	33:25	0:0	8	3
water	33:27	0:0	6	;
call	34:12	34:27	6	get_bits
arg	34:21	34:23	7	gb
water	34:21	0:0	8	gb
arg	34:25	34:27	7	11
water	34:25	0:0	8	11
water	34:28	0:0	6	;
call	35:12	35:61	6	check_marker
arg	35:25	35:27	7	gb
water	35:25	0:0	8	gb
arg	35:29	35:61	7	"after first_half_vbv_occupancy"
water	35:29	0:0	8	"after first_half_vbv_occupancy"
water	35:62	0:0	6	;
call	36:12	36:27	6	get_bits
arg	36:21	36:23	7	gb
water	36:21	0:0	8	gb
arg	36:25	36:27	7	15
water	36:25	0:0	8	15
water	36:28	0:0	6	;
call	37:12	37:62	6	check_marker
arg	37:25	37:27	7	gb
water	37:25	0:0	8	gb
arg	37:29	37:62	7	"after latter_half_vbv_occupancy"
water	37:29	0:0	8	"after latter_half_vbv_occupancy"
water	37:63	0:0	6	;
water	38:8	0:0	6	}
water	39:4	0:0	4	}
else	39:6	44:4	2
stmts	39:11	44:4	3	
water	39:11	0:0	4	{
if	42:8	43:28	4	(s -> picture_number == 0)
cond	42:12	42:33	5	s -> picture_number == 0
water	42:12	0:0	6	s
op	42:13	0:0	6	->
water	42:15	0:0	6	picture_number
op	42:30	0:0	6	==
water	42:33	0:0	6	0
stmts	43:12	43:28	5	
water	43:12	0:0	6	s
op	43:13	0:0	6	->
water	43:15	0:0	6	low_delay
op	43:25	0:0	6	=
water	43:27	0:0	6	0
water	43:28	0:0	6	;
water	44:4	0:0	4	}
water	45:4	0:0	2	ctx
op	45:7	0:0	2	->
water	45:9	0:0	2	shape
op	45:15	0:0	2	=
call	45:17	45:31	2	get_bits
arg	45:26	45:28	3	gb
water	45:26	0:0	4	gb
arg	45:30	45:31	3	2
water	45:30	0:0	4	2
water	45:32	0:0	2	;
if	46:4	47:74	2	(ctx -> shape != RECT_SHAPE)
cond	46:8	46:22	3	ctx -> shape != RECT_SHAPE
water	46:8	0:0	4	ctx
op	46:11	0:0	4	->
water	46:13	0:0	4	shape
op	46:19	0:0	4	!=
water	46:22	0:0	4	RECT_SHAPE
stmts	47:8	47:74	3	
call	47:8	47:73	4	av_log
arg	47:15	47:23	5	s->avctx
water	47:15	0:0	6	s
op	47:16	0:0	6	->
water	47:18	0:0	6	avctx
arg	47:25	47:37	5	AV_LOG_ERROR
water	47:25	0:0	6	AV_LOG_ERROR
arg	47:39	47:73	5	"only rectangular vol supported\n"
water	47:39	0:0	6	"only rectangular vol supported\n"
water	47:74	0:0	4	;
if	48:4	51:4	2	(ctx -> shape == GRAY_SHAPE && vo_ver_id != 1)
cond	48:8	48:49	3	ctx -> shape == GRAY_SHAPE && vo_ver_id != 1
water	48:8	0:0	4	ctx
op	48:11	0:0	4	->
water	48:13	0:0	4	shape
op	48:19	0:0	4	==
water	48:22	0:0	4	GRAY_SHAPE
op	48:33	0:0	4	&&
water	48:36	0:0	4	vo_ver_id
op	48:46	0:0	4	!=
water	48:49	0:0	4	1
stmts	48:52	51:4	3	
water	48:52	0:0	4	{
call	49:8	49:67	4	av_log
arg	49:15	49:23	5	s->avctx
water	49:15	0:0	6	s
op	49:16	0:0	6	->
water	49:18	0:0	6	avctx
arg	49:25	49:37	5	AV_LOG_ERROR
water	49:25	0:0	6	AV_LOG_ERROR
arg	49:39	49:67	5	"Gray shape not supported\n"
water	49:39	0:0	6	"Gray shape not supported\n"
water	49:68	0:0	4	;
call	50:8	50:23	4	skip_bits
arg	50:18	50:20	5	gb
water	50:18	0:0	6	gb
arg	50:22	50:23	5	4
water	50:22	0:0	6	4
water	50:24	0:0	4	;
water	51:4	0:0	4	}
call	52:4	52:55	2	check_marker
arg	52:17	52:19	3	gb
water	52:17	0:0	4	gb
arg	52:21	52:55	3	"before time_increment_resolution"
water	52:21	0:0	4	"before time_increment_resolution"
water	52:56	0:0	2	;
water	53:4	0:0	2	s
op	53:5	0:0	2	->
water	53:7	0:0	2	avctx
op	53:12	0:0	2	->
water	53:14	0:0	2	framerate
op	53:23	0:0	2	.
water	53:24	0:0	2	num
op	53:28	0:0	2	=
call	53:30	53:45	2	get_bits
arg	53:39	53:41	3	gb
water	53:39	0:0	4	gb
arg	53:43	53:45	3	16
water	53:43	0:0	4	16
water	53:46	0:0	2	;
if	54:4	57:4	2	(! s -> avctx -> framerate . num)
cond	54:8	54:29	3	! s -> avctx -> framerate . num
op	54:8	0:0	4	!
water	54:9	0:0	4	s
op	54:10	0:0	4	->
water	54:12	0:0	4	avctx
op	54:17	0:0	4	->
water	54:19	0:0	4	framerate
op	54:28	0:0	4	.
water	54:29	0:0	4	num
stmts	54:34	57:4	3	
water	54:34	0:0	4	{
call	55:8	55:55	4	av_log
arg	55:15	55:23	5	s->avctx
water	55:15	0:0	6	s
op	55:16	0:0	6	->
water	55:18	0:0	6	avctx
arg	55:25	55:37	5	AV_LOG_ERROR
water	55:25	0:0	6	AV_LOG_ERROR
arg	55:39	55:55	5	"framerate==0\n"
water	55:39	0:0	6	"framerate==0\n"
water	55:56	0:0	4	;
return	56:8	56:34	4	AVERROR_INVALIDDATA
water	56:15	0:0	5	AVERROR_INVALIDDATA
water	57:4	0:0	4	}
water	58:4	0:0	2	ctx
op	58:7	0:0	2	->
water	58:9	0:0	2	time_increment_bits
op	58:29	0:0	2	=
call	58:31	58:66	2	av_log2
arg	58:39	58:66	3	s->avctx->framerate.num-1
water	58:39	0:0	4	s
op	58:40	0:0	4	->
water	58:42	0:0	4	avctx
op	58:47	0:0	4	->
water	58:49	0:0	4	framerate
op	58:58	0:0	4	.
water	58:59	0:0	4	num
op	58:63	0:0	4	-
water	58:65	0:0	4	1
op	58:68	0:0	2	+
water	58:70	0:0	2	1
water	58:71	0:0	2	;
if	59:4	60:36	2	(ctx -> time_increment_bits < 1)
cond	59:8	59:35	3	ctx -> time_increment_bits < 1
water	59:8	0:0	4	ctx
op	59:11	0:0	4	->
water	59:13	0:0	4	time_increment_bits
op	59:33	0:0	4	<
water	59:35	0:0	4	1
stmts	60:8	60:36	3	
water	60:8	0:0	4	ctx
op	60:11	0:0	4	->
water	60:13	0:0	4	time_increment_bits
op	60:33	0:0	4	=
water	60:35	0:0	4	1
water	60:36	0:0	4	;
call	61:4	61:44	2	check_marker
arg	61:17	61:19	3	gb
water	61:17	0:0	4	gb
arg	61:21	61:44	3	"before fixed_vop_rate"
water	61:21	0:0	4	"before fixed_vop_rate"
water	61:45	0:0	2	;
if	62:4	63:72	2	(get_bits1 (gb ) != 0)
cond	62:8	62:25	3	get_bits1 (gb ) != 0
call	62:8	62:20	4	get_bits1
arg	62:18	62:20	5	gb
water	62:18	0:0	6	gb
op	62:22	0:0	4	!=
water	62:25	0:0	4	0
stmts	63:8	63:72	3	
water	63:8	0:0	4	s
op	63:9	0:0	4	->
water	63:11	0:0	4	avctx
op	63:16	0:0	4	->
water	63:18	0:0	4	framerate
op	63:27	0:0	4	.
water	63:28	0:0	4	den
op	63:32	0:0	4	=
call	63:34	63:71	4	get_bits
arg	63:43	63:45	5	gb
water	63:43	0:0	6	gb
arg	63:47	63:71	5	ctx->time_increment_bits
water	63:47	0:0	6	ctx
op	63:50	0:0	6	->
water	63:52	0:0	6	time_increment_bits
water	63:72	0:0	4	;
else	64:4	65:35	2
stmts	65:8	65:35	3	
water	65:8	0:0	4	s
op	65:9	0:0	4	->
water	65:11	0:0	4	avctx
op	65:16	0:0	4	->
water	65:18	0:0	4	framerate
op	65:27	0:0	4	.
water	65:28	0:0	4	den
op	65:32	0:0	4	=
water	65:34	0:0	4	1
water	65:35	0:0	4	;
water	66:4	0:0	2	s
op	66:5	0:0	2	->
water	66:7	0:0	2	avctx
op	66:12	0:0	2	->
water	66:14	0:0	2	time_base
op	66:24	0:0	2	=
call	66:26	66:108	2	av_inv_q
arg	66:35	66:108	3	av_mul_q(s->avctx->framerate,(AVRational){s->avctx->ticks_per_frame,1})
call	66:35	66:107	4	av_mul_q
arg	66:44	66:63	5	s->avctx->framerate
water	66:44	0:0	6	s
op	66:45	0:0	6	->
water	66:47	0:0	6	avctx
op	66:52	0:0	6	->
water	66:54	0:0	6	framerate
arg	66:65	66:107	5	(AVRational){s->avctx->ticks_per_frame,1}
water	66:65	0:0	6	(
water	66:66	0:0	6	AVRational
water	66:76	0:0	6	)
water	66:77	0:0	6	{
water	66:78	0:0	6	s
op	66:79	0:0	6	->
water	66:81	0:0	6	avctx
op	66:86	0:0	6	->
water	66:88	0:0	6	ticks_per_frame
water	66:103	0:0	6	,
water	66:105	0:0	6	1
water	66:106	0:0	6	}
water	66:109	0:0	2	;
water	67:4	0:0	2	ctx
op	67:7	0:0	2	->
water	67:9	0:0	2	t_frame
op	67:17	0:0	2	=
water	67:19	0:0	2	0
water	67:20	0:0	2	;
if	68:4	294:4	2	(ctx -> shape != BIN_ONLY_SHAPE)
cond	68:8	68:22	3	ctx -> shape != BIN_ONLY_SHAPE
water	68:8	0:0	4	ctx
op	68:11	0:0	4	->
water	68:13	0:0	4	shape
op	68:19	0:0	4	!=
water	68:22	0:0	4	BIN_ONLY_SHAPE
stmts	68:38	294:4	3	
water	68:38	0:0	4	{
if	69:8	83:8	4	(ctx -> shape == RECT_SHAPE)
cond	69:12	69:26	5	ctx -> shape == RECT_SHAPE
water	69:12	0:0	6	ctx
op	69:15	0:0	6	->
water	69:17	0:0	6	shape
op	69:23	0:0	6	==
water	69:26	0:0	6	RECT_SHAPE
stmts	69:38	83:8	5	
water	69:38	0:0	6	{
call	70:12	70:43	6	check_marker
arg	70:25	70:27	7	gb
water	70:25	0:0	8	gb
arg	70:29	70:43	7	"before width"
water	70:29	0:0	8	"before width"
water	70:44	0:0	6	;
water	71:12	0:0	6	width
op	71:18	0:0	6	=
call	71:20	71:35	6	get_bits
arg	71:29	71:31	7	gb
water	71:29	0:0	8	gb
arg	71:33	71:35	7	13
water	71:33	0:0	8	13
water	71:36	0:0	6	;
call	72:12	72:44	6	check_marker
arg	72:25	72:27	7	gb
water	72:25	0:0	8	gb
arg	72:29	72:44	7	"before height"
water	72:29	0:0	8	"before height"
water	72:45	0:0	6	;
water	73:12	0:0	6	height
op	73:19	0:0	6	=
call	73:21	73:36	6	get_bits
arg	73:30	73:32	7	gb
water	73:30	0:0	8	gb
arg	73:34	73:36	7	13
water	73:34	0:0	8	13
water	73:37	0:0	6	;
call	74:12	74:43	6	check_marker
arg	74:25	74:27	7	gb
water	74:25	0:0	8	gb
arg	74:29	74:43	7	"after height"
water	74:29	0:0	8	"after height"
water	74:44	0:0	6	;
if	75:12	82:12	6	(width && height && ! ( s -> width && s -> codec_tag ==AV_RL32 ("MP4S" ) ))
cond	75:16	76:61	7	width && height && ! ( s -> width && s -> codec_tag ==AV_RL32 ("MP4S" ) )
water	75:16	0:0	8	width
op	75:22	0:0	8	&&
water	75:25	0:0	8	height
op	75:32	0:0	8	&&
op	76:16	0:0	8	!
water	76:17	0:0	8	(
water	76:18	0:0	8	s
op	76:19	0:0	8	->
water	76:21	0:0	8	width
op	76:27	0:0	8	&&
water	76:30	0:0	8	s
op	76:31	0:0	8	->
water	76:33	0:0	8	codec_tag
op	76:43	0:0	8	==
call	76:46	76:60	8	AV_RL32
arg	76:54	76:60	9	"MP4S"
water	76:54	0:0	10	"MP4S"
water	76:61	0:0	8	)
stmts	76:64	82:12	7	
water	76:64	0:0	8	{
if	77:16	79:41	8	(s -> width && s -> height && ( s -> width != width || s -> height != height ))
cond	77:20	78:61	9	s -> width && s -> height && ( s -> width != width || s -> height != height )
water	77:20	0:0	10	s
op	77:21	0:0	10	->
water	77:23	0:0	10	width
op	77:29	0:0	10	&&
water	77:32	0:0	10	s
op	77:33	0:0	10	->
water	77:35	0:0	10	height
op	77:42	0:0	10	&&
water	78:20	0:0	10	(
water	78:21	0:0	10	s
op	78:22	0:0	10	->
water	78:24	0:0	10	width
op	78:30	0:0	10	!=
water	78:33	0:0	10	width
op	78:39	0:0	10	||
water	78:42	0:0	10	s
op	78:43	0:0	10	->
water	78:45	0:0	10	height
op	78:52	0:0	10	!=
water	78:55	0:0	10	height
water	78:61	0:0	10	)
stmts	79:20	79:41	9	
water	79:20	0:0	10	s
op	79:21	0:0	10	->
water	79:23	0:0	10	context_reinit
op	79:38	0:0	10	=
water	79:40	0:0	10	1
water	79:41	0:0	10	;
water	80:16	0:0	8	s
op	80:17	0:0	8	->
water	80:19	0:0	8	width
op	80:26	0:0	8	=
water	80:28	0:0	8	width
water	80:33	0:0	8	;
water	81:16	0:0	8	s
op	81:17	0:0	8	->
water	81:19	0:0	8	height
op	81:26	0:0	8	=
water	81:28	0:0	8	height
water	81:34	0:0	8	;
water	82:12	0:0	8	}
water	83:8	0:0	6	}
water	84:8	0:0	4	s
op	84:9	0:0	4	->
water	84:11	0:0	4	progressive_sequence
op	84:33	0:0	4	=
water	85:8	0:0	4	s
op	85:9	0:0	4	->
water	85:11	0:0	4	progressive_frame
op	85:33	0:0	4	=
call	85:35	85:47	4	get_bits1
arg	85:45	85:47	5	gb
water	85:45	0:0	6	gb
op	85:49	0:0	4	^
water	85:51	0:0	4	1
water	85:52	0:0	4	;
water	86:8	0:0	4	s
op	86:9	0:0	4	->
water	86:11	0:0	4	interlaced_dct
op	86:33	0:0	4	=
water	86:35	0:0	4	0
water	86:36	0:0	4	;
if	87:8	89:76	4	(!get_bits1 (gb ) && ( s -> avctx -> debug & FF_DEBUG_PICT_INFO ))
cond	87:12	87:67	5	!get_bits1 (gb ) && ( s -> avctx -> debug & FF_DEBUG_PICT_INFO )
op	87:12	0:0	6	!
call	87:13	87:25	6	get_bits1
arg	87:23	87:25	7	gb
water	87:23	0:0	8	gb
op	87:27	0:0	6	&&
water	87:30	0:0	6	(
water	87:31	0:0	6	s
op	87:32	0:0	6	->
water	87:34	0:0	6	avctx
op	87:39	0:0	6	->
water	87:41	0:0	6	debug
op	87:47	0:0	6	&
water	87:49	0:0	6	FF_DEBUG_PICT_INFO
water	87:67	0:0	6	)
stmts	88:12	89:76	5	
call	88:12	89:75	6	av_log
arg	88:19	88:27	7	s->avctx
water	88:19	0:0	8	s
op	88:20	0:0	8	->
water	88:22	0:0	8	avctx
arg	88:29	88:40	7	AV_LOG_INFO
water	88:29	0:0	8	AV_LOG_INFO
arg	89:19	89:75	7	"MPEG4 OBMC not supported (very likely buggy encoder)\n"
water	89:19	0:0	8	"MPEG4 OBMC not supported (very likely buggy encoder)\n"
water	89:76	0:0	6	;
if	90:8	91:49	4	(vo_ver_id == 1)
cond	90:12	90:25	5	vo_ver_id == 1
water	90:12	0:0	6	vo_ver_id
op	90:22	0:0	6	==
water	90:25	0:0	6	1
stmts	91:12	91:49	5	
water	91:12	0:0	6	ctx
op	91:15	0:0	6	->
water	91:17	0:0	6	vol_sprite_usage
op	91:34	0:0	6	=
call	91:36	91:48	6	get_bits1
arg	91:46	91:48	7	gb
water	91:46	0:0	8	gb
water	91:49	0:0	6	;
else	92:8	93:51	4
stmts	93:12	93:51	5	
water	93:12	0:0	6	ctx
op	93:15	0:0	6	->
water	93:17	0:0	6	vol_sprite_usage
op	93:34	0:0	6	=
call	93:36	93:50	6	get_bits
arg	93:45	93:47	7	gb
water	93:45	0:0	8	gb
arg	93:49	93:50	7	2
water	93:49	0:0	8	2
water	93:51	0:0	6	;
if	94:8	95:76	4	(ctx -> vol_sprite_usage == STATIC_SPRITE)
cond	94:12	94:37	5	ctx -> vol_sprite_usage == STATIC_SPRITE
water	94:12	0:0	6	ctx
op	94:15	0:0	6	->
water	94:17	0:0	6	vol_sprite_usage
op	94:34	0:0	6	==
water	94:37	0:0	6	STATIC_SPRITE
stmts	95:12	95:76	5	
call	95:12	95:75	6	av_log
arg	95:19	95:27	7	s->avctx
water	95:19	0:0	8	s
op	95:20	0:0	8	->
water	95:22	0:0	8	avctx
arg	95:29	95:41	7	AV_LOG_ERROR
water	95:29	0:0	8	AV_LOG_ERROR
arg	95:43	95:75	7	"Static Sprites not supported\n"
water	95:43	0:0	8	"Static Sprites not supported\n"
water	95:76	0:0	6	;
if	96:8	120:8	4	(ctx -> vol_sprite_usage == STATIC_SPRITE || ctx -> vol_sprite_usage == GMC_SPRITE)
cond	96:12	97:37	5	ctx -> vol_sprite_usage == STATIC_SPRITE || ctx -> vol_sprite_usage == GMC_SPRITE
water	96:12	0:0	6	ctx
op	96:15	0:0	6	->
water	96:17	0:0	6	vol_sprite_usage
op	96:34	0:0	6	==
water	96:37	0:0	6	STATIC_SPRITE
op	96:51	0:0	6	||
water	97:12	0:0	6	ctx
op	97:15	0:0	6	->
water	97:17	0:0	6	vol_sprite_usage
op	97:34	0:0	6	==
water	97:37	0:0	6	GMC_SPRITE
stmts	97:49	120:8	5	
water	97:49	0:0	6	{
if	98:12	107:12	6	(ctx -> vol_sprite_usage == STATIC_SPRITE)
cond	98:16	98:41	7	ctx -> vol_sprite_usage == STATIC_SPRITE
water	98:16	0:0	8	ctx
op	98:19	0:0	8	->
water	98:21	0:0	8	vol_sprite_usage
op	98:38	0:0	8	==
water	98:41	0:0	8	STATIC_SPRITE
stmts	98:56	107:12	7	
water	98:56	0:0	8	{
call	99:16	99:32	8	skip_bits
arg	99:26	99:28	9	gb
water	99:26	0:0	10	gb
arg	99:30	99:32	9	13
water	99:30	0:0	10	13
water	99:33	0:0	8	;
call	100:16	100:53	8	check_marker
arg	100:29	100:31	9	gb
water	100:29	0:0	10	gb
arg	100:33	100:53	9	"after sprite_width"
water	100:33	0:0	10	"after sprite_width"
water	100:54	0:0	8	;
call	101:16	101:32	8	skip_bits
arg	101:26	101:28	9	gb
water	101:26	0:0	10	gb
arg	101:30	101:32	9	13
water	101:30	0:0	10	13
water	101:33	0:0	8	;
call	102:16	102:54	8	check_marker
arg	102:29	102:31	9	gb
water	102:29	0:0	10	gb
arg	102:33	102:54	9	"after sprite_height"
water	102:33	0:0	10	"after sprite_height"
water	102:55	0:0	8	;
call	103:16	103:32	8	skip_bits
arg	103:26	103:28	9	gb
water	103:26	0:0	10	gb
arg	103:30	103:32	9	13
water	103:30	0:0	10	13
water	103:33	0:0	8	;
call	104:16	104:52	8	check_marker
arg	104:29	104:31	9	gb
water	104:29	0:0	10	gb
arg	104:33	104:52	9	"after sprite_left"
water	104:33	0:0	10	"after sprite_left"
water	104:53	0:0	8	;
call	105:16	105:32	8	skip_bits
arg	105:26	105:28	9	gb
water	105:26	0:0	10	gb
arg	105:30	105:32	9	13
water	105:30	0:0	10	13
water	105:33	0:0	8	;
call	106:16	106:51	8	check_marker
arg	106:29	106:31	9	gb
water	106:29	0:0	10	gb
arg	106:33	106:51	9	"after sprite_top"
water	106:33	0:0	10	"after sprite_top"
water	106:52	0:0	8	;
water	107:12	0:0	8	}
water	108:12	0:0	6	ctx
op	108:15	0:0	6	->
water	108:17	0:0	6	num_sprite_warping_points
op	108:43	0:0	6	=
call	108:45	108:59	6	get_bits
arg	108:54	108:56	7	gb
water	108:54	0:0	8	gb
arg	108:58	108:59	7	6
water	108:58	0:0	8	6
water	108:60	0:0	6	;
if	109:12	115:12	6	(ctx -> num_sprite_warping_points > 3)
cond	109:16	109:49	7	ctx -> num_sprite_warping_points > 3
water	109:16	0:0	8	ctx
op	109:19	0:0	8	->
water	109:21	0:0	8	num_sprite_warping_points
op	109:47	0:0	8	>
water	109:49	0:0	8	3
stmts	109:52	115:12	7	
water	109:52	0:0	8	{
call	110:16	112:53	8	av_log
arg	110:23	110:31	9	s->avctx
water	110:23	0:0	10	s
op	110:24	0:0	10	->
water	110:26	0:0	10	avctx
arg	110:33	110:45	9	AV_LOG_ERROR
water	110:33	0:0	10	AV_LOG_ERROR
arg	111:23	111:51	9	"%d sprite_warping_points\n"
water	111:23	0:0	10	"%d sprite_warping_points\n"
arg	112:23	112:53	9	ctx->num_sprite_warping_points
water	112:23	0:0	10	ctx
op	112:26	0:0	10	->
water	112:28	0:0	10	num_sprite_warping_points
water	112:54	0:0	8	;
water	113:16	0:0	8	ctx
op	113:19	0:0	8	->
water	113:21	0:0	8	num_sprite_warping_points
op	113:47	0:0	8	=
water	113:49	0:0	8	0
water	113:50	0:0	8	;
return	114:16	114:42	8	AVERROR_INVALIDDATA
water	114:23	0:0	9	AVERROR_INVALIDDATA
water	115:12	0:0	8	}
water	116:12	0:0	6	s
op	116:13	0:0	6	->
water	116:15	0:0	6	sprite_warping_accuracy
op	116:40	0:0	6	=
call	116:42	116:56	6	get_bits
arg	116:51	116:53	7	gb
water	116:51	0:0	8	gb
arg	116:55	116:56	7	2
water	116:55	0:0	8	2
water	116:57	0:0	6	;
water	117:12	0:0	6	ctx
op	117:15	0:0	6	->
water	117:17	0:0	6	sprite_brightness_change
op	117:42	0:0	6	=
call	117:44	117:56	6	get_bits1
arg	117:54	117:56	7	gb
water	117:54	0:0	8	gb
water	117:57	0:0	6	;
if	118:12	119:30	6	(ctx -> vol_sprite_usage == STATIC_SPRITE)
cond	118:16	118:41	7	ctx -> vol_sprite_usage == STATIC_SPRITE
water	118:16	0:0	8	ctx
op	118:19	0:0	8	->
water	118:21	0:0	8	vol_sprite_usage
op	118:38	0:0	8	==
water	118:41	0:0	8	STATIC_SPRITE
stmts	119:16	119:30	7	
call	119:16	119:29	8	skip_bits1
arg	119:27	119:29	9	gb
water	119:27	0:0	10	gb
water	119:30	0:0	8	;
water	120:8	0:0	6	}
if	122:8	132:8	4	(get_bits1 (gb ) == 1)
cond	122:12	122:29	5	get_bits1 (gb ) == 1
call	122:12	122:24	6	get_bits1
arg	122:22	122:24	7	gb
water	122:22	0:0	8	gb
op	122:26	0:0	6	==
water	122:29	0:0	6	1
stmts	122:32	132:8	5	
water	122:32	0:0	6	{
water	123:12	0:0	6	s
op	123:13	0:0	6	->
water	123:15	0:0	6	quant_precision
op	123:31	0:0	6	=
call	123:33	123:47	6	get_bits
arg	123:42	123:44	7	gb
water	123:42	0:0	8	gb
arg	123:46	123:47	7	4
water	123:46	0:0	8	4
water	123:48	0:0	6	;
if	124:12	125:71	6	(get_bits (gb ,4 ) != 8)
cond	124:16	124:35	7	get_bits (gb ,4 ) != 8
call	124:16	124:30	8	get_bits
arg	124:25	124:27	9	gb
water	124:25	0:0	10	gb
arg	124:29	124:30	9	4
water	124:29	0:0	10	4
op	124:32	0:0	8	!=
water	124:35	0:0	8	8
stmts	125:16	125:71	7	
call	125:16	125:70	8	av_log
arg	125:23	125:31	9	s->avctx
water	125:23	0:0	10	s
op	125:24	0:0	10	->
water	125:26	0:0	10	avctx
arg	125:33	125:45	9	AV_LOG_ERROR
water	125:33	0:0	10	AV_LOG_ERROR
arg	125:47	125:70	9	"N-bit not supported\n"
water	125:47	0:0	10	"N-bit not supported\n"
water	125:71	0:0	8	;
if	126:12	128:66	6	(s -> quant_precision != 5)
cond	126:16	126:38	7	s -> quant_precision != 5
water	126:16	0:0	8	s
op	126:17	0:0	8	->
water	126:19	0:0	8	quant_precision
op	126:35	0:0	8	!=
water	126:38	0:0	8	5
stmts	127:16	128:66	7	
call	127:16	128:65	8	av_log
arg	127:23	127:31	9	s->avctx
water	127:23	0:0	10	s
op	127:24	0:0	10	->
water	127:26	0:0	10	avctx
arg	127:33	127:45	9	AV_LOG_ERROR
water	127:33	0:0	10	AV_LOG_ERROR
arg	128:23	128:45	9	"quant precision %d\n"
water	128:23	0:0	10	"quant precision %d\n"
arg	128:47	128:65	9	s->quant_precision
water	128:47	0:0	10	s
op	128:48	0:0	10	->
water	128:50	0:0	10	quant_precision
water	128:66	0:0	8	;
if	129:12	131:12	6	(s -> quant_precision < 3 || s -> quant_precision > 9)
cond	129:16	129:59	7	s -> quant_precision < 3 || s -> quant_precision > 9
water	129:16	0:0	8	s
op	129:17	0:0	8	->
water	129:19	0:0	8	quant_precision
op	129:34	0:0	8	<
water	129:35	0:0	8	3
op	129:37	0:0	8	||
water	129:40	0:0	8	s
op	129:41	0:0	8	->
water	129:43	0:0	8	quant_precision
op	129:58	0:0	8	>
water	129:59	0:0	8	9
stmts	129:62	131:12	7	
water	129:62	0:0	8	{
water	130:16	0:0	8	s
op	130:17	0:0	8	->
water	130:19	0:0	8	quant_precision
op	130:35	0:0	8	=
water	130:37	0:0	8	5
water	130:38	0:0	8	;
water	131:12	0:0	8	}
water	132:8	0:0	6	}
else	132:10	134:8	4
stmts	132:15	134:8	5	
water	132:15	0:0	6	{
water	133:12	0:0	6	s
op	133:13	0:0	6	->
water	133:15	0:0	6	quant_precision
op	133:31	0:0	6	=
water	133:33	0:0	6	5
water	133:34	0:0	6	;
water	134:8	0:0	6	}
if	136:8	189:8	4	(( s -> mpeg_quant =get_bits1 (gb ) ))
cond	136:12	136:42	5	( s -> mpeg_quant =get_bits1 (gb ) )
water	136:12	0:0	6	(
water	136:13	0:0	6	s
op	136:14	0:0	6	->
water	136:16	0:0	6	mpeg_quant
op	136:27	0:0	6	=
call	136:29	136:41	6	get_bits1
arg	136:39	136:41	7	gb
water	136:39	0:0	8	gb
water	136:42	0:0	6	)
stmts	136:45	189:8	5	
water	136:45	0:0	6	{
decl	137:12	137:20	6	int	i
water	137:17	0:0	6	,
decl	137:12	137:20	6	int	v
for	139:12	147:12	6	(i = 0 ;i < 64;i ++)
forinit	139:17	139:22	7	i = 0 ;
water	139:17	0:0	8	i
op	139:19	0:0	8	=
water	139:21	0:0	8	0
water	139:22	0:0	8	;
cond	139:24	139:28	7	i < 64
water	139:24	0:0	8	i
op	139:26	0:0	8	<
water	139:28	0:0	8	64
forexpr	139:32	139:33	7	i ++
water	139:32	0:0	8	i
op	139:33	0:0	8	++
stmts	139:37	147:12	7	
water	139:37	0:0	8	{
decl	140:16	140:51	8	int	j
op	140:22	0:0	8	=
water	140:24	0:0	8	s
op	140:25	0:0	8	->
water	140:27	0:0	8	idsp
op	140:31	0:0	8	.
water	140:32	0:0	8	idct_permutation
op	140:48	0:0	8	[
water	140:49	0:0	8	i
op	140:50	0:0	8	]
water	141:16	0:0	8	v
op	141:18	0:0	8	=
water	141:20	0:0	8	ff_mpeg4_default_intra_matrix
op	141:49	0:0	8	[
water	141:50	0:0	8	i
op	141:51	0:0	8	]
water	141:52	0:0	8	;
water	142:16	0:0	8	s
op	142:17	0:0	8	->
water	142:19	0:0	8	intra_matrix
op	142:31	0:0	8	[
water	142:32	0:0	8	j
op	142:33	0:0	8	]
op	142:42	0:0	8	=
water	142:44	0:0	8	v
water	142:45	0:0	8	;
water	143:16	0:0	8	s
op	143:17	0:0	8	->
water	143:19	0:0	8	chroma_intra_matrix
op	143:38	0:0	8	[
water	143:39	0:0	8	j
op	143:40	0:0	8	]
op	143:42	0:0	8	=
water	143:44	0:0	8	v
water	143:45	0:0	8	;
water	144:16	0:0	8	v
op	144:18	0:0	8	=
water	144:20	0:0	8	ff_mpeg4_default_non_intra_matrix
op	144:53	0:0	8	[
water	144:54	0:0	8	i
op	144:55	0:0	8	]
water	144:56	0:0	8	;
water	145:16	0:0	8	s
op	145:17	0:0	8	->
water	145:19	0:0	8	inter_matrix
op	145:31	0:0	8	[
water	145:32	0:0	8	j
op	145:33	0:0	8	]
op	145:42	0:0	8	=
water	145:44	0:0	8	v
water	145:45	0:0	8	;
water	146:16	0:0	8	s
op	146:17	0:0	8	->
water	146:19	0:0	8	chroma_inter_matrix
op	146:38	0:0	8	[
water	146:39	0:0	8	j
op	146:40	0:0	8	]
op	146:42	0:0	8	=
water	146:44	0:0	8	v
water	146:45	0:0	8	;
water	147:12	0:0	8	}
if	149:12	167:12	6	(get_bits1 (gb ))
cond	149:16	149:28	7	get_bits1 (gb )
call	149:16	149:28	8	get_bits1
arg	149:26	149:28	9	gb
water	149:26	0:0	10	gb
stmts	149:31	167:12	7	
water	149:31	0:0	8	{
decl	150:16	150:28	8	int	last
op	150:25	0:0	8	=
water	150:27	0:0	8	0
for	151:16	160:16	8	(i = 0 ;i < 64;i ++)
forinit	151:21	151:26	9	i = 0 ;
water	151:21	0:0	10	i
op	151:23	0:0	10	=
water	151:25	0:0	10	0
water	151:26	0:0	10	;
cond	151:28	151:32	9	i < 64
water	151:28	0:0	10	i
op	151:30	0:0	10	<
water	151:32	0:0	10	64
forexpr	151:36	151:37	9	i ++
water	151:36	0:0	10	i
op	151:37	0:0	10	++
stmts	151:41	160:16	9	
water	151:41	0:0	10	{
decl	152:20	152:25	10	int	j
water	153:20	0:0	10	v
op	153:22	0:0	10	=
call	153:24	153:38	10	get_bits
arg	153:33	153:35	11	gb
water	153:33	0:0	12	gb
arg	153:37	153:38	11	8
water	153:37	0:0	12	8
water	153:39	0:0	10	;
if	154:20	155:29	10	(v == 0)
cond	154:24	154:29	11	v == 0
water	154:24	0:0	12	v
op	154:26	0:0	12	==
water	154:29	0:0	12	0
stmts	155:24	155:29	11	
break	155:24	155:29	12	
water	156:20	0:0	10	last
op	156:25	0:0	10	=
water	156:27	0:0	10	v
water	156:28	0:0	10	;
water	157:20	0:0	10	j
op	157:22	0:0	10	=
water	157:24	0:0	10	s
op	157:25	0:0	10	->
water	157:27	0:0	10	idsp
op	157:31	0:0	10	.
water	157:32	0:0	10	idct_permutation
op	157:48	0:0	10	[
water	157:49	0:0	10	ff_zigzag_direct
op	157:65	0:0	10	[
water	157:66	0:0	10	i
op	157:67	0:0	10	]
op	157:68	0:0	10	]
water	157:69	0:0	10	;
water	158:20	0:0	10	s
op	158:21	0:0	10	->
water	158:23	0:0	10	intra_matrix
op	158:35	0:0	10	[
water	158:36	0:0	10	j
op	158:37	0:0	10	]
op	158:46	0:0	10	=
water	158:48	0:0	10	last
water	158:52	0:0	10	;
water	159:20	0:0	10	s
op	159:21	0:0	10	->
water	159:23	0:0	10	chroma_intra_matrix
op	159:42	0:0	10	[
water	159:43	0:0	10	j
op	159:44	0:0	10	]
op	159:46	0:0	10	=
water	159:48	0:0	10	last
water	159:52	0:0	10	;
water	160:16	0:0	10	}
for	162:16	166:16	8	(;i < 64;i ++)
forinit	162:21	162:21	9	;
water	162:21	0:0	10	;
cond	162:23	162:27	9	i < 64
water	162:23	0:0	10	i
op	162:25	0:0	10	<
water	162:27	0:0	10	64
forexpr	162:31	162:32	9	i ++
water	162:31	0:0	10	i
op	162:32	0:0	10	++
stmts	162:36	166:16	9	
water	162:36	0:0	10	{
decl	163:20	163:73	10	int	j
op	163:26	0:0	10	=
water	163:28	0:0	10	s
op	163:29	0:0	10	->
water	163:31	0:0	10	idsp
op	163:35	0:0	10	.
water	163:36	0:0	10	idct_permutation
op	163:52	0:0	10	[
water	163:53	0:0	10	ff_zigzag_direct
op	163:69	0:0	10	[
water	163:70	0:0	10	i
op	163:71	0:0	10	]
op	163:72	0:0	10	]
water	164:20	0:0	10	s
op	164:21	0:0	10	->
water	164:23	0:0	10	intra_matrix
op	164:35	0:0	10	[
water	164:36	0:0	10	j
op	164:37	0:0	10	]
op	164:46	0:0	10	=
water	164:48	0:0	10	last
water	164:52	0:0	10	;
water	165:20	0:0	10	s
op	165:21	0:0	10	->
water	165:23	0:0	10	chroma_intra_matrix
op	165:42	0:0	10	[
water	165:43	0:0	10	j
op	165:44	0:0	10	]
op	165:46	0:0	10	=
water	165:48	0:0	10	last
water	165:52	0:0	10	;
water	166:16	0:0	10	}
water	167:12	0:0	8	}
if	169:12	187:12	6	(get_bits1 (gb ))
cond	169:16	169:28	7	get_bits1 (gb )
call	169:16	169:28	8	get_bits1
arg	169:26	169:28	9	gb
water	169:26	0:0	10	gb
stmts	169:31	187:12	7	
water	169:31	0:0	8	{
decl	170:16	170:28	8	int	last
op	170:25	0:0	8	=
water	170:27	0:0	8	0
for	171:16	180:16	8	(i = 0 ;i < 64;i ++)
forinit	171:21	171:26	9	i = 0 ;
water	171:21	0:0	10	i
op	171:23	0:0	10	=
water	171:25	0:0	10	0
water	171:26	0:0	10	;
cond	171:28	171:32	9	i < 64
water	171:28	0:0	10	i
op	171:30	0:0	10	<
water	171:32	0:0	10	64
forexpr	171:36	171:37	9	i ++
water	171:36	0:0	10	i
op	171:37	0:0	10	++
stmts	171:41	180:16	9	
water	171:41	0:0	10	{
decl	172:20	172:25	10	int	j
water	173:20	0:0	10	v
op	173:22	0:0	10	=
call	173:24	173:38	10	get_bits
arg	173:33	173:35	11	gb
water	173:33	0:0	12	gb
arg	173:37	173:38	11	8
water	173:37	0:0	12	8
water	173:39	0:0	10	;
if	174:20	175:29	10	(v == 0)
cond	174:24	174:29	11	v == 0
water	174:24	0:0	12	v
op	174:26	0:0	12	==
water	174:29	0:0	12	0
stmts	175:24	175:29	11	
break	175:24	175:29	12	
water	176:20	0:0	10	last
op	176:25	0:0	10	=
water	176:27	0:0	10	v
water	176:28	0:0	10	;
water	177:20	0:0	10	j
op	177:22	0:0	10	=
water	177:24	0:0	10	s
op	177:25	0:0	10	->
water	177:27	0:0	10	idsp
op	177:31	0:0	10	.
water	177:32	0:0	10	idct_permutation
op	177:48	0:0	10	[
water	177:49	0:0	10	ff_zigzag_direct
op	177:65	0:0	10	[
water	177:66	0:0	10	i
op	177:67	0:0	10	]
op	177:68	0:0	10	]
water	177:69	0:0	10	;
water	178:20	0:0	10	s
op	178:21	0:0	10	->
water	178:23	0:0	10	inter_matrix
op	178:35	0:0	10	[
water	178:36	0:0	10	j
op	178:37	0:0	10	]
op	178:46	0:0	10	=
water	178:48	0:0	10	v
water	178:49	0:0	10	;
water	179:20	0:0	10	s
op	179:21	0:0	10	->
water	179:23	0:0	10	chroma_inter_matrix
op	179:42	0:0	10	[
water	179:43	0:0	10	j
op	179:44	0:0	10	]
op	179:46	0:0	10	=
water	179:48	0:0	10	v
water	179:49	0:0	10	;
water	180:16	0:0	10	}
for	182:16	186:16	8	(;i < 64;i ++)
forinit	182:21	182:21	9	;
water	182:21	0:0	10	;
cond	182:23	182:27	9	i < 64
water	182:23	0:0	10	i
op	182:25	0:0	10	<
water	182:27	0:0	10	64
forexpr	182:31	182:32	9	i ++
water	182:31	0:0	10	i
op	182:32	0:0	10	++
stmts	182:36	186:16	9	
water	182:36	0:0	10	{
decl	183:20	183:73	10	int	j
op	183:26	0:0	10	=
water	183:28	0:0	10	s
op	183:29	0:0	10	->
water	183:31	0:0	10	idsp
op	183:35	0:0	10	.
water	183:36	0:0	10	idct_permutation
op	183:52	0:0	10	[
water	183:53	0:0	10	ff_zigzag_direct
op	183:69	0:0	10	[
water	183:70	0:0	10	i
op	183:71	0:0	10	]
op	183:72	0:0	10	]
water	184:20	0:0	10	s
op	184:21	0:0	10	->
water	184:23	0:0	10	inter_matrix
op	184:35	0:0	10	[
water	184:36	0:0	10	j
op	184:37	0:0	10	]
op	184:46	0:0	10	=
water	184:48	0:0	10	last
water	184:52	0:0	10	;
water	185:20	0:0	10	s
op	185:21	0:0	10	->
water	185:23	0:0	10	chroma_inter_matrix
op	185:42	0:0	10	[
water	185:43	0:0	10	j
op	185:44	0:0	10	]
op	185:46	0:0	10	=
water	185:48	0:0	10	last
water	185:52	0:0	10	;
water	186:16	0:0	10	}
water	187:12	0:0	8	}
water	189:8	0:0	6	}
if	190:8	191:45	4	(vo_ver_id != 1)
cond	190:12	190:25	5	vo_ver_id != 1
water	190:12	0:0	6	vo_ver_id
op	190:22	0:0	6	!=
water	190:25	0:0	6	1
stmts	191:12	191:45	5	
water	191:12	0:0	6	s
op	191:13	0:0	6	->
water	191:15	0:0	6	quarter_sample
op	191:30	0:0	6	=
call	191:32	191:44	6	get_bits1
arg	191:42	191:44	7	gb
water	191:42	0:0	8	gb
water	191:45	0:0	6	;
else	192:8	193:33	4
stmts	193:12	193:33	5	
water	193:12	0:0	6	s
op	193:13	0:0	6	->
water	193:15	0:0	6	quarter_sample
op	193:30	0:0	6	=
water	193:32	0:0	6	0
water	193:33	0:0	6	;
if	194:8	197:8	4	(get_bits_left (gb ) < 4)
cond	194:12	194:32	5	get_bits_left (gb ) < 4
call	194:12	194:28	6	get_bits_left
arg	194:26	194:28	7	gb
water	194:26	0:0	8	gb
op	194:30	0:0	6	<
water	194:32	0:0	6	4
stmts	194:35	197:8	5	
water	194:35	0:0	6	{
call	195:12	195:67	6	av_log
arg	195:19	195:27	7	s->avctx
water	195:19	0:0	8	s
op	195:20	0:0	8	->
water	195:22	0:0	8	avctx
arg	195:29	195:41	7	AV_LOG_ERROR
water	195:29	0:0	8	AV_LOG_ERROR
arg	195:43	195:67	7	"VOL Header truncated\n"
water	195:43	0:0	8	"VOL Header truncated\n"
water	195:68	0:0	6	;
return	196:12	196:38	6	AVERROR_INVALIDDATA
water	196:19	0:0	7	AVERROR_INVALIDDATA
water	197:8	0:0	6	}
if	198:8	246:8	4	(!get_bits1 (gb ))
cond	198:12	198:25	5	!get_bits1 (gb )
op	198:12	0:0	6	!
call	198:13	198:25	6	get_bits1
arg	198:23	198:25	7	gb
water	198:23	0:0	8	gb
stmts	198:28	246:8	5	
water	198:28	0:0	6	{
decl	199:12	199:54	6	int	pos
op	199:34	0:0	6	=
call	199:36	199:53	7	get_bits_count
arg	199:51	199:53	8	gb
water	199:51	0:0	9	gb
decl	200:12	200:51	6	int	estimation_method
op	200:34	0:0	6	=
call	200:36	200:50	7	get_bits
arg	200:45	200:47	8	gb
water	200:45	0:0	9	gb
arg	200:49	200:50	8	2
water	200:49	0:0	9	2
if	201:12	242:12	6	(estimation_method < 2)
cond	201:16	201:36	7	estimation_method < 2
water	201:16	0:0	8	estimation_method
op	201:34	0:0	8	<
water	201:36	0:0	8	2
stmts	201:39	242:12	7	
water	201:39	0:0	8	{
if	202:16	209:16	8	(!get_bits1 (gb ))
cond	202:20	202:33	9	!get_bits1 (gb )
op	202:20	0:0	10	!
call	202:21	202:33	10	get_bits1
arg	202:31	202:33	11	gb
water	202:31	0:0	12	gb
stmts	202:36	209:16	9	
water	202:36	0:0	10	{
water	203:20	0:0	10	ctx
op	203:23	0:0	10	->
water	203:25	0:0	10	cplx_estimation_trash_i
op	203:49	0:0	10	+=
water	203:52	0:0	10	8
call	203:54	203:68	10	*get_bits1
arg	203:66	203:68	11	gb
water	203:66	0:0	12	gb
water	203:69	0:0	10	;
water	204:20	0:0	10	ctx
op	204:23	0:0	10	->
water	204:25	0:0	10	cplx_estimation_trash_i
op	204:49	0:0	10	+=
water	204:52	0:0	10	8
call	204:54	204:68	10	*get_bits1
arg	204:66	204:68	11	gb
water	204:66	0:0	12	gb
water	204:69	0:0	10	;
water	205:20	0:0	10	ctx
op	205:23	0:0	10	->
water	205:25	0:0	10	cplx_estimation_trash_i
op	205:49	0:0	10	+=
water	205:52	0:0	10	8
call	205:54	205:68	10	*get_bits1
arg	205:66	205:68	11	gb
water	205:66	0:0	12	gb
water	205:69	0:0	10	;
water	206:20	0:0	10	ctx
op	206:23	0:0	10	->
water	206:25	0:0	10	cplx_estimation_trash_i
op	206:49	0:0	10	+=
water	206:52	0:0	10	8
call	206:54	206:68	10	*get_bits1
arg	206:66	206:68	11	gb
water	206:66	0:0	12	gb
water	206:69	0:0	10	;
water	207:20	0:0	10	ctx
op	207:23	0:0	10	->
water	207:25	0:0	10	cplx_estimation_trash_i
op	207:49	0:0	10	+=
water	207:52	0:0	10	8
call	207:54	207:68	10	*get_bits1
arg	207:66	207:68	11	gb
water	207:66	0:0	12	gb
water	207:69	0:0	10	;
water	208:20	0:0	10	ctx
op	208:23	0:0	10	->
water	208:25	0:0	10	cplx_estimation_trash_i
op	208:49	0:0	10	+=
water	208:52	0:0	10	8
call	208:54	208:68	10	*get_bits1
arg	208:66	208:68	11	gb
water	208:66	0:0	12	gb
water	208:69	0:0	10	;
water	209:16	0:0	10	}
if	210:16	215:16	8	(!get_bits1 (gb ))
cond	210:20	210:33	9	!get_bits1 (gb )
op	210:20	0:0	10	!
call	210:21	210:33	10	get_bits1
arg	210:31	210:33	11	gb
water	210:31	0:0	12	gb
stmts	210:36	215:16	9	
water	210:36	0:0	10	{
water	211:20	0:0	10	ctx
op	211:23	0:0	10	->
water	211:25	0:0	10	cplx_estimation_trash_i
op	211:49	0:0	10	+=
water	211:52	0:0	10	8
call	211:54	211:68	10	*get_bits1
arg	211:66	211:68	11	gb
water	211:66	0:0	12	gb
water	211:69	0:0	10	;
water	212:20	0:0	10	ctx
op	212:23	0:0	10	->
water	212:25	0:0	10	cplx_estimation_trash_p
op	212:49	0:0	10	+=
water	212:52	0:0	10	8
call	212:54	212:68	10	*get_bits1
arg	212:66	212:68	11	gb
water	212:66	0:0	12	gb
water	212:69	0:0	10	;
water	213:20	0:0	10	ctx
op	213:23	0:0	10	->
water	213:25	0:0	10	cplx_estimation_trash_p
op	213:49	0:0	10	+=
water	213:52	0:0	10	8
call	213:54	213:68	10	*get_bits1
arg	213:66	213:68	11	gb
water	213:66	0:0	12	gb
water	213:69	0:0	10	;
water	214:20	0:0	10	ctx
op	214:23	0:0	10	->
water	214:25	0:0	10	cplx_estimation_trash_i
op	214:49	0:0	10	+=
water	214:52	0:0	10	8
call	214:54	214:68	10	*get_bits1
arg	214:66	214:68	11	gb
water	214:66	0:0	12	gb
water	214:69	0:0	10	;
water	215:16	0:0	10	}
if	216:16	219:16	8	(!check_marker (gb ,"in complexity estimation part 1" ))
cond	216:20	216:71	9	!check_marker (gb ,"in complexity estimation part 1" )
op	216:20	0:0	10	!
call	216:21	216:71	10	check_marker
arg	216:34	216:36	11	gb
water	216:34	0:0	12	gb
arg	216:38	216:71	11	"in complexity estimation part 1"
water	216:38	0:0	12	"in complexity estimation part 1"
stmts	216:74	219:16	9	
water	216:74	0:0	10	{
call	217:20	217:63	10	skip_bits_long
arg	217:35	217:37	11	gb
water	217:35	0:0	12	gb
arg	217:39	217:63	11	pos-get_bits_count(gb)
water	217:39	0:0	12	pos
op	217:43	0:0	12	-
call	217:45	217:62	12	get_bits_count
arg	217:60	217:62	13	gb
water	217:60	0:0	14	gb
water	217:64	0:0	10	;
goto	218:20	218:36	10	no_cplx_est
water	218:25	0:0	11	no_cplx_est
water	219:16	0:0	10	}
if	220:16	225:16	8	(!get_bits1 (gb ))
cond	220:20	220:33	9	!get_bits1 (gb )
op	220:20	0:0	10	!
call	220:21	220:33	10	get_bits1
arg	220:31	220:33	11	gb
water	220:31	0:0	12	gb
stmts	220:36	225:16	9	
water	220:36	0:0	10	{
water	221:20	0:0	10	ctx
op	221:23	0:0	10	->
water	221:25	0:0	10	cplx_estimation_trash_i
op	221:49	0:0	10	+=
water	221:52	0:0	10	8
call	221:54	221:68	10	*get_bits1
arg	221:66	221:68	11	gb
water	221:66	0:0	12	gb
water	221:69	0:0	10	;
water	222:20	0:0	10	ctx
op	222:23	0:0	10	->
water	222:25	0:0	10	cplx_estimation_trash_i
op	222:49	0:0	10	+=
water	222:52	0:0	10	8
call	222:54	222:68	10	*get_bits1
arg	222:66	222:68	11	gb
water	222:66	0:0	12	gb
water	222:69	0:0	10	;
water	223:20	0:0	10	ctx
op	223:23	0:0	10	->
water	223:25	0:0	10	cplx_estimation_trash_i
op	223:49	0:0	10	+=
water	223:52	0:0	10	8
call	223:54	223:68	10	*get_bits1
arg	223:66	223:68	11	gb
water	223:66	0:0	12	gb
water	223:69	0:0	10	;
water	224:20	0:0	10	ctx
op	224:23	0:0	10	->
water	224:25	0:0	10	cplx_estimation_trash_i
op	224:49	0:0	10	+=
water	224:52	0:0	10	4
call	224:54	224:68	10	*get_bits1
arg	224:66	224:68	11	gb
water	224:66	0:0	12	gb
water	224:69	0:0	10	;
water	225:16	0:0	10	}
if	226:16	233:16	8	(!get_bits1 (gb ))
cond	226:20	226:33	9	!get_bits1 (gb )
op	226:20	0:0	10	!
call	226:21	226:33	10	get_bits1
arg	226:31	226:33	11	gb
water	226:31	0:0	12	gb
stmts	226:36	233:16	9	
water	226:36	0:0	10	{
water	227:20	0:0	10	ctx
op	227:23	0:0	10	->
water	227:25	0:0	10	cplx_estimation_trash_p
op	227:49	0:0	10	+=
water	227:52	0:0	10	8
call	227:54	227:68	10	*get_bits1
arg	227:66	227:68	11	gb
water	227:66	0:0	12	gb
water	227:69	0:0	10	;
water	228:20	0:0	10	ctx
op	228:23	0:0	10	->
water	228:25	0:0	10	cplx_estimation_trash_p
op	228:49	0:0	10	+=
water	228:52	0:0	10	8
call	228:54	228:68	10	*get_bits1
arg	228:66	228:68	11	gb
water	228:66	0:0	12	gb
water	228:69	0:0	10	;
water	229:20	0:0	10	ctx
op	229:23	0:0	10	->
water	229:25	0:0	10	cplx_estimation_trash_b
op	229:49	0:0	10	+=
water	229:52	0:0	10	8
call	229:54	229:68	10	*get_bits1
arg	229:66	229:68	11	gb
water	229:66	0:0	12	gb
water	229:69	0:0	10	;
water	230:20	0:0	10	ctx
op	230:23	0:0	10	->
water	230:25	0:0	10	cplx_estimation_trash_p
op	230:49	0:0	10	+=
water	230:52	0:0	10	8
call	230:54	230:68	10	*get_bits1
arg	230:66	230:68	11	gb
water	230:66	0:0	12	gb
water	230:69	0:0	10	;
water	231:20	0:0	10	ctx
op	231:23	0:0	10	->
water	231:25	0:0	10	cplx_estimation_trash_p
op	231:49	0:0	10	+=
water	231:52	0:0	10	8
call	231:54	231:68	10	*get_bits1
arg	231:66	231:68	11	gb
water	231:66	0:0	12	gb
water	231:69	0:0	10	;
water	232:20	0:0	10	ctx
op	232:23	0:0	10	->
water	232:25	0:0	10	cplx_estimation_trash_p
op	232:49	0:0	10	+=
water	232:52	0:0	10	8
call	232:54	232:68	10	*get_bits1
arg	232:66	232:68	11	gb
water	232:66	0:0	12	gb
water	232:69	0:0	10	;
water	233:16	0:0	10	}
if	234:16	237:16	8	(!check_marker (gb ,"in complexity estimation part 2" ))
cond	234:20	234:71	9	!check_marker (gb ,"in complexity estimation part 2" )
op	234:20	0:0	10	!
call	234:21	234:71	10	check_marker
arg	234:34	234:36	11	gb
water	234:34	0:0	12	gb
arg	234:38	234:71	11	"in complexity estimation part 2"
water	234:38	0:0	12	"in complexity estimation part 2"
stmts	234:74	237:16	9	
water	234:74	0:0	10	{
call	235:20	235:63	10	skip_bits_long
arg	235:35	235:37	11	gb
water	235:35	0:0	12	gb
arg	235:39	235:63	11	pos-get_bits_count(gb)
water	235:39	0:0	12	pos
op	235:43	0:0	12	-
call	235:45	235:62	12	get_bits_count
arg	235:60	235:62	13	gb
water	235:60	0:0	14	gb
water	235:64	0:0	10	;
goto	236:20	236:36	10	no_cplx_est
water	236:25	0:0	11	no_cplx_est
water	237:16	0:0	10	}
if	238:16	241:16	8	(estimation_method == 1)
cond	238:20	238:41	9	estimation_method == 1
water	238:20	0:0	10	estimation_method
op	238:38	0:0	10	==
water	238:41	0:0	10	1
stmts	238:44	241:16	9	
water	238:44	0:0	10	{
water	239:20	0:0	10	ctx
op	239:23	0:0	10	->
water	239:25	0:0	10	cplx_estimation_trash_i
op	239:49	0:0	10	+=
water	239:52	0:0	10	8
call	239:54	239:68	10	*get_bits1
arg	239:66	239:68	11	gb
water	239:66	0:0	12	gb
water	239:69	0:0	10	;
water	240:20	0:0	10	ctx
op	240:23	0:0	10	->
water	240:25	0:0	10	cplx_estimation_trash_p
op	240:49	0:0	10	+=
water	240:52	0:0	10	8
call	240:54	240:68	10	*get_bits1
arg	240:66	240:68	11	gb
water	240:66	0:0	12	gb
water	240:69	0:0	10	;
water	241:16	0:0	10	}
water	242:12	0:0	8	}
else	242:14	245:41	6
stmts	243:16	245:41	7	
call	243:16	245:40	8	av_log
arg	243:23	243:31	9	s->avctx
water	243:23	0:0	10	s
op	243:24	0:0	10	->
water	243:26	0:0	10	avctx
arg	243:33	243:45	9	AV_LOG_ERROR
water	243:33	0:0	10	AV_LOG_ERROR
arg	244:23	244:66	9	"Invalid Complexity estimation method %d\n"
water	244:23	0:0	10	"Invalid Complexity estimation method %d\n"
arg	245:23	245:40	9	estimation_method
water	245:23	0:0	10	estimation_method
water	245:41	0:0	8	;
water	246:8	0:0	6	}
else	246:10	251:8	4
stmts	246:15	251:8	5	
water	246:15	0:0	6	{
label	247:0	247:11	6	no_cplx_est :
water	248:12	0:0	6	ctx
op	248:15	0:0	6	->
water	248:17	0:0	6	cplx_estimation_trash_i
op	248:41	0:0	6	=
water	249:12	0:0	6	ctx
op	249:15	0:0	6	->
water	249:17	0:0	6	cplx_estimation_trash_p
op	249:41	0:0	6	=
water	250:12	0:0	6	ctx
op	250:15	0:0	6	->
water	250:17	0:0	6	cplx_estimation_trash_b
op	250:41	0:0	6	=
water	250:43	0:0	6	0
water	250:44	0:0	6	;
water	251:8	0:0	6	}
water	252:8	0:0	4	ctx
op	252:11	0:0	4	->
water	252:13	0:0	4	resync_marker
op	252:27	0:0	4	=
op	252:29	0:0	4	!
call	252:30	252:42	4	get_bits1
arg	252:40	252:42	5	gb
water	252:40	0:0	6	gb
water	252:43	0:0	4	;
water	253:8	0:0	4	s
op	253:9	0:0	4	->
water	253:11	0:0	4	data_partitioning
op	253:29	0:0	4	=
call	253:31	253:43	4	get_bits1
arg	253:41	253:43	5	gb
water	253:41	0:0	6	gb
water	253:44	0:0	4	;
if	254:8	255:37	4	(s -> data_partitioning)
cond	254:12	254:15	5	s -> data_partitioning
water	254:12	0:0	6	s
op	254:13	0:0	6	->
water	254:15	0:0	6	data_partitioning
stmts	255:12	255:37	5	
water	255:12	0:0	6	ctx
op	255:15	0:0	6	->
water	255:17	0:0	6	rvlc
op	255:22	0:0	6	=
call	255:24	255:36	6	get_bits1
arg	255:34	255:36	7	gb
water	255:34	0:0	8	gb
water	255:37	0:0	6	;
if	256:8	266:8	4	(vo_ver_id != 1)
cond	256:12	256:25	5	vo_ver_id != 1
water	256:12	0:0	6	vo_ver_id
op	256:22	0:0	6	!=
water	256:25	0:0	6	1
stmts	256:28	266:8	5	
water	256:28	0:0	6	{
water	257:12	0:0	6	ctx
op	257:15	0:0	6	->
water	257:17	0:0	6	new_pred
op	257:26	0:0	6	=
call	257:28	257:40	6	get_bits1
arg	257:38	257:40	7	gb
water	257:38	0:0	8	gb
water	257:41	0:0	6	;
if	258:12	262:12	6	(ctx -> new_pred)
cond	258:16	258:21	7	ctx -> new_pred
water	258:16	0:0	8	ctx
op	258:19	0:0	8	->
water	258:21	0:0	8	new_pred
stmts	258:31	262:12	7	
water	258:31	0:0	8	{
call	259:16	259:73	8	av_log
arg	259:23	259:31	9	s->avctx
water	259:23	0:0	10	s
op	259:24	0:0	10	->
water	259:26	0:0	10	avctx
arg	259:33	259:45	9	AV_LOG_ERROR
water	259:33	0:0	10	AV_LOG_ERROR
arg	259:47	259:73	9	"new pred not supported\n"
water	259:47	0:0	10	"new pred not supported\n"
water	259:74	0:0	8	;
call	260:16	260:31	8	skip_bits
arg	260:26	260:28	9	gb
water	260:26	0:0	10	gb
arg	260:30	260:31	9	2
water	260:30	0:0	10	2
water	260:32	0:0	8	;
call	261:16	261:29	8	skip_bits1
arg	261:27	261:29	9	gb
water	261:27	0:0	10	gb
water	261:30	0:0	8	;
water	262:12	0:0	8	}
if	263:12	265:64	6	(get_bits1 (gb ))
cond	263:16	263:28	7	get_bits1 (gb )
call	263:16	263:28	8	get_bits1
arg	263:26	263:28	9	gb
water	263:26	0:0	10	gb
stmts	264:16	265:64	7	
call	264:16	265:63	8	av_log
arg	264:23	264:31	9	s->avctx
water	264:23	0:0	10	s
op	264:24	0:0	10	->
water	264:26	0:0	10	avctx
arg	264:33	264:45	9	AV_LOG_ERROR
water	264:33	0:0	10	AV_LOG_ERROR
arg	265:23	265:63	9	"reduced resolution VOP not supported\n"
water	265:23	0:0	10	"reduced resolution VOP not supported\n"
water	265:64	0:0	8	;
water	266:8	0:0	6	}
else	266:10	268:8	4
stmts	266:15	268:8	5	
water	266:15	0:0	6	{
water	267:12	0:0	6	ctx
op	267:15	0:0	6	->
water	267:17	0:0	6	new_pred
op	267:26	0:0	6	=
water	267:28	0:0	6	0
water	267:29	0:0	6	;
water	268:8	0:0	6	}
water	269:8	0:0	4	ctx
op	269:11	0:0	4	->
water	269:13	0:0	4	scalability
op	269:25	0:0	4	=
call	269:27	269:39	4	get_bits1
arg	269:37	269:39	5	gb
water	269:37	0:0	6	gb
water	269:40	0:0	4	;
if	270:8	293:8	4	(ctx -> scalability)
cond	270:12	270:17	5	ctx -> scalability
water	270:12	0:0	6	ctx
op	270:15	0:0	6	->
water	270:17	0:0	6	scalability
stmts	270:30	293:8	5	
water	270:30	0:0	6	{
decl	271:12	271:35	6	GetBitContext	bak
op	271:30	0:0	6	=
op	271:32	0:0	6	*
water	271:33	0:0	6	gb
decl	272:12	272:35	6	int	h_sampling_factor_n
decl	273:12	273:35	6	int	h_sampling_factor_m
decl	274:12	274:35	6	int	v_sampling_factor_n
decl	275:12	275:35	6	int	v_sampling_factor_m
call	276:12	276:25	6	skip_bits1
arg	276:23	276:25	7	gb
water	276:23	0:0	8	gb
water	276:26	0:0	6	;
call	277:12	277:27	6	skip_bits
arg	277:22	277:24	7	gb
water	277:22	0:0	8	gb
arg	277:26	277:27	7	4
water	277:26	0:0	8	4
water	277:28	0:0	6	;
call	278:12	278:25	6	skip_bits1
arg	278:23	278:25	7	gb
water	278:23	0:0	8	gb
water	278:26	0:0	6	;
water	279:12	0:0	6	h_sampling_factor_n
op	279:32	0:0	6	=
call	279:34	279:48	6	get_bits
arg	279:43	279:45	7	gb
water	279:43	0:0	8	gb
arg	279:47	279:48	7	5
water	279:47	0:0	8	5
water	279:49	0:0	6	;
water	280:12	0:0	6	h_sampling_factor_m
op	280:32	0:0	6	=
call	280:34	280:48	6	get_bits
arg	280:43	280:45	7	gb
water	280:43	0:0	8	gb
arg	280:47	280:48	7	5
water	280:47	0:0	8	5
water	280:49	0:0	6	;
water	281:12	0:0	6	v_sampling_factor_n
op	281:32	0:0	6	=
call	281:34	281:48	6	get_bits
arg	281:43	281:45	7	gb
water	281:43	0:0	8	gb
arg	281:47	281:48	7	5
water	281:47	0:0	8	5
water	281:49	0:0	6	;
water	282:12	0:0	6	v_sampling_factor_m
op	282:32	0:0	6	=
call	282:34	282:48	6	get_bits
arg	282:43	282:45	7	gb
water	282:43	0:0	8	gb
arg	282:47	282:48	7	5
water	282:47	0:0	8	5
water	282:49	0:0	6	;
water	283:12	0:0	6	ctx
op	283:15	0:0	6	->
water	283:17	0:0	6	enhancement_type
op	283:34	0:0	6	=
call	283:36	283:48	6	get_bits1
arg	283:46	283:48	7	gb
water	283:46	0:0	8	gb
water	283:49	0:0	6	;
if	284:12	290:12	6	(h_sampling_factor_n == 0 || h_sampling_factor_m == 0 || v_sampling_factor_n == 0 || v_sampling_factor_m == 0)
cond	284:16	285:67	7	h_sampling_factor_n == 0 || h_sampling_factor_m == 0 || v_sampling_factor_n == 0 || v_sampling_factor_m == 0
water	284:16	0:0	8	h_sampling_factor_n
op	284:36	0:0	8	==
water	284:39	0:0	8	0
op	284:41	0:0	8	||
water	284:44	0:0	8	h_sampling_factor_m
op	284:64	0:0	8	==
water	284:67	0:0	8	0
op	284:69	0:0	8	||
water	285:16	0:0	8	v_sampling_factor_n
op	285:36	0:0	8	==
water	285:39	0:0	8	0
op	285:41	0:0	8	||
water	285:44	0:0	8	v_sampling_factor_m
op	285:64	0:0	8	==
water	285:67	0:0	8	0
stmts	285:70	290:12	7	
water	285:70	0:0	8	{
water	288:16	0:0	8	ctx
op	288:19	0:0	8	->
water	288:21	0:0	8	scalability
op	288:33	0:0	8	=
water	288:35	0:0	8	0
water	288:36	0:0	8	;
op	289:16	0:0	8	*
water	289:17	0:0	8	gb
op	289:31	0:0	8	=
water	289:33	0:0	8	bak
water	289:36	0:0	8	;
water	290:12	0:0	8	}
else	290:14	291:77	6
stmts	291:16	291:77	7	
call	291:16	291:76	8	av_log
arg	291:23	291:31	9	s->avctx
water	291:23	0:0	10	s
op	291:24	0:0	10	->
water	291:26	0:0	10	avctx
arg	291:33	291:45	9	AV_LOG_ERROR
water	291:33	0:0	10	AV_LOG_ERROR
arg	291:47	291:76	9	"scalability not supported\n"
water	291:47	0:0	10	"scalability not supported\n"
water	291:77	0:0	8	;
water	293:8	0:0	6	}
water	294:4	0:0	4	}
if	295:4	304:4	2	(s -> avctx -> debug & FF_DEBUG_PICT_INFO)
cond	295:8	295:24	3	s -> avctx -> debug & FF_DEBUG_PICT_INFO
water	295:8	0:0	4	s
op	295:9	0:0	4	->
water	295:11	0:0	4	avctx
op	295:16	0:0	4	->
water	295:18	0:0	4	debug
op	295:23	0:0	4	&
water	295:24	0:0	4	FF_DEBUG_PICT_INFO
stmts	295:44	304:4	3	
water	295:44	0:0	4	{
call	296:8	303:8	4	av_log
arg	296:15	296:23	5	s->avctx
water	296:15	0:0	6	s
op	296:16	0:0	6	->
water	296:18	0:0	6	avctx
arg	296:25	296:37	5	AV_LOG_DEBUG
water	296:25	0:0	6	AV_LOG_DEBUG
arg	296:39	296:95	5	"tb %d/%d, tincrbits:%d, qp_prec:%d, ps:%d,  %s%s%s%s\n"
water	296:39	0:0	6	"tb %d/%d, tincrbits:%d, qp_prec:%d, ps:%d,  %s%s%s%s\n"
arg	297:15	297:38	5	s->avctx->framerate.den
water	297:15	0:0	6	s
op	297:16	0:0	6	->
water	297:18	0:0	6	avctx
op	297:23	0:0	6	->
water	297:25	0:0	6	framerate
op	297:34	0:0	6	.
water	297:35	0:0	6	den
arg	297:40	297:63	5	s->avctx->framerate.num
water	297:40	0:0	6	s
op	297:41	0:0	6	->
water	297:43	0:0	6	avctx
op	297:48	0:0	6	->
water	297:50	0:0	6	framerate
op	297:59	0:0	6	.
water	297:60	0:0	6	num
arg	298:15	298:39	5	ctx->time_increment_bits
water	298:15	0:0	6	ctx
op	298:18	0:0	6	->
water	298:20	0:0	6	time_increment_bits
arg	299:15	299:33	5	s->quant_precision
water	299:15	0:0	6	s
op	299:16	0:0	6	->
water	299:18	0:0	6	quant_precision
arg	300:15	300:38	5	s->progressive_sequence
water	300:15	0:0	6	s
op	300:16	0:0	6	->
water	300:18	0:0	6	progressive_sequence
arg	301:15	301:53	5	ctx->scalability?"scalability ":""
water	301:15	0:0	6	ctx
op	301:18	0:0	6	->
water	301:20	0:0	6	scalability
water	301:32	0:0	6	?
water	301:34	0:0	6	"scalability "
water	301:49	0:0	6	:
water	301:50	0:0	6	""
arg	301:55	301:87	5	s->quarter_sample?"qpel ":""
water	301:55	0:0	6	s
op	301:56	0:0	6	->
water	301:58	0:0	6	quarter_sample
water	301:73	0:0	6	?
water	301:75	0:0	6	"qpel "
water	301:83	0:0	6	:
water	301:85	0:0	6	""
arg	302:15	302:55	5	s->data_partitioning?"partition ":""
water	302:15	0:0	6	s
op	302:16	0:0	6	->
water	302:18	0:0	6	data_partitioning
water	302:36	0:0	6	?
water	302:38	0:0	6	"partition "
water	302:51	0:0	6	:
water	302:53	0:0	6	""
arg	302:57	303:8	5	ctx->rvlc?"rvlc ":""
water	302:57	0:0	6	ctx
op	302:60	0:0	6	->
water	302:62	0:0	6	rvlc
water	302:67	0:0	6	?
water	302:69	0:0	6	"rvlc "
water	302:77	0:0	6	:
water	302:79	0:0	6	""
water	303:9	0:0	4	;
water	304:4	0:0	4	}
return	305:4	305:12	2	0
water	305:11	0:0	3	0
