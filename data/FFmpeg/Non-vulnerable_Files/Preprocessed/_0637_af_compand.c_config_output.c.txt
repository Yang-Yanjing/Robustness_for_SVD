func	1:0	176:0	0	static int	config_output
params	1:24	0:0	1	
param	1:25	1:46	2	AVFilterLink *	outlink
stmnts	0:0	175:12	1	
decl	3:4	3:40	2	AVFilterContext	*ctx
op	3:26	0:0	2	=
water	3:28	0:0	2	outlink
op	3:35	0:0	2	->
water	3:37	0:0	2	src
decl	4:4	4:37	2	CompandContext	*s
op	4:26	0:0	2	=
water	4:28	0:0	2	ctx
op	4:31	0:0	2	->
water	4:33	0:0	2	priv
decl	5:4	5:48	2	const int	sample_rate
op	5:26	0:0	2	=
water	5:28	0:0	2	outlink
op	5:35	0:0	2	->
water	5:37	0:0	2	sample_rate
decl	6:4	6:55	2	double	radius
op	6:26	0:0	2	=
water	6:28	0:0	2	s
op	6:29	0:0	2	->
water	6:31	0:0	2	curve_dB
op	6:40	0:0	2	*
water	6:42	0:0	2	M_LN10
op	6:49	0:0	2	/
water	6:51	0:0	2	20
op	6:53	0:0	2	.
water	6:54	0:0	2	0
decl	7:4	7:32	2	char	*p
water	7:11	0:0	2	,
decl	7:4	7:32	2	char	*saveptr
op	7:26	0:0	2	=
water	7:28	0:0	2	NULL
decl	8:4	8:45	2	const int	channels
op	8:26	0:0	2	=
water	8:28	0:0	2	outlink
op	8:35	0:0	2	->
water	8:37	0:0	2	channels
decl	9:4	9:40	2	int	nb_attacks
water	9:18	0:0	2	,
decl	9:4	9:40	2	int	nb_decays
water	9:29	0:0	2	,
decl	9:4	9:40	2	int	nb_points
decl	10:4	10:25	2	int	new_nb_items
water	10:20	0:0	2	,
decl	10:4	10:25	2	int	num
decl	11:4	11:9	2	int	i
decl	12:4	12:11	2	int	err
call	13:4	13:39	2	count_items
arg	13:16	13:26	3	s->attacks
water	13:16	0:0	4	s
op	13:17	0:0	4	->
water	13:19	0:0	4	attacks
arg	13:28	13:39	3	&nb_attacks
op	13:28	0:0	4	&
water	13:29	0:0	4	nb_attacks
water	13:40	0:0	2	;
call	14:4	14:37	2	count_items
arg	14:16	14:25	3	s->decays
water	14:16	0:0	4	s
op	14:17	0:0	4	->
water	14:19	0:0	4	decays
arg	14:27	14:37	3	&nb_decays
op	14:27	0:0	4	&
water	14:28	0:0	4	nb_decays
water	14:38	0:0	2	;
call	15:4	15:37	2	count_items
arg	15:16	15:25	3	s->points
water	15:16	0:0	4	s
op	15:17	0:0	4	->
water	15:19	0:0	4	points
arg	15:27	15:37	3	&nb_points
op	15:27	0:0	4	&
water	15:28	0:0	4	nb_points
water	15:38	0:0	2	;
if	16:4	19:4	2	(channels <= 0)
cond	16:8	16:20	3	channels <= 0
water	16:8	0:0	4	channels
op	16:17	0:0	4	<=
water	16:20	0:0	4	0
stmts	16:23	19:4	3	
water	16:23	0:0	4	{
call	17:8	17:78	4	av_log
arg	17:15	17:18	5	ctx
water	17:15	0:0	6	ctx
arg	17:20	17:32	5	AV_LOG_ERROR
water	17:20	0:0	6	AV_LOG_ERROR
arg	17:34	17:68	5	"Invalid number of channels: %d\n"
water	17:34	0:0	6	"Invalid number of channels: %d\n"
arg	17:70	17:78	5	channels
water	17:70	0:0	6	channels
water	17:79	0:0	4	;
return	18:8	18:30	4	AVERROR(EINVAL)
call	18:15	18:29	5	AVERROR
arg	18:23	18:29	6	EINVAL
water	18:23	0:0	7	EINVAL
water	19:4	0:0	4	}
if	20:4	24:4	2	(nb_attacks > channels || nb_decays > channels)
cond	20:8	20:45	3	nb_attacks > channels || nb_decays > channels
water	20:8	0:0	4	nb_attacks
op	20:19	0:0	4	>
water	20:21	0:0	4	channels
op	20:30	0:0	4	||
water	20:33	0:0	4	nb_decays
op	20:43	0:0	4	>
water	20:45	0:0	4	channels
stmts	20:55	24:4	3	
water	20:55	0:0	4	{
call	21:8	22:76	4	av_log
arg	21:15	21:18	5	ctx
water	21:15	0:0	6	ctx
arg	21:20	21:32	5	AV_LOG_ERROR
water	21:20	0:0	6	AV_LOG_ERROR
arg	22:16	22:76	5	"Number of attacks/decays bigger than number of channels.\n"
water	22:16	0:0	6	"Number of attacks/decays bigger than number of channels.\n"
water	22:77	0:0	4	;
return	23:8	23:30	4	AVERROR(EINVAL)
call	23:15	23:29	5	AVERROR
arg	23:23	23:29	6	EINVAL
water	23:23	0:0	7	EINVAL
water	24:4	0:0	4	}
call	25:4	25:14	2	uninit
arg	25:11	25:14	3	ctx
water	25:11	0:0	4	ctx
water	25:15	0:0	2	;
water	26:4	0:0	2	s
op	26:5	0:0	2	->
water	26:7	0:0	2	channels
op	26:16	0:0	2	=
call	26:18	26:65	2	av_mallocz_array
arg	26:35	26:43	3	channels
water	26:35	0:0	4	channels
arg	26:45	26:65	3	sizeof(*s->channels)
op	26:45	0:0	4	sizeof
water	26:51	0:0	4	(
op	26:52	0:0	4	*
water	26:53	0:0	4	s
op	26:54	0:0	4	->
water	26:56	0:0	4	channels
water	26:64	0:0	4	)
water	26:66	0:0	2	;
water	27:4	0:0	2	s
op	27:5	0:0	2	->
water	27:7	0:0	2	nb_segments
op	27:19	0:0	2	=
water	27:21	0:0	2	(
water	27:22	0:0	2	nb_points
op	27:32	0:0	2	+
water	27:34	0:0	2	4
water	27:35	0:0	2	)
op	27:37	0:0	2	*
water	27:39	0:0	2	2
water	27:40	0:0	2	;
water	28:4	0:0	2	s
op	28:5	0:0	2	->
water	28:7	0:0	2	segments
op	28:16	0:0	2	=
call	28:18	28:71	2	av_mallocz_array
arg	28:35	28:49	3	s->nb_segments
water	28:35	0:0	4	s
op	28:36	0:0	4	->
water	28:38	0:0	4	nb_segments
arg	28:51	28:71	3	sizeof(*s->segments)
op	28:51	0:0	4	sizeof
water	28:57	0:0	4	(
op	28:58	0:0	4	*
water	28:59	0:0	4	s
op	28:60	0:0	4	->
water	28:62	0:0	4	segments
water	28:70	0:0	4	)
water	28:72	0:0	2	;
if	29:4	32:4	2	(! s -> channels || ! s -> segments)
cond	29:8	29:28	3	! s -> channels || ! s -> segments
op	29:8	0:0	4	!
water	29:9	0:0	4	s
op	29:10	0:0	4	->
water	29:12	0:0	4	channels
op	29:21	0:0	4	||
op	29:24	0:0	4	!
water	29:25	0:0	4	s
op	29:26	0:0	4	->
water	29:28	0:0	4	segments
stmts	29:38	32:4	3	
water	29:38	0:0	4	{
call	30:8	30:18	4	uninit
arg	30:15	30:18	5	ctx
water	30:15	0:0	6	ctx
water	30:19	0:0	4	;
return	31:8	31:30	4	AVERROR(ENOMEM)
call	31:15	31:29	5	AVERROR
arg	31:23	31:29	6	ENOMEM
water	31:23	0:0	7	ENOMEM
water	32:4	0:0	4	}
water	33:4	0:0	2	p
op	33:6	0:0	2	=
water	33:8	0:0	2	s
op	33:9	0:0	2	->
water	33:11	0:0	2	attacks
water	33:18	0:0	2	;
for	34:4	42:4	2	(i = 0 , new_nb_items = 0 ;i < nb_attacks;i ++)
forinit	34:9	34:32	3	i = 0 , new_nb_items = 0 ;
water	34:9	0:0	4	i
op	34:11	0:0	4	=
water	34:13	0:0	4	0
water	34:14	0:0	4	,
water	34:16	0:0	4	new_nb_items
op	34:29	0:0	4	=
water	34:31	0:0	4	0
water	34:32	0:0	4	;
cond	34:34	34:38	3	i < nb_attacks
water	34:34	0:0	4	i
op	34:36	0:0	4	<
water	34:38	0:0	4	nb_attacks
forexpr	34:50	34:51	3	i ++
water	34:50	0:0	4	i
op	34:51	0:0	4	++
stmts	34:55	42:4	3	
water	34:55	0:0	4	{
decl	35:8	35:49	4	char	*tstr
op	35:19	0:0	4	=
call	35:21	35:48	5	av_strtok
arg	35:31	35:32	6	p
water	35:31	0:0	7	p
arg	35:34	35:38	6	" |"
water	35:34	0:0	7	" |"
arg	35:40	35:48	6	&saveptr
op	35:40	0:0	7	&
water	35:41	0:0	7	saveptr
water	36:8	0:0	4	p
op	36:10	0:0	4	=
water	36:12	0:0	4	NULL
water	36:16	0:0	4	;
water	37:8	0:0	4	new_nb_items
op	37:21	0:0	4	+=
call	37:24	37:66	4	sscanf
arg	37:31	37:35	5	tstr
water	37:31	0:0	6	tstr
arg	37:37	37:42	5	"%lf"
water	37:37	0:0	6	"%lf"
arg	37:44	37:66	5	&s->channels[i].attack
op	37:44	0:0	6	&
water	37:45	0:0	6	s
op	37:46	0:0	6	->
water	37:48	0:0	6	channels
op	37:56	0:0	6	[
water	37:57	0:0	6	i
op	37:58	0:0	6	]
op	37:59	0:0	6	.
water	37:60	0:0	6	attack
op	37:68	0:0	4	==
water	37:71	0:0	4	1
water	37:72	0:0	4	;
if	38:8	41:8	4	(s -> channels [ i ] . attack < 0)
cond	38:12	38:36	5	s -> channels [ i ] . attack < 0
water	38:12	0:0	6	s
op	38:13	0:0	6	->
water	38:15	0:0	6	channels
op	38:23	0:0	6	[
water	38:24	0:0	6	i
op	38:25	0:0	6	]
op	38:26	0:0	6	.
water	38:27	0:0	6	attack
op	38:34	0:0	6	<
water	38:36	0:0	6	0
stmts	38:39	41:8	5	
water	38:39	0:0	6	{
call	39:12	39:22	6	uninit
arg	39:19	39:22	7	ctx
water	39:19	0:0	8	ctx
water	39:23	0:0	6	;
return	40:12	40:34	6	AVERROR(EINVAL)
call	40:19	40:33	7	AVERROR
arg	40:27	40:33	8	EINVAL
water	40:27	0:0	9	EINVAL
water	41:8	0:0	6	}
water	42:4	0:0	4	}
water	43:4	0:0	2	nb_attacks
op	43:15	0:0	2	=
water	43:17	0:0	2	new_nb_items
water	43:29	0:0	2	;
water	44:4	0:0	2	p
op	44:6	0:0	2	=
water	44:8	0:0	2	s
op	44:9	0:0	2	->
water	44:11	0:0	2	decays
water	44:17	0:0	2	;
for	45:4	53:4	2	(i = 0 , new_nb_items = 0 ;i < nb_decays;i ++)
forinit	45:9	45:32	3	i = 0 , new_nb_items = 0 ;
water	45:9	0:0	4	i
op	45:11	0:0	4	=
water	45:13	0:0	4	0
water	45:14	0:0	4	,
water	45:16	0:0	4	new_nb_items
op	45:29	0:0	4	=
water	45:31	0:0	4	0
water	45:32	0:0	4	;
cond	45:34	45:38	3	i < nb_decays
water	45:34	0:0	4	i
op	45:36	0:0	4	<
water	45:38	0:0	4	nb_decays
forexpr	45:49	45:50	3	i ++
water	45:49	0:0	4	i
op	45:50	0:0	4	++
stmts	45:54	53:4	3	
water	45:54	0:0	4	{
decl	46:8	46:49	4	char	*tstr
op	46:19	0:0	4	=
call	46:21	46:48	5	av_strtok
arg	46:31	46:32	6	p
water	46:31	0:0	7	p
arg	46:34	46:38	6	" |"
water	46:34	0:0	7	" |"
arg	46:40	46:48	6	&saveptr
op	46:40	0:0	7	&
water	46:41	0:0	7	saveptr
water	47:8	0:0	4	p
op	47:10	0:0	4	=
water	47:12	0:0	4	NULL
water	47:16	0:0	4	;
water	48:8	0:0	4	new_nb_items
op	48:21	0:0	4	+=
call	48:24	48:65	4	sscanf
arg	48:31	48:35	5	tstr
water	48:31	0:0	6	tstr
arg	48:37	48:42	5	"%lf"
water	48:37	0:0	6	"%lf"
arg	48:44	48:65	5	&s->channels[i].decay
op	48:44	0:0	6	&
water	48:45	0:0	6	s
op	48:46	0:0	6	->
water	48:48	0:0	6	channels
op	48:56	0:0	6	[
water	48:57	0:0	6	i
op	48:58	0:0	6	]
op	48:59	0:0	6	.
water	48:60	0:0	6	decay
op	48:67	0:0	4	==
water	48:70	0:0	4	1
water	48:71	0:0	4	;
if	49:8	52:8	4	(s -> channels [ i ] . decay < 0)
cond	49:12	49:35	5	s -> channels [ i ] . decay < 0
water	49:12	0:0	6	s
op	49:13	0:0	6	->
water	49:15	0:0	6	channels
op	49:23	0:0	6	[
water	49:24	0:0	6	i
op	49:25	0:0	6	]
op	49:26	0:0	6	.
water	49:27	0:0	6	decay
op	49:33	0:0	6	<
water	49:35	0:0	6	0
stmts	49:38	52:8	5	
water	49:38	0:0	6	{
call	50:12	50:22	6	uninit
arg	50:19	50:22	7	ctx
water	50:19	0:0	8	ctx
water	50:23	0:0	6	;
return	51:12	51:34	6	AVERROR(EINVAL)
call	51:19	51:33	7	AVERROR
arg	51:27	51:33	8	EINVAL
water	51:27	0:0	9	EINVAL
water	52:8	0:0	6	}
water	53:4	0:0	4	}
water	54:4	0:0	2	nb_decays
op	54:14	0:0	2	=
water	54:16	0:0	2	new_nb_items
water	54:28	0:0	2	;
if	55:4	61:4	2	(nb_attacks != nb_decays)
cond	55:8	55:22	3	nb_attacks != nb_decays
water	55:8	0:0	4	nb_attacks
op	55:19	0:0	4	!=
water	55:22	0:0	4	nb_decays
stmts	55:33	61:4	3	
water	55:33	0:0	4	{
call	56:8	58:37	4	av_log
arg	56:15	56:18	5	ctx
water	56:15	0:0	6	ctx
arg	56:20	56:32	5	AV_LOG_ERROR
water	56:20	0:0	6	AV_LOG_ERROR
arg	57:16	57:74	5	"Number of attacks %d differs from number of decays %d.\n"
water	57:16	0:0	6	"Number of attacks %d differs from number of decays %d.\n"
arg	58:16	58:26	5	nb_attacks
water	58:16	0:0	6	nb_attacks
arg	58:28	58:37	5	nb_decays
water	58:28	0:0	6	nb_decays
water	58:38	0:0	4	;
call	59:8	59:18	4	uninit
arg	59:15	59:18	5	ctx
water	59:15	0:0	6	ctx
water	59:19	0:0	4	;
return	60:8	60:30	4	AVERROR(EINVAL)
call	60:15	60:29	5	AVERROR
arg	60:23	60:29	6	EINVAL
water	60:23	0:0	7	EINVAL
water	61:4	0:0	4	}
for	62:4	65:4	2	(i = nb_decays ;i < channels;i ++)
forinit	62:9	62:22	3	i = nb_decays ;
water	62:9	0:0	4	i
op	62:11	0:0	4	=
water	62:13	0:0	4	nb_decays
water	62:22	0:0	4	;
cond	62:24	62:28	3	i < channels
water	62:24	0:0	4	i
op	62:26	0:0	4	<
water	62:28	0:0	4	channels
forexpr	62:38	62:39	3	i ++
water	62:38	0:0	4	i
op	62:39	0:0	4	++
stmts	62:43	65:4	3	
water	62:43	0:0	4	{
water	63:8	0:0	4	s
op	63:9	0:0	4	->
water	63:11	0:0	4	channels
op	63:19	0:0	4	[
water	63:20	0:0	4	i
op	63:21	0:0	4	]
op	63:22	0:0	4	.
water	63:23	0:0	4	attack
op	63:30	0:0	4	=
water	63:32	0:0	4	s
op	63:33	0:0	4	->
water	63:35	0:0	4	channels
op	63:43	0:0	4	[
water	63:44	0:0	4	nb_decays
op	63:54	0:0	4	-
water	63:56	0:0	4	1
op	63:57	0:0	4	]
op	63:58	0:0	4	.
water	63:59	0:0	4	attack
water	63:65	0:0	4	;
water	64:8	0:0	4	s
op	64:9	0:0	4	->
water	64:11	0:0	4	channels
op	64:19	0:0	4	[
water	64:20	0:0	4	i
op	64:21	0:0	4	]
op	64:22	0:0	4	.
water	64:23	0:0	4	decay
op	64:29	0:0	4	=
water	64:31	0:0	4	s
op	64:32	0:0	4	->
water	64:34	0:0	4	channels
op	64:42	0:0	4	[
water	64:43	0:0	4	nb_decays
op	64:53	0:0	4	-
water	64:55	0:0	4	1
op	64:56	0:0	4	]
op	64:57	0:0	4	.
water	64:58	0:0	4	decay
water	64:63	0:0	4	;
water	65:4	0:0	4	}
water	67:4	0:0	2	p
op	67:6	0:0	2	=
water	67:8	0:0	2	s
op	67:9	0:0	2	->
water	67:11	0:0	2	points
water	67:17	0:0	2	;
for	68:4	86:4	2	(i = 0 , new_nb_items = 0 ;i < nb_points;i ++)
forinit	68:9	68:32	3	i = 0 , new_nb_items = 0 ;
water	68:9	0:0	4	i
op	68:11	0:0	4	=
water	68:13	0:0	4	0
water	68:14	0:0	4	,
water	68:16	0:0	4	new_nb_items
op	68:29	0:0	4	=
water	68:31	0:0	4	0
water	68:32	0:0	4	;
cond	68:34	68:38	3	i < nb_points
water	68:34	0:0	4	i
op	68:36	0:0	4	<
water	68:38	0:0	4	nb_points
forexpr	68:49	68:50	3	i ++
water	68:49	0:0	4	i
op	68:50	0:0	4	++
stmts	68:54	86:4	3	
water	68:54	0:0	4	{
decl	69:8	69:49	4	char	*tstr
op	69:19	0:0	4	=
call	69:21	69:48	5	av_strtok
arg	69:31	69:32	6	p
water	69:31	0:0	7	p
arg	69:34	69:38	6	" |"
water	69:34	0:0	7	" |"
arg	69:40	69:48	6	&saveptr
op	69:40	0:0	7	&
water	69:41	0:0	7	saveptr
water	70:8	0:0	4	p
op	70:10	0:0	4	=
water	70:12	0:0	4	NULL
water	70:16	0:0	4	;
if	71:8	76:8	4	(sscanf (tstr ,"%lf/%lf" ,& S (i ) . x ,& S (i ) . y ) != 2)
cond	71:12	71:57	5	sscanf (tstr ,"%lf/%lf" ,& S (i ) . x ,& S (i ) . y ) != 2
call	71:12	71:52	6	sscanf
arg	71:19	71:23	7	tstr
water	71:19	0:0	8	tstr
arg	71:25	71:34	7	"%lf/%lf"
water	71:25	0:0	8	"%lf/%lf"
arg	71:36	71:43	7	&S(i).x
call	71:36	71:40	8	&S
arg	71:39	71:40	9	i
water	71:39	0:0	10	i
op	71:41	0:0	8	.
water	71:42	0:0	8	x
arg	71:45	71:52	7	&S(i).y
call	71:45	71:49	8	&S
arg	71:48	71:49	9	i
water	71:48	0:0	10	i
op	71:50	0:0	8	.
water	71:51	0:0	8	y
op	71:54	0:0	6	!=
water	71:57	0:0	6	2
stmts	71:60	76:8	5	
water	71:60	0:0	6	{
call	72:12	73:66	6	av_log
arg	72:19	72:22	7	ctx
water	72:19	0:0	8	ctx
arg	72:24	72:36	7	AV_LOG_ERROR
water	72:24	0:0	8	AV_LOG_ERROR
arg	73:20	73:66	7	"Invalid and/or missing input/output value.\n"
water	73:20	0:0	8	"Invalid and/or missing input/output value.\n"
water	73:67	0:0	6	;
call	74:12	74:22	6	uninit
arg	74:19	74:22	7	ctx
water	74:19	0:0	8	ctx
water	74:23	0:0	6	;
return	75:12	75:34	6	AVERROR(EINVAL)
call	75:19	75:33	7	AVERROR
arg	75:27	75:33	8	EINVAL
water	75:27	0:0	9	EINVAL
water	76:8	0:0	6	}
if	77:8	82:8	4	(i &&S (i - 1 ) . x >S (i ) . x)
cond	77:12	77:35	5	i &&S (i - 1 ) . x >S (i ) . x
water	77:12	0:0	6	i
op	77:14	0:0	6	&&
call	77:17	77:24	6	S
arg	77:19	77:24	7	i-1
water	77:19	0:0	8	i
op	77:21	0:0	8	-
water	77:23	0:0	8	1
op	77:25	0:0	6	.
water	77:26	0:0	6	x
op	77:28	0:0	6	>
call	77:30	77:33	6	S
arg	77:32	77:33	7	i
water	77:32	0:0	8	i
op	77:34	0:0	6	.
water	77:35	0:0	6	x
stmts	77:38	82:8	5	
water	77:38	0:0	6	{
call	78:12	79:74	6	av_log
arg	78:19	78:22	7	ctx
water	78:19	0:0	8	ctx
arg	78:24	78:36	7	AV_LOG_ERROR
water	78:24	0:0	8	AV_LOG_ERROR
arg	79:20	79:74	7	"Transfer function input values must be increasing.\n"
water	79:20	0:0	8	"Transfer function input values must be increasing.\n"
water	79:75	0:0	6	;
call	80:12	80:22	6	uninit
arg	80:19	80:22	7	ctx
water	80:19	0:0	8	ctx
water	80:23	0:0	6	;
return	81:12	81:34	6	AVERROR(EINVAL)
call	81:19	81:33	7	AVERROR
arg	81:27	81:33	8	EINVAL
water	81:27	0:0	9	EINVAL
water	82:8	0:0	6	}
call	83:8	83:11	4	S
arg	83:10	83:11	5	i
water	83:10	0:0	6	i
op	83:12	0:0	4	.
water	83:13	0:0	4	y
op	83:15	0:0	4	-=
call	83:18	83:21	4	S
arg	83:20	83:21	5	i
water	83:20	0:0	6	i
op	83:22	0:0	4	.
water	83:23	0:0	4	x
water	83:24	0:0	4	;
call	84:8	84:70	4	av_log
arg	84:15	84:18	5	ctx
water	84:15	0:0	6	ctx
arg	84:20	84:32	5	AV_LOG_DEBUG
water	84:20	0:0	6	AV_LOG_DEBUG
arg	84:34	84:51	5	"%d: x=%f y=%f\n"
water	84:34	0:0	6	"%d: x=%f y=%f\n"
arg	84:53	84:54	5	i
water	84:53	0:0	6	i
arg	84:56	84:62	5	S(i).x
call	84:56	84:59	6	S
arg	84:58	84:59	7	i
water	84:58	0:0	8	i
op	84:60	0:0	6	.
water	84:61	0:0	6	x
arg	84:64	84:70	5	S(i).y
call	84:64	84:67	6	S
arg	84:66	84:67	7	i
water	84:66	0:0	8	i
op	84:68	0:0	6	.
water	84:69	0:0	6	y
water	84:71	0:0	4	;
water	85:8	0:0	4	new_nb_items
op	85:20	0:0	4	++
water	85:22	0:0	4	;
water	86:4	0:0	4	}
water	87:4	0:0	2	num
op	87:8	0:0	2	=
water	87:10	0:0	2	new_nb_items
water	87:22	0:0	2	;
if	89:4	90:13	2	(num == 0 ||S (num - 1 ) . x)
cond	89:8	89:31	3	num == 0 ||S (num - 1 ) . x
water	89:8	0:0	4	num
op	89:12	0:0	4	==
water	89:15	0:0	4	0
op	89:17	0:0	4	||
call	89:20	89:29	4	S
arg	89:22	89:29	5	num-1
water	89:22	0:0	6	num
op	89:26	0:0	6	-
water	89:28	0:0	6	1
op	89:30	0:0	4	.
water	89:31	0:0	4	x
stmts	90:8	90:13	3	
water	90:8	0:0	4	num
op	90:11	0:0	4	++
water	90:13	0:0	4	;
call	94:4	94:7	2	S
arg	94:6	94:7	3	0
water	94:6	0:0	4	0
op	94:8	0:0	2	.
water	94:9	0:0	2	x
op	94:11	0:0	2	=
call	94:13	94:16	2	S
arg	94:15	94:16	3	1
water	94:15	0:0	4	1
op	94:17	0:0	2	.
water	94:18	0:0	2	x
op	94:20	0:0	2	-
water	94:22	0:0	2	2
op	94:24	0:0	2	*
water	94:26	0:0	2	s
op	94:27	0:0	2	->
water	94:29	0:0	2	curve_dB
water	94:37	0:0	2	;
call	95:4	95:7	2	S
arg	95:6	95:7	3	0
water	95:6	0:0	4	0
op	95:8	0:0	2	.
water	95:9	0:0	2	y
op	95:11	0:0	2	=
call	95:13	95:16	2	S
arg	95:15	95:16	3	1
water	95:15	0:0	4	1
op	95:17	0:0	2	.
water	95:18	0:0	2	y
water	95:19	0:0	2	;
water	96:4	0:0	2	num
op	96:7	0:0	2	++
water	96:9	0:0	2	;
for	98:4	107:4	2	(i = 2 ;i < num;i ++)
forinit	98:9	98:14	3	i = 2 ;
water	98:9	0:0	4	i
op	98:11	0:0	4	=
water	98:13	0:0	4	2
water	98:14	0:0	4	;
cond	98:16	98:20	3	i < num
water	98:16	0:0	4	i
op	98:18	0:0	4	<
water	98:20	0:0	4	num
forexpr	98:25	98:26	3	i ++
water	98:25	0:0	4	i
op	98:26	0:0	4	++
stmts	98:30	107:4	3	
water	98:30	0:0	4	{
decl	99:8	99:73	4	double	g1
op	99:18	0:0	4	=
water	99:20	0:0	4	(
call	99:21	99:28	5	S
arg	99:23	99:28	6	i-1
water	99:23	0:0	7	i
op	99:25	0:0	7	-
water	99:27	0:0	7	1
op	99:29	0:0	4	.
water	99:30	0:0	4	y
op	99:32	0:0	4	-
call	99:34	99:41	5	S
arg	99:36	99:41	6	i-2
water	99:36	0:0	7	i
op	99:38	0:0	7	-
water	99:40	0:0	7	2
op	99:42	0:0	4	.
water	99:43	0:0	4	y
water	99:44	0:0	4	)
op	99:46	0:0	4	*
water	99:48	0:0	4	(
call	99:49	99:56	5	S
arg	99:51	99:56	6	i-0
water	99:51	0:0	7	i
op	99:53	0:0	7	-
water	99:55	0:0	7	0
op	99:57	0:0	4	.
water	99:58	0:0	4	x
op	99:60	0:0	4	-
call	99:62	99:69	5	S
arg	99:64	99:69	6	i-1
water	99:64	0:0	7	i
op	99:66	0:0	7	-
water	99:68	0:0	7	1
op	99:70	0:0	4	.
water	99:71	0:0	4	x
water	99:72	0:0	4	)
decl	100:8	100:73	4	double	g2
op	100:18	0:0	4	=
water	100:20	0:0	4	(
call	100:21	100:28	5	S
arg	100:23	100:28	6	i-0
water	100:23	0:0	7	i
op	100:25	0:0	7	-
water	100:27	0:0	7	0
op	100:29	0:0	4	.
water	100:30	0:0	4	y
op	100:32	0:0	4	-
call	100:34	100:41	5	S
arg	100:36	100:41	6	i-1
water	100:36	0:0	7	i
op	100:38	0:0	7	-
water	100:40	0:0	7	1
op	100:42	0:0	4	.
water	100:43	0:0	4	y
water	100:44	0:0	4	)
op	100:46	0:0	4	*
water	100:48	0:0	4	(
call	100:49	100:56	5	S
arg	100:51	100:56	6	i-1
water	100:51	0:0	7	i
op	100:53	0:0	7	-
water	100:55	0:0	7	1
op	100:57	0:0	4	.
water	100:58	0:0	4	x
op	100:60	0:0	4	-
call	100:62	100:69	5	S
arg	100:64	100:69	6	i-2
water	100:64	0:0	7	i
op	100:66	0:0	7	-
water	100:68	0:0	7	2
op	100:70	0:0	4	.
water	100:71	0:0	4	x
water	100:72	0:0	4	)
decl	101:8	101:13	4	int	j
if	102:8	103:20	4	(fabs (g1 - g2 ))
cond	102:12	102:24	5	fabs (g1 - g2 )
call	102:12	102:24	6	fabs
arg	102:17	102:24	7	g1-g2
water	102:17	0:0	8	g1
op	102:20	0:0	8	-
water	102:22	0:0	8	g2
stmts	103:12	103:20	5	
continue	103:12	103:20	6	
water	104:8	0:0	4	num
op	104:11	0:0	4	--
water	104:13	0:0	4	;
for	105:8	106:27	4	(j = -- i ;j < num;j ++)
forinit	105:13	105:20	5	j = -- i ;
water	105:13	0:0	6	j
op	105:15	0:0	6	=
op	105:17	0:0	6	--
water	105:19	0:0	6	i
water	105:20	0:0	6	;
cond	105:22	105:26	5	j < num
water	105:22	0:0	6	j
op	105:24	0:0	6	<
water	105:26	0:0	6	num
forexpr	105:31	105:32	5	j ++
water	105:31	0:0	6	j
op	105:32	0:0	6	++
stmts	106:12	106:27	5	
call	106:12	106:15	6	S
arg	106:14	106:15	7	j
water	106:14	0:0	8	j
op	106:17	0:0	6	=
call	106:19	106:26	6	S
arg	106:21	106:26	7	j+1
water	106:21	0:0	8	j
op	106:23	0:0	8	+
water	106:25	0:0	8	1
water	106:27	0:0	6	;
water	107:4	0:0	4	}
for	108:4	112:4	2	(i = 0 ;! i || s -> segments [ i - 2 ] . x;i += 2)
forinit	108:9	108:14	3	i = 0 ;
water	108:9	0:0	4	i
op	108:11	0:0	4	=
water	108:13	0:0	4	0
water	108:14	0:0	4	;
cond	108:16	108:41	3	! i || s -> segments [ i - 2 ] . x
op	108:16	0:0	4	!
water	108:17	0:0	4	i
op	108:19	0:0	4	||
water	108:22	0:0	4	s
op	108:23	0:0	4	->
water	108:25	0:0	4	segments
op	108:33	0:0	4	[
water	108:34	0:0	4	i
op	108:36	0:0	4	-
water	108:38	0:0	4	2
op	108:39	0:0	4	]
op	108:40	0:0	4	.
water	108:41	0:0	4	x
forexpr	108:44	108:49	3	i += 2
water	108:44	0:0	4	i
op	108:46	0:0	4	+=
water	108:49	0:0	4	2
stmts	108:52	112:4	3	
water	108:52	0:0	4	{
water	109:8	0:0	4	s
op	109:9	0:0	4	->
water	109:11	0:0	4	segments
op	109:19	0:0	4	[
water	109:20	0:0	4	i
op	109:21	0:0	4	]
op	109:22	0:0	4	.
water	109:23	0:0	4	y
op	109:25	0:0	4	+=
water	109:28	0:0	4	s
op	109:29	0:0	4	->
water	109:31	0:0	4	gain_dB
water	109:38	0:0	4	;
water	110:8	0:0	4	s
op	110:9	0:0	4	->
water	110:11	0:0	4	segments
op	110:19	0:0	4	[
water	110:20	0:0	4	i
op	110:21	0:0	4	]
op	110:22	0:0	4	.
water	110:23	0:0	4	x
op	110:25	0:0	4	*=
water	110:28	0:0	4	M_LN10
op	110:35	0:0	4	/
water	110:37	0:0	4	20
water	110:39	0:0	4	;
water	111:8	0:0	4	s
op	111:9	0:0	4	->
water	111:11	0:0	4	segments
op	111:19	0:0	4	[
water	111:20	0:0	4	i
op	111:21	0:0	4	]
op	111:22	0:0	4	.
water	111:23	0:0	4	y
op	111:25	0:0	4	*=
water	111:28	0:0	4	M_LN10
op	111:35	0:0	4	/
water	111:37	0:0	4	20
water	111:39	0:0	4	;
water	112:4	0:0	4	}
for	114:4	140:4	2	(i = 4 ;s -> segments [ i - 2 ] . x;i += 2)
forinit	114:9	114:14	3	i = 4 ;
water	114:9	0:0	4	i
op	114:11	0:0	4	=
water	114:13	0:0	4	4
water	114:14	0:0	4	;
cond	114:16	114:35	3	s -> segments [ i - 2 ] . x
water	114:16	0:0	4	s
op	114:17	0:0	4	->
water	114:19	0:0	4	segments
op	114:27	0:0	4	[
water	114:28	0:0	4	i
op	114:30	0:0	4	-
water	114:32	0:0	4	2
op	114:33	0:0	4	]
op	114:34	0:0	4	.
water	114:35	0:0	4	x
forexpr	114:38	114:43	3	i += 2
water	114:38	0:0	4	i
op	114:40	0:0	4	+=
water	114:43	0:0	4	2
stmts	114:46	140:4	3	
water	114:46	0:0	4	{
decl	115:8	115:64	4	double	x
water	115:16	0:0	4	,
decl	115:8	115:64	4	double	y
water	115:19	0:0	4	,
decl	115:8	115:64	4	double	cx
water	115:23	0:0	4	,
decl	115:8	115:64	4	double	cy
water	115:27	0:0	4	,
decl	115:8	115:64	4	double	in1
water	115:32	0:0	4	,
decl	115:8	115:64	4	double	in2
water	115:37	0:0	4	,
decl	115:8	115:64	4	double	out1
water	115:43	0:0	4	,
decl	115:8	115:64	4	double	out2
water	115:49	0:0	4	,
decl	115:8	115:64	4	double	theta
water	115:56	0:0	4	,
decl	115:8	115:64	4	double	len
water	115:61	0:0	4	,
decl	115:8	115:64	4	double	r
call	116:8	116:11	4	L
arg	116:10	116:11	5	4
water	116:10	0:0	6	4
op	116:12	0:0	4	.
water	116:13	0:0	4	a
op	116:15	0:0	4	=
water	116:17	0:0	4	0
water	116:18	0:0	4	;
call	117:8	117:11	4	L
arg	117:10	117:11	5	4
water	117:10	0:0	6	4
op	117:12	0:0	4	.
water	117:13	0:0	4	b
op	117:15	0:0	4	=
water	117:17	0:0	4	(
call	117:18	117:21	4	L
arg	117:20	117:21	5	2
water	117:20	0:0	6	2
op	117:22	0:0	4	.
water	117:23	0:0	4	y
op	117:25	0:0	4	-
call	117:27	117:30	4	L
arg	117:29	117:30	5	4
water	117:29	0:0	6	4
op	117:31	0:0	4	.
water	117:32	0:0	4	y
water	117:33	0:0	4	)
op	117:35	0:0	4	/
water	117:37	0:0	4	(
call	117:38	117:41	4	L
arg	117:40	117:41	5	2
water	117:40	0:0	6	2
op	117:42	0:0	4	.
water	117:43	0:0	4	x
op	117:45	0:0	4	-
call	117:47	117:50	4	L
arg	117:49	117:50	5	4
water	117:49	0:0	6	4
op	117:51	0:0	4	.
water	117:52	0:0	4	x
water	117:53	0:0	4	)
water	117:54	0:0	4	;
call	118:8	118:11	4	L
arg	118:10	118:11	5	2
water	118:10	0:0	6	2
op	118:12	0:0	4	.
water	118:13	0:0	4	a
op	118:15	0:0	4	=
water	118:17	0:0	4	0
water	118:18	0:0	4	;
call	119:8	119:11	4	L
arg	119:10	119:11	5	2
water	119:10	0:0	6	2
op	119:12	0:0	4	.
water	119:13	0:0	4	b
op	119:15	0:0	4	=
water	119:17	0:0	4	(
call	119:18	119:21	4	L
arg	119:20	119:21	5	0
water	119:20	0:0	6	0
op	119:22	0:0	4	.
water	119:23	0:0	4	y
op	119:25	0:0	4	-
call	119:27	119:30	4	L
arg	119:29	119:30	5	2
water	119:29	0:0	6	2
op	119:31	0:0	4	.
water	119:32	0:0	4	y
water	119:33	0:0	4	)
op	119:35	0:0	4	/
water	119:37	0:0	4	(
call	119:38	119:41	4	L
arg	119:40	119:41	5	0
water	119:40	0:0	6	0
op	119:42	0:0	4	.
water	119:43	0:0	4	x
op	119:45	0:0	4	-
call	119:47	119:50	4	L
arg	119:49	119:50	5	2
water	119:49	0:0	6	2
op	119:51	0:0	4	.
water	119:52	0:0	4	x
water	119:53	0:0	4	)
water	119:54	0:0	4	;
water	120:8	0:0	4	theta
op	120:14	0:0	4	=
call	120:16	120:54	4	atan2
arg	120:22	120:37	5	L(2).y-L(4).y
call	120:22	120:25	6	L
arg	120:24	120:25	7	2
water	120:24	0:0	8	2
op	120:26	0:0	6	.
water	120:27	0:0	6	y
op	120:29	0:0	6	-
call	120:31	120:34	6	L
arg	120:33	120:34	7	4
water	120:33	0:0	8	4
op	120:35	0:0	6	.
water	120:36	0:0	6	y
arg	120:39	120:54	5	L(2).x-L(4).x
call	120:39	120:42	6	L
arg	120:41	120:42	7	2
water	120:41	0:0	8	2
op	120:43	0:0	6	.
water	120:44	0:0	6	x
op	120:46	0:0	6	-
call	120:48	120:51	6	L
arg	120:50	120:51	7	4
water	120:50	0:0	8	4
op	120:52	0:0	6	.
water	120:53	0:0	6	x
water	120:55	0:0	4	;
water	121:8	0:0	4	len
op	121:12	0:0	4	=
call	121:14	121:70	4	sqrt
arg	121:19	121:70	5	pow(L(2).x-L(4).x,2.)+pow(L(2).y-L(4).y,2.)
call	121:19	121:42	6	pow
arg	121:23	121:38	7	L(2).x-L(4).x
call	121:23	121:26	8	L
arg	121:25	121:26	9	2
water	121:25	0:0	10	2
op	121:27	0:0	8	.
water	121:28	0:0	8	x
op	121:30	0:0	8	-
call	121:32	121:35	8	L
arg	121:34	121:35	9	4
water	121:34	0:0	10	4
op	121:36	0:0	8	.
water	121:37	0:0	8	x
arg	121:40	121:42	7	2.
water	121:40	0:0	8	2
op	121:41	0:0	8	.
op	121:44	0:0	6	+
call	121:46	121:69	6	pow
arg	121:50	121:65	7	L(2).y-L(4).y
call	121:50	121:53	8	L
arg	121:52	121:53	9	2
water	121:52	0:0	10	2
op	121:54	0:0	8	.
water	121:55	0:0	8	y
op	121:57	0:0	8	-
call	121:59	121:62	8	L
arg	121:61	121:62	9	4
water	121:61	0:0	10	4
op	121:63	0:0	8	.
water	121:64	0:0	8	y
arg	121:67	121:69	7	2.
water	121:67	0:0	8	2
op	121:68	0:0	8	.
water	121:71	0:0	4	;
water	122:8	0:0	4	r
op	122:10	0:0	4	=
call	122:12	122:29	4	FFMIN
arg	122:18	122:24	5	radius
water	122:18	0:0	6	radius
arg	122:26	122:29	5	len
water	122:26	0:0	6	len
water	122:30	0:0	4	;
call	123:8	123:11	4	L
arg	123:10	123:11	5	3
water	123:10	0:0	6	3
op	123:12	0:0	4	.
water	123:13	0:0	4	x
op	123:15	0:0	4	=
call	123:17	123:20	4	L
arg	123:19	123:20	5	2
water	123:19	0:0	6	2
op	123:21	0:0	4	.
water	123:22	0:0	4	x
op	123:24	0:0	4	-
water	123:26	0:0	4	r
call	123:28	123:39	4	*cos
arg	123:34	123:39	5	theta
water	123:34	0:0	6	theta
water	123:40	0:0	4	;
call	124:8	124:11	4	L
arg	124:10	124:11	5	3
water	124:10	0:0	6	3
op	124:12	0:0	4	.
water	124:13	0:0	4	y
op	124:15	0:0	4	=
call	124:17	124:20	4	L
arg	124:19	124:20	5	2
water	124:19	0:0	6	2
op	124:21	0:0	4	.
water	124:22	0:0	4	y
op	124:24	0:0	4	-
water	124:26	0:0	4	r
call	124:28	124:39	4	*sin
arg	124:34	124:39	5	theta
water	124:34	0:0	6	theta
water	124:40	0:0	4	;
water	125:8	0:0	4	theta
op	125:14	0:0	4	=
call	125:16	125:54	4	atan2
arg	125:22	125:37	5	L(0).y-L(2).y
call	125:22	125:25	6	L
arg	125:24	125:25	7	0
water	125:24	0:0	8	0
op	125:26	0:0	6	.
water	125:27	0:0	6	y
op	125:29	0:0	6	-
call	125:31	125:34	6	L
arg	125:33	125:34	7	2
water	125:33	0:0	8	2
op	125:35	0:0	6	.
water	125:36	0:0	6	y
arg	125:39	125:54	5	L(0).x-L(2).x
call	125:39	125:42	6	L
arg	125:41	125:42	7	0
water	125:41	0:0	8	0
op	125:43	0:0	6	.
water	125:44	0:0	6	x
op	125:46	0:0	6	-
call	125:48	125:51	6	L
arg	125:50	125:51	7	2
water	125:50	0:0	8	2
op	125:52	0:0	6	.
water	125:53	0:0	6	x
water	125:55	0:0	4	;
water	126:8	0:0	4	len
op	126:12	0:0	4	=
call	126:14	126:70	4	sqrt
arg	126:19	126:70	5	pow(L(0).x-L(2).x,2.)+pow(L(0).y-L(2).y,2.)
call	126:19	126:42	6	pow
arg	126:23	126:38	7	L(0).x-L(2).x
call	126:23	126:26	8	L
arg	126:25	126:26	9	0
water	126:25	0:0	10	0
op	126:27	0:0	8	.
water	126:28	0:0	8	x
op	126:30	0:0	8	-
call	126:32	126:35	8	L
arg	126:34	126:35	9	2
water	126:34	0:0	10	2
op	126:36	0:0	8	.
water	126:37	0:0	8	x
arg	126:40	126:42	7	2.
water	126:40	0:0	8	2
op	126:41	0:0	8	.
op	126:44	0:0	6	+
call	126:46	126:69	6	pow
arg	126:50	126:65	7	L(0).y-L(2).y
call	126:50	126:53	8	L
arg	126:52	126:53	9	0
water	126:52	0:0	10	0
op	126:54	0:0	8	.
water	126:55	0:0	8	y
op	126:57	0:0	8	-
call	126:59	126:62	8	L
arg	126:61	126:62	9	2
water	126:61	0:0	10	2
op	126:63	0:0	8	.
water	126:64	0:0	8	y
arg	126:67	126:69	7	2.
water	126:67	0:0	8	2
op	126:68	0:0	8	.
water	126:71	0:0	4	;
water	127:8	0:0	4	r
op	127:10	0:0	4	=
call	127:12	127:33	4	FFMIN
arg	127:18	127:24	5	radius
water	127:18	0:0	6	radius
arg	127:26	127:33	5	len/2
water	127:26	0:0	6	len
op	127:30	0:0	6	/
water	127:32	0:0	6	2
water	127:34	0:0	4	;
water	128:8	0:0	4	x
op	128:10	0:0	4	=
call	128:12	128:15	4	L
arg	128:14	128:15	5	2
water	128:14	0:0	6	2
op	128:16	0:0	4	.
water	128:17	0:0	4	x
op	128:19	0:0	4	+
water	128:21	0:0	4	r
call	128:23	128:34	4	*cos
arg	128:29	128:34	5	theta
water	128:29	0:0	6	theta
water	128:35	0:0	4	;
water	129:8	0:0	4	y
op	129:10	0:0	4	=
call	129:12	129:15	4	L
arg	129:14	129:15	5	2
water	129:14	0:0	6	2
op	129:16	0:0	4	.
water	129:17	0:0	4	y
op	129:19	0:0	4	+
water	129:21	0:0	4	r
call	129:23	129:34	4	*sin
arg	129:29	129:34	5	theta
water	129:29	0:0	6	theta
water	129:35	0:0	4	;
water	130:8	0:0	4	cx
op	130:11	0:0	4	=
water	130:13	0:0	4	(
call	130:14	130:17	4	L
arg	130:16	130:17	5	3
water	130:16	0:0	6	3
op	130:18	0:0	4	.
water	130:19	0:0	4	x
op	130:21	0:0	4	+
call	130:23	130:26	4	L
arg	130:25	130:26	5	2
water	130:25	0:0	6	2
op	130:27	0:0	4	.
water	130:28	0:0	4	x
op	130:30	0:0	4	+
water	130:32	0:0	4	x
water	130:33	0:0	4	)
op	130:35	0:0	4	/
water	130:37	0:0	4	3
water	130:38	0:0	4	;
water	131:8	0:0	4	cy
op	131:11	0:0	4	=
water	131:13	0:0	4	(
call	131:14	131:17	4	L
arg	131:16	131:17	5	3
water	131:16	0:0	6	3
op	131:18	0:0	4	.
water	131:19	0:0	4	y
op	131:21	0:0	4	+
call	131:23	131:26	4	L
arg	131:25	131:26	5	2
water	131:25	0:0	6	2
op	131:27	0:0	4	.
water	131:28	0:0	4	y
op	131:30	0:0	4	+
water	131:32	0:0	4	y
water	131:33	0:0	4	)
op	131:35	0:0	4	/
water	131:37	0:0	4	3
water	131:38	0:0	4	;
call	132:8	132:11	4	L
arg	132:10	132:11	5	2
water	132:10	0:0	6	2
op	132:12	0:0	4	.
water	132:13	0:0	4	x
op	132:15	0:0	4	=
water	132:17	0:0	4	x
water	132:18	0:0	4	;
call	133:8	133:11	4	L
arg	133:10	133:11	5	2
water	133:10	0:0	6	2
op	133:12	0:0	4	.
water	133:13	0:0	4	y
op	133:15	0:0	4	=
water	133:17	0:0	4	y
water	133:18	0:0	4	;
water	134:8	0:0	4	in1
op	134:13	0:0	4	=
water	134:15	0:0	4	cx
op	134:18	0:0	4	-
call	134:20	134:23	4	L
arg	134:22	134:23	5	3
water	134:22	0:0	6	3
op	134:24	0:0	4	.
water	134:25	0:0	4	x
water	134:26	0:0	4	;
water	135:8	0:0	4	out1
op	135:13	0:0	4	=
water	135:15	0:0	4	cy
op	135:18	0:0	4	-
call	135:20	135:23	4	L
arg	135:22	135:23	5	3
water	135:22	0:0	6	3
op	135:24	0:0	4	.
water	135:25	0:0	4	y
water	135:26	0:0	4	;
water	136:8	0:0	4	in2
op	136:13	0:0	4	=
call	136:15	136:18	4	L
arg	136:17	136:18	5	2
water	136:17	0:0	6	2
op	136:19	0:0	4	.
water	136:20	0:0	4	x
op	136:22	0:0	4	-
call	136:24	136:27	4	L
arg	136:26	136:27	5	3
water	136:26	0:0	6	3
op	136:28	0:0	4	.
water	136:29	0:0	4	x
water	136:30	0:0	4	;
water	137:8	0:0	4	out2
op	137:13	0:0	4	=
call	137:15	137:18	4	L
arg	137:17	137:18	5	2
water	137:17	0:0	6	2
op	137:19	0:0	4	.
water	137:20	0:0	4	y
op	137:22	0:0	4	-
call	137:24	137:27	4	L
arg	137:26	137:27	5	3
water	137:26	0:0	6	3
op	137:28	0:0	4	.
water	137:29	0:0	4	y
water	137:30	0:0	4	;
call	138:8	138:11	4	L
arg	138:10	138:11	5	3
water	138:10	0:0	6	3
op	138:12	0:0	4	.
water	138:13	0:0	4	a
op	138:15	0:0	4	=
water	138:17	0:0	4	(
water	138:18	0:0	4	out2
op	138:23	0:0	4	/
water	138:25	0:0	4	in2
op	138:29	0:0	4	-
water	138:31	0:0	4	out1
op	138:36	0:0	4	/
water	138:38	0:0	4	in1
water	138:41	0:0	4	)
op	138:43	0:0	4	/
water	138:45	0:0	4	(
water	138:46	0:0	4	in2
op	138:50	0:0	4	-
water	138:52	0:0	4	in1
water	138:55	0:0	4	)
water	138:56	0:0	4	;
call	139:8	139:11	4	L
arg	139:10	139:11	5	3
water	139:10	0:0	6	3
op	139:12	0:0	4	.
water	139:13	0:0	4	b
op	139:15	0:0	4	=
water	139:17	0:0	4	out1
op	139:22	0:0	4	/
water	139:24	0:0	4	in1
op	139:28	0:0	4	-
call	139:30	139:33	4	L
arg	139:32	139:33	5	3
water	139:32	0:0	6	3
op	139:34	0:0	4	.
water	139:35	0:0	4	a
op	139:37	0:0	4	*
water	139:39	0:0	4	in1
water	139:42	0:0	4	;
water	140:4	0:0	4	}
call	141:4	141:7	2	L
arg	141:6	141:7	3	3
water	141:6	0:0	4	3
op	141:8	0:0	2	.
water	141:9	0:0	2	x
op	141:11	0:0	2	=
water	141:13	0:0	2	0
water	141:14	0:0	2	;
call	142:4	142:7	2	L
arg	142:6	142:7	3	3
water	142:6	0:0	4	3
op	142:8	0:0	2	.
water	142:9	0:0	2	y
op	142:11	0:0	2	=
call	142:13	142:16	2	L
arg	142:15	142:16	3	2
water	142:15	0:0	4	2
op	142:17	0:0	2	.
water	142:18	0:0	2	y
water	142:19	0:0	2	;
water	143:4	0:0	2	s
op	143:5	0:0	2	->
water	143:7	0:0	2	in_min_lin
op	143:19	0:0	2	=
call	143:21	143:41	2	exp
arg	143:25	143:41	3	s->segments[1].x
water	143:25	0:0	4	s
op	143:26	0:0	4	->
water	143:28	0:0	4	segments
op	143:36	0:0	4	[
water	143:37	0:0	4	1
op	143:38	0:0	4	]
op	143:39	0:0	4	.
water	143:40	0:0	4	x
water	143:42	0:0	2	;
water	144:4	0:0	2	s
op	144:5	0:0	2	->
water	144:7	0:0	2	out_min_lin
op	144:19	0:0	2	=
call	144:21	144:41	2	exp
arg	144:25	144:41	3	s->segments[1].y
water	144:25	0:0	4	s
op	144:26	0:0	4	->
water	144:28	0:0	4	segments
op	144:36	0:0	4	[
water	144:37	0:0	4	1
op	144:38	0:0	4	]
op	144:39	0:0	4	.
water	144:40	0:0	4	y
water	144:42	0:0	2	;
for	145:4	156:4	2	(i = 0 ;i < channels;i ++)
forinit	145:9	145:14	3	i = 0 ;
water	145:9	0:0	4	i
op	145:11	0:0	4	=
water	145:13	0:0	4	0
water	145:14	0:0	4	;
cond	145:16	145:20	3	i < channels
water	145:16	0:0	4	i
op	145:18	0:0	4	<
water	145:20	0:0	4	channels
forexpr	145:30	145:31	3	i ++
water	145:30	0:0	4	i
op	145:31	0:0	4	++
stmts	145:35	156:4	3	
water	145:35	0:0	4	{
decl	146:8	146:39	4	ChanParam	*cp
op	146:22	0:0	4	=
op	146:24	0:0	4	&
water	146:25	0:0	4	s
op	146:26	0:0	4	->
water	146:28	0:0	4	channels
op	146:36	0:0	4	[
water	146:37	0:0	4	i
op	146:38	0:0	4	]
if	147:8	148:69	4	(cp -> attack > 1 . 0 / sample_rate)
cond	147:12	147:31	5	cp -> attack > 1 . 0 / sample_rate
water	147:12	0:0	6	cp
op	147:14	0:0	6	->
water	147:16	0:0	6	attack
op	147:23	0:0	6	>
water	147:25	0:0	6	1
op	147:26	0:0	6	.
water	147:27	0:0	6	0
op	147:29	0:0	6	/
water	147:31	0:0	6	sample_rate
stmts	148:12	148:69	5	
water	148:12	0:0	6	cp
op	148:14	0:0	6	->
water	148:16	0:0	6	attack
op	148:23	0:0	6	=
water	148:25	0:0	6	1
op	148:26	0:0	6	.
water	148:27	0:0	6	0
op	148:29	0:0	6	-
call	148:31	148:68	6	exp
arg	148:35	148:68	7	-1.0/(sample_rate*cp->attack)
op	148:35	0:0	8	-
water	148:36	0:0	8	1
op	148:37	0:0	8	.
water	148:38	0:0	8	0
op	148:40	0:0	8	/
water	148:42	0:0	8	(
water	148:43	0:0	8	sample_rate
op	148:55	0:0	8	*
water	148:57	0:0	8	cp
op	148:59	0:0	8	->
water	148:61	0:0	8	attack
water	148:67	0:0	8	)
water	148:69	0:0	6	;
else	149:8	150:28	4
stmts	150:12	150:28	5	
water	150:12	0:0	6	cp
op	150:14	0:0	6	->
water	150:16	0:0	6	attack
op	150:23	0:0	6	=
water	150:25	0:0	6	1
op	150:26	0:0	6	.
water	150:27	0:0	6	0
water	150:28	0:0	6	;
if	151:8	152:67	4	(cp -> decay > 1 . 0 / sample_rate)
cond	151:12	151:30	5	cp -> decay > 1 . 0 / sample_rate
water	151:12	0:0	6	cp
op	151:14	0:0	6	->
water	151:16	0:0	6	decay
op	151:22	0:0	6	>
water	151:24	0:0	6	1
op	151:25	0:0	6	.
water	151:26	0:0	6	0
op	151:28	0:0	6	/
water	151:30	0:0	6	sample_rate
stmts	152:12	152:67	5	
water	152:12	0:0	6	cp
op	152:14	0:0	6	->
water	152:16	0:0	6	decay
op	152:22	0:0	6	=
water	152:24	0:0	6	1
op	152:25	0:0	6	.
water	152:26	0:0	6	0
op	152:28	0:0	6	-
call	152:30	152:66	6	exp
arg	152:34	152:66	7	-1.0/(sample_rate*cp->decay)
op	152:34	0:0	8	-
water	152:35	0:0	8	1
op	152:36	0:0	8	.
water	152:37	0:0	8	0
op	152:39	0:0	8	/
water	152:41	0:0	8	(
water	152:42	0:0	8	sample_rate
op	152:54	0:0	8	*
water	152:56	0:0	8	cp
op	152:58	0:0	8	->
water	152:60	0:0	8	decay
water	152:65	0:0	8	)
water	152:67	0:0	6	;
else	153:8	154:27	4
stmts	154:12	154:27	5	
water	154:12	0:0	6	cp
op	154:14	0:0	6	->
water	154:16	0:0	6	decay
op	154:22	0:0	6	=
water	154:24	0:0	6	1
op	154:25	0:0	6	.
water	154:26	0:0	6	0
water	154:27	0:0	6	;
water	155:8	0:0	4	cp
op	155:10	0:0	4	->
water	155:12	0:0	4	volume
op	155:19	0:0	4	=
call	155:21	155:53	4	pow
arg	155:25	155:29	5	10.0
water	155:25	0:0	6	10
op	155:27	0:0	6	.
water	155:28	0:0	6	0
arg	155:31	155:53	5	s->initial_volume/20
water	155:31	0:0	6	s
op	155:32	0:0	6	->
water	155:34	0:0	6	initial_volume
op	155:49	0:0	6	/
water	155:51	0:0	6	20
water	155:54	0:0	4	;
water	156:4	0:0	4	}
water	157:4	0:0	2	s
op	157:5	0:0	2	->
water	157:7	0:0	2	delay_samples
op	157:21	0:0	2	=
water	157:23	0:0	2	s
op	157:24	0:0	2	->
water	157:26	0:0	2	delay
op	157:32	0:0	2	*
water	157:34	0:0	2	sample_rate
water	157:45	0:0	2	;
if	158:4	161:4	2	(s -> delay_samples <= 0)
cond	158:8	158:28	3	s -> delay_samples <= 0
water	158:8	0:0	4	s
op	158:9	0:0	4	->
water	158:11	0:0	4	delay_samples
op	158:25	0:0	4	<=
water	158:28	0:0	4	0
stmts	158:31	161:4	3	
water	158:31	0:0	4	{
water	159:8	0:0	4	s
op	159:9	0:0	4	->
water	159:11	0:0	4	compand
op	159:19	0:0	4	=
water	159:21	0:0	4	compand_nodelay
water	159:36	0:0	4	;
return	160:8	160:16	4	0
water	160:15	0:0	5	0
water	161:4	0:0	4	}
water	162:4	0:0	2	s
op	162:5	0:0	2	->
water	162:7	0:0	2	delay_frame
op	162:19	0:0	2	=
call	162:21	162:36	2	av_frame_alloc
water	162:37	0:0	2	;
if	163:4	166:4	2	(! s -> delay_frame)
cond	163:8	163:12	3	! s -> delay_frame
op	163:8	0:0	4	!
water	163:9	0:0	4	s
op	163:10	0:0	4	->
water	163:12	0:0	4	delay_frame
stmts	163:25	166:4	3	
water	163:25	0:0	4	{
call	164:8	164:18	4	uninit
arg	164:15	164:18	5	ctx
water	164:15	0:0	6	ctx
water	164:19	0:0	4	;
return	165:8	165:30	4	AVERROR(ENOMEM)
call	165:15	165:29	5	AVERROR
arg	165:23	165:29	6	ENOMEM
water	165:23	0:0	7	ENOMEM
water	166:4	0:0	4	}
water	167:4	0:0	2	s
op	167:5	0:0	2	->
water	167:7	0:0	2	delay_frame
op	167:18	0:0	2	->
water	167:20	0:0	2	format
op	167:35	0:0	2	=
water	167:37	0:0	2	outlink
op	167:44	0:0	2	->
water	167:46	0:0	2	format
water	167:52	0:0	2	;
water	168:4	0:0	2	s
op	168:5	0:0	2	->
water	168:7	0:0	2	delay_frame
op	168:18	0:0	2	->
water	168:20	0:0	2	nb_samples
op	168:35	0:0	2	=
water	168:37	0:0	2	s
op	168:38	0:0	2	->
water	168:40	0:0	2	delay_samples
water	168:53	0:0	2	;
water	169:4	0:0	2	s
op	169:5	0:0	2	->
water	169:7	0:0	2	delay_frame
op	169:18	0:0	2	->
water	169:20	0:0	2	channel_layout
op	169:35	0:0	2	=
water	169:37	0:0	2	outlink
op	169:44	0:0	2	->
water	169:46	0:0	2	channel_layout
water	169:60	0:0	2	;
water	170:4	0:0	2	err
op	170:8	0:0	2	=
call	170:10	170:48	2	av_frame_get_buffer
arg	170:30	170:44	3	s->delay_frame
water	170:30	0:0	4	s
op	170:31	0:0	4	->
water	170:33	0:0	4	delay_frame
arg	170:46	170:48	3	32
water	170:46	0:0	4	32
water	170:49	0:0	2	;
if	171:4	172:18	2	(err)
cond	171:8	171:8	3	err
water	171:8	0:0	4	err
stmts	172:8	172:18	3	
return	172:8	172:18	4	err
water	172:15	0:0	5	err
water	173:4	0:0	2	outlink
op	173:11	0:0	2	->
water	173:13	0:0	2	flags
op	173:19	0:0	2	|=
water	173:22	0:0	2	FF_LINK_FLAG_REQUEST_LOOP
water	173:47	0:0	2	;
water	174:4	0:0	2	s
op	174:5	0:0	2	->
water	174:7	0:0	2	compand
op	174:15	0:0	2	=
water	174:17	0:0	2	compand_delay
water	174:30	0:0	2	;
return	175:4	175:12	2	0
water	175:11	0:0	3	0
