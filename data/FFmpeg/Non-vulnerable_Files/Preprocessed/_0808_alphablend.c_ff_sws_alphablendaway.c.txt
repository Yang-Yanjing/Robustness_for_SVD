func	1:0	144:0	0	int	ff_sws_alphablendaway
params	1:25	0:0	1	
param	1:26	1:39	2	SwsContext *	c
param	1:41	1:61	2	const uint8_t *	src[]
param	2:26	2:41	2	int	srcStride[]
param	2:43	2:56	2	int	srcSliceY
param	2:58	2:71	2	int	srcSliceH
param	3:26	3:40	2	uint8_t *	dst[]
param	3:42	3:57	2	int	dstStride[]
stmnts	0:0	143:12	1	
decl	5:4	5:70	2	const AVPixFmtDescriptor	*desc
op	5:35	0:0	2	=
call	5:37	5:69	3	av_pix_fmt_desc_get
arg	5:57	5:69	4	c->srcFormat
water	5:57	0:0	5	c
op	5:58	0:0	5	->
water	5:60	0:0	5	srcFormat
decl	6:4	6:43	2	int	nb_components
op	6:22	0:0	2	=
water	6:24	0:0	2	desc
op	6:28	0:0	2	->
water	6:30	0:0	2	nb_components
decl	7:4	7:19	2	int	plane
water	7:13	0:0	2	,
decl	7:4	7:19	2	int	x
water	7:16	0:0	2	,
decl	7:4	7:19	2	int	y
decl	8:4	8:50	2	int	plane_count
op	8:20	0:0	2	=
call	8:22	8:41	3	isGray
arg	8:29	8:41	4	c->srcFormat
water	8:29	0:0	5	c
op	8:30	0:0	5	->
water	8:32	0:0	5	srcFormat
water	8:43	0:0	2	?
water	8:45	0:0	2	1
water	8:47	0:0	2	:
water	8:49	0:0	2	3
decl	9:4	9:54	2	int	sixteen_bits
op	9:21	0:0	2	=
water	9:23	0:0	2	desc
op	9:27	0:0	2	->
water	9:29	0:0	2	comp
op	9:33	0:0	2	[
water	9:34	0:0	2	0
op	9:35	0:0	2	]
op	9:36	0:0	2	.
water	9:37	0:0	2	depth_minus1
op	9:50	0:0	2	>=
water	9:53	0:0	2	8
water	10:4	0:0	2	unsigned
water	10:13	0:0	2	off
op	10:20	0:0	2	=
water	10:22	0:0	2	1
op	10:23	0:0	2	<<
water	10:25	0:0	2	desc
op	10:29	0:0	2	->
water	10:31	0:0	2	comp
op	10:35	0:0	2	[
water	10:36	0:0	2	0
op	10:37	0:0	2	]
op	10:38	0:0	2	.
water	10:39	0:0	2	depth_minus1
water	10:51	0:0	2	;
water	11:4	0:0	2	unsigned
water	11:13	0:0	2	shift
op	11:20	0:0	2	=
water	11:22	0:0	2	desc
op	11:26	0:0	2	->
water	11:28	0:0	2	comp
op	11:32	0:0	2	[
water	11:33	0:0	2	0
op	11:34	0:0	2	]
op	11:35	0:0	2	.
water	11:36	0:0	2	depth_minus1
op	11:49	0:0	2	+
water	11:51	0:0	2	1
water	11:52	0:0	2	;
water	12:4	0:0	2	unsigned
water	12:13	0:0	2	max
op	12:20	0:0	2	=
water	12:22	0:0	2	(
water	12:23	0:0	2	1
op	12:24	0:0	2	<<
water	12:26	0:0	2	shift
water	12:31	0:0	2	)
op	12:33	0:0	2	-
water	12:35	0:0	2	1
water	12:36	0:0	2	;
water	13:4	0:0	2	int
water	13:8	0:0	2	target_table
op	13:20	0:0	2	[
water	13:21	0:0	2	2
op	13:22	0:0	2	]
op	13:23	0:0	2	[
water	13:24	0:0	2	3
op	13:25	0:0	2	]
water	13:26	0:0	2	;
for	14:4	22:4	2	(plane = 0 ;plane < plane_count;plane ++)
forinit	14:9	14:18	3	plane = 0 ;
water	14:9	0:0	4	plane
op	14:15	0:0	4	=
water	14:17	0:0	4	0
water	14:18	0:0	4	;
cond	14:20	14:28	3	plane < plane_count
water	14:20	0:0	4	plane
op	14:26	0:0	4	<
water	14:28	0:0	4	plane_count
forexpr	14:41	14:46	3	plane ++
water	14:41	0:0	4	plane
op	14:46	0:0	4	++
stmts	14:50	22:4	3	
water	14:50	0:0	4	{
decl	15:8	15:24	4	int	a
op	15:14	0:0	4	=
water	15:16	0:0	4	0
water	15:17	0:0	4	,
decl	15:8	15:24	4	int	b
op	15:21	0:0	4	=
water	15:23	0:0	4	0
if	16:8	19:8	4	(c -> alphablend == SWS_ALPHA_BLEND_CHECKERBOARD)
cond	16:12	16:29	5	c -> alphablend == SWS_ALPHA_BLEND_CHECKERBOARD
water	16:12	0:0	6	c
op	16:13	0:0	6	->
water	16:15	0:0	6	alphablend
op	16:26	0:0	6	==
water	16:29	0:0	6	SWS_ALPHA_BLEND_CHECKERBOARD
stmts	16:59	19:8	5	
water	16:59	0:0	6	{
water	17:12	0:0	6	a
op	17:14	0:0	6	=
water	17:16	0:0	6	(
water	17:17	0:0	6	1
op	17:18	0:0	6	<<
water	17:20	0:0	6	desc
op	17:24	0:0	6	->
water	17:26	0:0	6	comp
op	17:30	0:0	6	[
water	17:31	0:0	6	0
op	17:32	0:0	6	]
op	17:33	0:0	6	.
water	17:34	0:0	6	depth_minus1
water	17:46	0:0	6	)
op	17:47	0:0	6	/
water	17:48	0:0	6	2
water	17:49	0:0	6	;
water	18:12	0:0	6	b
op	18:14	0:0	6	=
water	18:16	0:0	6	3
op	18:17	0:0	6	*
water	18:18	0:0	6	(
water	18:19	0:0	6	1
op	18:20	0:0	6	<<
water	18:22	0:0	6	desc
op	18:26	0:0	6	->
water	18:28	0:0	6	comp
op	18:32	0:0	6	[
water	18:33	0:0	6	0
op	18:34	0:0	6	]
op	18:35	0:0	6	.
water	18:36	0:0	6	depth_minus1
water	18:48	0:0	6	)
op	18:49	0:0	6	/
water	18:50	0:0	6	2
water	18:51	0:0	6	;
water	19:8	0:0	6	}
water	20:8	0:0	4	target_table
op	20:20	0:0	4	[
water	20:21	0:0	4	0
op	20:22	0:0	4	]
op	20:23	0:0	4	[
water	20:24	0:0	4	plane
op	20:29	0:0	4	]
op	20:31	0:0	4	=
water	20:33	0:0	4	plane
op	20:39	0:0	4	&&
op	20:42	0:0	4	!
water	20:43	0:0	4	(
water	20:44	0:0	4	desc
op	20:48	0:0	4	->
water	20:50	0:0	4	flags
op	20:56	0:0	4	&
water	20:58	0:0	4	AV_PIX_FMT_FLAG_RGB
water	20:77	0:0	4	)
water	20:79	0:0	4	?
water	20:81	0:0	4	1
op	20:82	0:0	4	<<
water	20:84	0:0	4	desc
op	20:88	0:0	4	->
water	20:90	0:0	4	comp
op	20:94	0:0	4	[
water	20:95	0:0	4	0
op	20:96	0:0	4	]
op	20:97	0:0	4	.
water	20:98	0:0	4	depth_minus1
water	20:111	0:0	4	:
water	20:113	0:0	4	a
water	20:114	0:0	4	;
water	21:8	0:0	4	target_table
op	21:20	0:0	4	[
water	21:21	0:0	4	1
op	21:22	0:0	4	]
op	21:23	0:0	4	[
water	21:24	0:0	4	plane
op	21:29	0:0	4	]
op	21:31	0:0	4	=
water	21:33	0:0	4	plane
op	21:39	0:0	4	&&
op	21:42	0:0	4	!
water	21:43	0:0	4	(
water	21:44	0:0	4	desc
op	21:48	0:0	4	->
water	21:50	0:0	4	flags
op	21:56	0:0	4	&
water	21:58	0:0	4	AV_PIX_FMT_FLAG_RGB
water	21:77	0:0	4	)
water	21:79	0:0	4	?
water	21:81	0:0	4	1
op	21:82	0:0	4	<<
water	21:84	0:0	4	desc
op	21:88	0:0	4	->
water	21:90	0:0	4	comp
op	21:94	0:0	4	[
water	21:95	0:0	4	0
op	21:96	0:0	4	]
op	21:97	0:0	4	.
water	21:98	0:0	4	depth_minus1
water	21:111	0:0	4	:
water	21:113	0:0	4	b
water	21:114	0:0	4	;
water	22:4	0:0	4	}
call	23:4	23:47	2	av_assert0
arg	23:15	23:47	3	plane_count==nb_components-1
water	23:15	0:0	4	plane_count
op	23:27	0:0	4	==
water	23:30	0:0	4	nb_components
op	23:44	0:0	4	-
water	23:46	0:0	4	1
water	23:48	0:0	2	;
if	24:4	103:4	2	(desc -> flags & AV_PIX_FMT_FLAG_PLANAR)
cond	24:8	24:22	3	desc -> flags & AV_PIX_FMT_FLAG_PLANAR
water	24:8	0:0	4	desc
op	24:12	0:0	4	->
water	24:14	0:0	4	flags
op	24:20	0:0	4	&
water	24:22	0:0	4	AV_PIX_FMT_FLAG_PLANAR
stmts	24:46	103:4	3	
water	24:46	0:0	4	{
for	25:8	102:8	4	(plane = 0 ;plane < plane_count;plane ++)
forinit	25:13	25:22	5	plane = 0 ;
water	25:13	0:0	6	plane
op	25:19	0:0	6	=
water	25:21	0:0	6	0
water	25:22	0:0	6	;
cond	25:24	25:32	5	plane < plane_count
water	25:24	0:0	6	plane
op	25:30	0:0	6	<
water	25:32	0:0	6	plane_count
forexpr	25:45	25:50	5	plane ++
water	25:45	0:0	6	plane
op	25:50	0:0	6	++
stmts	25:54	102:8	5	
water	25:54	0:0	6	{
decl	26:12	26:48	6	int	w
op	26:18	0:0	6	=
water	26:20	0:0	6	plane
water	26:26	0:0	6	?
water	26:28	0:0	6	c
op	26:29	0:0	6	->
water	26:31	0:0	6	chrSrcW
water	26:39	0:0	6	:
water	26:41	0:0	6	c
op	26:42	0:0	6	->
water	26:44	0:0	6	srcW
decl	27:12	27:60	6	int	x_subsample
op	27:28	0:0	6	=
water	27:30	0:0	6	plane
water	27:36	0:0	6	?
water	27:38	0:0	6	desc
op	27:42	0:0	6	->
water	27:44	0:0	6	log2_chroma_w
water	27:57	0:0	6	:
water	27:59	0:0	6	0
decl	28:12	28:60	6	int	y_subsample
op	28:28	0:0	6	=
water	28:30	0:0	6	plane
water	28:36	0:0	6	?
water	28:38	0:0	6	desc
op	28:42	0:0	6	->
water	28:44	0:0	6	log2_chroma_h
water	28:57	0:0	6	:
water	28:59	0:0	6	0
for	29:12	101:12	6	(y = srcSliceY >> y_subsample ;y <FF_CEIL_RSHIFT (srcSliceH ,y_subsample );y ++)
forinit	29:17	29:45	7	y = srcSliceY >> y_subsample ;
water	29:17	0:0	8	y
op	29:19	0:0	8	=
water	29:21	0:0	8	srcSliceY
op	29:31	0:0	8	>>
water	29:34	0:0	8	y_subsample
water	29:45	0:0	8	;
cond	29:47	29:88	7	y <FF_CEIL_RSHIFT (srcSliceH ,y_subsample )
water	29:47	0:0	8	y
op	29:49	0:0	8	<
call	29:51	29:88	8	FF_CEIL_RSHIFT
arg	29:66	29:75	9	srcSliceH
water	29:66	0:0	10	srcSliceH
arg	29:77	29:88	9	y_subsample
water	29:77	0:0	10	y_subsample
forexpr	29:91	29:92	7	y ++
water	29:91	0:0	8	y
op	29:92	0:0	8	++
stmts	29:96	101:12	7	
water	29:96	0:0	8	{
if	30:16	74:16	8	(x_subsample || y_subsample)
cond	30:20	30:35	9	x_subsample || y_subsample
water	30:20	0:0	10	x_subsample
op	30:32	0:0	10	||
water	30:35	0:0	10	y_subsample
stmts	30:48	74:16	9	
water	30:48	0:0	10	{
decl	31:20	31:29	10	int	alpha
water	32:20	0:0	10	unsigned
water	32:29	0:0	10	u
water	32:30	0:0	10	;
if	33:20	59:20	10	(sixteen_bits)
cond	33:24	33:24	11	sixteen_bits
water	33:24	0:0	12	sixteen_bits
stmts	33:38	59:20	11	
water	33:38	0:0	12	{
decl	34:24	34:74	12	ptrdiff_t	alpha_step
op	34:45	0:0	12	=
water	34:47	0:0	12	srcStride
op	34:56	0:0	12	[
water	34:57	0:0	12	plane_count
op	34:68	0:0	12	]
op	34:70	0:0	12	>>
water	34:73	0:0	12	1
decl	35:24	35:110	12	const uint16_t	*s
op	35:42	0:0	12	=
call	35:44	35:109	13	(constuint16_t*)
arg	35:63	35:109	14	src[plane]+srcStride[plane]*y
water	35:63	0:0	15	src
op	35:66	0:0	15	[
water	35:67	0:0	15	plane
op	35:78	0:0	15	]
op	35:80	0:0	15	+
water	35:83	0:0	15	srcStride
op	35:92	0:0	15	[
water	35:93	0:0	15	plane
op	35:104	0:0	15	]
op	35:106	0:0	15	*
water	35:108	0:0	15	y
decl	36:24	36:126	12	const uint16_t	*a
op	36:42	0:0	12	=
call	36:44	36:125	13	(constuint16_t*)
arg	36:63	36:125	14	src[plane_count]+(srcStride[plane_count]*y<<y_subsample)
water	36:63	0:0	15	src
op	36:66	0:0	15	[
water	36:67	0:0	15	plane_count
op	36:78	0:0	15	]
op	36:80	0:0	15	+
water	36:82	0:0	15	(
water	36:83	0:0	15	srcStride
op	36:92	0:0	15	[
water	36:93	0:0	15	plane_count
op	36:104	0:0	15	]
op	36:106	0:0	15	*
water	36:108	0:0	15	y
op	36:110	0:0	15	<<
water	36:113	0:0	15	y_subsample
water	36:124	0:0	15	)
decl	37:30	37:110	12	uint16_t	*d
op	37:42	0:0	12	=
call	37:44	37:109	13	(uint16_t*)
arg	37:63	37:109	14	dst[plane]+dstStride[plane]*y
water	37:63	0:0	15	dst
op	37:66	0:0	15	[
water	37:67	0:0	15	plane
op	37:78	0:0	15	]
op	37:80	0:0	15	+
water	37:83	0:0	15	dstStride
op	37:92	0:0	15	[
water	37:93	0:0	15	plane
op	37:104	0:0	15	]
op	37:106	0:0	15	*
water	37:108	0:0	15	y
if	38:24	48:24	12	(( !isBE (c -> srcFormat ) ) == ! HAVE_BIGENDIAN)
cond	38:28	38:54	13	( !isBE (c -> srcFormat ) ) == ! HAVE_BIGENDIAN
water	38:28	0:0	14	(
op	38:29	0:0	14	!
call	38:30	38:47	14	isBE
arg	38:35	38:47	15	c->srcFormat
water	38:35	0:0	16	c
op	38:36	0:0	16	->
water	38:38	0:0	16	srcFormat
water	38:48	0:0	14	)
op	38:50	0:0	14	==
op	38:53	0:0	14	!
water	38:54	0:0	14	HAVE_BIGENDIAN
stmts	38:70	48:24	13	
water	38:70	0:0	14	{
for	39:28	47:28	14	(x = 0 ;x < w;x ++)
forinit	39:33	39:38	15	x = 0 ;
water	39:33	0:0	16	x
op	39:35	0:0	16	=
water	39:37	0:0	16	0
water	39:38	0:0	16	;
cond	39:40	39:44	15	x < w
water	39:40	0:0	16	x
op	39:42	0:0	16	<
water	39:44	0:0	16	w
forexpr	39:47	39:48	15	x ++
water	39:47	0:0	16	x
op	39:48	0:0	16	++
stmts	39:52	47:28	15	
water	39:52	0:0	16	{
if	40:32	43:32	16	(y_subsample)
cond	40:36	40:36	17	y_subsample
water	40:36	0:0	18	y_subsample
stmts	40:49	43:32	17	
water	40:49	0:0	18	{
water	41:36	0:0	18	alpha
op	41:42	0:0	18	=
water	41:44	0:0	18	(
water	41:45	0:0	18	a
op	41:46	0:0	18	[
water	41:47	0:0	18	2
op	41:48	0:0	18	*
water	41:49	0:0	18	x
op	41:50	0:0	18	]
op	41:65	0:0	18	+
water	41:67	0:0	18	a
op	41:68	0:0	18	[
water	41:69	0:0	18	2
op	41:70	0:0	18	*
water	41:71	0:0	18	x
op	41:73	0:0	18	+
water	41:75	0:0	18	1
op	41:76	0:0	18	]
op	41:78	0:0	18	+
water	41:80	0:0	18	2
op	41:82	0:0	18	+
water	42:45	0:0	18	a
op	42:46	0:0	18	[
water	42:47	0:0	18	2
op	42:48	0:0	18	*
water	42:49	0:0	18	x
op	42:51	0:0	18	+
water	42:53	0:0	18	alpha_step
op	42:63	0:0	18	]
op	42:65	0:0	18	+
water	42:67	0:0	18	a
op	42:68	0:0	18	[
water	42:69	0:0	18	2
op	42:70	0:0	18	*
water	42:71	0:0	18	x
op	42:73	0:0	18	+
water	42:75	0:0	18	alpha_step
op	42:86	0:0	18	+
water	42:88	0:0	18	1
op	42:89	0:0	18	]
water	42:90	0:0	18	)
op	42:92	0:0	18	>>
water	42:95	0:0	18	2
water	42:96	0:0	18	;
water	43:32	0:0	18	}
else	43:34	44:70	16
stmts	44:36	44:70	17	
water	44:36	0:0	18	alpha
op	44:42	0:0	18	=
water	44:44	0:0	18	(
water	44:45	0:0	18	a
op	44:46	0:0	18	[
water	44:47	0:0	18	2
op	44:48	0:0	18	*
water	44:49	0:0	18	x
op	44:50	0:0	18	]
op	44:52	0:0	18	+
water	44:54	0:0	18	a
op	44:55	0:0	18	[
water	44:56	0:0	18	2
op	44:57	0:0	18	*
water	44:58	0:0	18	x
op	44:60	0:0	18	+
water	44:62	0:0	18	1
op	44:63	0:0	18	]
water	44:64	0:0	18	)
op	44:66	0:0	18	>>
water	44:69	0:0	18	1
water	44:70	0:0	18	;
water	45:32	0:0	16	u
op	45:34	0:0	16	=
water	45:36	0:0	16	s
op	45:37	0:0	16	[
water	45:38	0:0	16	x
op	45:39	0:0	16	]
op	45:40	0:0	16	*
water	45:41	0:0	16	alpha
op	45:47	0:0	16	+
water	45:49	0:0	16	target_table
op	45:61	0:0	16	[
water	45:62	0:0	16	(
water	45:63	0:0	16	(
water	45:64	0:0	16	x
op	45:65	0:0	16	^
water	45:66	0:0	16	y
water	45:67	0:0	16	)
op	45:68	0:0	16	>>
water	45:70	0:0	16	5
water	45:71	0:0	16	)
op	45:72	0:0	16	&
water	45:73	0:0	16	1
op	45:74	0:0	16	]
op	45:75	0:0	16	[
water	45:76	0:0	16	plane
op	45:81	0:0	16	]
op	45:82	0:0	16	*
water	45:83	0:0	16	(
water	45:84	0:0	16	max
op	45:87	0:0	16	-
water	45:88	0:0	16	alpha
water	45:93	0:0	16	)
op	45:95	0:0	16	+
water	45:97	0:0	16	off
water	45:100	0:0	16	;
water	46:32	0:0	16	d
op	46:33	0:0	16	[
water	46:34	0:0	16	x
op	46:35	0:0	16	]
op	46:37	0:0	16	=
call	46:39	46:82	16	av_clip
arg	46:47	46:74	17	(u+(u>>shift))>>shift
water	46:47	0:0	18	(
water	46:48	0:0	18	u
op	46:50	0:0	18	+
water	46:52	0:0	18	(
water	46:53	0:0	18	u
op	46:55	0:0	18	>>
water	46:58	0:0	18	shift
water	46:63	0:0	18	)
water	46:64	0:0	18	)
op	46:66	0:0	18	>>
water	46:69	0:0	18	shift
arg	46:76	46:77	17	0
water	46:76	0:0	18	0
arg	46:79	46:82	17	max
water	46:79	0:0	18	max
water	46:83	0:0	16	;
water	47:28	0:0	16	}
water	48:24	0:0	14	}
else	48:26	58:24	12
stmts	48:31	58:24	13	
water	48:31	0:0	14	{
for	49:28	57:28	14	(x = 0 ;x < w;x ++)
forinit	49:33	49:38	15	x = 0 ;
water	49:33	0:0	16	x
op	49:35	0:0	16	=
water	49:37	0:0	16	0
water	49:38	0:0	16	;
cond	49:40	49:44	15	x < w
water	49:40	0:0	16	x
op	49:42	0:0	16	<
water	49:44	0:0	16	w
forexpr	49:47	49:48	15	x ++
water	49:47	0:0	16	x
op	49:48	0:0	16	++
stmts	49:52	57:28	15	
water	49:52	0:0	16	{
if	50:32	53:32	16	(y_subsample)
cond	50:36	50:36	17	y_subsample
water	50:36	0:0	18	y_subsample
stmts	50:49	53:32	17	
water	50:49	0:0	18	{
water	51:36	0:0	18	alpha
op	51:42	0:0	18	=
water	51:44	0:0	18	(
call	51:45	51:62	18	av_bswap16
arg	51:56	51:62	19	a[2*x]
water	51:56	0:0	20	a
op	51:57	0:0	20	[
water	51:58	0:0	20	2
op	51:59	0:0	20	*
water	51:60	0:0	20	x
op	51:61	0:0	20	]
op	51:77	0:0	18	+
call	51:79	51:100	18	av_bswap16
arg	51:90	51:100	19	a[2*x+1]
water	51:90	0:0	20	a
op	51:91	0:0	20	[
water	51:92	0:0	20	2
op	51:93	0:0	20	*
water	51:94	0:0	20	x
op	51:96	0:0	20	+
water	51:98	0:0	20	1
op	51:99	0:0	20	]
op	51:102	0:0	18	+
water	51:104	0:0	18	2
op	51:106	0:0	18	+
call	52:45	52:75	18	av_bswap16
arg	52:56	52:75	19	a[2*x+alpha_step]
water	52:56	0:0	20	a
op	52:57	0:0	20	[
water	52:58	0:0	20	2
op	52:59	0:0	20	*
water	52:60	0:0	20	x
op	52:62	0:0	20	+
water	52:64	0:0	20	alpha_step
op	52:74	0:0	20	]
op	52:77	0:0	18	+
call	52:79	52:113	18	av_bswap16
arg	52:90	52:113	19	a[2*x+alpha_step+1]
water	52:90	0:0	20	a
op	52:91	0:0	20	[
water	52:92	0:0	20	2
op	52:93	0:0	20	*
water	52:94	0:0	20	x
op	52:96	0:0	20	+
water	52:98	0:0	20	alpha_step
op	52:109	0:0	20	+
water	52:111	0:0	20	1
op	52:112	0:0	20	]
water	52:114	0:0	18	)
op	52:116	0:0	18	>>
water	52:119	0:0	18	2
water	52:120	0:0	18	;
water	53:32	0:0	18	}
else	53:34	54:94	16
stmts	54:36	54:94	17	
water	54:36	0:0	18	alpha
op	54:42	0:0	18	=
water	54:44	0:0	18	(
call	54:45	54:62	18	av_bswap16
arg	54:56	54:62	19	a[2*x]
water	54:56	0:0	20	a
op	54:57	0:0	20	[
water	54:58	0:0	20	2
op	54:59	0:0	20	*
water	54:60	0:0	20	x
op	54:61	0:0	20	]
op	54:64	0:0	18	+
call	54:66	54:87	18	av_bswap16
arg	54:77	54:87	19	a[2*x+1]
water	54:77	0:0	20	a
op	54:78	0:0	20	[
water	54:79	0:0	20	2
op	54:80	0:0	20	*
water	54:81	0:0	20	x
op	54:83	0:0	20	+
water	54:85	0:0	20	1
op	54:86	0:0	20	]
water	54:88	0:0	18	)
op	54:90	0:0	18	>>
water	54:93	0:0	18	1
water	54:94	0:0	18	;
water	55:32	0:0	16	u
op	55:34	0:0	16	=
call	55:36	55:51	16	av_bswap16
arg	55:47	55:51	17	s[x]
water	55:47	0:0	18	s
op	55:48	0:0	18	[
water	55:49	0:0	18	x
op	55:50	0:0	18	]
op	55:52	0:0	16	*
water	55:53	0:0	16	alpha
op	55:59	0:0	16	+
water	55:61	0:0	16	target_table
op	55:73	0:0	16	[
water	55:74	0:0	16	(
water	55:75	0:0	16	(
water	55:76	0:0	16	x
op	55:77	0:0	16	^
water	55:78	0:0	16	y
water	55:79	0:0	16	)
op	55:80	0:0	16	>>
water	55:82	0:0	16	5
water	55:83	0:0	16	)
op	55:84	0:0	16	&
water	55:85	0:0	16	1
op	55:86	0:0	16	]
op	55:87	0:0	16	[
water	55:88	0:0	16	plane
op	55:93	0:0	16	]
op	55:94	0:0	16	*
water	55:95	0:0	16	(
water	55:96	0:0	16	max
op	55:99	0:0	16	-
water	55:100	0:0	16	alpha
water	55:105	0:0	16	)
op	55:107	0:0	16	+
water	55:109	0:0	16	off
water	55:112	0:0	16	;
water	56:32	0:0	16	d
op	56:33	0:0	16	[
water	56:34	0:0	16	x
op	56:35	0:0	16	]
op	56:37	0:0	16	=
call	56:39	56:82	16	av_clip
arg	56:47	56:74	17	(u+(u>>shift))>>shift
water	56:47	0:0	18	(
water	56:48	0:0	18	u
op	56:50	0:0	18	+
water	56:52	0:0	18	(
water	56:53	0:0	18	u
op	56:55	0:0	18	>>
water	56:58	0:0	18	shift
water	56:63	0:0	18	)
water	56:64	0:0	18	)
op	56:66	0:0	18	>>
water	56:69	0:0	18	shift
arg	56:76	56:77	17	0
water	56:76	0:0	18	0
arg	56:79	56:82	17	max
water	56:79	0:0	18	max
water	56:83	0:0	16	;
water	57:28	0:0	16	}
water	58:24	0:0	14	}
water	59:20	0:0	12	}
else	59:22	73:20	10
stmts	59:27	73:20	11	
water	59:27	0:0	12	{
decl	60:24	60:69	12	ptrdiff_t	alpha_step
op	60:45	0:0	12	=
water	60:47	0:0	12	srcStride
op	60:56	0:0	12	[
water	60:57	0:0	12	plane_count
op	60:68	0:0	12	]
decl	61:24	61:82	12	const uint8_t	*s
op	61:41	0:0	12	=
water	61:43	0:0	12	src
op	61:46	0:0	12	[
water	61:47	0:0	12	plane
op	61:58	0:0	12	]
op	61:60	0:0	12	+
water	61:62	0:0	12	srcStride
op	61:71	0:0	12	[
water	61:72	0:0	12	plane
op	61:77	0:0	12	]
op	61:79	0:0	12	*
water	61:81	0:0	12	y
decl	62:24	62:105	12	const uint8_t	*a
op	62:41	0:0	12	=
water	62:43	0:0	12	src
op	62:46	0:0	12	[
water	62:47	0:0	12	plane_count
op	62:58	0:0	12	]
op	62:60	0:0	12	+
water	62:62	0:0	12	(
water	62:63	0:0	12	srcStride
op	62:72	0:0	12	[
water	62:73	0:0	12	plane_count
op	62:84	0:0	12	]
op	62:86	0:0	12	*
water	62:88	0:0	12	y
op	62:90	0:0	12	<<
water	62:93	0:0	12	y_subsample
water	62:104	0:0	12	)
decl	63:30	63:82	12	uint8_t	*d
op	63:41	0:0	12	=
water	63:43	0:0	12	dst
op	63:46	0:0	12	[
water	63:47	0:0	12	plane
op	63:58	0:0	12	]
op	63:60	0:0	12	+
water	63:62	0:0	12	dstStride
op	63:71	0:0	12	[
water	63:72	0:0	12	plane
op	63:77	0:0	12	]
op	63:79	0:0	12	*
water	63:81	0:0	12	y
for	64:24	72:24	12	(x = 0 ;x < w;x ++)
forinit	64:29	64:34	13	x = 0 ;
water	64:29	0:0	14	x
op	64:31	0:0	14	=
water	64:33	0:0	14	0
water	64:34	0:0	14	;
cond	64:36	64:40	13	x < w
water	64:36	0:0	14	x
op	64:38	0:0	14	<
water	64:40	0:0	14	w
forexpr	64:43	64:44	13	x ++
water	64:43	0:0	14	x
op	64:44	0:0	14	++
stmts	64:48	72:24	13	
water	64:48	0:0	14	{
if	65:28	68:28	14	(y_subsample)
cond	65:32	65:32	15	y_subsample
water	65:32	0:0	16	y_subsample
stmts	65:45	68:28	15	
water	65:45	0:0	16	{
water	66:32	0:0	16	alpha
op	66:38	0:0	16	=
water	66:40	0:0	16	(
water	66:41	0:0	16	a
op	66:42	0:0	16	[
water	66:43	0:0	16	2
op	66:44	0:0	16	*
water	66:45	0:0	16	x
op	66:46	0:0	16	]
op	66:61	0:0	16	+
water	66:63	0:0	16	a
op	66:64	0:0	16	[
water	66:65	0:0	16	2
op	66:66	0:0	16	*
water	66:67	0:0	16	x
op	66:69	0:0	16	+
water	66:71	0:0	16	1
op	66:72	0:0	16	]
op	66:74	0:0	16	+
water	66:76	0:0	16	2
op	66:78	0:0	16	+
water	67:41	0:0	16	a
op	67:42	0:0	16	[
water	67:43	0:0	16	2
op	67:44	0:0	16	*
water	67:45	0:0	16	x
op	67:47	0:0	16	+
water	67:49	0:0	16	alpha_step
op	67:59	0:0	16	]
op	67:61	0:0	16	+
water	67:63	0:0	16	a
op	67:64	0:0	16	[
water	67:65	0:0	16	2
op	67:66	0:0	16	*
water	67:67	0:0	16	x
op	67:69	0:0	16	+
water	67:71	0:0	16	alpha_step
op	67:82	0:0	16	+
water	67:84	0:0	16	1
op	67:85	0:0	16	]
water	67:86	0:0	16	)
op	67:88	0:0	16	>>
water	67:91	0:0	16	2
water	67:92	0:0	16	;
water	68:28	0:0	16	}
else	68:30	69:66	14
stmts	69:32	69:66	15	
water	69:32	0:0	16	alpha
op	69:38	0:0	16	=
water	69:40	0:0	16	(
water	69:41	0:0	16	a
op	69:42	0:0	16	[
water	69:43	0:0	16	2
op	69:44	0:0	16	*
water	69:45	0:0	16	x
op	69:46	0:0	16	]
op	69:48	0:0	16	+
water	69:50	0:0	16	a
op	69:51	0:0	16	[
water	69:52	0:0	16	2
op	69:53	0:0	16	*
water	69:54	0:0	16	x
op	69:56	0:0	16	+
water	69:58	0:0	16	1
op	69:59	0:0	16	]
water	69:60	0:0	16	)
op	69:62	0:0	16	>>
water	69:65	0:0	16	1
water	69:66	0:0	16	;
water	70:28	0:0	14	u
op	70:30	0:0	14	=
water	70:32	0:0	14	s
op	70:33	0:0	14	[
water	70:34	0:0	14	x
op	70:35	0:0	14	]
op	70:36	0:0	14	*
water	70:37	0:0	14	alpha
op	70:43	0:0	14	+
water	70:45	0:0	14	target_table
op	70:57	0:0	14	[
water	70:58	0:0	14	(
water	70:59	0:0	14	(
water	70:60	0:0	14	x
op	70:61	0:0	14	^
water	70:62	0:0	14	y
water	70:63	0:0	14	)
op	70:64	0:0	14	>>
water	70:66	0:0	14	5
water	70:67	0:0	14	)
op	70:68	0:0	14	&
water	70:69	0:0	14	1
op	70:70	0:0	14	]
op	70:71	0:0	14	[
water	70:72	0:0	14	plane
op	70:77	0:0	14	]
op	70:78	0:0	14	*
water	70:79	0:0	14	(
water	70:80	0:0	14	255
op	70:83	0:0	14	-
water	70:84	0:0	14	alpha
water	70:89	0:0	14	)
op	70:91	0:0	14	+
water	70:93	0:0	14	128
water	70:96	0:0	14	;
water	71:28	0:0	14	d
op	71:29	0:0	14	[
water	71:30	0:0	14	x
op	71:31	0:0	14	]
op	71:33	0:0	14	=
water	71:35	0:0	14	(
water	71:36	0:0	14	257
op	71:39	0:0	14	*
water	71:40	0:0	14	u
water	71:41	0:0	14	)
op	71:43	0:0	14	>>
water	71:46	0:0	14	16
water	71:48	0:0	14	;
water	72:24	0:0	14	}
water	73:20	0:0	12	}
water	74:16	0:0	10	}
else	74:18	100:16	8
stmts	74:23	100:16	9	
water	74:23	0:0	10	{
if	75:16	91:16	10	(sixteen_bits)
cond	75:20	75:20	11	sixteen_bits
water	75:20	0:0	12	sixteen_bits
stmts	75:34	91:16	11	
water	75:34	0:0	12	{
decl	76:20	76:105	12	const uint16_t	*s
op	76:38	0:0	12	=
call	76:40	76:104	13	(constuint16_t*)
arg	76:59	76:104	14	src[plane]+srcStride[plane]*y
water	76:59	0:0	15	src
op	76:62	0:0	15	[
water	76:63	0:0	15	plane
op	76:74	0:0	15	]
op	76:76	0:0	15	+
water	76:78	0:0	15	srcStride
op	76:87	0:0	15	[
water	76:88	0:0	15	plane
op	76:99	0:0	15	]
op	76:101	0:0	15	*
water	76:103	0:0	15	y
decl	77:20	77:105	12	const uint16_t	*a
op	77:38	0:0	12	=
call	77:40	77:104	13	(constuint16_t*)
arg	77:59	77:104	14	src[plane_count]+srcStride[plane_count]*y
water	77:59	0:0	15	src
op	77:62	0:0	15	[
water	77:63	0:0	15	plane_count
op	77:74	0:0	15	]
op	77:76	0:0	15	+
water	77:78	0:0	15	srcStride
op	77:87	0:0	15	[
water	77:88	0:0	15	plane_count
op	77:99	0:0	15	]
op	77:101	0:0	15	*
water	77:103	0:0	15	y
decl	78:26	78:105	12	uint16_t	*d
op	78:38	0:0	12	=
call	78:40	78:104	13	(uint16_t*)
arg	78:59	78:104	14	dst[plane]+dstStride[plane]*y
water	78:59	0:0	15	dst
op	78:62	0:0	15	[
water	78:63	0:0	15	plane
op	78:74	0:0	15	]
op	78:76	0:0	15	+
water	78:78	0:0	15	dstStride
op	78:87	0:0	15	[
water	78:88	0:0	15	plane
op	78:99	0:0	15	]
op	78:101	0:0	15	*
water	78:103	0:0	15	y
if	79:20	84:20	12	(( !isBE (c -> srcFormat ) ) == ! HAVE_BIGENDIAN)
cond	79:24	79:50	13	( !isBE (c -> srcFormat ) ) == ! HAVE_BIGENDIAN
water	79:24	0:0	14	(
op	79:25	0:0	14	!
call	79:26	79:43	14	isBE
arg	79:31	79:43	15	c->srcFormat
water	79:31	0:0	16	c
op	79:32	0:0	16	->
water	79:34	0:0	16	srcFormat
water	79:44	0:0	14	)
op	79:46	0:0	14	==
op	79:49	0:0	14	!
water	79:50	0:0	14	HAVE_BIGENDIAN
stmts	79:66	84:20	13	
water	79:66	0:0	14	{
for	80:24	83:24	14	(x = 0 ;x < w;x ++)
forinit	80:29	80:34	15	x = 0 ;
water	80:29	0:0	16	x
op	80:31	0:0	16	=
water	80:33	0:0	16	0
water	80:34	0:0	16	;
cond	80:36	80:40	15	x < w
water	80:36	0:0	16	x
op	80:38	0:0	16	<
water	80:40	0:0	16	w
forexpr	80:43	80:44	15	x ++
water	80:43	0:0	16	x
op	80:44	0:0	16	++
stmts	80:48	83:24	15	
water	80:48	0:0	16	{
water	81:28	0:0	16	unsigned
water	81:37	0:0	16	u
op	81:39	0:0	16	=
water	81:41	0:0	16	s
op	81:42	0:0	16	[
water	81:43	0:0	16	x
op	81:44	0:0	16	]
op	81:45	0:0	16	*
water	81:46	0:0	16	a
op	81:47	0:0	16	[
water	81:48	0:0	16	x
op	81:49	0:0	16	]
op	81:51	0:0	16	+
water	81:53	0:0	16	target_table
op	81:65	0:0	16	[
water	81:66	0:0	16	(
water	81:67	0:0	16	(
water	81:68	0:0	16	x
op	81:69	0:0	16	^
water	81:70	0:0	16	y
water	81:71	0:0	16	)
op	81:72	0:0	16	>>
water	81:74	0:0	16	5
water	81:75	0:0	16	)
op	81:76	0:0	16	&
water	81:77	0:0	16	1
op	81:78	0:0	16	]
op	81:79	0:0	16	[
water	81:80	0:0	16	plane
op	81:85	0:0	16	]
op	81:86	0:0	16	*
water	81:87	0:0	16	(
water	81:88	0:0	16	max
op	81:91	0:0	16	-
water	81:92	0:0	16	a
op	81:93	0:0	16	[
water	81:94	0:0	16	x
op	81:95	0:0	16	]
water	81:96	0:0	16	)
op	81:98	0:0	16	+
water	81:100	0:0	16	off
water	81:103	0:0	16	;
water	82:28	0:0	16	d
op	82:29	0:0	16	[
water	82:30	0:0	16	x
op	82:31	0:0	16	]
op	82:33	0:0	16	=
call	82:35	82:78	16	av_clip
arg	82:43	82:70	17	(u+(u>>shift))>>shift
water	82:43	0:0	18	(
water	82:44	0:0	18	u
op	82:46	0:0	18	+
water	82:48	0:0	18	(
water	82:49	0:0	18	u
op	82:51	0:0	18	>>
water	82:54	0:0	18	shift
water	82:59	0:0	18	)
water	82:60	0:0	18	)
op	82:62	0:0	18	>>
water	82:65	0:0	18	shift
arg	82:72	82:73	17	0
water	82:72	0:0	18	0
arg	82:75	82:78	17	max
water	82:75	0:0	18	max
water	82:79	0:0	16	;
water	83:24	0:0	16	}
water	84:20	0:0	14	}
else	84:22	90:20	12
stmts	84:27	90:20	13	
water	84:27	0:0	14	{
for	85:24	89:24	14	(x = 0 ;x < w;x ++)
forinit	85:29	85:34	15	x = 0 ;
water	85:29	0:0	16	x
op	85:31	0:0	16	=
water	85:33	0:0	16	0
water	85:34	0:0	16	;
cond	85:36	85:40	15	x < w
water	85:36	0:0	16	x
op	85:38	0:0	16	<
water	85:40	0:0	16	w
forexpr	85:43	85:44	15	x ++
water	85:43	0:0	16	x
op	85:44	0:0	16	++
stmts	85:48	89:24	15	
water	85:48	0:0	16	{
water	86:28	0:0	16	unsigned
water	86:37	0:0	16	aswap
op	86:43	0:0	16	=
call	86:44	86:59	16	av_bswap16
arg	86:55	86:59	17	a[x]
water	86:55	0:0	18	a
op	86:56	0:0	18	[
water	86:57	0:0	18	x
op	86:58	0:0	18	]
water	86:60	0:0	16	;
water	87:28	0:0	16	unsigned
water	87:37	0:0	16	u
op	87:39	0:0	16	=
call	87:41	87:56	16	av_bswap16
arg	87:52	87:56	17	s[x]
water	87:52	0:0	18	s
op	87:53	0:0	18	[
water	87:54	0:0	18	x
op	87:55	0:0	18	]
op	87:57	0:0	16	*
water	87:58	0:0	16	aswap
op	87:64	0:0	16	+
water	87:66	0:0	16	target_table
op	87:78	0:0	16	[
water	87:79	0:0	16	(
water	87:80	0:0	16	(
water	87:81	0:0	16	x
op	87:82	0:0	16	^
water	87:83	0:0	16	y
water	87:84	0:0	16	)
op	87:85	0:0	16	>>
water	87:87	0:0	16	5
water	87:88	0:0	16	)
op	87:89	0:0	16	&
water	87:90	0:0	16	1
op	87:91	0:0	16	]
op	87:92	0:0	16	[
water	87:93	0:0	16	plane
op	87:98	0:0	16	]
op	87:99	0:0	16	*
water	87:100	0:0	16	(
water	87:101	0:0	16	max
op	87:104	0:0	16	-
water	87:105	0:0	16	aswap
water	87:110	0:0	16	)
op	87:112	0:0	16	+
water	87:114	0:0	16	off
water	87:117	0:0	16	;
water	88:28	0:0	16	d
op	88:29	0:0	16	[
water	88:30	0:0	16	x
op	88:31	0:0	16	]
op	88:33	0:0	16	=
call	88:35	88:78	16	av_clip
arg	88:43	88:70	17	(u+(u>>shift))>>shift
water	88:43	0:0	18	(
water	88:44	0:0	18	u
op	88:46	0:0	18	+
water	88:48	0:0	18	(
water	88:49	0:0	18	u
op	88:51	0:0	18	>>
water	88:54	0:0	18	shift
water	88:59	0:0	18	)
water	88:60	0:0	18	)
op	88:62	0:0	18	>>
water	88:65	0:0	18	shift
arg	88:72	88:73	17	0
water	88:72	0:0	18	0
arg	88:75	88:78	17	max
water	88:75	0:0	18	max
water	88:79	0:0	16	;
water	89:24	0:0	16	}
water	90:20	0:0	14	}
water	91:16	0:0	12	}
else	91:18	99:16	10
stmts	91:23	99:16	11	
water	91:23	0:0	12	{
decl	92:20	92:78	12	const uint8_t	*s
op	92:37	0:0	12	=
water	92:39	0:0	12	src
op	92:42	0:0	12	[
water	92:43	0:0	12	plane
op	92:54	0:0	12	]
op	92:56	0:0	12	+
water	92:58	0:0	12	srcStride
op	92:67	0:0	12	[
water	92:68	0:0	12	plane
op	92:73	0:0	12	]
op	92:75	0:0	12	*
water	92:77	0:0	12	y
decl	93:20	93:84	12	const uint8_t	*a
op	93:37	0:0	12	=
water	93:39	0:0	12	src
op	93:42	0:0	12	[
water	93:43	0:0	12	plane_count
op	93:54	0:0	12	]
op	93:56	0:0	12	+
water	93:58	0:0	12	srcStride
op	93:67	0:0	12	[
water	93:68	0:0	12	plane_count
op	93:79	0:0	12	]
op	93:81	0:0	12	*
water	93:83	0:0	12	y
decl	94:26	94:78	12	uint8_t	*d
op	94:37	0:0	12	=
water	94:39	0:0	12	dst
op	94:42	0:0	12	[
water	94:43	0:0	12	plane
op	94:54	0:0	12	]
op	94:56	0:0	12	+
water	94:58	0:0	12	dstStride
op	94:67	0:0	12	[
water	94:68	0:0	12	plane
op	94:73	0:0	12	]
op	94:75	0:0	12	*
water	94:77	0:0	12	y
for	95:20	98:20	12	(x = 0 ;x < w;x ++)
forinit	95:25	95:30	13	x = 0 ;
water	95:25	0:0	14	x
op	95:27	0:0	14	=
water	95:29	0:0	14	0
water	95:30	0:0	14	;
cond	95:32	95:36	13	x < w
water	95:32	0:0	14	x
op	95:34	0:0	14	<
water	95:36	0:0	14	w
forexpr	95:39	95:40	13	x ++
water	95:39	0:0	14	x
op	95:40	0:0	14	++
stmts	95:44	98:20	13	
water	95:44	0:0	14	{
water	96:24	0:0	14	unsigned
water	96:33	0:0	14	u
op	96:35	0:0	14	=
water	96:37	0:0	14	s
op	96:38	0:0	14	[
water	96:39	0:0	14	x
op	96:40	0:0	14	]
op	96:41	0:0	14	*
water	96:42	0:0	14	a
op	96:43	0:0	14	[
water	96:44	0:0	14	x
op	96:45	0:0	14	]
op	96:47	0:0	14	+
water	96:49	0:0	14	target_table
op	96:61	0:0	14	[
water	96:62	0:0	14	(
water	96:63	0:0	14	(
water	96:64	0:0	14	x
op	96:65	0:0	14	^
water	96:66	0:0	14	y
water	96:67	0:0	14	)
op	96:68	0:0	14	>>
water	96:70	0:0	14	5
water	96:71	0:0	14	)
op	96:72	0:0	14	&
water	96:73	0:0	14	1
op	96:74	0:0	14	]
op	96:75	0:0	14	[
water	96:76	0:0	14	plane
op	96:81	0:0	14	]
op	96:82	0:0	14	*
water	96:83	0:0	14	(
water	96:84	0:0	14	255
op	96:87	0:0	14	-
water	96:88	0:0	14	a
op	96:89	0:0	14	[
water	96:90	0:0	14	x
op	96:91	0:0	14	]
water	96:92	0:0	14	)
op	96:94	0:0	14	+
water	96:96	0:0	14	128
water	96:99	0:0	14	;
water	97:24	0:0	14	d
op	97:25	0:0	14	[
water	97:26	0:0	14	x
op	97:27	0:0	14	]
op	97:29	0:0	14	=
water	97:31	0:0	14	(
water	97:32	0:0	14	257
op	97:35	0:0	14	*
water	97:36	0:0	14	u
water	97:37	0:0	14	)
op	97:39	0:0	14	>>
water	97:42	0:0	14	16
water	97:44	0:0	14	;
water	98:20	0:0	14	}
water	99:16	0:0	12	}
water	100:16	0:0	10	}
water	101:12	0:0	8	}
water	102:8	0:0	6	}
water	103:4	0:0	4	}
else	103:6	142:4	2
stmts	103:11	142:4	3	
water	103:11	0:0	4	{
decl	104:8	104:64	4	int	alpha_pos
op	104:22	0:0	4	=
water	104:24	0:0	4	desc
op	104:28	0:0	4	->
water	104:30	0:0	4	comp
op	104:34	0:0	4	[
water	104:35	0:0	4	plane_count
op	104:46	0:0	4	]
op	104:47	0:0	4	.
water	104:48	0:0	4	offset_plus1
op	104:61	0:0	4	-
water	104:63	0:0	4	1
decl	105:8	105:23	4	int	w
op	105:14	0:0	4	=
water	105:16	0:0	4	c
op	105:17	0:0	4	->
water	105:19	0:0	4	srcW
for	106:8	141:8	4	(y = srcSliceY ;y < srcSliceH;y ++)
forinit	106:13	106:26	5	y = srcSliceY ;
water	106:13	0:0	6	y
op	106:15	0:0	6	=
water	106:17	0:0	6	srcSliceY
water	106:26	0:0	6	;
cond	106:28	106:32	5	y < srcSliceH
water	106:28	0:0	6	y
op	106:30	0:0	6	<
water	106:32	0:0	6	srcSliceH
forexpr	106:43	106:44	5	y ++
water	106:43	0:0	6	y
op	106:44	0:0	6	++
stmts	106:48	141:8	5	
water	106:48	0:0	6	{
if	107:12	129:12	6	(sixteen_bits)
cond	107:16	107:16	7	sixteen_bits
water	107:16	0:0	8	sixteen_bits
stmts	107:30	129:12	7	
water	107:30	0:0	8	{
decl	108:16	108:96	8	const uint16_t	*s
op	108:34	0:0	8	=
call	108:36	108:95	9	(constuint16_t*)
arg	108:55	108:95	10	src[0]+srcStride[0]*y+2*!alpha_pos
water	108:55	0:0	11	src
op	108:58	0:0	11	[
water	108:59	0:0	11	0
op	108:60	0:0	11	]
op	108:62	0:0	11	+
water	108:64	0:0	11	srcStride
op	108:73	0:0	11	[
water	108:74	0:0	11	0
op	108:75	0:0	11	]
op	108:77	0:0	11	*
water	108:79	0:0	11	y
op	108:81	0:0	11	+
water	108:83	0:0	11	2
op	108:84	0:0	11	*
op	108:85	0:0	11	!
water	108:86	0:0	11	alpha_pos
decl	109:16	109:96	8	const uint16_t	*a
op	109:34	0:0	8	=
call	109:36	109:95	9	(constuint16_t*)
arg	109:55	109:95	10	src[0]+srcStride[0]*y+alpha_pos
water	109:55	0:0	11	src
op	109:58	0:0	11	[
water	109:59	0:0	11	0
op	109:60	0:0	11	]
op	109:62	0:0	11	+
water	109:64	0:0	11	srcStride
op	109:73	0:0	11	[
water	109:74	0:0	11	0
op	109:75	0:0	11	]
op	109:77	0:0	11	*
water	109:79	0:0	11	y
op	109:81	0:0	11	+
water	109:86	0:0	11	alpha_pos
decl	110:22	110:81	8	uint16_t	*d
op	110:34	0:0	8	=
call	110:36	110:80	9	(uint16_t*)
arg	110:55	110:80	10	dst[0]+dstStride[0]*y
water	110:55	0:0	11	dst
op	110:58	0:0	11	[
water	110:59	0:0	11	0
op	110:60	0:0	11	]
op	110:62	0:0	11	+
water	110:64	0:0	11	dstStride
op	110:73	0:0	11	[
water	110:74	0:0	11	0
op	110:75	0:0	11	]
op	110:77	0:0	11	*
water	110:79	0:0	11	y
if	111:16	119:16	8	(( !isBE (c -> srcFormat ) ) == ! HAVE_BIGENDIAN)
cond	111:20	111:46	9	( !isBE (c -> srcFormat ) ) == ! HAVE_BIGENDIAN
water	111:20	0:0	10	(
op	111:21	0:0	10	!
call	111:22	111:39	10	isBE
arg	111:27	111:39	11	c->srcFormat
water	111:27	0:0	12	c
op	111:28	0:0	12	->
water	111:30	0:0	12	srcFormat
water	111:40	0:0	10	)
op	111:42	0:0	10	==
op	111:45	0:0	10	!
water	111:46	0:0	10	HAVE_BIGENDIAN
stmts	111:62	119:16	9	
water	111:62	0:0	10	{
for	112:20	118:20	10	(x = 0 ;x < w;x ++)
forinit	112:25	112:30	11	x = 0 ;
water	112:25	0:0	12	x
op	112:27	0:0	12	=
water	112:29	0:0	12	0
water	112:30	0:0	12	;
cond	112:32	112:36	11	x < w
water	112:32	0:0	12	x
op	112:34	0:0	12	<
water	112:36	0:0	12	w
forexpr	112:39	112:40	11	x ++
water	112:39	0:0	12	x
op	112:40	0:0	12	++
stmts	112:44	118:20	11	
water	112:44	0:0	12	{
for	113:24	117:24	12	(plane = 0 ;plane < plane_count;plane ++)
forinit	113:29	113:38	13	plane = 0 ;
water	113:29	0:0	14	plane
op	113:35	0:0	14	=
water	113:37	0:0	14	0
water	113:38	0:0	14	;
cond	113:40	113:48	13	plane < plane_count
water	113:40	0:0	14	plane
op	113:46	0:0	14	<
water	113:48	0:0	14	plane_count
forexpr	113:61	113:66	13	plane ++
water	113:61	0:0	14	plane
op	113:66	0:0	14	++
stmts	113:70	117:24	13	
water	113:70	0:0	14	{
decl	114:28	114:63	14	int	x_index
op	114:40	0:0	14	=
water	114:42	0:0	14	(
water	114:43	0:0	14	plane_count
op	114:55	0:0	14	+
water	114:57	0:0	14	1
water	114:58	0:0	14	)
op	114:60	0:0	14	*
water	114:62	0:0	14	x
water	115:28	0:0	14	unsigned
water	115:37	0:0	14	u
op	115:39	0:0	14	=
water	115:41	0:0	14	s
op	115:42	0:0	14	[
water	115:43	0:0	14	x_index
op	115:51	0:0	14	+
water	115:53	0:0	14	plane
op	115:58	0:0	14	]
op	115:59	0:0	14	*
water	115:60	0:0	14	a
op	115:61	0:0	14	[
water	115:62	0:0	14	x_index
op	115:69	0:0	14	]
op	115:71	0:0	14	+
water	115:73	0:0	14	target_table
op	115:85	0:0	14	[
water	115:86	0:0	14	(
water	115:87	0:0	14	(
water	115:88	0:0	14	x
op	115:89	0:0	14	^
water	115:90	0:0	14	y
water	115:91	0:0	14	)
op	115:92	0:0	14	>>
water	115:94	0:0	14	5
water	115:95	0:0	14	)
op	115:96	0:0	14	&
water	115:97	0:0	14	1
op	115:98	0:0	14	]
op	115:99	0:0	14	[
water	115:100	0:0	14	plane
op	115:105	0:0	14	]
op	115:106	0:0	14	*
water	115:107	0:0	14	(
water	115:108	0:0	14	max
op	115:111	0:0	14	-
water	115:112	0:0	14	a
op	115:113	0:0	14	[
water	115:114	0:0	14	x_index
op	115:121	0:0	14	]
water	115:122	0:0	14	)
op	115:124	0:0	14	+
water	115:126	0:0	14	off
water	115:129	0:0	14	;
water	116:28	0:0	14	d
op	116:29	0:0	14	[
water	116:30	0:0	14	plane_count
op	116:41	0:0	14	*
water	116:42	0:0	14	x
op	116:44	0:0	14	+
water	116:46	0:0	14	plane
op	116:51	0:0	14	]
op	116:53	0:0	14	=
call	116:55	116:98	14	av_clip
arg	116:63	116:90	15	(u+(u>>shift))>>shift
water	116:63	0:0	16	(
water	116:64	0:0	16	u
op	116:66	0:0	16	+
water	116:68	0:0	16	(
water	116:69	0:0	16	u
op	116:71	0:0	16	>>
water	116:74	0:0	16	shift
water	116:79	0:0	16	)
water	116:80	0:0	16	)
op	116:82	0:0	16	>>
water	116:85	0:0	16	shift
arg	116:92	116:93	15	0
water	116:92	0:0	16	0
arg	116:95	116:98	15	max
water	116:95	0:0	16	max
water	116:99	0:0	14	;
water	117:24	0:0	14	}
water	118:20	0:0	12	}
water	119:16	0:0	10	}
else	119:18	128:16	8
stmts	119:23	128:16	9	
water	119:23	0:0	10	{
for	120:20	127:20	10	(x = 0 ;x < w;x ++)
forinit	120:25	120:30	11	x = 0 ;
water	120:25	0:0	12	x
op	120:27	0:0	12	=
water	120:29	0:0	12	0
water	120:30	0:0	12	;
cond	120:32	120:36	11	x < w
water	120:32	0:0	12	x
op	120:34	0:0	12	<
water	120:36	0:0	12	w
forexpr	120:39	120:40	11	x ++
water	120:39	0:0	12	x
op	120:40	0:0	12	++
stmts	120:44	127:20	11	
water	120:44	0:0	12	{
for	121:24	126:24	12	(plane = 0 ;plane < plane_count;plane ++)
forinit	121:29	121:38	13	plane = 0 ;
water	121:29	0:0	14	plane
op	121:35	0:0	14	=
water	121:37	0:0	14	0
water	121:38	0:0	14	;
cond	121:40	121:48	13	plane < plane_count
water	121:40	0:0	14	plane
op	121:46	0:0	14	<
water	121:48	0:0	14	plane_count
forexpr	121:61	121:66	13	plane ++
water	121:61	0:0	14	plane
op	121:66	0:0	14	++
stmts	121:70	126:24	13	
water	121:70	0:0	14	{
decl	122:28	122:63	14	int	x_index
op	122:40	0:0	14	=
water	122:42	0:0	14	(
water	122:43	0:0	14	plane_count
op	122:55	0:0	14	+
water	122:57	0:0	14	1
water	122:58	0:0	14	)
op	122:60	0:0	14	*
water	122:62	0:0	14	x
water	123:28	0:0	14	unsigned
water	123:37	0:0	14	aswap
op	123:43	0:0	14	=
call	123:44	123:65	14	av_bswap16
arg	123:55	123:65	15	a[x_index]
water	123:55	0:0	16	a
op	123:56	0:0	16	[
water	123:57	0:0	16	x_index
op	123:64	0:0	16	]
water	123:66	0:0	14	;
water	124:28	0:0	14	unsigned
water	124:37	0:0	14	u
op	124:39	0:0	14	=
call	124:41	124:70	14	av_bswap16
arg	124:52	124:70	15	s[x_index+plane]
water	124:52	0:0	16	s
op	124:53	0:0	16	[
water	124:54	0:0	16	x_index
op	124:62	0:0	16	+
water	124:64	0:0	16	plane
op	124:69	0:0	16	]
op	124:71	0:0	14	*
water	124:72	0:0	14	aswap
op	124:78	0:0	14	+
water	124:80	0:0	14	target_table
op	124:92	0:0	14	[
water	124:93	0:0	14	(
water	124:94	0:0	14	(
water	124:95	0:0	14	x
op	124:96	0:0	14	^
water	124:97	0:0	14	y
water	124:98	0:0	14	)
op	124:99	0:0	14	>>
water	124:101	0:0	14	5
water	124:102	0:0	14	)
op	124:103	0:0	14	&
water	124:104	0:0	14	1
op	124:105	0:0	14	]
op	124:106	0:0	14	[
water	124:107	0:0	14	plane
op	124:112	0:0	14	]
op	124:113	0:0	14	*
water	124:114	0:0	14	(
water	124:115	0:0	14	max
op	124:118	0:0	14	-
water	124:119	0:0	14	aswap
water	124:124	0:0	14	)
op	124:126	0:0	14	+
water	124:128	0:0	14	off
water	124:131	0:0	14	;
water	125:28	0:0	14	d
op	125:29	0:0	14	[
water	125:30	0:0	14	plane_count
op	125:41	0:0	14	*
water	125:42	0:0	14	x
op	125:44	0:0	14	+
water	125:46	0:0	14	plane
op	125:51	0:0	14	]
op	125:53	0:0	14	=
call	125:55	125:98	14	av_clip
arg	125:63	125:90	15	(u+(u>>shift))>>shift
water	125:63	0:0	16	(
water	125:64	0:0	16	u
op	125:66	0:0	16	+
water	125:68	0:0	16	(
water	125:69	0:0	16	u
op	125:71	0:0	16	>>
water	125:74	0:0	16	shift
water	125:79	0:0	16	)
water	125:80	0:0	16	)
op	125:82	0:0	16	>>
water	125:85	0:0	16	shift
arg	125:92	125:93	15	0
water	125:92	0:0	16	0
arg	125:95	125:98	15	max
water	125:95	0:0	16	max
water	125:99	0:0	14	;
water	126:24	0:0	14	}
water	127:20	0:0	12	}
water	128:16	0:0	10	}
water	129:12	0:0	8	}
else	129:14	140:12	6
stmts	129:19	140:12	7	
water	129:19	0:0	8	{
decl	130:16	130:73	8	const uint8_t	*s
op	130:33	0:0	8	=
water	130:35	0:0	8	src
op	130:38	0:0	8	[
water	130:39	0:0	8	0
op	130:40	0:0	8	]
op	130:42	0:0	8	+
water	130:44	0:0	8	srcStride
op	130:53	0:0	8	[
water	130:54	0:0	8	0
op	130:55	0:0	8	]
op	130:57	0:0	8	*
water	130:59	0:0	8	y
op	130:61	0:0	8	+
op	130:63	0:0	8	!
water	130:64	0:0	8	alpha_pos
decl	131:16	131:72	8	const uint8_t	*a
op	131:33	0:0	8	=
water	131:35	0:0	8	src
op	131:38	0:0	8	[
water	131:39	0:0	8	0
op	131:40	0:0	8	]
op	131:42	0:0	8	+
water	131:44	0:0	8	srcStride
op	131:53	0:0	8	[
water	131:54	0:0	8	0
op	131:55	0:0	8	]
op	131:57	0:0	8	*
water	131:59	0:0	8	y
op	131:61	0:0	8	+
water	131:63	0:0	8	alpha_pos
decl	132:22	132:60	8	uint8_t	*d
op	132:33	0:0	8	=
water	132:35	0:0	8	dst
op	132:38	0:0	8	[
water	132:39	0:0	8	0
op	132:40	0:0	8	]
op	132:42	0:0	8	+
water	132:44	0:0	8	dstStride
op	132:53	0:0	8	[
water	132:54	0:0	8	0
op	132:55	0:0	8	]
op	132:57	0:0	8	*
water	132:59	0:0	8	y
for	133:16	139:16	8	(x = 0 ;x < w;x ++)
forinit	133:21	133:26	9	x = 0 ;
water	133:21	0:0	10	x
op	133:23	0:0	10	=
water	133:25	0:0	10	0
water	133:26	0:0	10	;
cond	133:28	133:32	9	x < w
water	133:28	0:0	10	x
op	133:30	0:0	10	<
water	133:32	0:0	10	w
forexpr	133:35	133:36	9	x ++
water	133:35	0:0	10	x
op	133:36	0:0	10	++
stmts	133:40	139:16	9	
water	133:40	0:0	10	{
for	134:20	138:20	10	(plane = 0 ;plane < plane_count;plane ++)
forinit	134:25	134:34	11	plane = 0 ;
water	134:25	0:0	12	plane
op	134:31	0:0	12	=
water	134:33	0:0	12	0
water	134:34	0:0	12	;
cond	134:36	134:44	11	plane < plane_count
water	134:36	0:0	12	plane
op	134:42	0:0	12	<
water	134:44	0:0	12	plane_count
forexpr	134:57	134:62	11	plane ++
water	134:57	0:0	12	plane
op	134:62	0:0	12	++
stmts	134:66	138:20	11	
water	134:66	0:0	12	{
decl	135:24	135:59	12	int	x_index
op	135:36	0:0	12	=
water	135:38	0:0	12	(
water	135:39	0:0	12	plane_count
op	135:51	0:0	12	+
water	135:53	0:0	12	1
water	135:54	0:0	12	)
op	135:56	0:0	12	*
water	135:58	0:0	12	x
water	136:24	0:0	12	unsigned
water	136:33	0:0	12	u
op	136:35	0:0	12	=
water	136:37	0:0	12	s
op	136:38	0:0	12	[
water	136:39	0:0	12	x_index
op	136:47	0:0	12	+
water	136:49	0:0	12	plane
op	136:54	0:0	12	]
op	136:55	0:0	12	*
water	136:56	0:0	12	a
op	136:57	0:0	12	[
water	136:58	0:0	12	x_index
op	136:65	0:0	12	]
op	136:67	0:0	12	+
water	136:69	0:0	12	target_table
op	136:81	0:0	12	[
water	136:82	0:0	12	(
water	136:83	0:0	12	(
water	136:84	0:0	12	x
op	136:85	0:0	12	^
water	136:86	0:0	12	y
water	136:87	0:0	12	)
op	136:88	0:0	12	>>
water	136:90	0:0	12	5
water	136:91	0:0	12	)
op	136:92	0:0	12	&
water	136:93	0:0	12	1
op	136:94	0:0	12	]
op	136:95	0:0	12	[
water	136:96	0:0	12	plane
op	136:101	0:0	12	]
op	136:102	0:0	12	*
water	136:103	0:0	12	(
water	136:104	0:0	12	255
op	136:107	0:0	12	-
water	136:108	0:0	12	a
op	136:109	0:0	12	[
water	136:110	0:0	12	x_index
op	136:117	0:0	12	]
water	136:118	0:0	12	)
op	136:120	0:0	12	+
water	136:122	0:0	12	128
water	136:125	0:0	12	;
water	137:24	0:0	12	d
op	137:25	0:0	12	[
water	137:26	0:0	12	plane_count
op	137:37	0:0	12	*
water	137:38	0:0	12	x
op	137:40	0:0	12	+
water	137:42	0:0	12	plane
op	137:47	0:0	12	]
op	137:49	0:0	12	=
water	137:51	0:0	12	(
water	137:52	0:0	12	257
op	137:55	0:0	12	*
water	137:56	0:0	12	u
water	137:57	0:0	12	)
op	137:59	0:0	12	>>
water	137:62	0:0	12	16
water	137:64	0:0	12	;
water	138:20	0:0	12	}
water	139:16	0:0	10	}
water	140:12	0:0	8	}
water	141:8	0:0	6	}
water	142:4	0:0	4	}
return	143:4	143:12	2	0
water	143:11	0:0	3	0
